# Error Handling Best Practices

**Date:** 2025-11-15
**Purpose:** Guidelines for error handling in mdminecraft
**Audience:** Contributors and developers

---

## Overview

This document establishes best practices for error handling in the mdminecraft codebase. Good error handling improves debugging, user experience, and system reliability.

---

## Principles

### 1. Use Result Types for Fallible Operations

**DO:**
```rust
pub fn load_chunk(&self, pos: ChunkPos) -> Result<Chunk, PersistError> {
    let region_pos = chunk_to_region(pos);
    let file_path = self.region_path(region_pos);

    let data = std::fs::read(&file_path)
        .map_err(|e| PersistError::FileRead {
            path: file_path.clone(),
            source: e,
        })?;

    // ... decompress and deserialize
    Ok(chunk)
}
```

**DON'T:**
```rust
pub fn load_chunk(&self, pos: ChunkPos) -> Chunk {
    let data = std::fs::read(&file_path).unwrap(); // âŒ Can panic!
    // ...
}
```

### 2. Provide Context in Errors

**DO:**
```rust
let chunk = chunks.get(&pos).ok_or_else(|| {
    ChunkError::NotFound {
        position: pos,
        available_chunks: chunks.len(),
        requested_at: SystemTime::now(),
    }
})?;
```

**DON'T:**
```rust
let chunk = chunks.get(&pos).unwrap(); // âŒ No context on failure
```

### 3. Use Descriptive Error Types

**DO:**
```rust
#[derive(Debug, thiserror::Error)]
pub enum PersistError {
    #[error("Failed to read file {path}: {source}")]
    FileRead {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    #[error("Invalid chunk data at {pos}: {reason}")]
    InvalidChunkData {
        pos: ChunkPos,
        reason: String,
    },

    #[error("Decompression failed: {0}")]
    Decompression(#[from] std::io::Error),
}
```

**DON'T:**
```rust
type PersistError = String; // âŒ Loses type information
```

### 4. unwrap() vs expect() vs ?

**When to use `unwrap()`:**
- **Test code only**
- When failure is truly impossible (document why)

```rust
// In tests
#[test]
fn test_something() {
    let chunk = generate_chunk().unwrap(); // OK in tests
    assert_eq!(chunk.size(), 4096);
}

// When provably safe (rare)
let value = Some(42);
let unwrapped = value.unwrap(); // Safe because we just created it
```

**When to use `expect()`:**
- When failure indicates a programming error
- With a descriptive message explaining why it should never fail

```rust
let config = include_str!("config.toml")
    .parse()
    .expect("Built-in config.toml should always be valid");
```

**When to use `?`:**
- **All production code**
- Propagate errors up the call stack

```rust
pub fn process_data() -> Result<(), Error> {
    let data = load_data()?; // âœ… Propagate error
    validate_data(&data)?;
    save_data(&data)?;
    Ok(())
}
```

---

## Error Message Guidelines

### Include Relevant Context

**DO:**
```rust
return Err(NetworkError::ConnectionFailed {
    address: server_addr.to_string(),
    port: server_port,
    timeout: Duration::from_secs(5),
    attempt: retry_count,
    last_error: last_err.to_string(),
});
```

**DON'T:**
```rust
return Err(NetworkError::ConnectionFailed); // âŒ No context
```

### Be Specific About What Went Wrong

**DO:**
```rust
if chunk_count > MAX_CHUNKS {
    return Err(ChunkError::TooManyChunks {
        requested: chunk_count,
        maximum: MAX_CHUNKS,
        suggestion: "Reduce render distance or free some chunks",
    });
}
```

**DON'T:**
```rust
if chunk_count > MAX_CHUNKS {
    return Err(ChunkError::Invalid); // âŒ Not specific
}
```

### Include Recovery Suggestions

**DO:**
```rust
#[error("Save file corrupted at offset {offset}. Try: 1) Restore from backup, 2) Delete and regenerate world")]
SaveFileCorrupted { offset: u64 }
```

**DON'T:**
```rust
#[error("Save file corrupted")] // âŒ No guidance
SaveFileCorrupted
```

---

## Patterns

### Pattern 1: Validation with Context

```rust
pub fn validate_chunk_position(pos: ChunkPos) -> Result<(), ValidationError> {
    const MAX_COORD: i32 = 1_000_000;

    if pos.x.abs() > MAX_COORD || pos.z.abs() > MAX_COORD {
        return Err(ValidationError::ChunkPositionOutOfBounds {
            position: pos,
            max_coordinate: MAX_COORD,
            help: "Chunk coordinates must be within Â±1,000,000".to_string(),
        });
    }

    Ok(())
}
```

### Pattern 2: Chain Errors with Context

```rust
pub fn load_world(path: &Path) -> Result<World, WorldError> {
    let store = RegionStore::new(path)
        .map_err(|e| WorldError::PersistenceInit {
            path: path.to_path_buf(),
            source: e,
        })?;

    let spawn_chunks = load_spawn_area(&store)
        .map_err(|e| WorldError::SpawnAreaLoad {
            source: e,
        })?;

    Ok(World::new(store, spawn_chunks))
}
```

### Pattern 3: Graceful Degradation

```rust
pub fn load_config(path: &Path) -> Config {
    match std::fs::read_to_string(path) {
        Ok(content) => match toml::from_str(&content) {
            Ok(config) => config,
            Err(e) => {
                eprintln!("Warning: Invalid config file: {}", e);
                eprintln!("Using default configuration");
                Config::default()
            }
        },
        Err(e) => {
            eprintln!("Warning: Could not read config file: {}", e);
            eprintln!("Using default configuration");
            Config::default()
        }
    }
}
```

### Pattern 4: Collect Multiple Errors

```rust
pub fn validate_world(world: &World) -> Result<(), Vec<ValidationError>> {
    let mut errors = Vec::new();

    if world.chunks.is_empty() {
        errors.push(ValidationError::NoChunks);
    }

    if world.spawn_point.y < 0.0 {
        errors.push(ValidationError::InvalidSpawnPoint {
            position: world.spawn_point,
        });
    }

    for chunk in &world.chunks {
        if let Err(e) = validate_chunk(chunk) {
            errors.push(e);
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(errors)
    }
}
```

---

## Testing Error Paths

### Test Happy Path AND Error Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn load_chunk_success() {
        let store = RegionStore::new("test_world").unwrap();
        let chunk = store.load_chunk(ChunkPos::new(0, 0)).unwrap();
        assert_eq!(chunk.position().x, 0);
    }

    #[test]
    fn load_chunk_not_found() {
        let store = RegionStore::new("test_world").unwrap();
        let result = store.load_chunk(ChunkPos::new(999, 999));

        match result {
            Err(PersistError::ChunkNotFound { position }) => {
                assert_eq!(position.x, 999);
            }
            _ => panic!("Expected ChunkNotFound error"),
        }
    }

    #[test]
    fn load_chunk_corrupted_data() {
        // Write corrupted data
        let path = "test_corrupted.rg";
        std::fs::write(path, &[0xFF; 100]).unwrap();

        let store = RegionStore::new("test_corrupted").unwrap();
        let result = store.load_chunk(ChunkPos::new(0, 0));

        assert!(matches!(result, Err(PersistError::InvalidChunkData { .. })));

        std::fs::remove_file(path).ok();
    }
}
```

---

## Logging Errors

### Use Structured Logging

```rust
use tracing::{error, warn, info, debug};

pub fn process_network_message(msg: &Message) -> Result<(), NetworkError> {
    debug!(message_type = ?msg.msg_type, "Processing message");

    match handle_message(msg) {
        Ok(()) => {
            info!(message_type = ?msg.msg_type, "Message processed successfully");
            Ok(())
        }
        Err(e) => {
            error!(
                error = ?e,
                message_type = ?msg.msg_type,
                "Failed to process message"
            );
            Err(e)
        }
    }
}
```

### Log at Appropriate Levels

- **error!()** - Failures that need attention
- **warn!()** - Degraded operation, using fallbacks
- **info!()** - Important state changes
- **debug!()** - Detailed diagnostic information
- **trace!()** - Very verbose, performance-sensitive paths

```rust
error!(path = ?file_path, "Failed to load save file: {}", e); // âŒ ERROR
warn!("Config file not found, using defaults"); // âš ï¸ WARNING
info!("Server started on port {}", port); // â„¹ï¸ INFO
debug!(chunk_pos = ?pos, "Generated chunk"); // ðŸ› DEBUG
trace!("Checking voxel at ({}, {}, {})", x, y, z); // ðŸ” TRACE
```

---

## Common Pitfalls

### Pitfall 1: Silent Failures

**DON'T:**
```rust
if let Err(e) = save_chunk(&chunk) {
    // Silently ignore error
}
```

**DO:**
```rust
if let Err(e) = save_chunk(&chunk) {
    error!(chunk_pos = ?chunk.position(), error = ?e, "Failed to save chunk");
    // Or propagate the error
    return Err(e);
}
```

### Pitfall 2: Generic Error Messages

**DON'T:**
```rust
.expect("Error occurred")
.ok_or("Failed")?
```

**DO:**
```rust
.expect("Config should be set during initialization")
.ok_or_else(|| ChunkError::NotFound { position: pos })?
```

### Pitfall 3: Losing Error Context

**DON'T:**
```rust
let data = load_data().map_err(|_| "Load failed")?; // âŒ Loses source error
```

**DO:**
```rust
let data = load_data()
    .map_err(|e| LoadError::DataLoad { source: e })?; // âœ… Preserves context
```

### Pitfall 4: Panicking in Production

**DON'T:**
```rust
pub fn get_chunk(&self, pos: ChunkPos) -> Chunk {
    self.chunks.get(&pos).unwrap() // âŒ Panics if not found
}
```

**DO:**
```rust
pub fn get_chunk(&self, pos: ChunkPos) -> Result<&Chunk, ChunkError> {
    self.chunks.get(&pos).ok_or(ChunkError::NotFound { position: pos })
}
```

---

## Error Handling Checklist

When writing new code, ask:

- [ ] Can this operation fail?
- [ ] If yes, does it return Result<T, E>?
- [ ] Does the error type provide sufficient context?
- [ ] Are errors logged at appropriate levels?
- [ ] Do error messages include relevant data (IDs, paths, etc.)?
- [ ] Do error messages suggest recovery actions?
- [ ] Are error paths tested?
- [ ] Is there a fallback or graceful degradation?

---

## References

- [Rust Error Handling Book](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
- [thiserror crate](https://docs.rs/thiserror/latest/thiserror/)
- [anyhow crate](https://docs.rs/anyhow/latest/anyhow/)
- [tracing documentation](https://docs.rs/tracing/latest/tracing/)

---

**Document Version:** 1.0
**Last Updated:** 2025-11-15
**Maintained By:** Core development team
