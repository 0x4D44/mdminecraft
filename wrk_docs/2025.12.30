# Real-time Capture + Teen Commentary Video Pipeline (HLD)
Date: 2025-12-30
Author: Codex

## Goal
Add a first-party, headless-friendly recording mode to `mdminecraft` that:
- Captures continuous gameplay video (frame sequence) in real time.
- Generates in-the-moment commentary in an excitable teen style.
- Produces a 30-second MP4 with synchronized narration (music optional).

This HLD focuses on a minimal, reliable v1 that can be automated in CI/dev while keeping the engine deterministic.

---

## Non-Goals (v1)
- Shipping a built-in MP4 encoder or bundling full ffmpeg libraries.
- Full AI-driven commentary generation (LLM) at runtime.
- Live voice synthesis during the run (we synthesize after capture for simplicity).
- Music sourcing or licensing; music remains optional and external.

---

## Summary of Proposed System
**Recording Mode** runs the game in a deterministic headless render loop and:
1) **Captures frames** to disk at a fixed FPS.
2) **Emits commentary events** in real time to a log with timestamps.
3) **After run**, a pipeline step:
   - Converts the frame sequence into MP4.
   - Converts commentary into a single TTS track (Windows SAPI via PowerShell).
   - Muxes narration over the video using `ffmpeg`.

---

## Artifacts & File Layout
Output under the existing `video_insights/` structure:
```
video_insights/
  run_YYYY-MM-DD_XX/
    frames/
      frame_000001.png
      ...
    commentary.jsonl
    commentary.txt
    narration.wav
    capture.mp4
    final.mp4
    capture.log
```

- `frames/`: PNG sequence, 1-based index, fixed width/height.
- `commentary.jsonl`: timestamped lines generated during the run.
- `commentary.txt`: joined/cleaned narration script used for TTS.
- `narration.wav`: generated by Windows SAPI TTS.
- `capture.mp4`: frames -> video (no audio).
- `final.mp4`: capture + narration audio.

---

## CLI / Configuration (Proposed)
Add a new CLI flag set to `mdminecraft`:
```
--record-dir <path>
--record-fps <int>               # default: 20
--record-duration-seconds <int>  # default: 30
--record-format png              # future: raw/pipe
--commentary-style teen          # default: teen
--commentary-min-interval-ms 2000
--commentary-max-interval-ms 5000
--commentary-log <path>
```

Notes:
- `--record-duration-seconds` hard-stops the run to keep output bounded.
- `--record-fps` decouples capture from simulation ticks if needed.
- `--commentary-style` is a rule-driven template engine (see below).

---

## Recording Architecture
### Frame Capture
- Capture at fixed FPS, using a frame scheduler that either:
  - Samples the render output every N ticks (for 20 FPS if ticks=20), or
  - Interpolates/records per-frame if render frequency differs.
- Output PNG for simplicity and determinism.

### Commentary Generation
- On a fixed interval, emit a commentary line based on current world state.
- Each line tagged with `t_ms` from recording start to allow later alignment.
- Commentary **must be generated during the run** to be “in the moment.”

**Example JSONL entry:**
```
{"t_ms": 4200, "text": "Yo that lighting shift is insane, no cap."}
```

---

## Commentary Engine (Rule/Template Based)
We use a small rule engine keyed on game state + recent events.

**Inputs:**
- Time of day / weather changes
- Player position changes (teleport, elevation shifts)
- Mobs nearby count
- Action pulses (jump/attack/use)
- Terrain slope detection (optional)

**Outputs:**
- Short, slang-heavy sentences in the requested style.
- Avoid repetition with a small cooldown + phrase pools.

### Style: “Excitable teen”
Phrase pool examples:
- “Yo, this is **insane**.”
- “No cap, that looks **clean**.”
- “Brooo, that’s **wild**.”
- “Low-key the lighting is **fire**.”
- “That cliff is kinda **sketch**.”
- “That sheep model is **so clean**, fr.”

**Heuristics:**
- Min interval: 2s, max interval: 5s.
- Prioritize new events (weather/time change, teleport, mob spikes).
- If nothing notable, use light filler: “Okay this view is kinda sick.”

---

## Timing & Sync Model
- Capture is **frame-timed** at FPS; commentary is **timestamped** in ms.
- Video timeline: `frame_index / fps` seconds.
- Commentary clip placement: align start time to `t_ms / 1000`.

**Simplest v1:**
- Concatenate commentary into a single narration track with minimal padding.
- Align first narration start to t=0 and let it run over the video.

**More precise option (v1.1):**
- Generate per-line audio clips and place them on a timeline with silence padding.

---

## TTS Pipeline (WSL + Windows SAPI)
Given WSL under Windows:
- Use `powershell.exe` to call SAPI voices (e.g., Microsoft Zira/David).

**Example command (conceptual):**
```
powershell.exe -Command "Add-Type -AssemblyName System.Speech; \
  $speak = New-Object System.Speech.Synthesis.SpeechSynthesizer; \
  $speak.SelectVoice('Microsoft Zira Desktop'); \
  $speak.SetOutputToWaveFile('narration.wav'); \
  $speak.Speak((Get-Content commentary.txt -Raw));"
```

---

## Video Assembly (ffmpeg)
**Frames to MP4:**
```
ffmpeg -framerate <fps> -i frames/frame_%06d.png -c:v libx264 -pix_fmt yuv420p capture.mp4
```

**Mux narration:**
```
ffmpeg -i capture.mp4 -i narration.wav -c:v copy -c:a aac -shortest final.mp4
```

---

## Determinism Considerations
- Recording should not alter simulation behavior.
- Commentary generation should not affect state; it is read-only.
- Use deterministic RNG seeded per run for any randomized phrase selection.

---

## Implementation Sketch (Modules)
1) **Recorder** (new module)
   - Handles frame scheduling and writes PNGs.
   - Knows FPS, duration, output folder.
2) **CommentaryEngine** (new module)
   - State machine + rule system.
   - Emits JSONL events with timestamps.
3) **CLI wiring**
   - Flags to enable recording and configure commentary.
4) **Postprocess Script (optional)**
   - Runs TTS and ffmpeg steps.
   - Can be a Rust subcommand or `tools/` script.

---

## Failure Modes & Mitigations
- **Huge disk usage**: limit duration + FPS + use PNG compression.
- **Dropped frames**: record frame timestamps; warn if behind schedule.
- **TTS not available**: fail gracefully, keep `capture.mp4`.
- **ffmpeg missing**: warn and leave assets for manual postprocess.

---

## Testing & Validation
- **Unit**: commentary rule outputs, deterministic phrase selection.
- **Integration**: record 5s sequence, ensure frames count and commentary log entries.
- **Smoke**: run postprocess on a small sample.

---

## Open Questions
- Preferred FPS: 20 or 30?
- Default voice: Zira or David?
- Do we want a built-in `mdminecraft record` subcommand?
- Should we store a single WAV or per-line clips in v1?

---

## Proposed Next Steps
1) Add CLI flags + frame capture (PNG sequence, 30s @ 20 FPS).
2) Add commentary engine with teen-slang template pool and JSONL output.
3) Add a postprocess tool/script for TTS + ffmpeg.
4) Run one 30s test and verify audio sync.
