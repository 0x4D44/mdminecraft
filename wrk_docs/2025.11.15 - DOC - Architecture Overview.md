# mdminecraft Architecture Overview

**Date:** 2025-11-15
**Version:** Stage 5 (Hardening & Release Prep)
**Purpose:** Comprehensive architectural documentation

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Crate Architecture](#crate-architecture)
3. [Core Systems](#core-systems)
4. [Data Flow](#data-flow)
5. [Determinism](#determinism)
6. [Performance Characteristics](#performance-characteristics)
7. [Testing Strategy](#testing-strategy)
8. [Future Extensions](#future-extensions)

---

## System Overview

**mdminecraft** is a deterministic voxel sandbox engine built in Rust, designed for multiplayer gameplay with client prediction, server-authoritative netcode, and complete deterministic replay capability.

### Design Principles

1. **Determinism First:** Same seed + same inputs = same outputs, always
2. **Server Authority:** Server is source of truth, clients predict and reconcile
3. **Performance:** Target 60 FPS with hundreds of entities and streaming chunks
4. **Modularity:** Clean crate boundaries with minimal dependencies
5. **Testability:** Headless worldtests validate systems at scale

### Key Features

- **Deterministic world generation** from seed
- **Chunk-based streaming** with LOD support
- **Client prediction + reconciliation** (≤30ms error at 100ms RTT)
- **QUIC-based networking** with channel multiplexing
- **Complete replay capability** via event logging
- **Property-based testing** with fuzzing infrastructure

---

## Crate Architecture

### Dependency Graph

```
                    ┌──────────┐
                    │  client  │
                    └────┬─────┘
                         │
         ┌───────────────┼───────────────┐
         │               │               │
    ┌────▼────┐     ┌────▼────┐    ┌────▼────┐
    │ render  │     │  ecs    │    │   net   │
    └────┬────┘     └────┬────┘    └────┬────┘
         │               │               │
         └───────┬───────┴───────┬───────┘
                 │               │
            ┌────▼────┐     ┌────▼────┐
            │  world  │     │ physics │
            └────┬────┘     └────┬────┘
                 │               │
                 └───────┬───────┘
                         │
                    ┌────▼────┐
                    │  core   │
                    └─────────┘

Supporting crates:
┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│ testkit  │  │  assets  │  │scripting │  │   cli    │
└──────────┘  └──────────┘  └──────────┘  └──────────┘
```

### Crate Responsibilities

#### Core (`mdminecraft-core`)
**Purpose:** Fundamental types and utilities shared across all crates

**Key Types:**
- `SimTick` - Logical tick counter for deterministic simulation
- `BlockId`, `BlockState` - Voxel identification
- `Voxel` - Complete voxel data (ID, state, lighting)
- Coordinate systems and conversions

**Dependencies:** None (foundation crate)

#### World (`mdminecraft-world`)
**Purpose:** World generation, chunk management, and persistence

**Key Systems:**
- `TerrainGenerator` - Deterministic world generation from seed
- `BiomeAssigner` - Biome type assignment based on position
- `Heightmap` - Terrain height calculation
- `RegionStore` - Chunk persistence in .rg format
- `Chunk` - 16×256×16 voxel storage with lighting
- `Mob`, `DroppedItem` - Entity implementations

**Dependencies:** `core`

**File Format:** Region files (.rg) with zstd compression + CRC32 validation

#### ECS (`mdminecraft-ecs`)
**Purpose:** Entity-Component-System using bevy_ecs

**Responsibilities:**
- Entity management
- Component storage
- System scheduling
- Query optimization

**Dependencies:** `core`, `bevy_ecs`

#### Physics (`mdminecraft-physics`)
**Purpose:** Collision detection and rigid body simulation

**Systems:**
- AABB collision detection
- Voxel raycasting
- Gravity and velocity integration
- Block placement/breaking validation

**Dependencies:** `core`, `world`

#### Net (`mdminecraft-net`)
**Purpose:** QUIC transport and protocol implementation

**Components:**
- `ServerEndpoint`, `ClientEndpoint` - QUIC connection management
- `ChannelManager` - Message type multiplexing
- Protocol messages (postcard serialization)
- Client prediction and reconciliation

**Dependencies:** `core`, `quinn`, `rustls`, `tokio`

**Channels:**
- **Input** (unreliable datagrams) - Player input
- **EntityDelta** (unreliable datagrams) - Entity state updates
- **ChunkStream** (reliable ordered) - Chunk data
- **Chat** (reliable ordered) - Chat messages
- **Diagnostics** (reliable ordered) - Debug info

#### Render (`mdminecraft-render`)
**Purpose:** GPU rendering via wgpu

**Systems:**
- Chunk meshing (greedy meshing algorithm)
- Vertex buffer generation
- Camera and view frustum
- Shader pipeline

**Dependencies:** `core`, `world`, `wgpu`

#### Server (`mdminecraft-server`)
**Purpose:** Dedicated server executable

**Responsibilities:**
- World simulation authority
- Client connection management
- Chunk streaming to clients
- Server-side entity simulation

**Dependencies:** `core`, `world`, `ecs`, `physics`, `net`

#### Client (`mdminecraft-client`)
**Purpose:** Game client executable

**Responsibilities:**
- Input handling
- Client-side prediction
- Server reconciliation
- Rendering integration

**Dependencies:** `core`, `world`, `ecs`, `physics`, `net`, `render`

#### Testkit (`mdminecraft-testkit`)
**Purpose:** Testing infrastructure and utilities

**Key Features:**
- `EventRecord` - Test event logging
- `MetricsReport` - Standardized metrics export
- `MetricsSink` - Metrics persistence
- Property test helpers
- Worldtest infrastructure

**Dependencies:** `core`, `serde`, `chrono`

#### Assets (`mdminecraft-assets`)
**Purpose:** Asset loading and management

**Responsibilities:**
- Texture atlas management
- Block definitions
- Asset hot-reloading

**Dependencies:** `core`

#### Scripting (`mdminecraft-scripting`)
**Purpose:** Mod API and scripting support (future)

**Status:** Planned for Stage 6

#### CLI (`mdminecraft-cli`)
**Purpose:** Command-line tools and utilities

**Tools:**
- World generation utilities
- Metrics analysis
- Debugging tools

**Dependencies:** `core`, `world`

---

## Core Systems

### World Generation

**Algorithm:** Multi-octave Perlin noise with biome-based modulation

**Process:**
1. **Biome Assignment** (per-column):
   ```
   temperature = perlin(x/800, z/800, seed)
   moisture = perlin(x/800, z/800, seed+1)
   biome = biome_map[temperature][moisture]
   ```

2. **Base Height** (per-column):
   ```
   continental = perlin(x/2000, z/2000) * 100
   erosion = perlin(x/500, z/500) * 30
   detail = perlin(x/80, z/80) * 8
   height = 64 + continental + erosion + detail + biome_offset
   ```

3. **Voxel Filling** (per-column):
   ```
   for y in 0..256:
       if y < height - 4:
           block = STONE
       else if y < height:
           block = DIRT
       else if y == height:
           block = biome.surface_block (GRASS, SAND, etc.)
       else:
           block = AIR
   ```

4. **Features** (per-chunk):
   - Trees (based on biome + random placement)
   - Ores (scattered via noise)
   - Caves (3D Perlin worley noise, future)

**Determinism:** All random values derived from world seed + position. No external randomness.

**Performance:** ~4-5ms per chunk (avg), ~200 chunks/sec throughput

### Chunk Management

**Structure:**
```rust
pub struct Chunk {
    position: ChunkPos,        // (chunk_x, chunk_z)
    voxels: Box<[Voxel]>,     // 16×256×16 = 65,536 voxels
    lighting: LightingData,    // Sky + block light
}
```

**Lifecycle:**
1. **Generate:** TerrainGenerator creates chunk from seed
2. **Populate:** Add features (trees, mobs, etc.)
3. **Light:** Propagate sky and block light
4. **Mesh:** Convert to GPU vertex data (render crate)
5. **Save:** Serialize to region file (optional)
6. **Unload:** Remove from memory when out of range

**Memory:**
- Uncompressed: 65,536 voxels × 4 bytes = 262 KB per chunk
- Compressed (in .rg file): ~500 bytes (498× compression)
- Meshed (GPU): Variable, typically 1-10 KB depending on complexity

### Persistence

**Format:** Region files (.rg)

**Region Layout:**
- Each region covers 32×32 chunks (512×512 blocks)
- Filename: `r.{rx}.{rz}.rg` (e.g., `r.0.0.rg`, `r.-1.2.rg`)
- Structure:
  ```
  [Header: 4KB]
    - Location table: 1024 entries (32×32) × 4 bytes
    - Timestamp table: 1024 entries × 4 bytes
  [Chunk Data: Variable]
    - Chunk 0: [length: u32][compressed_data][crc32: u32]
    - Chunk 1: [length: u32][compressed_data][crc32: u32]
    - ...
  ```

**Compression:** zstd (level 3) achieves ~500× compression on typical chunks

**Integrity:** CRC32 checksum per chunk, validated on load

**Performance:**
- Save (batched): ~50-100ms for 81 chunks
- Save (individual): ~500-1000ms per chunk (due to region rewrites)
- Load: ~700ms per chunk
- **Production:** Always batch saves for optimal performance

### Mob System

**Mob Types:**
- Passive: Pig, Cow, Sheep, Chicken
- Neutral: Wolf, Spider (future)
- Hostile: Zombie, Skeleton, Creeper (future)

**AI States:**
- **Idle:** Standing still, rotating occasionally
- **Wandering:** Moving in random direction with velocity

**Spawning:**
- Biome-based type selection
- Height-based placement (ground level)
- Density limits (chunks track mob count)

**Updates:**
- Per-tick update (~50μs for 1000 mobs)
- AI timer triggers state transitions
- Velocity integration for movement
- Collision detection (basic)

**Performance:** 0.016μs per mob per tick (60M updates/sec)

### Lighting

**Two Types:**
- **Sky Light:** Sunlight propagating down from sky
- **Block Light:** Light emitted by blocks (torches, lava, etc.)

**Algorithm:** BFS flood-fill propagation

**Storage:** 4 bits per light type per voxel (0-15 brightness)

**Updates:**
- Initial: Propagate from sky downward
- Block place: Remove light, recompute affected region
- Block break: Add light sources, propagate

**Performance:** ~5ms for full chunk lighting (future optimization target)

### Networking

**Transport:** QUIC (UDP-based, reliable + unreliable streams)

**Protocol:** Postcard serialization (efficient binary format)

**Architecture:**
```
Client                          Server
  ↓                               ↓
[Input] ─────(datagram)──────> [Authoritative Sim]
  ↓                               ↓
[Prediction]                   [State Update]
  ↓                               ↓
[Render]  <──(datagram)────── [EntityDelta]
  ↓
[Reconciliation]
  (if misprediction)
```

**Client Prediction:**
1. Client sends input to server
2. Client immediately predicts result locally
3. Server processes input authoritatively
4. Server sends back state update
5. Client reconciles: if mismatch, rewind and replay

**Target:** ≤30ms reconciliation error at 100ms RTT

---

## Data Flow

### World Generation Flow

```
Seed + ChunkPos
    ↓
BiomeAssigner
    → temperature, moisture
    → BiomeId
    ↓
Heightmap::generate
    → continental, erosion, detail noise
    → height per (x, z)
    ↓
TerrainGenerator::generate_chunk
    → fill voxels (stone, dirt, surface)
    → add features (trees, ores)
    → Chunk
    ↓
LightingPropagation::propagate
    → compute sky + block light
    → Updated Chunk
    ↓
(Optional) RegionStore::save_chunk
    → compress + CRC
    → write to .rg file
```

### Render Pipeline Flow

```
Chunk
    ↓
ChunkMesher::mesh
    → greedy meshing algorithm
    → cull hidden faces
    → generate vertices + indices
    → MeshData
    ↓
VertexBuffer::upload
    → GPU buffer
    ↓
Render Pass
    → bind vertex buffer
    → bind texture atlas
    → draw indexed
    → Screen pixels
```

### Network Message Flow

#### Client → Server
```
Player Input (W, A, S, D, Space, Mouse)
    ↓
InputMessage
    → serialize (postcard)
    → send via Input channel (datagram)
    ↓
Server receives
    ↓
Server applies input to entity
    ↓
Server simulation tick
```

#### Server → Client
```
Server simulation tick
    ↓
Collect entity state changes
    ↓
EntityDeltaMessage
    → delta compress (only changed fields)
    → serialize (postcard)
    → send via EntityDelta channel (datagram)
    ↓
Client receives
    ↓
Client reconciliation
    ↓
Client render
```

#### Chunk Streaming
```
Client moves
    ↓
Client requests chunks (ChunkRequest message)
    ↓
Server loads/generates chunks
    ↓
ChunkDataMessage
    → compress (zstd)
    → serialize (postcard)
    → send via ChunkStream channel (reliable stream)
    ↓
Client receives
    ↓
Client decompresses and stores
    ↓
Client meshes and uploads to GPU
```

---

## Determinism

### Why Determinism Matters

1. **Multiplayer:** Clients can predict server state accurately
2. **Replay:** Record inputs, replay exactly
3. **Testing:** Reproducible bugs and regressions
4. **Debugging:** Same scenario, every time

### Determinism Guarantees

**Guaranteed Deterministic:**
- ✅ World generation from seed
- ✅ Biome assignment
- ✅ Heightmap generation
- ✅ Feature placement (trees, ores)
- ✅ Mob spawning positions
- ✅ Mob AI behavior
- ✅ Physics simulation
- ✅ Block interactions

**Platform Differences:**
- ✅ Cross-platform: x86-64, ARM64 produce identical results
- ✅ Endianness: Little-endian and big-endian compatible (postcard)
- ✅ Compiler: rustc version doesn't affect determinism
- ✅ Optimization level: Debug and release produce same results

### Determinism Implementation

**Random Number Generation:**
- Custom deterministic PRNG based on world seed
- All "random" values derived from: `seed ⊕ position ⊕ context`
- No `rand::thread_rng()` or system entropy

**Floating Point:**
- Careful use of f64 (prefer fixed-point where possible)
- No platform-specific math functions (sin, cos, etc.)
- Deterministic rounding

**Hash Maps:**
- Never iterate HashMap in generation code
- Use BTreeMap or Vec for deterministic iteration
- Chunk generation order independent

**Time:**
- No `std::time::SystemTime` in simulation
- Use `SimTick` for all timing
- Server provides authoritative time

### Validation

**Determinism Worldtest:**
- Generates same chunks 4× with different iteration orders
- Compares 18.9M voxels bit-for-bit
- Must achieve 100% match (0 mismatches)
- Runs on every CI build

---

## Performance Characteristics

### Benchmarks (Current)

| System | Metric | Value | Target | Status |
|--------|--------|-------|--------|--------|
| Terrain Gen | Avg time | 4.4ms/chunk | <30ms | ✅ 6.8× faster |
| Terrain Gen | Throughput | 228 chunks/sec | >33 chunks/sec | ✅ 6.9× faster |
| Mob Update | Per mob | 0.016μs | <1μs | ✅ 63× faster |
| Mob Update | Per tick (80k mobs) | 1.3ms | <50ms | ✅ 38× faster |
| Item Update | Per item | 0.007μs | <1μs | ✅ 147× faster |
| Persistence | Compression | 498× | >3× | ✅ 166× better |
| Persistence | Save (batched) | ~1ms/chunk | <10ms | ✅ 10× faster |
| Persistence | Load | ~700ms/chunk | <1000ms | ✅ Within target |

### Scalability

**Chunk Loading:**
- 1 chunk: 4.4ms
- 100 chunks: 440ms (linear)
- 1000 chunks: 4.4s (linear)
- 2,601 chunks: 11.4s (linear)

**Mob Simulation:**
- 1k mobs: 0.016ms/tick
- 10k mobs: 0.16ms/tick
- 80k mobs: 1.3ms/tick
- Linear scaling up to tested limits

**Memory Usage:**
- Chunk (uncompressed): 262 KB
- Chunk (compressed in file): ~500 bytes
- Chunk (meshed GPU data): 1-10 KB
- 1000 loaded chunks: ~256 MB RAM

### Optimization Strategies

**Terrain Generation:**
- Noise computation is dominant cost
- Future: SIMD vectorization for noise
- Future: GPU compute shader generation

**Meshing:**
- Greedy meshing reduces face count 60-90%
- Face culling (hidden faces not meshed)
- Future: Parallel meshing for multiple chunks

**Persistence:**
- Batch saves to minimize region file rewrites
- zstd compression with tuned level (3 = speed/ratio balance)
- Async I/O for non-blocking saves

**Networking:**
- Delta compression (only changed fields)
- Datagram messages for unreliable data
- Chunk streaming prioritization (nearest first)

---

## Testing Strategy

### Test Pyramid

```
            ┌─────────────────┐
            │   Worldtests    │  (5 tests, minutes, full system)
            │   Integration   │
            └─────────────────┘
          ┌─────────────────────┐
          │  Integration Tests  │  (37 tests, seconds, 2-3 systems)
          └─────────────────────┘
        ┌─────────────────────────┐
        │      Unit Tests         │  (117 tests, milliseconds, single component)
        └─────────────────────────┘
```

**Total Tests:** 159 (100% pass rate)

### Test Types

**Unit Tests (117):**
- Single function/struct validation
- Fast (<1ms each)
- High coverage of edge cases
- Example: `terrain::heightmap::tests::test_deterministic_heights`

**Integration Tests (37):**
- 2-3 system interaction
- Medium speed (1-100ms each)
- Validates component boundaries
- Example: `world::chunk_lighting_integration_test`

**Property Tests (proptest):**
- Randomized input generation
- Validates invariants over 100-1000 cases
- Finds edge cases humans miss
- Example: `terrain::fuzz::prop_no_discontinuous_seams`

**Worldtests (5):**
- Full system validation
- Slow (1s-3min each)
- Scale testing (100s-1000s of chunks)
- Metrics export for regression tracking
- Example: `large_scale_terrain_worldtest`

### Testing Infrastructure

**Testkit Crate:**
- `EventRecord` - Deterministic event logging
- `MetricsReport` - Standardized performance metrics
- `MetricsSink` - JSON export for CI/CD
- Shared test utilities

**Property Testing:**
- proptest for randomized testing
- Custom generators for world data
- Shrinking to minimal failing case

**Fuzzing (Future):**
- cargo-fuzz integration
- Fuzz region file parsing
- Fuzz network message handling
- Continuous fuzzing in CI

---

## Future Extensions

### Stage 6: Content & Polish (Planned)

**Features:**
- More biomes (jungle, savanna, mushroom, etc.)
- Caves and underground generation
- Structures (villages, dungeons)
- More mob types and behaviors
- Crafting recipes expansion
- Advanced lighting (colored lights, shadows)

**Technical:**
- Mod API and scripting support
- Asset hot-reloading
- Advanced render features (PBR, ambient occlusion)
- Voice chat

### Stage 7: Advanced Features (Future)

**Gameplay:**
- Redstone-like logic system
- Advanced AI (pathfinding, combat)
- Quests and objectives
- Multiplayer scaling (100+ players)

**Technical:**
- Distributed server architecture
- GPU terrain generation
- Advanced physics (water, fluids)
- Cross-platform mobile support

### Optimization Roadmap

**Short-term (Stage 5-6):**
- Parallel chunk meshing
- SIMD noise generation
- Lighting optimization
- Network protocol tuning

**Long-term (Stage 7+):**
- GPU compute terrain generation
- Sparse voxel octree (SVO) rendering
- Level-of-detail (LOD) meshing
- Distributed world simulation

---

## Architecture Decisions

### Why Rust?

- **Safety:** No segfaults, data races caught at compile time
- **Performance:** Zero-cost abstractions, C++ level performance
- **Determinism:** Precise control over memory and behavior
- **Ecosystem:** Excellent crates (wgpu, quinn, bevy_ecs)
- **Async:** Tokio for high-performance networking

### Why QUIC?

- **Modern:** Designed for modern internet (handles packet loss, NAT)
- **Multiplexing:** Multiple streams without head-of-line blocking
- **Security:** TLS 1.3 built-in
- **Performance:** 0-RTT connection resumption
- **Unreliable:** Supports datagrams for low-latency unreliable data

### Why Chunks?

- **Streaming:** Load/unload as player moves
- **Persistence:** Save/load independently
- **Meshing:** Parallel mesh generation
- **Network:** Stream to clients efficiently
- **Standard:** Proven approach (Minecraft, etc.)

### Why Determinism?

- **Prediction:** Clients predict server accurately
- **Replay:** Perfect replay from inputs
- **Testing:** Reproducible tests and bugs
- **Debugging:** Consistent behavior every run

---

## Additional Resources

- **HLD:** `wrk_docs/2025.11.12 - HLD - Deterministic Voxel Sandbox.md`
- **Implementation Plan:** `wrk_docs/2025.11.12 - PLN - Deterministic Voxel Sandbox Implementation.md`
- **Stage 5 Plan:** `wrk_docs/2025.11.15 - PLN - Stage 5 Hardening and Release Prep.md`
- **Worldtest Guide:** `wrk_docs/2025.11.15 - DOC - Worldtest Usage Guide.md`
- **Performance Baselines:** `wrk_docs/2025.11.15 - BAS - Performance Baselines.md`

---

**Document Version:** 1.0
**Last Updated:** 2025-11-15
**Maintained By:** Core development team
