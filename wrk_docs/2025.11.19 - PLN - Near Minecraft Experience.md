# Implementation Plan — Near-Minecraft Experience (2025-11-19)

## Change Log
- **2025-11-19 (initial)**: Authored phase-based rollout aligning with HLD milestones.
- **2025-11-19 (review update)**: Added staffing assumptions, success metrics per phase, highlighted risks/mitigations, QA/perf gates, and clarified inter-phase dependencies/parallelism.

## Plan Structure
- **Phase 0**: Foundations & Tooling
- **Phase 1**: Rendering Upgrade
- **Phase 2**: Core Gameplay Loop
- **Phase 3**: World Persistence & Streaming
- **Phase 4**: Entities & Combat
- **Phase 5**: Audio & UX Polish
- **Phase 6**: Content Expansion (Stretch)

Each phase now specifies objectives, tasks, ownership, dependencies, exit criteria, KPIs, and top risks.

## Assumptions & Staffing
- Team: 4 engineers (Render/Graphics, Gameplay/UI, World/Systems, Tools/Platform), 1 technical artist, 1 audio contractor. QA support ramps starting Phase 2.
- Cadence: 2-week sprints with phase-level kickoff/exit reviews. Phases may overlap (e.g., audio groundwork during Phase 4).
- Hardware target: GTX 1660 / Ryzen 5 3600 / 16 GB RAM; Windows/Linux parity.

## Phase Gating & Releases
- Phases 0–3 culminate in **Alpha** (playable survival loop, saves, but placeholder mobs/audio).
- Phase 4 unlocks **Beta** (combat + mobs). Phase 5 drives **Content Complete**; Phase 6 optional polish/stretch.
- Each phase exit requires: feature checklist complete, regression suite green, perf budget met, docs updated.

---

## Phase 0 — Foundations & Tooling (2 weeks)
**Objectives**
- Establish project scaffolding for assets, data, and testing.
- Decide on ECS/audio libraries, create internal tooling.

**Owners**: Tools/Platform engineer (lead), Render engineer (asset pipeline support), QA-infra partner.

**Tasks**
1. Asset pipeline spike: texture packer prototype (atlas builder), audio ingestion tool.
2. ECS evaluation: benchmark `bevy_ecs` vs `hecs`, choose architecture, document patterns.
3. Serialization format decision: select chunk storage format, design version metadata.
4. Build/test infra: automated builds, perf benchmark harness, QA checklist integration.

**Deliverables**
- Tooling binaries/scripts checked into `tools/`.
- Decision docs for ECS, serialization, asset pipeline.
- CI workflows running `cargo fmt/clippy/test`, perf smoke test, worldgen validation.

**Exit Criteria**
- Tooling usable by art/audio teams.
- ECS & save-format decisions ratified.
- Baseline CI green.

**KPIs / Gates**
- CI duration < 10 minutes, ≥95% pass rate.
- Asset pipeline packs ≥500 textures in <1 min on target dev machine.

**Risks & Mitigations**
- *Tooling churn*: schedule design reviews, keep CLI tools versioned.
- *Indecision on ECS*: time-box spike (1 week) and document trade-offs.

---

## Phase 1 — Rendering Upgrade (6 weeks)
**Objectives**
- Replace debug visuals with Minecraft-like fidelity: texture atlas, lighting, sky/weather, fluids, particles.

**Owners**: Render/Graphics engineer (lead), Technical artist (atlas assets), Tools engineer (build integration).

**Tasks**
1. Texture atlas system: per-face UVs, mipmaps, biome tint masks, animation frames.
2. Lighting rewrite: skylight & block light propagation, smooth lighting in shader, gamma-correct pipeline.
3. Sky/weather renderer: sun/moon, stars, clouds, fog, rain/snow overlays.
4. Fluid shader: animated water/lava with transparency, refraction-ish normals, edge foam.
5. Particle framework: emitters for block break, footsteps, ambient FX.
6. Performance testing + optimization (frustum culling, chunk mesh caching, GPU profiling).

**Dependencies**
- Asset pipeline from Phase 0.

**Deliverables**
- Visual demo showcasing new renderer, weather toggles, fluid animations.
- Lighting unit tests + debug visualizations.
- Documented render settings (render distance, graphics quality).

**Exit Criteria**
- Game runs ≥60 FPS on target hardware with new visuals.
- All faces render correctly with textures and lighting.
- Weather toggles, day/night transitions, particles functioning.

**KPIs / Gates**
- Frame time ≤16.6 ms @1080p, 12-chunk render distance.
- Lighting correctness validated via automated screenshot diff tests.
- 0 critical GPU validation errors over 30‑minute soak.

**Risks & Mitigations**
- *Performance regression*: integrate GPU/perf telemetry dashboards, gate merges on perf budgets.
- *Asset timing*: ensure placeholder textures exist; sync regularly with art pipeline.

---

## Phase 2 — Core Gameplay Loop (8 weeks)
**Objectives**
- Implement block/item registries, inventory UI, crafting/smelting, hunger/health, tool durability.

**Owners**: Gameplay/UI engineer (lead), World/Systems engineer (data schema), UX designer support.

**Tasks**
1. Data-driven block/item schemas (JSON/RON), loader, hot reload for dev.
2. Inventory system: backend + UI (hotbar, backpack, armor slots, tooltips).
3. Crafting: 2×2 + 3×3 grids, recipe book UI, furnace/smoker/blast furnace workflows.
4. Tool + block interaction: hardness, correct drops, tool tiers, durability, XP orbs placeholder.
5. Hunger, saturation, exhaustion integration; passive health regen, damage sources.
6. Bed/spawn logic; simple death/respawn screen.

**Dependencies**
- Rendering upgrades for UI components.
- ECS decision (inventory may tie into ECS later, but can start standalone).

**Deliverables**
- Playtest build where player can harvest wood, craft stone/iron tools, cook food, manage hunger.
- Documentation for adding new blocks/items/recipes.

**Exit Criteria**
- Player can survive first in-game night with shelter, craft iron gear, maintain hunger/health.
- Inventory/crafting UI polished and controller-friendly (if planned).

**KPIs / Gates**
- Tutorial checklist: wood→stone→iron path completable in <20 minutes.
- Crafting success rate ≥95% in QA scenarios; no dupes/exploits.
- Save size increase from new data <10% vs Phase 1 baseline.

**Risks & Mitigations**
- *Data-driven complexity*: implement schema validation + migration tests.
- *UI scope creep*: lock MVP UI spec, backlog cosmetic improvements.

---

## Phase 3 — World Persistence & Streaming (4 weeks)
**Objectives**
- Implement chunk saving/loading, asynchronous streaming, world selection UI.

**Owners**: World/Systems engineer (lead), Tools engineer (IO pipeline), Gameplay engineer (UI hooks).

**Tasks**
1. Region file format implementation (chunk compression, metadata, indexes).
2. World streaming manager: chunk request queue, LRU eviction, priorities for player direction.
3. Background workers for generation, lighting, meshing, save IO.
4. World selection/create/delete UI with seed, game mode settings.
5. Autosave + crash recovery (safe writes, journaling).

**Dependencies**
- Block/item data from Phase 2.
- Lighting pipeline from Phase 1.

**Deliverables**
- Spawn radius loading seamlessly while moving; debug metrics for streaming.
- Save files stored per world; load/resume functionality tested.

**Exit Criteria**
- Player can quit/relaunch without world corruption; streaming keeps up with movement at 60 FPS.
- Autosave every N minutes; crash recovery tested.

**KPIs / Gates**
- Chunk round-trip (request→render) median <250 ms within 8-chunk radius.
- Save/load fuzz tests (10k iterations) report zero corruption.
- Disk footprint per chunk <128 KB average (compressed).

**Risks & Mitigations**
- *IO stalls*: implement async IO + rate limiting; instrument metrics.
- *Save compatibility*: versioned schema with migration tests each release.

---

## Phase 4 — Entities & Combat (8 weeks)
**Objectives**
- Introduce ECS-based entity simulation, passive/hostile mobs, combat, drops, simple AI.

**Owners**: Systems engineer (ECS lead), Gameplay engineer (combat), Audio contractor (temp SFX), QA for combat tuning.

**Tasks**
1. Integrate chosen ECS; refactor player and world systems to components/systems.
2. Physics/collision for entities (AABB), simple steering.
3. Passive mobs: cow, pig, sheep, chicken (wander, breeding, drops, sounds).
4. Hostiles: zombie, skeleton, creeper with spawn rules (light <7), pathfinding, attacks, loot.
5. Projectiles (arrows) and TNT/explosion logic (damage terrain, apply knockback).
6. Combat feedback: damage numbers, hit sounds, particle effects.

**Dependencies**
- Tool/weapon data, hunger/health from Phase 2.
- Audio hooks for SFX (Phase 5 partially parallelizable).

**Deliverables**
- Demo where player survives multiple nights fighting mobs, collecting drops.
- AI tuning docs, spawn rate config.

**Exit Criteria**
- >500 entities handled without dropping below performance target.
- Combat loop felt “fun” per playtest feedback (qualitative).

**KPIs / Gates**
- AI tick budget ≤4 ms @ 400 entities.
- Spawn/despawn rates configurable; 0 crashes after 2‑hour survival soak.
- Player survival metrics: success rate ≥70% over 5-night scenario.

**Risks & Mitigations**
- *ECS integration regressions*: staged rollout (player first, mobs later), plenty of automated tests.
- *AI pathfinding cost*: start with simple navgrid + caching, escalate to BT only if needed.

---

## Phase 5 — Audio & UX Polish (4 weeks)
**Objectives**
- Integrate audio engine, implement HUD parity, menus/options, accessibility tweaks.

**Owners**: Audio contractor (engine + assets), Gameplay/UI engineer (HUD/menus), UX designer.

**Tasks**
1. Audio engine hookup (Kira/Rodio): mixers, event routing, positional audio.
2. Asset integration: music playlists, ambience, SFX sets; create volume sliders.
3. HUD polish: health, hunger, armor, XP, status effect icons, crosshair, chat overlay (if scope allows).
4. Main menu + pause menu design (animated background, world list integration).
5. Settings UI: video, audio, controls, accessibility (font scaling, colorblind filter baseline).
6. Tutorial onboarding hints/tooltips; debug HUD refinements.

**Dependencies**
- Rendering HUD elements from Phase 1, gameplay data from Phase 2/4.

**Deliverables**
- Audio test suite (unit + manual) verifying event coverage.
- UX playtest report.

**Exit Criteria**
- Audio playing in-game with context transitions; UI parity close to Minecraft baseline.
- Options saved per user profile; onboarding/tutorial present.

**KPIs / Gates**
- Audio latency <60 ms for SFX; verified via profiler.
- Accessibility checklist (text scaling, colorblind filter, remappable inputs) complete.
- Usability study: ≥80% tasks completed without guidance.

**Risks & Mitigations**
- *Audio popping/perf*: precompute mixes, stream longer tracks, profile CPU load.
- *UI scope*: keep theme guidelines; backlog cosmetic polish.

---

## Phase 6 — Content Expansion (Stretch 6+ weeks)
**Objectives**
- Layer on additional content (structures, advanced biomes, weather impacts, advanced mobs) and polish.

**Owners**: Shared across gameplay/world teams; producer prioritizes backlog; QA leads long-run tests.

**Tasks**
1. Structures: villages, mineshafts-lite, dungeons, ruins generation.
2. Weather effects influencing gameplay (snow accumulation, thunderstorms, lightning strikes).
3. Additional biomes + flora, crop growth cycles, farmland hydration.
4. Advanced mobs (witch, enderman, spiders) + new combat mechanics.
5. Enchanting/potions/planned Redstone foundations if time.
6. QA hardening: long-run soak tests, perf regression automation, save migration tests.

**Dependencies**
- All previous phases.

**Deliverables**
- Feature-complete survival demo with diverse content.
- Release candidate checklist, regression suite results.

**Exit Criteria**
- MVP goals/meters satisfied (see HLD success metrics).
- Stability sign-off, documentation complete.

**KPIs / Gates**
- Content breadth metrics met (≥8 biomes, ≥6 mobs, etc.).
- 24‑hour soak with ≤1 crash, memory leak <2% growth.

**Risks & Mitigations**
- *Scope balloon*: maintain prioritized content list; drop low-impact features if schedule slips.
- *Regression risk*: automate nightly worldgen + survival soak tests.

---

## Cross-Cutting Concerns
- **QA/Testing**: add integration tests per phase (render visual tests, crafting unit tests, worldgen validation, AI behavior tests). Maintain regression checklist docs.
- **Performance**: instrument metrics (frame time, chunk gen latency, entity counts) and gate merges with budgets.
- **Docs**: update README, developer wiki, and user manual after each phase; maintain API docs for data-driven registries.
- **Project Management**: hold phase kickoff/exit reviews, backlog grooming, and risk assessments.
