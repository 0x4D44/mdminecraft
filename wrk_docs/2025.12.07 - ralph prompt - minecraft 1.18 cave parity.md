# Ralph Prompt: Minecraft 1.18 Cave Generation Parity

## TASK: Implement Full Minecraft 1.18 Cave System

Upgrade mdminecraft's cave generation to match Minecraft 1.18+ "Caves and Cliffs" feature parity. This builds on the existing basic cave system to add multiple carver types, aquifers, ravines, geodes, and extensive cave decorations.

### JOURNAL REQUIREMENT

Maintain a journal in `wrk_journals` folder. Name: `2025.12.07 - JRN - Minecraft 1.18 Cave Parity.md`

### PREREQUISITES

- Existing cave system in `crates/world/src/caves.rs` (basic CaveCarver)
- Existing cave biomes: Stone, Lush, Dripstone, DeepDark, Flooded
- Existing cave blocks: moss_block(100), deepslate(101), glow_lichen(102), pointed_dripstone(103), sculk(104)

### COMPLETION CRITERIA

1. `cargo build` compiles with zero errors and zero warnings
2. `cargo clippy --all-targets --all-features` passes with zero warnings
3. `cargo fmt --all -- --check` passes
4. `cargo test --all` passes ALL tests
5. Three distinct cave types generate (Cheese, Spaghetti, Noodle)
6. Aquifer system creates water and lava lakes at appropriate depths
7. Ravines generate as vertical canyons
8. Amethyst geodes spawn rarely underground
9. All Minecraft 1.18 cave biome blocks are present and render
10. Surface detection prevents floating islands

---

## PHASE 1: Multiple Cave Carver Types

### 1.1 Create Cheese Cave Carver (Large Caverns)

Add to `crates/world/src/caves.rs`:

```rust
/// Cheese cave carver - large open caverns
pub struct CheeseCaveCarver {
    noise: NoiseGenerator,
    params: CaveParams,
}

impl CheeseCaveCarver {
    pub fn new(seed: u64) -> Self {
        let config = NoiseConfig {
            octaves: 3,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.03, // Lower frequency = larger caves
            seed: ((seed ^ 0xCHEESE01) as u32),
        };
        Self {
            noise: NoiseGenerator::new(config),
            params: CaveParams {
                frequency: 0.03,
                threshold: 0.5, // Higher threshold = more air
                min_y: 5,
                max_y: 120,
                vertical_squash: 1.5,
            },
        }
    }

    pub fn carve_chunk(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in self.params.min_y..=self.params.max_y.min(CHUNK_SIZE_Y as i32 - 1) {
                    if self.should_carve(world_x, y, world_z) {
                        let voxel = chunk.voxel(local_x, y as usize, local_z);
                        if voxel.id != 0 && voxel.id != 1 && voxel.id != 14 {
                            let mut new_voxel = voxel;
                            new_voxel.id = 0;
                            chunk.set_voxel(local_x, y as usize, local_z, new_voxel);
                        }
                    }
                }
            }
        }
    }

    fn should_carve(&self, x: i32, y: i32, z: i32) -> bool {
        let squashed_y = y as f64 / self.params.vertical_squash;
        let noise_val = self.noise.sample_3d(
            x as f64 * self.params.frequency,
            squashed_y * self.params.frequency,
            z as f64 * self.params.frequency,
        );
        let normalized = (noise_val + 1.0) / 2.0;
        normalized > self.params.threshold
    }
}
```

### 1.2 Create Spaghetti Cave Carver (Winding Tunnels)

```rust
/// Spaghetti cave carver - long winding tunnels
pub struct SpaghettiCaveCarver {
    noise: NoiseGenerator,
    thickness_noise: NoiseGenerator,
}

impl SpaghettiCaveCarver {
    pub fn new(seed: u64) -> Self {
        let noise_config = NoiseConfig {
            octaves: 4,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.08,
            seed: ((seed ^ 0x5PAGHETT) as u32),
        };
        let thickness_config = NoiseConfig {
            octaves: 2,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.15,
            seed: ((seed ^ 0xTHICKNE5) as u32),
        };
        Self {
            noise: NoiseGenerator::new(noise_config),
            thickness_noise: NoiseGenerator::new(thickness_config),
        }
    }

    pub fn carve_chunk(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 5..120 {
                    if self.should_carve(world_x, y, world_z) {
                        let voxel = chunk.voxel(local_x, y, local_z);
                        if voxel.id != 0 && voxel.id != 1 && voxel.id != 14 {
                            let mut new_voxel = voxel;
                            new_voxel.id = 0;
                            chunk.set_voxel(local_x, y, local_z, new_voxel);
                        }
                    }
                }
            }
        }
    }

    fn should_carve(&self, x: i32, y: i32, z: i32) -> bool {
        // Use 3D noise to determine tunnel path
        let path_noise = self.noise.sample_3d(
            x as f64 * 0.08,
            y as f64 * 0.08,
            z as f64 * 0.08,
        );

        // Use separate noise for tunnel thickness
        let thickness = self.thickness_noise.sample_3d(
            x as f64 * 0.15,
            y as f64 * 0.15,
            z as f64 * 0.15,
        );

        // Carve if within threshold of the path
        let threshold = 0.15 + thickness.abs() * 0.1;
        path_noise.abs() < threshold
    }
}
```

### 1.3 Create Noodle Cave Carver (Thin Passages)

```rust
/// Noodle cave carver - very thin winding passages
pub struct NoodleCaveCarver {
    noise: NoiseGenerator,
}

impl NoodleCaveCarver {
    pub fn new(seed: u64) -> Self {
        let config = NoiseConfig {
            octaves: 5,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.12,
            seed: ((seed ^ 0xN00DLE99) as u32),
        };
        Self {
            noise: NoiseGenerator::new(config),
        }
    }

    pub fn carve_chunk(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 5..120 {
                    if self.should_carve(world_x, y, world_z) {
                        let voxel = chunk.voxel(local_x, y, local_z);
                        if voxel.id != 0 && voxel.id != 1 && voxel.id != 14 {
                            let mut new_voxel = voxel;
                            new_voxel.id = 0;
                            chunk.set_voxel(local_x, y, local_z, new_voxel);
                        }
                    }
                }
            }
        }
    }

    fn should_carve(&self, x: i32, y: i32, z: i32) -> bool {
        let noise_val = self.noise.sample_3d(
            x as f64 * 0.12,
            y as f64 * 0.12,
            z as f64 * 0.12,
        );

        // Very thin threshold for noodle caves
        noise_val.abs() < 0.08
    }
}
```

### 1.4 Integrate All Carvers into TerrainGenerator

Modify `crates/world/src/terrain.rs`:

```rust
pub struct TerrainGenerator {
    // ... existing fields ...
    cheese_carver: CheeseCaveCarver,
    spaghetti_carver: SpaghettiCaveCarver,
    noodle_carver: NoodleCaveCarver,
}

impl TerrainGenerator {
    pub fn new(seed: u64) -> Self {
        Self {
            // ... existing initialization ...
            cheese_carver: CheeseCaveCarver::new(seed),
            spaghetti_carver: SpaghettiCaveCarver::new(seed),
            noodle_carver: NoodleCaveCarver::new(seed),
        }
    }

    pub fn generate_chunk(&self, pos: ChunkPos) -> Chunk {
        let mut chunk = Chunk::new(pos);

        // Existing terrain generation...
        self.generate_terrain(&mut chunk, pos);
        self.place_ores(&mut chunk, pos);

        // Carve caves in order - cheese first (largest)
        self.cheese_carver.carve_chunk(&mut chunk, pos.x, pos.z);
        self.spaghetti_carver.carve_chunk(&mut chunk, pos.x, pos.z);
        self.noodle_carver.carve_chunk(&mut chunk, pos.x, pos.z);

        // Surface features AFTER caves
        self.place_trees(&mut chunk, pos);

        chunk
    }
}
```

---

## PHASE 2: Aquifer System (Water & Lava Lakes)

### 2.1 Create Aquifer Generator

Create `crates/world/src/aquifer.rs`:

```rust
//! Aquifer system for underground water and lava lakes

use crate::chunk::{BlockId, Chunk, CHUNK_SIZE_X, CHUNK_SIZE_Y, CHUNK_SIZE_Z};
use crate::noise::{NoiseConfig, NoiseGenerator};

pub struct AquiferGenerator {
    aquifer_noise: NoiseGenerator,
    lava_noise: NoiseGenerator,
}

impl AquiferGenerator {
    pub fn new(seed: u64) -> Self {
        let aquifer_config = NoiseConfig {
            octaves: 4,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.02,
            seed: ((seed ^ 0xAQUIFER1) as u32),
        };
        let lava_config = NoiseConfig {
            octaves: 3,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.03,
            seed: ((seed ^ 0xLAVA1234) as u32),
        };
        Self {
            aquifer_noise: NoiseGenerator::new(aquifer_config),
            lava_noise: NoiseGenerator::new(lava_config),
        }
    }

    /// Fill air pockets with water or lava based on depth and noise
    pub fn fill_aquifers(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 1..CHUNK_SIZE_Y {
                    let voxel = chunk.voxel(local_x, y, local_z);
                    if voxel.id != 0 {
                        continue; // Not air
                    }

                    let fluid = self.get_fluid_at(world_x, y as i32, world_z);
                    if fluid != 0 {
                        let mut new_voxel = voxel;
                        new_voxel.id = fluid;
                        chunk.set_voxel(local_x, y, local_z, new_voxel);
                    }
                }
            }
        }
    }

    fn get_fluid_at(&self, x: i32, y: i32, z: i32) -> BlockId {
        // Below y=10, check for lava
        if y < 10 {
            let lava_noise = self.lava_noise.sample_3d(
                x as f64 * 0.03,
                y as f64 * 0.03,
                z as f64 * 0.03,
            );
            if lava_noise > 0.3 {
                return 15; // lava block ID
            }
        }

        // Check for water aquifers
        let aquifer_noise = self.aquifer_noise.sample_3d(
            x as f64 * 0.02,
            y as f64 * 0.02,
            z as f64 * 0.02,
        );

        // Water level depends on depth
        let water_threshold = if y < 30 {
            0.4
        } else if y < 50 {
            0.5
        } else {
            0.6
        };

        if aquifer_noise > water_threshold {
            14 // water block ID
        } else {
            0 // air
        }
    }

    /// Place magma blocks under lava lakes
    pub fn place_lava_floor(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 1..20 {
                    let voxel = chunk.voxel(local_x, y, local_z);
                    if voxel.id == 15 {
                        // Lava above
                        let below = chunk.voxel(local_x, y - 1, local_z);
                        if below.id == 13 {
                            // Stone below lava
                            let mut new_voxel = below;
                            new_voxel.id = 105; // magma_block
                            chunk.set_voxel(local_x, y - 1, local_z, new_voxel);
                        }
                    }
                }
            }
        }
    }
}
```

### 2.2 Add Lava and Magma Blocks

Update `config/blocks.json`:

```json
{
  "name": "lava",
  "id": 15,
  "opaque": false,
  "transparent": true,
  "light_level": 15,
  "textures": {
    "all": "blocks/lava"
  }
},
{
  "name": "magma_block",
  "id": 105,
  "opaque": true,
  "light_level": 3,
  "textures": {
    "all": "blocks/magma_block"
  }
}
```

---

## PHASE 3: Ravine Carver (Vertical Canyons)

### 3.1 Create Ravine Carver

Add to `crates/world/src/caves.rs`:

```rust
/// Ravine carver - deep vertical canyons
pub struct RavineCarver {
    noise: NoiseGenerator,
    width_noise: NoiseGenerator,
}

impl RavineCarver {
    pub fn new(seed: u64) -> Self {
        let noise_config = NoiseConfig {
            octaves: 3,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.01,
            seed: ((seed ^ 0xRAVINE42) as u32),
        };
        let width_config = NoiseConfig {
            octaves: 2,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.05,
            seed: ((seed ^ 0xWIDTH123) as u32),
        };
        Self {
            noise: NoiseGenerator::new(noise_config),
            width_noise: NoiseGenerator::new(width_config),
        }
    }

    pub fn carve_chunk(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                // Check if this column should have a ravine
                if !self.is_ravine_path(world_x, world_z) {
                    continue;
                }

                let width = self.get_width_at(world_x, world_z);

                // Carve vertically from top to near-bedrock
                for y in 5..80 {
                    // Calculate distance from ravine center
                    let distance = self.distance_from_center(world_x, world_z, local_x, local_z);

                    if distance < width {
                        let voxel = chunk.voxel(local_x, y, local_z);
                        if voxel.id != 0 && voxel.id != 1 {
                            let mut new_voxel = voxel;
                            new_voxel.id = 0;
                            chunk.set_voxel(local_x, y, local_z, new_voxel);
                        }
                    }
                }
            }
        }
    }

    fn is_ravine_path(&self, x: i32, z: i32) -> bool {
        let noise = self.noise.sample_2d(x as f64 * 0.01, z as f64 * 0.01);
        noise > 0.85 // Ravines are rare
    }

    fn get_width_at(&self, x: i32, z: i32) -> f64 {
        let width_noise = self.width_noise.sample_2d(x as f64 * 0.05, z as f64 * 0.05);
        3.0 + width_noise * 4.0 // Width varies from 3-7 blocks
    }

    fn distance_from_center(&self, world_x: i32, world_z: i32, local_x: usize, local_z: usize) -> f64 {
        // Simple distance calculation from ravine path
        let center_x = (world_x / 16) * 16 + 8;
        let center_z = (world_z / 16) * 16 + 8;
        let dx = (world_x - center_x) as f64;
        let dz = (world_z - center_z) as f64;
        (dx * dx + dz * dz).sqrt()
    }
}
```

---

## PHASE 4: Amethyst Geodes

### 4.1 Create Geode Generator

Create `crates/world/src/geode.rs`:

```rust
//! Amethyst geode generation

use crate::chunk::{BlockId, Chunk, CHUNK_SIZE_X, CHUNK_SIZE_Y, CHUNK_SIZE_Z};
use crate::noise::{NoiseConfig, NoiseGenerator};

pub struct GeodeGenerator {
    spawn_noise: NoiseGenerator,
}

impl GeodeGenerator {
    pub fn new(seed: u64) -> Self {
        let config = NoiseConfig {
            octaves: 2,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.005,
            seed: ((seed ^ 0xGE0DE999) as u32),
        };
        Self {
            spawn_noise: NoiseGenerator::new(config),
        }
    }

    pub fn generate_in_chunk(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        // Check if this chunk should spawn a geode
        let spawn_check = self.spawn_noise.sample_2d(
            chunk_x as f64 * 0.005,
            chunk_z as f64 * 0.005,
        );

        if spawn_check < 0.95 {
            return; // Geodes are very rare
        }

        // Pick a center point
        let center_x = 8;
        let center_y = 20 + ((spawn_check * 100.0) as i32 % 30);
        let center_z = 8;

        // Generate spherical geode structure
        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                for y in (center_y - 10).max(5)..(center_y + 10).min(CHUNK_SIZE_Y as i32) {
                    let dx = (local_x as i32 - center_x) as f64;
                    let dy = (y - center_y) as f64;
                    let dz = (local_z as i32 - center_z) as f64;
                    let distance = (dx * dx + dy * dy + dz * dz).sqrt();

                    let block_id = if distance < 3.0 {
                        110 // budding_amethyst
                    } else if distance < 4.0 {
                        109 // amethyst_block
                    } else if distance < 5.0 {
                        108 // calcite
                    } else if distance < 6.0 {
                        107 // smooth_basalt
                    } else {
                        continue;
                    };

                    let voxel = chunk.voxel(local_x, y as usize, local_z);
                    if voxel.id != 0 {
                        let mut new_voxel = voxel;
                        new_voxel.id = block_id;
                        chunk.set_voxel(local_x, y as usize, local_z, new_voxel);
                    }
                }
            }
        }
    }
}
```

### 4.2 Add Geode Blocks

Update `config/blocks.json`:

```json
{
  "name": "smooth_basalt",
  "id": 107,
  "opaque": true,
  "textures": {
    "all": "blocks/smooth_basalt"
  }
},
{
  "name": "calcite",
  "id": 108,
  "opaque": true,
  "textures": {
    "all": "blocks/calcite"
  }
},
{
  "name": "amethyst_block",
  "id": 109,
  "opaque": true,
  "textures": {
    "all": "blocks/amethyst_block"
  }
},
{
  "name": "budding_amethyst",
  "id": 110,
  "opaque": true,
  "textures": {
    "all": "blocks/budding_amethyst"
  }
}
```

---

## PHASE 5: Lush Cave Decorations

### 5.1 Add Missing Lush Cave Blocks

Update `config/blocks.json`:

```json
{
  "name": "cave_vines",
  "id": 111,
  "opaque": false,
  "transparent": true,
  "light_level": 7,
  "textures": {
    "all": "blocks/cave_vines"
  }
},
{
  "name": "moss_carpet",
  "id": 112,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/moss_carpet"
  }
},
{
  "name": "spore_blossom",
  "id": 113,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/spore_blossom"
  }
},
{
  "name": "azalea_leaves",
  "id": 114,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/azalea_leaves"
  }
},
{
  "name": "rooted_dirt",
  "id": 115,
  "opaque": true,
  "textures": {
    "all": "blocks/rooted_dirt"
  }
},
{
  "name": "hanging_roots",
  "id": 116,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/hanging_roots"
  }
}
```

### 5.2 Create Lush Cave Decorator

Add to `crates/world/src/caves.rs`:

```rust
pub struct LushCaveDecorator {
    noise: NoiseGenerator,
}

impl LushCaveDecorator {
    pub fn new(seed: u64) -> Self {
        let config = NoiseConfig {
            octaves: 3,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.2,
            seed: ((seed ^ 0xLU5HCA7E) as u32),
        };
        Self {
            noise: NoiseGenerator::new(config),
        }
    }

    pub fn decorate_chunk(
        &self,
        chunk: &mut Chunk,
        chunk_x: i32,
        chunk_z: i32,
        biome_fn: impl Fn(i32, i32, i32) -> CaveBiome,
    ) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 5..120 {
                    let biome = biome_fn(world_x, y as i32, world_z);
                    if biome != CaveBiome::Lush {
                        continue;
                    }

                    let voxel = chunk.voxel(local_x, y, local_z);
                    if voxel.id != 0 {
                        continue;
                    }

                    // Ceiling decorations (cave vines, spore blossoms)
                    if y + 1 < CHUNK_SIZE_Y {
                        let above = chunk.voxel(local_x, y + 1, local_z);
                        if above.id == 100 || above.id == 13 {
                            // Moss or stone ceiling
                            let decoration_noise = self.noise.sample_3d(
                                world_x as f64 * 0.2,
                                y as f64 * 0.2,
                                world_z as f64 * 0.2,
                            );

                            if decoration_noise > 0.7 {
                                let mut new_voxel = voxel;
                                new_voxel.id = 111; // cave_vines
                                chunk.set_voxel(local_x, y, local_z, new_voxel);
                            } else if decoration_noise > 0.85 {
                                let mut new_voxel = voxel;
                                new_voxel.id = 113; // spore_blossom
                                chunk.set_voxel(local_x, y, local_z, new_voxel);
                            }
                        }
                    }

                    // Floor decorations (moss carpet)
                    if y > 0 {
                        let below = chunk.voxel(local_x, y - 1, local_z);
                        if below.id == 100 {
                            // Moss block floor
                            let carpet_noise = self.noise.sample_3d(
                                world_x as f64 * 0.3,
                                y as f64 * 0.3,
                                world_z as f64 * 0.3,
                            );
                            if carpet_noise > 0.6 {
                                let mut new_voxel = voxel;
                                new_voxel.id = 112; // moss_carpet
                                chunk.set_voxel(local_x, y, local_z, new_voxel);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

---

## PHASE 6: Deep Dark Enhancements

### 6.1 Add Sculk Variants

Update `config/blocks.json`:

```json
{
  "name": "sculk_sensor",
  "id": 117,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/sculk_sensor"
  }
},
{
  "name": "sculk_shrieker",
  "id": 118,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/sculk_shrieker"
  }
},
{
  "name": "sculk_catalyst",
  "id": 119,
  "opaque": true,
  "textures": {
    "all": "blocks/sculk_catalyst"
  }
},
{
  "name": "sculk_vein",
  "id": 120,
  "opaque": false,
  "transparent": true,
  "textures": {
    "all": "blocks/sculk_vein"
  }
},
{
  "name": "reinforced_deepslate",
  "id": 121,
  "opaque": true,
  "textures": {
    "all": "blocks/reinforced_deepslate"
  }
}
```

### 6.2 Create Deep Dark Decorator

```rust
pub struct DeepDarkDecorator {
    noise: NoiseGenerator,
}

impl DeepDarkDecorator {
    pub fn new(seed: u64) -> Self {
        let config = NoiseConfig {
            octaves: 3,
            lacunarity: 2.0,
            persistence: 0.5,
            frequency: 0.15,
            seed: ((seed ^ 0xDEEPDARK) as u32),
        };
        Self {
            noise: NoiseGenerator::new(config),
        }
    }

    pub fn decorate_chunk(
        &self,
        chunk: &mut Chunk,
        chunk_x: i32,
        chunk_z: i32,
        biome_fn: impl Fn(i32, i32, i32) -> CaveBiome,
    ) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 1..30 {
                    let biome = biome_fn(world_x, y as i32, world_z);
                    if biome != CaveBiome::DeepDark {
                        continue;
                    }

                    let voxel = chunk.voxel(local_x, y, local_z);
                    if voxel.id != 0 {
                        continue;
                    }

                    // Floor decorations
                    if y > 0 {
                        let below = chunk.voxel(local_x, y - 1, local_z);
                        if below.id == 101 || below.id == 104 {
                            // Deepslate or sculk floor
                            let decoration_noise = self.noise.sample_3d(
                                world_x as f64 * 0.15,
                                y as f64 * 0.15,
                                world_z as f64 * 0.15,
                            );

                            let block_id = if decoration_noise > 0.9 {
                                119 // sculk_catalyst (rare)
                            } else if decoration_noise > 0.8 {
                                118 // sculk_shrieker
                            } else if decoration_noise > 0.7 {
                                117 // sculk_sensor
                            } else if decoration_noise > 0.5 {
                                120 // sculk_vein
                            } else {
                                continue;
                            };

                            let mut new_voxel = voxel;
                            new_voxel.id = block_id;
                            chunk.set_voxel(local_x, y, local_z, new_voxel);
                        }
                    }
                }
            }
        }
    }
}
```

---

## PHASE 7: Dripstone Enhancements

### 7.1 Add Dripstone Block

Update `config/blocks.json`:

```json
{
  "name": "dripstone_block",
  "id": 122,
  "opaque": true,
  "textures": {
    "all": "blocks/dripstone_block"
  }
}
```

### 7.2 Enhance DripstoneGenerator

Modify existing `DripstoneGenerator` in `caves.rs`:

```rust
impl DripstoneGenerator {
    // ... existing new() method ...

    pub fn decorate_chunk(
        &self,
        chunk: &mut Chunk,
        chunk_x: i32,
        chunk_z: i32,
        biome_fn: impl Fn(i32, i32, i32) -> CaveBiome,
    ) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 5..120 {
                    let biome = biome_fn(world_x, y as i32, world_z);
                    if biome != CaveBiome::Dripstone {
                        continue;
                    }

                    let voxel = chunk.voxel(local_x, y, local_z);

                    // Replace some stone with dripstone blocks
                    if voxel.id == 13 {
                        let replacement_noise = self.noise.sample_3d(
                            world_x as f64 * 0.2,
                            y as f64 * 0.2,
                            world_z as f64 * 0.2,
                        );
                        if replacement_noise > 0.6 {
                            let mut new_voxel = voxel;
                            new_voxel.id = 122; // dripstone_block
                            chunk.set_voxel(local_x, y, local_z, new_voxel);
                        }
                    }

                    if voxel.id != 0 {
                        continue; // Not air
                    }

                    // Existing stalactite/stalagmite logic...
                    // (keep existing code from original implementation)
                }
            }
        }
    }
}
```

---

## PHASE 8: Surface Connection Detection

### 8.1 Add Surface Detection to CaveBiome

Modify `CaveBiome` in `caves.rs`:

```rust
impl CaveBiome {
    /// Check if a cave position connects to the surface
    pub fn is_surface_connected(chunk: &Chunk, x: usize, y: usize, z: usize) -> bool {
        // Scan upward from current position
        for scan_y in y..CHUNK_SIZE_Y {
            let voxel = chunk.voxel(x, scan_y, z);
            if voxel.id != 0 {
                // Hit solid block before reaching top
                return false;
            }
        }
        // Reached sky - surface connected
        true
    }

    /// Get appropriate decoration based on surface connection
    pub fn ceiling_decoration_with_surface(&self, is_surface: bool) -> Option<BlockId> {
        if is_surface {
            // Different decorations for surface-connected caves
            match self {
                CaveBiome::Lush => Some(116), // hanging_roots
                CaveBiome::Dripstone => Some(103), // pointed_dripstone
                _ => None,
            }
        } else {
            // Original underground decorations
            self.ceiling_decoration()
        }
    }
}
```

---

## PHASE 9: Textures

### 9.1 Create Placeholder Textures

Create 16x16 PNG files for all new blocks:
- `assets/textures/src/blocks/lava.png` - Orange/yellow animated (static for now)
- `assets/textures/src/blocks/magma_block.png` - Dark red with cracks
- `assets/textures/src/blocks/smooth_basalt.png` - Dark grey smooth
- `assets/textures/src/blocks/calcite.png` - White crystalline
- `assets/textures/src/blocks/amethyst_block.png` - Purple crystalline
- `assets/textures/src/blocks/budding_amethyst.png` - Purple with buds
- `assets/textures/src/blocks/cave_vines.png` - Green vines with berries
- `assets/textures/src/blocks/moss_carpet.png` - Green mossy thin
- `assets/textures/src/blocks/spore_blossom.png` - Pink flower
- `assets/textures/src/blocks/azalea_leaves.png` - Green leafy
- `assets/textures/src/blocks/rooted_dirt.png` - Brown with roots
- `assets/textures/src/blocks/hanging_roots.png` - Brown hanging
- `assets/textures/src/blocks/sculk_sensor.png` - Dark blue glowing
- `assets/textures/src/blocks/sculk_shrieker.png` - Dark blue mouth
- `assets/textures/src/blocks/sculk_catalyst.png` - Dark blue spreading
- `assets/textures/src/blocks/sculk_vein.png` - Dark blue veiny
- `assets/textures/src/blocks/reinforced_deepslate.png` - Dark grey reinforced
- `assets/textures/src/blocks/dripstone_block.png` - Brown dripstone texture

Regenerate atlas:
```bash
cargo run -p atlas_packer
```

---

## PHASE 10: Integration & Testing

### 10.1 Update TerrainGenerator Final Integration

```rust
pub struct TerrainGenerator {
    // Existing fields...
    cheese_carver: CheeseCaveCarver,
    spaghetti_carver: SpaghettiCaveCarver,
    noodle_carver: NoodleCaveCarver,
    ravine_carver: RavineCarver,
    aquifer_gen: AquiferGenerator,
    geode_gen: GeodeGenerator,
    lush_decorator: LushCaveDecorator,
    deepdark_decorator: DeepDarkDecorator,
    dripstone_gen: DripstoneGenerator,
}

impl TerrainGenerator {
    pub fn new(seed: u64) -> Self {
        Self {
            // ... existing fields ...
            cheese_carver: CheeseCaveCarver::new(seed),
            spaghetti_carver: SpaghettiCaveCarver::new(seed),
            noodle_carver: NoodleCaveCarver::new(seed),
            ravine_carver: RavineCarver::new(seed),
            aquifer_gen: AquiferGenerator::new(seed),
            geode_gen: GeodeGenerator::new(seed),
            lush_decorator: LushCaveDecorator::new(seed),
            deepdark_decorator: DeepDarkDecorator::new(seed),
            dripstone_gen: DripstoneGenerator::new(seed),
        }
    }

    pub fn generate_chunk(&self, pos: ChunkPos) -> Chunk {
        let mut chunk = Chunk::new(pos);

        // 1. Base terrain
        self.generate_terrain(&mut chunk, pos);
        self.place_ores(&mut chunk, pos);

        // 2. Carve caves (largest to smallest)
        self.cheese_carver.carve_chunk(&mut chunk, pos.x, pos.z);
        self.spaghetti_carver.carve_chunk(&mut chunk, pos.x, pos.z);
        self.noodle_carver.carve_chunk(&mut chunk, pos.x, pos.z);
        self.ravine_carver.carve_chunk(&mut chunk, pos.x, pos.z);

        // 3. Fill aquifers
        self.aquifer_gen.fill_aquifers(&mut chunk, pos.x, pos.z);
        self.aquifer_gen.place_lava_floor(&mut chunk, pos.x, pos.z);

        // 4. Generate geodes (rare)
        self.geode_gen.generate_in_chunk(&mut chunk, pos.x, pos.z);

        // 5. Cave decorations
        let cave_carver = CaveCarver::new(self.seed); // For biome detection
        self.dripstone_gen.decorate_chunk(&mut chunk, pos.x, pos.z, |x, y, z| {
            cave_carver.get_biome(x, y, z)
        });
        self.lush_decorator.decorate_chunk(&mut chunk, pos.x, pos.z, |x, y, z| {
            cave_carver.get_biome(x, y, z)
        });
        self.deepdark_decorator.decorate_chunk(&mut chunk, pos.x, pos.z, |x, y, z| {
            cave_carver.get_biome(x, y, z)
        });

        // 6. Surface features LAST
        self.place_trees(&mut chunk, pos);

        chunk
    }
}
```

### 10.2 Add Comprehensive Tests

Create `crates/world/src/caves_advanced_test.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cheese_caves_large_caverns() {
        let carver = CheeseCaveCarver::new(12345);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        // Fill with stone
        for x in 0..16 {
            for y in 0..64 {
                for z in 0..16 {
                    let mut voxel = chunk.voxel(x, y, z);
                    voxel.id = 13;
                    chunk.set_voxel(x, y, z, voxel);
                }
            }
        }

        carver.carve_chunk(&mut chunk, 0, 0);

        // Cheese caves should create larger open areas
        let mut air_count = 0;
        for x in 0..16 {
            for y in 5..120 {
                for z in 0..16 {
                    if chunk.voxel(x, y, z).id == 0 {
                        air_count += 1;
                    }
                }
            }
        }

        assert!(air_count > 0, "Cheese caves should create air pockets");
    }

    #[test]
    fn test_spaghetti_caves_tunnels() {
        let carver = SpaghettiCaveCarver::new(54321);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        for x in 0..16 {
            for y in 0..64 {
                for z in 0..16 {
                    let mut voxel = chunk.voxel(x, y, z);
                    voxel.id = 13;
                    chunk.set_voxel(x, y, z, voxel);
                }
            }
        }

        carver.carve_chunk(&mut chunk, 0, 0);

        // Should create some tunnel-like structures
        let mut air_count = 0;
        for x in 0..16 {
            for y in 5..120 {
                for z in 0..16 {
                    if chunk.voxel(x, y, z).id == 0 {
                        air_count += 1;
                    }
                }
            }
        }

        assert!(air_count >= 0, "Spaghetti caves should create tunnels");
    }

    #[test]
    fn test_aquifer_fills_low_areas() {
        let aquifer = AquiferGenerator::new(99999);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        // Create air pockets
        for x in 0..16 {
            for z in 0..16 {
                for y in 10..20 {
                    let mut voxel = chunk.voxel(x, y, z);
                    voxel.id = 0;
                    chunk.set_voxel(x, y, z, voxel);
                }
            }
        }

        aquifer.fill_aquifers(&mut chunk, 0, 0);

        // Check that some water was placed
        let mut water_count = 0;
        for x in 0..16 {
            for z in 0..16 {
                for y in 10..20 {
                    if chunk.voxel(x, y, z).id == 14 {
                        water_count += 1;
                    }
                }
            }
        }

        // May or may not place water depending on noise, but should be deterministic
        assert!(water_count >= 0);
    }

    #[test]
    fn test_geode_generation_rare() {
        let geode = GeodeGenerator::new(11111);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        // Fill with stone
        for x in 0..16 {
            for y in 0..64 {
                for z in 0..16 {
                    let mut voxel = chunk.voxel(x, y, z);
                    voxel.id = 13;
                    chunk.set_voxel(x, y, z, voxel);
                }
            }
        }

        geode.generate_in_chunk(&mut chunk, 0, 0);

        // Geodes are rare, but generation should not crash
        assert!(true, "Geode generation completed");
    }

    #[test]
    fn test_lush_cave_decorations() {
        let decorator = LushCaveDecorator::new(22222);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        // Create lush cave setup (moss floor, air above)
        for x in 0..16 {
            for z in 0..16 {
                let mut floor = chunk.voxel(x, 30, z);
                floor.id = 100; // moss_block
                chunk.set_voxel(x, 30, z, floor);

                let mut air = chunk.voxel(x, 31, z);
                air.id = 0;
                chunk.set_voxel(x, 31, z, air);
            }
        }

        decorator.decorate_chunk(&mut chunk, 0, 0, |_, y, _| {
            if y == 31 {
                CaveBiome::Lush
            } else {
                CaveBiome::Stone
            }
        });

        // Check that some decorations were placed
        let mut decoration_count = 0;
        for x in 0..16 {
            for z in 0..16 {
                let voxel = chunk.voxel(x, 31, z);
                if voxel.id == 111 || voxel.id == 112 || voxel.id == 113 {
                    decoration_count += 1;
                }
            }
        }

        assert!(decoration_count >= 0, "Lush decorations placed");
    }
}
```

---

## PHASE 11: Module Organization

### 11.1 Update lib.rs Exports

Modify `crates/world/src/lib.rs`:

```rust
pub mod caves;
pub mod aquifer;
pub mod geode;

// Re-export main types
pub use caves::{
    CaveCarver, CaveParams, CaveBiome,
    CheeseCaveCarver, SpaghettiCaveCarver, NoodleCaveCarver,
    RavineCarver, DripstoneGenerator,
    LushCaveDecorator, DeepDarkDecorator,
};
pub use aquifer::AquiferGenerator;
pub use geode::GeodeGenerator;
```

---

## FILES TO CREATE/MODIFY

### New Files:
- `crates/world/src/aquifer.rs` - Aquifer system for water/lava lakes
- `crates/world/src/geode.rs` - Amethyst geode generation
- `crates/world/src/caves_advanced_test.rs` - Additional tests
- 18 new texture files (lava, magma, geode blocks, lush decorations, sculk variants, dripstone_block)

### Files to Modify:
- `crates/world/src/caves.rs` - Add Cheese/Spaghetti/Noodle/Ravine carvers, Lush/DeepDark decorators, enhanced DripstoneGenerator
- `crates/world/src/lib.rs` - Export new modules
- `crates/world/src/terrain.rs` - Integrate all new carvers and decorators
- `config/blocks.json` - Add 17 new blocks (lava, magma, geode blocks, lush decorations, sculk variants, dripstone_block)

---

## IMPLEMENTATION ORDER

1. Add Cheese/Spaghetti/Noodle carvers to caves.rs
2. Create aquifer.rs with AquiferGenerator
3. Add lava and magma_block to blocks.json
4. Integrate aquifer into TerrainGenerator
5. Add RavineCarver to caves.rs
6. Create geode.rs with GeodeGenerator
7. Add geode blocks to blocks.json
8. Add lush cave blocks to blocks.json
9. Create LushCaveDecorator in caves.rs
10. Add deep dark blocks to blocks.json
11. Create DeepDarkDecorator in caves.rs
12. Add dripstone_block to blocks.json
13. Enhance DripstoneGenerator
14. Add surface detection to CaveBiome
15. Create all placeholder textures
16. Regenerate texture atlas
17. Update lib.rs exports
18. Add comprehensive tests
19. Final integration in TerrainGenerator
20. Run full test suite and fix issues

---

## VERIFICATION

After implementation, verify:

1. **Build & Quality:**
   - `cargo build` - zero errors, zero warnings
   - `cargo clippy --all-targets --all-features` - zero warnings
   - `cargo fmt --all -- --check` - passes
   - `cargo test --all` - all tests pass

2. **Visual Verification (if running game):**
   - Large cheese caves with open caverns
   - Winding spaghetti cave tunnels
   - Thin noodle cave passages
   - Deep vertical ravines
   - Underground water lakes
   - Lava lakes below y=10 with magma blocks
   - Rare amethyst geodes (smooth basalt shell)
   - Lush caves with moss, cave vines, spore blossoms
   - Deep dark with sculk sensors, shriekers, catalysts
   - Dripstone caves with dripstone blocks and stalactites

3. **Performance:**
   - No significant chunk generation slowdown
   - Memory usage remains stable
   - All cave types generate deterministically from seed

4. **Determinism:**
   - Same seed produces identical caves
   - All noise-based generation is reproducible

---

## EXPECTED OUTCOME

After completing this implementation, mdminecraft will have **feature parity with Minecraft 1.18 cave generation**, including:

- ✅ Multiple cave types (Cheese, Spaghetti, Noodle)
- ✅ Ravines (deep vertical canyons)
- ✅ Aquifer system (water + lava lakes)
- ✅ Amethyst geodes
- ✅ Complete lush cave biome blocks
- ✅ Complete deep dark biome blocks
- ✅ Enhanced dripstone caves
- ✅ Surface connection detection
- ✅ 17 additional cave-specific blocks
- ✅ Comprehensive decoration systems

This represents a **massive upgrade** from the basic single-carver system to a fully-featured Minecraft 1.18+ equivalent underground world.
