# Implementation Plan: Codebase Refactoring and Hardening
**Date:** 2025-12-10
**Based on:** 2025.12.10 - CR - Comprehensive Code Review
**Goal:** Restore strict determinism, harden network security, and optimize rendering pipeline to meet production standards.

---

## Phase 1: Core Determinism Restoration (CRITICAL)
**Objective:** Eliminate all sources of non-determinism in the simulation layer. This is the prerequisite for reliable multiplayer and replay functionality.

### 1.1 Fixed Timestep Game Loop
**Target:** `src/game.rs`
**Current State:** Variable `dt` passed to update functions.
**Changes:**
1.  Introduce `SimTick(u64)` constant `TICK_RATE = 1.0 / 20.0` (50ms).
2.  Implement the **Accumulator Pattern** in `GameWorld::update_and_render`:
    *   Accumulate frame `dt` into a `time_bank`.
    *   While `time_bank >= TICK_RATE`:
        *   Call `fixed_update()`.
        *   Decrement `time_bank` by `TICK_RATE`.
3.  Create `GameWorld::fixed_update(&mut self)`:
    *   Move all logic affecting game state here (Physics, Fluids, Redstone, Mobs, Health).
    *   Increment `frame_count` (which should be renamed to `sim_tick`).
4.  Modify `GameWorld::render()`:
    *   Calculate `alpha = time_bank / TICK_RATE`.
    *   Pass `alpha` to renderer for interpolation (optional for now, but good for smoothness).

### 1.2 Deterministic Container Iteration
**Target:** `crates/world/src/fluid.rs`, `crates/world/src/redstone.rs`
**Current State:** Iterating over `HashMap` and `HashSet` causes random update order.
**Changes:**
1.  **Redstone:** Change `pending_updates: HashSet<RedstonePos>` to `BTreeSet<RedstonePos>` OR collect-and-sort before iteration. `RedstonePos` derives `Ord`.
2.  **Fluids:** Change `pending_updates: HashMap<FluidPos, u64>` to `BTreeMap<FluidPos, u64>`. `FluidPos` derives `Ord`.
3.  **General:** Audit any other simulation-relevant `HashMap` iterations and replace with deterministic ordered traversal.

### 1.3 Float-Free Simulation (Cleanup)
**Target:** `crates/world/src/` (various)
**Current State:** Physics and health use `f32`.
**Changes:**
1.  Ensure all `update(dt: f32)` methods in `PlayerHealth`, `Mob`, etc., are changed to `tick()` methods that assume a constant time step.
2.  Remove `dt` parameters from these methods to prevent accidental variable-step usage.

---

## Phase 2: Network Protocol Hardening (SECURITY)
**Objective:** Prevent Denial of Service (DoS) attacks via malformed or oversized packets.

### 2.1 Message Size Limits
**Target:** `crates/net/src/protocol.rs`
**Current State:** Unbounded `String` and `Vec` in `Chat` and `ChunkDataMessage`.
**Changes:**
1.  Define constants: `MAX_CHAT_LEN = 256`, `MAX_CHUNK_DATA_LEN = 16 * 1024` (or reasonable limit).
2.  Implement a verification layer or custom `Deserialize` validation (or check immediately upon receipt) to reject messages exceeding these bounds.
3.  Consider using `heapless::String` or `BoundedVec` wrappers if `postcard` supports them cleanly, otherwise manual checks at the IO boundary.

### 2.2 Deserialization Safety
**Target:** `crates/net/src/codec.rs` (or where `postcard::from_bytes` is called)
**Changes:**
1.  Enforce a hard limit on the input buffer size for `postcard`.
2.  Wrap deserialization in a robust error handler that disconnects clients sending malformed data immediately.

---

## Phase 3: Rendering Optimization (PERFORMANCE)
**Objective:** Reduce CPU overhead and memory fragmentation during chunk updates.

### 3.1 Mesh Buffer Pooling
**Target:** `crates/render/src/chunk_manager.rs`
**Current State:** `device.create_buffer_init` called on every chunk update.
**Changes:**
1.  Implement a `BufferPool` that holds `wgpu::Buffer` objects.
2.  When a chunk needs a new buffer:
    *   Check pool for a buffer of sufficient size.
    *   If found, use `queue.write_buffer` (or mapping) to upload data.
    *   If not, create new.
3.  When a chunk is unloaded/remeshed, return old buffer to pool.

### 3.2 Mesh Builder Reuse
**Target:** `crates/render/src/mesh.rs`
**Current State:** `MeshBuilder` allocates new `Vec`s every call.
**Changes:**
1.  Refactor `mesh_chunk` to accept `&mut MeshBuilder` (workspace).
2.  Add `MeshBuilder::reset()` to clear vectors without deallocating.
3.  Store a thread-local or persistent `MeshBuilder` in the worker/main thread to reuse across chunk updates.

---

## Phase 4: Verification & Testing
**Objective:** Prove the system is now deterministic.

### 4.1 Determinism Integration Test
**Target:** `tests/game_loop_determinism.rs` (New File)
**Plan:**
1.  Initialize a headless `GameWorld` with a fixed seed.
2.  Feed a hardcoded sequence of `ActionState` inputs (move forward, jump, place block).
3.  Run the loop for 1000 ticks.
4.  Capture the hash of the final `GameWorld` state (player pos, world voxel data).
5.  Repeat the process 5 times.
6.  **Assert:** All 5 runs produce the *exact* same state hash.

---

## Execution Order

1.  **Phase 1 (Determinism)** - *Blocker for release.*
2.  **Phase 4 (Verification)** - *Verify Phase 1.*
3.  **Phase 2 (Security)** - *Required for public internet play.*
4.  **Phase 3 (Performance)** - *Quality of life improvement.*
