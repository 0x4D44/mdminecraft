# Plan — UI3D Billboard Implementation (2025-11-21)

## Goals
- Ship the feature-gated UI3D billboard pipeline per the revised HLD (2025.11.20 - HLD - UI3D Billboard Pipeline.md).
- Keep deterministic rendering, reuse existing camera/atlas resources, and maintain compatibility across backends.
- Add automated coverage (tests + demo) and CI guard rails.

## Scope
- Crate: `mdminecraft-ui3d` (render module, shaders, examples, tests).
- Glue: optional hooks to main renderer/game (behind feature flag) after pipeline works in isolation.
- CI: feature-specific job; docs/changelog updates.

## Stages & Tasks
1) **Data & Shader Foundations**
   - Define `BillboardInstance`, `BillboardFlags`, and stable sort key (layer + id).
   - Author instanced quad WGSL (camera-facing basis, emissive/overlay flags, light modulation).
   - Add unit test to assert Rust/WGSL layout (size/stride) and stable sort behavior.

2) **Renderer Core**
   - Build quad vertex/index buffers; create atlas bind group using existing atlas view/sampler inputs.
   - Create two pipelines: depth-tested (LessEqual, bias) and overlay (Always, no depth write) with premultiplied alpha.
   - Implement `BillboardRenderer` upload path with capacity growth up to cap; stats reporting; per-frame emitter clear.
   - Partition overlay vs depth instances based on flags; enforce cap with warning.

3) **Feature Wiring & Demo**
   - Expose `BillboardEmitter/Renderer` via `render::mod` under `ui3d_billboards` feature gate.
   - Add headless `billboard_demo` example that renders both depth and overlay instances.
   - Provide helper for downstream integration (camera bind group + atlas reuse contract documented in code).

4) **Quality Gates**
   - Tests: smoke render (wgpu headless), layout packing, deterministic sort.
   - CI job: run feature tests and demo example when feature enabled.
   - Lint/format: ensure `cargo fmt` and `cargo clippy` clean with feature.

5) **Docs & Release Notes**
   - Update HLD with implementation notes/decisions; update release notes and changelog to reflect implemented/gated status.
   - Add brief README/usage snippet if integrating into main game loop (optional when feature stays gated).

6) **Integration (Optional, post-isolation)**
   - Wire renderer into main render path using existing camera bind group and atlas; emitters fed by gameplay/UI systems.
   - Add frustum culling and perf tuning on hardware backend; iterate bias/light constants if artifacts appear.
   - Enable feature in dev profile only; keep prod disabled until validated.

## Milestones & Exit Criteria
- M1: Stages 1–2 complete; unit tests pass locally.
- M2: Stage 3 demo renders expected counts; feature gate respected.
- M3: Stage 4 CI job green; no new warnings with feature enabled.
- M4: Stage 5 docs updated; changelog entry added.
- M5 (optional): Stage 6 integration proved in-game with no regressions; toggle remains gated.

## Risks & Mitigations
- WGSL portability quirks (GL/Vulkan/Metal): stick to instanced quads (no point_size), test on llvmpipe headless; keep overlay path simple.
- Capacity growth churn: double-buffer growth policy with cap/logging; drop excess safely.
- Depth artifacts/z-fighting: initial bias applied; adjust during Stage 6 if needed.
- Determinism: deterministic sort by (layer, id) before upload; renderer assumes caller compliance.

## Timeline (conservative)
- Stage 1–2: 0.5 day
- Stage 3–4: 0.5 day
- Stage 5: 0.25 day
- Stage 6 (optional): 0.5–1 day depending on integration depth
