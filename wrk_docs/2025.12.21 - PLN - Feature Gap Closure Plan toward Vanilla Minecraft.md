# Feature Gap Closure Plan — Toward Vanilla Minecraft Parity (Reviewed)

**Date:** 2025-12-23  
**mdminecraft snapshot:** `efe8421323fdce6d075df569828a6e3b6c01f57e`  
**Companion analysis:** `wrk_docs/2025.12.16 - DOC - Feature Comparison vs Vanilla Minecraft.md`  
**Implementation journal:** `wrk_journals/2025.12.21 - JRN - Vanilla Parity Implementation.md`  

This roadmap targets **player-visible Minecraft-like survival breadth** while preserving mdminecraft’s defining constraints:

- **Determinism-first:** same seed + same inputs ⇒ same outputs (replayable; networking-friendly).
- **Performance budgets:** each milestone has a measurable budget enforced by CI metrics.
- **Server-authoritative by default:** implement gameplay in shared simulation so singleplayer = host+client.
- **Data-driven where possible:** blocks/items/recipes/loot/spawns defined as data, not hardcoded logic.

---

## Status (as of 2025-12-23)

- **Stage 1 baseline is in place:** `DimensionId` is threaded through networking + persistence (Overworld-only behavior remains default), and the shared authoring primitives (`RegistryKey`, `ComponentMap`) exist to converge toward a single registry truth.
- **Stage 2 persistence v2 is in place:** `world.meta` + `world.state` persist global sim time/weather plus player/entities/block-entities, with deterministic iteration order; migration tooling exists (`mdminecraft-cli` `save-upgrade`).
- **Stage 3 crafting UX is closing gaps:** shaped crafting patterns are supported (in addition to shapeless), recipe autofill is pattern-aware, and common early recipes (doors/trapdoors/fences/stairs/slabs/buttons/levers/pressure plates) are now craftable (see journal).
- **Stage 4 in progress:** collisions + placement rules were upgraded for common non-cube blocks (stairs/slabs/trapdoors/doors/fences/panes/gates/walls), **slabs can stack into “double slabs”**, doors/trapdoors/gates now respond to **redstone power** (iron doors are usable), and custom meshing now includes neighbor-aware connectivity + stair corner shapes (inner/outer) for panes/fences/gates/walls/stairs (see journal for exact changes). Connectivity was tightened to avoid “connecting” to non-full blocks (e.g., doors/trapdoors), and panes/bars now connect to each other (vanilla-ish). Waterlogging foundation is now in place for slabs/stairs/trapdoors (fluid sim + bucket/place/break + key survival checks like drowning/sugar cane/farmland hydration and bottle filling).
- **Stage 4 building parity:** cobblestone walls, iron bars, and the stone bricks family (stone bricks/slab/stairs/wall) now exist as real blocks with crafting, dropped-item representations, neighbor-aware meshing, and non-cube collisions (see journal).
- **Stage 5A groundwork in place:** chunk voxel storage is now section-backed (16×16×16 sections); persistence/net paths are section-aware and still serialize a linear voxel stream (see journal).
- **Stage 5B shipped:** chunk height increased to **384** with world range `-64..319`; world-space Y is routed through `WORLD_MIN_Y/WORLD_MAX_Y` plus `world_y_to_local_y` / `local_y_to_world_y` (see journal).
- **Stage 6 structures started (early):** region-based placement with cross-chunk generation for dungeons, surface ruins, mineshaft-lite corridors, and a minimal village v0 is in place; worldgen chests are filled with deterministic **structure-aware** loot (using usable legacy core item IDs) at chunk generation time (with optional content-pack overrides); a small ASCII template placement helper (palette scaffolding) exists and is used for the village well; vegetation worldgen skips placing trees/sugar cane inside surface structure bounds; surface ruins are suppressed when they would overlap a village and now fill foundation blocks down to the first solid ground; and villages now perform basic terrain adaptation (foundation fill + interior clearing), include baseline furnishings (doors + torches) plus a small deterministic farm patch (farmland + crops), and have corrected gravel paths (door/well/farm connections with support fill + clearing) so villages are usable and meaningful on uneven ground (see journal).
- **Stage 7 shipped:** villages spawn a small deterministic set of villagers at generation time and support a deterministic trading UI (professions-lite + trades-lite keyed by world seed + villager ID); hostile spawning respects a vanilla-ish light gate (torches prevent spawns) and solid-ground/headroom checks; non-flying mobs now respect world collision + grounding; zombie/skeleton/spider chase uses deterministic A* waypoint steering to navigate around obstacles; mobs only tick when their chunk is loaded (vanilla-ish); hostile mobs despawn when they leave the active chunk set; and passive mob spawning is limited to chunk generation (not chunk load) with a small loaded-area cap to avoid unbounded entity growth (see journal).
- **Stage 8 in place:** chunk load/save now supports a single “active dimension” (dimension-scoped persistence/streaming), `/dimension <overworld|nether|end>` enables travel (Overworld↔Nether x/z scaling), Nether chunks generate via a deterministic caverns+lava+quartz profile, world entities (mobs/dropped items/projectiles) are now dimension-scoped so they do not “carry across” dimension switches, and **Nether portals now work** (flint-and-steel activation + portal travel, with deterministic destination portal generation when needed). Nether content now includes a deterministic **fortress-lite** corridor structure and first Nether hostiles (**Blaze**, **Ghast**) with deterministic fireball projectiles and deterministic spawning hooks (fortress blazes + rare chunk-gen ghasts + periodic ghast spawns near the player). **Nether fortress chests now use a dedicated deterministic loot table** (with optional content-pack overrides) instead of the generic table.
- **Stage 9 in place:** End groundwork + portal entry path are implemented, plus a **boss loop baseline**: an `EnderDragon` spawns when entering the End, fires deterministic **dragon fireballs**, and on defeat an **End exit portal** (3×3 `end_portal`) is placed; defeat now persists (`end_boss_defeated`) so re-entering the End doesn’t respawn the dragon and ensures the exit portal is present; a boss bar renders while the dragon is alive. A scripted deterministic micro replay snapshot (`micro_end_boss_replay_script_snapshot`) covers the fight/portal outcome (see journal).
- **Stage 9 respawn anchors implemented:** `glowstone`, `crying_obsidian`, and `respawn_anchor` blocks exist with crafting; respawn now respects `spawn_point_dimension`, and charged respawn anchors can set Nether/End respawn points and consume charges on respawn (Overworld use explodes; missing/uncharged anchors fall back to Overworld spawn).
- **Stage 3 survival content expanded:** sugar cane worldgen + deterministic growth, sugar/paper/book crafting chain, bookshelf recipe updated to use books, and brewing sugar unlocks Swiftness (see journal).
- **Stage 3 brewing expansion continued:** brown mushrooms are now a real block (worldgen + placement/support rules), and fermented spider eyes are craftable and accepted by brewing stands, unlocking corruption paths like Swiftness→Slowness and Night Vision→Invisibility plus Water→Weakness (where base potions are available).
- **Stage 3 brewing expansion continued:** magma cream is now obtainable via a deterministic Overworld proxy ore block, unlocking **Awkward + Magma Cream → Fire Resistance** (see journal).
- **Stage 3 brewing expansion continued:** ghast tears are now obtainable via a deterministic Overworld proxy ore block, unlocking **Awkward + Ghast Tear → Regeneration** (see journal).
- **Stage 3 brewing expansion continued:** glistering melons + rabbit feet are now obtainable via deterministic Overworld proxy ore blocks, unlocking **Awkward + Glistering Melon → Healing** and **Awkward + Rabbit Foot → Leaping** (see journal).
- **Stage 3 brewing expansion continued:** phantom membranes are now obtainable via a deterministic Overworld proxy ore block, unlocking **Awkward + Phantom Membrane → Slow Falling** (see journal).
- **Stage 3 brewing expansion continued:** redstone dust + glowstone dust are now obtainable via deterministic Overworld proxy ore blocks, enabling vanilla-ish **Long** (Redstone) and **Strong** (Glowstone) potion modifiers; long/strong potion variants have stable core IDs + dropped-item representations (see journal).
- **Stage 4 redstone usability:** redstone dust now places redstone wire, and breaking redstone wire drops dust (bootstraps circuits from redstone ore; see journal).
- **Stage 3 crafting UX continued:** redstone torches are now craftable (1 redstone dust + 1 stick → 1 torch; craftable in 2×2), enabling basic redstone inverter/power-source builds in survival (see journal).
- **Stage 3 crafting UX continued:** redstone lamps are now craftable (vanilla-inspired redstone/glowstone dust pattern), enabling redstone lighting builds in survival (see journal).
- **Stage 10 redstone expansion started:** repeaters are now craftable/placeable; right-click cycles delay (1–4), and redstone output is delayed + directional (see journal).
- **Stage 10 redstone expansion continued:** comparators are now craftable/placeable; right-click toggles subtract mode; output is 1-tick delayed + directional; rear-input supports vanilla-ish **container read** (chests/hoppers/droppers/dispensers via cached analog output). Nether quartz is obtainable via a deterministic Overworld proxy ore (`nether_quartz_ore`) to support survival crafting (see journal).
- **Stage 10 redstone expansion continued:** observers are now craftable/placeable and emit a short directional pulse when their observed neighbor changes (vanilla-ish timing; see journal).
- **Stage 10 redstone expansion continued:** pistons are now craftable/placeable and can push a short line of blocks with a 1-tick extend/retract delay (horizontal-only for now; see journal).
- **Stage 10 automation continued:** hoppers are now craftable/placeable and support deterministic item transport (chest/hopper/dropper/dispenser) plus redstone lock; placement is vanilla-ish (top-face outputs down; side faces output into the clicked block); hopper UI is implemented (5 slots; shift-move + drag distribution) (see journal).
- **Stage 10 automation continued:** droppers/dispensers are now craftable/placeable with persisted inventories and dispense one item on power rising-edge; dispensers special-case buckets for water/lava placement/pickup and can also fire arrows / throw splash potions (limited projectile behaviors); UIs are implemented (3×3 slots; shift-move + drag distribution) (see journal).
- **Stage 11 commands expanded:** `/setblock` (`replace|keep|destroy`, optional numeric state or limited `[key=value]` blockstates), `/fill` (`replace|outline|hollow|keep|destroy` plus optional `replace <filter>`, capped at 32,768 blocks), `/clone` (`replace|masked`, capped at 32,768 blocks; copies common block-entity contents), `/effect` (`give|clear`, player-only), plus `/seed`, `/say`, `/clear`, and `/kill` (player-only; see journal).
- **Stage 3 brewing expansion continued:** pufferfish are now obtainable via a deterministic Overworld proxy ore block, unlocking **Awkward + Pufferfish → Water Breathing** (see journal).
- **Stage 3 survival loop:** buckets are now craftable and usable for basic fluid transport (pick up/place **water/lava source blocks**) with deterministic fluid-sim scheduling (see journal).
- **Stage 3 potion gameplay:** key potion effects now affect player movement/combat/health (and drinking returns an empty glass bottle), so brewing results are player-visible beyond UI/parity snapshots.
- **Stage 3 potion gameplay:** **Night Vision** now improves dark-area visibility (render-only), and **Invisibility** now reduces hostile mob detection range (see journal).
- **Stage 3 UX:** active status effects are now visible in the HUD with remaining time + level (see journal).
- **Test runtime hygiene:** heavy worldtests use debug-friendly defaults and env overrides; `determinism_worldtest` defaults are tuned to finish well under the 60s “looks hung” threshold (override via `MDM_DETERMINISM_CHUNK_RADIUS` / `MDM_DETERMINISM_VERIFICATION_ROUNDS` for heavier runs), `persistence_roundtrip_worldtest` defaults are tuned similarly (override via `MDM_PERSISTENCE_ROUNDTRIP_CHUNK_RADIUS`), `large_scale_terrain_worldtest` defaults are tuned similarly (override via `MDM_LARGE_SCALE_TERRAIN_CHUNK_RADIUS`), `biome_seams_worldtest` defaults are tuned similarly (override via `MDM_BIOME_SEAMS_CHUNK_RADIUS` and `MDM_BIOME_SEAMS_MAX_AVG_GEN_US`), and `stage4_integration_worldtest` defaults are tuned similarly (override via `MDM_STAGE4_INTEGRATION_CHUNK_RADIUS` and `MDM_STAGE4_INTEGRATION_MAX_AVG_GEN_US`).
- **Test runtime hygiene:** long-running unit tests sample fewer chunks by default to avoid misleading “over 60 seconds” output in `cargo test` (e.g., persistence fuzz proptests default to fewer cases in debug; override via `MDM_PROPTEST_PERSIST_CASES`) (see journal).

## 0) Review — issues found and how this revision fixes them

The previous plan was directionally correct but would cause rework/stalls. This version addresses the main failure modes explicitly.

### 0.1 Issues found

1. **Prereqs were “floating”**: registry/metadata/dimension abstraction and parity tests were listed as cross-cutting but not scheduled as owned stages.
2. **Dependencies were underspecified**: block state/modeling and world height refactors are high-blast-radius and need incremental rollout.
3. **World height change was too monolithic**: jumping straight to negative-Y + sectioned storage risks months of breakage (render, persistence, net, lighting, physics).
4. **UI/UX parity was missing as a stage**: inventory/crafting UX and options/accessibility are major “canonical Minecraft” gaps.
5. **AI/spawn depth wasn’t planned**: villagers, bosses, and “alive world” feel depend on pathfinding/goal systems and recognizable spawn rules.
6. **Save + network versioning was under-scoped**: parity work will repeatedly change chunk formats and state encoding; migrations need tooling and policy.
7. **Determinism risks weren’t operationalized**: float math, RNG surfaces, iteration order, and cross-platform verification need explicit exit gates.

### 0.2 Fixes applied

- Added **Stage 0 (harness + versioning)** and **Stage 1 (registry/metadata/dimension baseline)**.
- Split risky efforts into **incremental stages** (world height: sections first; then negative-Y expansion).
- Added **Stage 3 (UI/UX + survival rules)** to reach “feel parity” earlier.
- Added **Stage 7 (AI/spawn rules + villagers)** before Nether/End bosses.
- Made **migration tooling** and **protocol version bumps** explicit deliverables.
- Turned determinism/perf expectations into **required gates** per stage.

---

## 1) Define the parity target (choose deliberately)

“Minecraft parity” can mean different things:

1. **Feel parity (recommended):** “plays like vanilla” for the core survival loop; not protocol/world-format compatible; worldgen may differ while delivering similar experiences.
2. **Rule parity:** deeper behavioral matching (redstone update order, spawn rules, combat timing) without file/protocol compatibility.
3. **Compatibility parity:** read/write MC worlds, accept MC datapacks/resource packs, speak MC protocol (**very high cost** + maintenance + legal/IP risk).

This plan assumes **feel parity**, selectively pushing toward **rule parity** where it improves gameplay (redstone, combat, spawn rules).

---

## 2) Player-facing tier outcomes (goals, not stages)

### Tier A — “5 nights survival” (Overworld-only)
Spawn, gather, craft/smelt/enchant/brew, fight basic hostiles, sleep/respawn, and **save/load reliably**.

### Tier B — “Overworld depth”
Modern world height, richer biomes, major structures (villages/dungeons/mineshafts), more mobs, improved rule fidelity.

### Tier C — “Progression arc”
Nether + End, portals, bosses, endgame mobility and loot.

### Tier D — “Automation & meta”
Broader redstone ecosystem, commands, content packs/modding hooks, polish/accessibility.

---

## 3) Global guardrails (apply to every stage)

### 3.1 Determinism gates

1. **Stable ordering:** never rely on `HashMap` iteration for simulation decisions; use deterministic containers or explicit sorts.
2. **RNG discipline:** all randomness comes from seedable deterministic RNG streams; avoid OS entropy/time.
3. **Float policy:** if floats affect gameplay decisions, introduce tolerance-free deterministic representations (fixed-point/int) or restrict float usage to visuals.
4. **Cross-platform verification:** run determinism scenarios on multiple OS targets (Linux + Windows at minimum).

### 3.2 Performance gates

For each stage:

- Add **≥1 micro-test** (fast, targeted, runs in seconds).
- Add **≥1 worldtest** (integration, deterministic, emits metrics).
- Establish or update a **metrics baseline** with warning/fail thresholds.

### 3.3 Versioning gates

- **Persistence:** versioned schema + migration tool(s) for old saves.
- **Networking:** protocol version bumps with clear incompatibility errors; optionally support N-1 during dev.

---

## 4) Roadmap overview (stage sequencing)

Ordered to minimize rework:

1. Stage 0: parity harness + versioning scaffolding  
2. Stage 1: unified registry + metadata + dimension baseline  
3. Stage 2: persistence v2 (player/entities/block entities)  
4. Stage 3: UI/UX + survival loop fidelity (Tier A completion)  
5. Stage 4: block state/model/collision system (incremental)  
6. Stage 5: modern world height in two steps (sections → negative Y)  
7. Stage 6: structure pipeline + Overworld structures (Tier B)  
8. Stage 7: AI/spawn rules + villagers/trading (Tier B+)  
9. Stage 8: Nether dimension (Tier C)  
10. Stage 9: End dimension + boss loop (Tier C)  
11. Stage 10: redstone expansion toward practical automation (Tier D)  
12. Stage 11: commands + content packs + modding API (Tier D)  

---

## 5) Detailed multi-stage plan

Each stage lists: **Outcome**, **Scope**, **Dependencies**, **Engineering**, **Content**, **Tests/metrics**, **Exit criteria**, **Risks/mitigations**.

### Stage 0 — Parity harness + versioning scaffolding

**Outcome**
- A safe way to make progress: tests define expected behavior; formats can evolve without chaos.

**Scope**
- Deterministic “micro-worldtests”, golden snapshots, metrics baselines, version policy.

**Dependencies**
- None.

**Engineering**
- Add a micro-worldtest harness in `mdminecraft-testkit`:
  - tick-by-tick simulation runner
  - canonical snapshot writer (ordered, stable, minimal)
- Define snapshot schemas for:
  - block diffs over time
  - inventory diffs
  - entity state diffs
  - redstone power diffs
- Establish save/protocol version policy:
  - persistence schema version stored in headers
  - explicit protocol version bumps + mismatch errors
- Add multi-OS determinism CI job(s) (if available to the project).

**Tests/metrics**
- First golden micro-tests:
  - mining + drops timing
  - furnace tick progression
  - redstone wire propagation on a tiny circuit

**Exit criteria**
- Same scenario produces identical snapshot across reruns; metrics emit consistently.

**Risks/mitigations**
- Golden drift: snapshot only canonicalized data; avoid floats or quantize them deterministically.

---

### Stage 1 — Unified registry + metadata + dimension baseline

**Outcome**
- One authoritative definition of blocks/items/entities, deterministic metadata, and a dimension abstraction that avoids later rewrites.

**Scope**
- Identity + state model cleanup; no major content expansion required.

**Dependencies**
- Stage 0 harness.

**Engineering**
- Introduce a registry crate/module (in `mdminecraft-core` or new crate):
  - stable numeric IDs (`BlockId`, `ItemId`, `EntityTypeId`) for net/persist
  - stable string keys for authoring (e.g., `mdm:stone`)
  - tags (deterministic sets) for recipes/loot/spawn logic
- Define a deterministic metadata model:
  - “components” (typed fields) rather than raw NBT
  - ordered maps (`BTreeMap`) or sorted vectors for serialization
- Add a minimal dimension abstraction now:
  - `DimensionId` included in chunk keys, entity locations, persistence, networking
  - Overworld is the only enabled dimension initially
- Provide adapters so existing code paths keep working while migrating.

**Content**
- Convert `config/blocks.json` and recipes to use stable keys + tags (no behavior change needed).

**Tests/metrics**
- Golden tests for registry stability and metadata encode/decode.

**Exit criteria**
- A single registry truth is used across `world`, `render`, `net`, `client`, `server`.
- Persistence/networking are dimension-aware even in single-dimension mode.

**Risks/mitigations**
- Large refactor risk: migrate subsystem-by-subsystem with adapters/feature flags.

---

### Stage 2 — Persistence v2 (player + entities + block entities)

**Outcome**
- Worlds feel persistent: quitting and reloading preserves meaningful state.

**Scope**
- Save/load of player, entities, and block entities using the Stage 1 model.

**Dependencies**
- Stage 1 registry/metadata/dimension baseline.

**Engineering**
- Extend persistence to store:
  - player state (pos, inventory, health/hunger/xp, spawn point)
  - global state (time-of-day, weather)
  - entities (mobs, dropped items, projectiles; with despawn rules)
  - block entities (furnace/brewing/chest/etc inventories and timers)
- Add a migration tool:
  - `mdminecraft-cli` command (or tool) to upgrade old saves
- Deterministic ticking for block entities (stable ordering by position).

**Content**
- Define which entities persist vs despawn on reload (match vanilla expectations where practical).

**Tests/metrics**
- Worldtest: save/load roundtrip with machines running + mobs present.
- Property tests: `load(save(state)) == state` and serialization stability.

**Exit criteria**
- Scripted scenario survives 10 save/reload cycles without drift.

**Risks/mitigations**
- Save bloat: chunk-local block-entity tables; avoid per-tick disk writes; compress efficiently.

---

### Stage 3 — UI/UX + survival loop fidelity (Tier A completion)

**Outcome**
- The “first 5 nights” loop feels close to vanilla in core interactions.

**Scope**
- Player-facing UX + high-salience rules (inventory, crafting, sleep, damage sources, options).

**Dependencies**
- Stage 2 persistence (so UX flows matter).

**Engineering**
- Inventory UX parity improvements:
  - stack splitting, shift-click moves, drag behavior
  - tooltips + durability bars
- Crafting UX:
  - 2×2 personal crafting and 3×3 crafting table parity
  - optional “recipe book lite” (high impact, low content risk)
- Survival rules:
  - bed behavior (set spawn + skip night in singleplayer)
  - damage sources (fall, drowning, fire/lava, starvation) + invulnerability frames
  - basic difficulty knobs (mob damage, hunger drain)
- Options/accessibility:
  - keybind UI, mouse sensitivity/FOV, audio sliders, invert Y

**Content**
- Fill obvious early-game gaps needed for the loop (torches, basic food chain expansion if desired).

**Tests/metrics**
- Micro-tests: inventory operations + crafting correctness.
- Worldtest: scripted “first night” (spawn → gather → craft → shelter → sleep → reload).

**Exit criteria**
- A deterministic “5 nights” scripted scenario is replayable and survives save/load.

**Risks/mitigations**
- UI feel divergence: focus on functional parity first, visual parity later.

---

### Stage 4 — Block state/model/collision system (incremental)

**Outcome**
- Building feels Minecraft-like: orientation, connectivity, and non-cube collisions are correct enough for common builds.

**Scope**
- Block state schema + rendering models + collisions + placement rules.

**Dependencies**
- Stage 1 registry; Stage 3 UX.

**Engineering**
- Replace ad-hoc bit packing with a registry-driven state variant model:
  - blocks define finite valid state variants
  - runtime stores `BlockStateId` (index into variant table) for net/persist
  - canonical encoding stable across builds; versioned migrations when it changes
- Rendering:
  - stairs/slabs/fences/panes primitives
  - neighbor-aware connectivity resolution (meshing needs neighbor queries)
- Physics:
  - collision shapes derived from state (AABB sets)
- Placement/update rules:
  - support checks, facing rules, neighbor updates
- Waterlogging foundation (even if only some blocks support it initially).

**Content**
- Prioritize blocks that unlock parity building:
  - wood/stone families, slabs/stairs/walls
  - fences/panes, doors/trapdoors, torches

**Tests/metrics**
- Golden tests for state encode/decode and stability.
- Micro-worldtests for fence connectivity and stairs collision correctness.

**Exit criteria**
- Complex blocks roundtrip through save + network replication and behave correctly in key flows.

**Risks/mitigations**
- State-table churn: build explicit migration maps; avoid reordering IDs once shipped.

---

### Stage 5 — Modern world height (two-step refactor)

**Outcome**
- The world feels “modern” (deep caves + expanded vertical range) without destabilizing the engine.

**Scope**
- Chunk storage, worldgen, lighting, meshing, persistence, and networking changes required for modern height.

**Dependencies**
- Stage 4 strongly recommended (block state + neighbor queries will be needed anyway).

**Stage 5A: introduce vertical sections (no negative-Y yet)**
- Store chunks as 16×16×16 sections (still exposed via a flat `Chunk` API).
- Update lighting/meshing/persistence/net paths to address sections and centralized world-space Y bounds.

**Current status (implemented in repo)**
- Chunks are now stored internally as 16×16×16 vertical sections (exposed as a 16×384×16 `Chunk` API with world range `-64..319`).
- World-space Y bounds/indexing is centralized behind `WORLD_MIN_Y/WORLD_MAX_Y` and conversion helpers (enabling negative-Y without rewriting callsites).
- Chunk persistence still writes a linear voxel stream sized by `CHUNK_VOLUME`; older 256-height chunk payloads are upgraded on load by padding into the 384-height layout.
- Net chunk encoding/streaming centralizes chunk dimensions via `mdminecraft-net` protocol constants and has bumped `PROTOCOL_VERSION` for the height change (replacing hard-coded `65536` assumptions).

**Stage 5B: expand vertical range (e.g., -64..319)**
- (Done) Expand the vertical range to 384 blocks and shift origin to `-64..319`.
- (Done) Update worldgen (heightmaps/density/ores/fluids/vegetation) for world-space Y.
- (Done) Add a legacy save upgrade path for 256-height chunk payloads.
- (Done) Fix remaining runtime callsites (mob spawning, item ground queries) that still treated local Y as world Y.
- (Done) Recompute skylight correctly after voxel changes across sections and chunk seams (clear+re-init in a local area, then seam-stitch; runtime mesh refresh now includes all affected chunks).
- (Deferred) Consider a persistence region format v2 (sectioned payloads) once the vertical model stabilizes (current linear voxel stream is acceptable for parity; revisit if save size/perf becomes limiting).
- (Deferred) Consider section-addressed network chunk streaming payloads (opt-in bandwidth optimization; revisit only if chunk bandwidth becomes limiting in practice).

**Tests/metrics**
- Worldtests: determinism + seam continuity across vertical range.
- Encode/decode regression tests for section streaming and save migration.

**Exit criteria**
- No perf cliff vs baselines at comparable render distance.
- Determinism preserved under the new vertical model (replay + save/load).

**Risks/mitigations**
- Blast radius: ship Stage 5A first, Stage 5B behind a feature flag until stable.

---

### Stage 6 — Structure pipeline + Overworld structures (Tier B)

**Outcome**
- Exploration becomes compelling: structures provide landmarks, loot, and progression.

**Scope**
- Deterministic structure placement + generation across chunk boundaries; first major structure set.

**Dependencies**
- Stage 5 (structures should target final world scale).

**Engineering**
- Deterministic structure system:
  - region-based placement (seeded)
  - bounding boxes + terrain adaptation (initial vegetation masking: trees + sugar cane; village interiors cleared + foundations filled; ruins fill foundation blocks down to ground)
  - palette placement + data-driven loot hooks
- Add structures in increasing complexity:
  - dungeons, mineshafts-lite, surface ruins
  - villages v0 (static structures first; full villager economy later)

**Content**
- Palettes + loot definitions (data-driven).

**Tests/metrics**
- Worldtest: structure determinism (same seed → same placements/blocks).
- Spot-check lighting/collision correctness around structures.

**Exit criteria**
- Structures generate deterministically, persist correctly, and don’t corrupt chunks.

**Risks/mitigations**
- Scope explosion: ship “static villages” first; trading/POIs deferred to Stage 7.

---

### Stage 7 — AI/spawn rules + villagers/trading (Tier B+)

**Outcome**
- The world feels alive: spawn rules and mob behavior feel recognizable; villagers become meaningful.

**Scope**
- Deterministic AI framework, pathfinding, spawn/despawn rules, initial villager trading.

**Dependencies**
- Stage 6 structures (villages exist) + Stage 3 survival loop.

**Engineering**
- AI framework:
  - deterministic goal selection and ticking
  - pathfinding with deterministic tie-breaking
- Spawn rules:
  - light-level gating, biome gating, local caps (simplified but recognizable)
  - despawn rules aligned with persistence decisions
- Villagers:
  - professions-lite + trades-lite (data-driven offers)
  - POI system v0 only if needed; keep minimal initially

**Content**
- Trade tables and villager professions (small set).

**Tests/metrics**
- Micro-tests: deterministic pathfinding outputs on fixed maps.
- Worldtest: spawn reproducibility + villager trade determinism.

**Exit criteria**
- Villagers have stable trades; hostile spawns feel predictable and consistent.

**Risks/mitigations**
- AI determinism is subtle: enforce strict ordering and snapshot AI decisions.

---

### Stage 8 — Nether dimension (Tier C begins)

**Outcome**
- Portals work; Nether provides distinct resources and hazards.

**Scope**
- Dimension gameplay + core Nether content subset.

**Dependencies**
- Stage 1 dimension abstraction (already in place).

**Current status (implemented in repo)**
- Dimension-scoped chunk persistence/streaming via a single `active_dimension`.
- Debug travel command `/dimension` with Overworld↔Nether x/z scaling + safe-position snapping.
- Deterministic Nether chunk generator (caves + lava + quartz + bedrock).
- Deterministic fortress-lite structure: a region-based stone-brick corridor with a chest is placed during Nether chunk generation.
- Nether fortress chests select a dedicated deterministic loot table (`NetherFortress`) instead of using the generic table (with optional content-pack override via `loot.json`).
- First Nether hostiles: `MobType::Blaze` and `MobType::Ghast` exist with deterministic fireball projectiles; blazes spawn at fortress corridor points and ghasts can spawn (rarely) during Nether chunk generation and periodically near the player (low cap).
- Dimension-scoped entities: dropped items, projectiles, and mobs are tagged and updated/queried only in the active dimension.
- Nether portals implemented:
  - `flint_and_steel` is craftable and can activate a 4×5 obsidian frame into portal blocks.
  - Standing in portal blocks triggers Overworld↔Nether travel (charge + cooldown), creating a destination portal deterministically when needed.

**Engineering**
- Portal mechanics + dimension travel.
- Nether worldgen profile + environment rules.
- Dimension-aware persistence and networking exercised at scale.

**Content**
- Nether blocks subset + fortress-lite structure.
- First Nether mobs (minimal).

**Tests/metrics**
- Integration tests: portal determinism, dimension save/load, Nether chunk streaming.
- Integration test: fortress blaze spawns align with generated corridor (`nether_fortress_blaze_spawns`).

**Exit criteria**
- Stable travel between dimensions with persisted state and reproducible worldgen.

---

### Stage 9 — End dimension + boss loop (Tier C)

**Outcome**
- A completion arc exists: reach the End and defeat a boss under deterministic replay.

**Scope**
- End worldgen + boss entity framework + portal entry path.

**Dependencies**
- Stage 8 (if following vanilla progression).

**Current status (implemented in repo)**
- Base registry now includes `end_stone` with stone-like properties + dropped-item mapping.
- End chunks generate via a deterministic central-island profile (void elsewhere). A bedrock floor is retained intentionally to preserve engine invariants.
- Environment rules started:
  - water evaporates when placed in the Nether (water bucket becomes empty; no fluid placed)
  - beds explode when used in the Nether/End (vanilla-ish rule)
- End portal entry path implemented (mdminecraft alternative to strongholds for now):
  - `end_portal_frame` and `end_portal` blocks exist (stable IDs, properties, meshing).
  - `ender_pearl` (stacks to 16) and `eye_of_ender` items exist with dropped-item mappings.
  - Ender pearls are now throwable projectiles that teleport the player on impact (vanilla-ish self-damage).
  - Using an Eye of Ender on an End Portal Frame in the Overworld inserts an “eye” bit into the frame; a filled 5×5 ring activates a 3×3 End portal interior.
  - Standing in End portal blocks triggers Overworld↔End travel (End → Overworld returns near spawn).
  - Respawn anchors implemented: respawn anchors can be charged and used to set Nether/End respawn points; respawning in Nether/End consumes a charge, and if the anchor is missing/uncharged respawn falls back to the Overworld world spawn (Overworld use explodes).
  - Acquisition hooks: shapeless `ender_pearl + blaze_powder → eye_of_ender`, a craftable End Portal Frame recipe, and a basic librarian trade for ender pearls.
- End boss loop baseline implemented:
  - `MobType::EnderDragon` exists as a boss-lite entity with deterministic patrol/chase + an enraged phase (≤ 50% HP).
  - The dragon fires deterministic `DragonFireball` projectiles (ranged pressure; hit handling in the game layer).
  - Entering the End ensures a live dragon exists; defeating it places a simple End exit portal (3×3 `end_portal`).
- End boss loop polish: defeat persists (`end_boss_defeated`) so re-entering the End doesn’t respawn the dragon and ensures the exit portal is present; a boss bar renders while the dragon is alive.
- Deterministic replay harness:
  - `crates/world/tests/end_boss_replay_snapshot.rs` replays `crates/world/tests/fixtures/end_boss_replay_script.json` and snapshots the fight outcome (`micro_end_boss_replay_script_snapshot`).

**Engineering**
- End worldgen + portal logic.
- Boss framework with deterministic phases and projectiles.
- Stronghold-like route (or alternative) to reach the End.

**Tests/metrics**
- Deterministic boss fight replay harness (scripted input log must replay identically):
  - `micro_end_boss_replay_script_snapshot` (fixture-driven micro replay; validates dragon defeat → exit portal deterministically).

**Exit criteria**
- End-to-end deterministic playthrough scenario exists and is regression-tested.

---

### Stage 10 — Redstone expansion toward practical automation (Tier D)

**Outcome**
- Practical automation: timers, doors, and basic item transport/logic.

**Scope**
- Expand component set and define stable update/tick rules.

**Dependencies**
- Stage 4 block state system.

**Engineering**
- Add core components: repeater (**done**), comparator (**done**), observer (**done**), piston (**done**), dispenser/dropper (**done**), hopper (**done**).
- Add UIs for automation containers: hopper (5-slot) + dispenser/dropper (3×3), with shift-move + drag distribution (**done**).
- Dispensers special-case buckets to place/pick up water/lava (vanilla-ish) (**done**).
- Define update ordering and tick scheduling rules:
  - aim for “feel parity” first
  - document intentional deviations
- Current deviations (explicitly accepted for now):
  - pistons are horizontal-only (no up/down-facing pistons yet)
  - dispensers support buckets + basic projectiles (arrows, splash potions) but still lack most vanilla dispense behaviors (block placement, armor equipping, etc.)
  - comparator container read uses a cached analog output stored in voxel state bits.
- Deterministic replication + persistence of redstone state.

**Tests/metrics**
- Circuit snapshot tests (inputs over ticks → expected outputs):
  - `micro_redstone_observer_lamp_clock`
  - `micro_redstone_two_lever_door`
  - `micro_item_sorter_lite`
- Performance tests for large networks (avoid pathological update storms).

**Exit criteria**
- Canonical contraptions work (and are snapshot-tested): clock, 2-way door, item sorter-lite.

---

### Stage 11 — Commands + content packs + modding API (Tier D)

**Outcome**
- High-leverage admin tools and a scalable, safe extension path.

**Scope**
- Commands first, then content packs, then deterministic scripting.

**Status (2025-12-20)**
- Commands: implemented a local in-game command prompt + core command set (see journal).
- Content packs:
  - Deterministic pack discovery under `content_packs/` with optional `pack.json` manifest:
    - `enabled=false` skips the pack
    - deterministic ordering by `(priority, pack_id)`
  - Pack blocks via `content_packs/<pack>/blocks.json` are appended to the base `config/blocks.json` registry.
  - Pack crafting recipes via `content_packs/<pack>/recipes.json` (shapeless `RecipeDefinition` + shaped `pattern`/`key`) are appended to built-ins.
    - Crafting ingredients support block tags via `#<tag_key>` (plus `tag:<key>` / `block_tag:<key>`), backed by per-block tags in `blocks.json`/pack blocks.
    - Vanilla-ish: tag ingredients accept `#minecraft:<tag>` / `tag:minecraft:<tag>` / `block_tag:minecraft:<tag>` and fall back to `#<tag>` when `minecraft:<tag>` matches no blocks.
    - Vanilla-ish: item tokens accept `block:minecraft:<name>` as an alias for `block:<name>` (built-in blocks only).
    - Tag ingredient resolution/matching is deterministic even with overlapping tags (max-flow allocation; avoids greedy ambiguity).
    - Base `config/blocks.json` now tags common wood blocks (`planks`, `logs`), and built-in wood recipes prefer the `planks` tag (vanilla-ish).
  - Pack mob spawn overrides via `content_packs/<pack>/spawns.json` (per-biome weights; `weight=0` removes; applied in manifest order).
    - Vanilla-ish: biome and mob tokens accept `minecraft:` namespace prefixes (e.g. `minecraft:plains`, `minecraft:zombie`).
  - Pack loot overrides via `content_packs/<pack>/loot.json` (block + mob drops; per-entry `chance` and `min/max` counts; applied in manifest order).
    - Vanilla-ish: loot keys accept `minecraft:` namespace prefixes for block/mob identifiers (e.g. `minecraft:stone`, `minecraft:zombie`).
  - Example pack: `content_packs/example_pack` adds a new block (`example:polished_stone`) and a recipe (plus a manifest).
  - Validation: unit tests fail on invalid packs (duplicate keys, manifest/recipe/spawn/loot parse errors, unknown items).
- Deterministic scripting:
  - Added a minimal deterministic “command script” runner (`--command-script <path>`) executing `{tick, command}` steps on sim ticks.

**Dependencies**
- Stage 0 harness; Stage 1 registry/metadata.

**Engineering**
- Commands:
  - deterministic parsing/execution; stable, testable outputs
  - core set implemented: `tp`, `give`, `time`, `weather`, `gamemode`, `effect`, `setblock`, `fill`, `clone`, `summon`, `seed`, `say`, `clear`, `kill`
  - UX: in-game command prompt (open with `T` or `/`) rendered via egui; shows an on-screen command log.
  - Current limitations:
    - local-only (no server authority / permissions / audit log yet)
    - `setblock` auto-loads/generates chunks as needed
    - `setblock` supports `replace|keep|destroy` (default `replace`)
    - `setblock`/`fill` accept an optional raw numeric state, or a limited `<block>[key=value,...]` syntax for a subset of built-in blocks (`mdm:*`); content-pack blocks must use numeric state
    - `fill` supports `replace|outline|hollow|keep|destroy` (default `replace`) and is capped at 32,768 blocks
      - `replace` also accepts an optional filter block (by id + optional `[blockstate]`), e.g. `... replace stone` or `... replace dispenser[facing=east]`
    - `clone` supports `replace|masked` and is capped at 32,768 blocks; it copies voxel `id/state` plus common block-entity contents (containers/machines), but does not clone entities (mobs/items/etc.)
    - command-driven voxel edits perform unsupported-neighbor cleanup (e.g., torches/wires break when their support is removed); those support-break removals now spill block-entity contents (when applicable) and drop items (loot-table aware, deterministic); crops/sugar cane placed via commands are registered for deterministic growth
    - player-only targets: `/effect`, `/clear`, `/kill`, `/tp`, `/give`, and `/gamemode` accept `@s/@p/@a/@r` (and ignore selector args) for compatibility; no real selectors yet
    - effect-name parsing covers the effects implemented in this build (still not all vanilla effects)
    - vanilla-ish namespace compatibility: many command tokens accept `minecraft:<name>` as an alias for built-in ids (blocks/items/tools/mobs/effects) when this build knows that name
    - vanilla-ish command prefix compatibility: `/minecraft:<cmd>` is accepted (treated as `/<cmd>`)
- Content packs:
  - tags, recipes, loot tables, spawn tables, structure sets (mdminecraft-native formats)
- Modding:
  - scripting in a deterministic sandbox (WASM or a restricted embedded language)
  - explicit deterministic RNG and time surfaces

**Tests/metrics**
- Golden tests for command outputs (unit tests).
- Deterministic script execution tests.

**Exit criteria**
- ✅ A content pack can add a block/item/recipe and is validated via tests without code changes.

---

## 6) Fastest “Minecraft-feel” wins

If time is limited, prioritize:

1. **Stage 2 (Persistence v2)** — makes the world real.
2. **Stage 3 (UI/UX + survival rules)** — makes the game feel like Minecraft.
3. **Stage 6 (Structures)** — makes exploration meaningful without Nether/End yet.

---

## 7) Tracking artifact (recommended)

Maintain a living parity backlog derived from the companion doc’s matrix:

- Each row: feature, stage, owner, test link, perf budget, status, known deviations.
- Tie “done” to stage exit criteria + passing tests + perf gate.
