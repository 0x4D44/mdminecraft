# High-Level Design: Rust Voxel Sandbox Game Engine

**Document Version:** 1.0
**Date:** 2025.11.12
**Status:** Design Phase
**Target Platform:** Windows, Linux, macOS (Cross-platform)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [System Architecture](#2-system-architecture)
3. [Component Design](#3-component-design)
4. [Data Models & Structures](#4-data-models--structures)
5. [Subsystem Interactions](#5-subsystem-interactions)
6. [Network Architecture](#6-network-architecture)
7. [Testing & Validation Strategy](#7-testing--validation-strategy)
8. [Performance & Optimization](#8-performance--optimization)
9. [Security & Stability](#9-security--stability)
10. [Development Roadmap](#10-development-roadmap)
11. [Risk Analysis & Mitigation](#11-risk-analysis--mitigation)
12. [Appendices](#12-appendices)

---

## 1. Executive Summary

### 1.1 Project Vision

This document outlines the high-level design for a **performant, moddable, multiplayer voxel sandbox game engine** written in Rust. The engine prioritizes deterministic simulation, comprehensive automated testing, and cross-platform compatibility. The MVP will deliver core gameplay mechanics including infinite terrain generation, block manipulation, lighting, multiplayer networking, and basic survival/creative modes.

### 1.2 Key Design Principles

1. **Determinism First**: All simulation logic must be deterministic and replayable for testing
2. **Test-Driven Architecture**: Event streams, headless rendering, and world DSL enable comprehensive automated testing
3. **Modularity**: Multi-crate workspace ensures clean separation of concerns
4. **Performance**: Target 20 TPS simulation, 60 FPS rendering, <1.5GB memory footprint
5. **Cross-Platform**: Single codebase for Windows/Linux/macOS using wgpu
6. **Modding Ready**: Data-driven design with WASM plugin architecture

### 1.3 Technology Stack

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| Language | Rust (stable) | Memory safety, performance, concurrency |
| ECS | bevy_ecs | Pure ECS without engine lock-in |
| Rendering | wgpu | Cross-platform GPU abstraction with headless support |
| Networking | QUIC (quinn) | Reliable, encrypted, modern transport |
| Serialization | bincode/postcard | Compact, fast binary serialization |
| Compression | zstd | Fast compression for world saves |
| Modding | wasmtime | Safe WASM sandboxing |
| Testing | proptest, cargo-fuzz | Property-based and fuzz testing |

---

## 2. System Architecture

### 2.1 Workspace Structure

```
mdminecraft-workspace/
├── Cargo.toml (workspace)
└── crates/
    ├── core/           # Foundation: math, IDs, coords, time, RNG
    ├── ecs/            # ECS facade (bevy_ecs wrapper)
    ├── world/          # Voxel world, chunks, generation, lighting
    ├── physics/        # Collision detection, movement, raycasting
    ├── render/         # wgpu renderer, meshing, materials
    ├── net/            # Network protocol, serialization
    ├── server/         # Authoritative game server
    ├── client/         # Client logic, prediction, UI
    ├── assets/         # Asset registry, pack loading
    ├── scripting/      # WASM modding API (optional)
    ├── testkit/        # Testing framework & tools
    └── cli/            # Binary targets (game, server, tools)
```

### 2.2 Architectural Layers

```
┌─────────────────────────────────────────────────────────┐
│                    CLI Binaries                         │
│  (game-client, game-server, worldtool, worldtest)       │
└────────────┬──────────────────────────────┬─────────────┘
             │                              │
┌────────────┴───────────┐    ┌────────────┴─────────────┐
│   Client Application    │    │   Server Application     │
│  - Input handling       │    │  - Authoritative sim     │
│  - Prediction           │    │  - Client management     │
│  - Interpolation        │    │  - Chunk streaming       │
│  - UI/HUD               │    │  - Headless mode         │
└────────────┬───────────┘    └────────────┬─────────────┘
             │                              │
             └──────────────┬───────────────┘
                            │
        ┌───────────────────┴───────────────────┐
        │         Core Engine Layer              │
        ├────────────────────────────────────────┤
        │  ECS   │  World  │  Physics  │ Render  │
        │        │  Lighting│ Collision │ Meshing│
        │        │  Gen     │ Raycast   │         │
        └────────┴─────────┴───────────┴─────────┘
                            │
        ┌───────────────────┴───────────────────┐
        │         Foundation Layer               │
        ├────────────────────────────────────────┤
        │  Core   │  Assets │  Network │ Testkit │
        │  Math   │  Registry│ Protocol│ Events  │
        │  Types  │  Packs  │          │         │
        └─────────┴─────────┴──────────┴─────────┘
```

### 2.3 Process Architecture

#### Singleplayer Mode
```
┌─────────────────────────────────┐
│      Game Process               │
│  ┌──────────┐   ┌────────────┐ │
│  │  Client  │◄─►│ Local      │ │
│  │  Logic   │   │ Server     │ │
│  │          │   │ (embedded) │ │
│  └──────────┘   └────────────┘ │
│       │              │          │
│  ┌────▼──────────────▼────┐    │
│  │    Shared World ECS     │    │
│  └─────────────────────────┘    │
└─────────────────────────────────┘
```

#### Multiplayer Mode
```
┌──────────────┐              ┌──────────────┐
│ Client A     │              │ Server       │
│ ┌──────────┐ │   ┌─────┐   │ ┌──────────┐ │
│ │  Input   │─┼──►│QUIC │◄──┼─│ Auth Sim │ │
│ │Prediction│◄┼───│ Net │───┼►│ State    │ │
│ │ Render   │ │   └─────┘   │ │ Streaming│ │
│ └──────────┘ │              │ └──────────┘ │
└──────────────┘              └──────────────┘
         ▲                            │
         │                            ▼
┌────────┴──────┐              ┌──────────────┐
│ Client B      │              │ Client C     │
└───────────────┘              └──────────────┘
```

---

## 3. Component Design

### 3.1 Core Crate

**Purpose**: Foundation library providing shared primitives used across all crates.

**Key Types**:

```rust
// Coordinate system (right-handed: X=east, Y=up, Z=south)
pub struct BlockPos(pub IVec3);      // Block-space coordinates
pub struct ChunkPos(pub IVec2);      // Chunk-space coordinates (xz)
pub struct RegionPos(pub IVec2);     // Region-space coordinates

// Block identification
pub struct BlockId(pub u16);         // 0 = air, max 65535 block types
pub struct BlockState(pub u16);      // Variant bits (rotation, moisture, etc.)

// Time management
pub struct SimTick(pub u64);         // Simulation tick counter (20 TPS)
pub const TICK_RATE: f32 = 20.0;     // 50ms per tick
pub const TICK_DURATION: Duration = Duration::from_millis(50);

// Deterministic RNG
pub struct DeterministicRng {
    seed: u64,
    tick: u64,
    chunk: ChunkPos,
}

// Error handling
pub enum GameError {
    WorldGen(String),
    Serialization(String),
    Network(String),
    InvalidBlock(BlockId),
    ChunkNotLoaded(ChunkPos),
}
```

**Responsibilities**:
- Math utilities (AABB, Ray, frustum culling helpers)
- Coordinate transformations
- Deterministic RNG seeding
- Common error types
- Time and tick management

**Dependencies**: None (foundation crate)

---

### 3.2 ECS Crate

**Purpose**: Thin facade over bevy_ecs for entity-component management.

**Key Components**:

```rust
// Entity components
#[derive(Component)]
pub struct Transform {
    pub position: Vec3,
    pub rotation: Quat,
    pub scale: Vec3,
}

#[derive(Component)]
pub struct Velocity(pub Vec3);

#[derive(Component)]
pub struct Collider {
    pub shape: ColliderShape,  // AABB or Capsule
    pub solid: bool,
}

#[derive(Component)]
pub struct Health {
    pub current: f32,
    pub max: f32,
}

#[derive(Component)]
pub struct Inventory {
    pub slots: Vec<ItemStack>,
    pub selected_slot: u8,
}

#[derive(Component)]
pub struct PlayerTag {
    pub id: u64,
    pub name: String,
}

#[derive(Component)]
pub struct ChunkEntity {
    pub pos: ChunkPos,
    pub mesh_dirty: bool,
}
```

**System Organization**:
- Physics systems (movement, collision, gravity)
- AI systems (pathfinding, behavior trees)
- Inventory systems (pickup, crafting)
- Networking systems (sync, interpolation)

**Dependencies**: bevy_ecs, core

---

### 3.3 World Crate

**Purpose**: Voxel world management including chunks, generation, lighting, and persistence.

**Architecture**:

```rust
pub struct World {
    seed: u64,
    chunks: ChunkStorage,
    light_queue: LightingQueue,
    block_tick_queue: BlockTickQueue,
    gen_params: WorldGenParams,
}

// Chunk storage with spatial indexing
pub struct ChunkStorage {
    chunks: HashMap<ChunkPos, Chunk>,
    loader: ChunkLoader,
    cache: LRUCache<ChunkPos, Chunk>,
}

pub struct Chunk {
    pos: ChunkPos,
    blocks: Box<[Voxel; 16 * 256 * 16]>,  // Dense array
    dirty: bool,
    mesh_version: u32,
}

#[derive(Clone, Copy)]
pub struct Voxel {
    id: BlockId,
    state: BlockState,
    light_sky: u8,      // 0-15 skylight
    light_block: u8,    // 0-15 block emission
}
```

**World Generation Pipeline**:

```
Input: (seed, chunk_pos, params)
  │
  ├─► 1. Heightmap Generation (multi-octave noise)
  │
  ├─► 2. Biome Assignment (temperature/moisture map)
  │
  ├─► 3. Surface Composition (grass, sand, stone layers)
  │
  ├─► 4. Cave Carving (3D worley/perlin noise)
  │
  ├─► 5. Structure Placement (trees, ores, lakes)
  │
  ├─► 6. Population Pass (decorations, entities)
  │
  └─► 7. Lighting Pre-compute (skylight flood fill)

Output: Fully generated Chunk
```

**Lighting System**:

```rust
pub struct LightingQueue {
    add_queue: VecDeque<(BlockPos, u8)>,
    remove_queue: VecDeque<(BlockPos, u8)>,
}

impl LightingQueue {
    // BFS propagation with Manhattan distance attenuation
    pub fn propagate_light(&mut self, world: &mut World) {
        // Add pass: spread light from sources
        // Remove pass: clear outdated light values
    }
}
```

**Persistence**:

```rust
pub struct RegionFile {
    path: PathBuf,
    header: RegionHeader,
    chunks: HashMap<ChunkPos, CompressedChunkData>,
}

pub struct ChunkRecord {
    version: u32,
    crc32: u32,
    uncompressed_len: u32,
    data: Vec<u8>,  // zstd compressed
}
```

**Dependencies**: core, ecs

---

### 3.4 Physics Crate

**Purpose**: Collision detection, rigid body dynamics, and raycasting.

**Key Systems**:

```rust
// Movement integration
pub fn integrate_movement(
    dt: f32,
    velocity: &mut Velocity,
    transform: &mut Transform,
    gravity: Vec3,
) {
    // Semi-implicit Euler integration
    velocity.0 += gravity * dt;
    transform.position += velocity.0 * dt;
}

// AABB collision resolution
pub fn resolve_collision(
    collider: &Collider,
    transform: &mut Transform,
    velocity: &mut Velocity,
    world: &World,
) -> bool {
    // Sweep against voxel grid
    // Resolve penetration with MTV
    // Apply friction
}

// Voxel raycasting (DDA algorithm)
pub struct RaycastResult {
    pub hit_pos: BlockPos,
    pub hit_face: BlockFace,
    pub distance: f32,
}

pub fn raycast_voxel(
    origin: Vec3,
    direction: Vec3,
    max_distance: f32,
    world: &World,
) -> Option<RaycastResult> {
    // Discrete DDA voxel traversal
}
```

**Collision Shapes**:
- AABB (axis-aligned bounding box)
- Capsule (player character)
- Voxel grid (world collisions)

**Dependencies**: core, ecs, world

---

### 3.5 Render Crate

**Purpose**: GPU rendering using wgpu with support for headless mode.

**Rendering Pipeline**:

```
Chunk Updates → Meshing → GPU Upload → Render
     │             │           │           │
     │             │           │           ├─► Opaque Pass
     │             │           │           ├─► Alpha Cutout Pass
     │             │           │           ├─► Translucent Pass
     │             │           │           └─► UI Pass
     │             │           │
     │             │           └─► Vertex/Index Buffers
     │             │
     │             └─► Greedy Meshing Algorithm
     │
     └─► Block Change Events
```

**Greedy Meshing**:

```rust
pub struct ChunkMesh {
    opaque_vertices: Vec<Vertex>,
    opaque_indices: Vec<u32>,
    transparent_vertices: Vec<Vertex>,
    transparent_indices: Vec<u32>,
    hash: u64,  // For deterministic testing
}

#[repr(C)]
pub struct Vertex {
    position: [f32; 3],
    normal: [f32; 3],
    uv: [f32; 2],
    light: [u8; 2],     // [skylight, blocklight]
    ao: u8,             // Ambient occlusion factor
}

pub fn greedy_mesh_chunk(chunk: &Chunk, registry: &BlockRegistry) -> ChunkMesh {
    // 1. Cull hidden faces
    // 2. Merge adjacent same-material quads (greedy)
    // 3. Generate vertices with AO and lighting
    // 4. Compute deterministic hash
}
```

**Rendering Backend**:

```rust
pub struct Renderer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    pipelines: PipelineCache,
    atlas: TextureAtlas,
    camera: Camera,
    mode: RenderMode,
}

pub enum RenderMode {
    Normal { surface: wgpu::Surface },
    Headless { target: wgpu::Texture },
}

impl Renderer {
    pub fn render_frame(&mut self, world: &World, ecs: &EcsWorld) {
        // Frustum culling
        // Sort transparent meshes
        // Bind materials and draw
    }

    pub fn snapshot(&self) -> (Vec<u8>, String) {
        // PNG bytes + SHA256 hash
    }
}
```

**Material System**:

```rust
pub struct Material {
    albedo_texture: TextureId,
    normal_texture: Option<TextureId>,
    emission: f32,
    alpha_mode: AlphaMode,
}

pub struct TextureAtlas {
    texture: wgpu::Texture,
    layout: AtlasLayout,
    hash: u64,  // Locked for deterministic rendering
}
```

**Dependencies**: core, ecs, world, wgpu

---

### 3.6 Network Crate

**Purpose**: Multiplayer networking with client-server architecture.

**Protocol Design**:

```rust
// Message envelope
pub struct NetworkMessage {
    version: u8,
    schema_hash: u32,
    payload: MessagePayload,
}

#[derive(Serialize, Deserialize)]
pub enum MessagePayload {
    // Client → Server
    ClientHello { username: String, client_version: String },
    InputCommand { tick: u64, input: PlayerInput },
    ChunkRequest { pos: ChunkPos },
    BlockAction { action: BlockAction },

    // Server → Client
    ServerHello { player_id: u64, spawn_pos: Vec3, tick: u64 },
    WorldState { tick: u64, entities: Vec<EntityState> },
    ChunkData { pos: ChunkPos, data: CompressedChunkData },
    BlockUpdate { pos: BlockPos, voxel: Voxel },
    EntitySpawn { id: u64, data: EntityData },
    EntityDespawn { id: u64 },
    TickAck { tick: u64 },
}

// Delta compression for entity state
pub struct EntityState {
    id: u64,
    position: Vec3,
    rotation: Quat,
    velocity: Vec3,
}
```

**Client Prediction & Reconciliation**:

```rust
pub struct PredictionBuffer {
    inputs: VecDeque<(u64, PlayerInput)>,  // Unacked inputs
    states: VecDeque<(u64, Transform)>,    // Local predicted states
}

impl PredictionBuffer {
    pub fn predict(&mut self, input: PlayerInput, current_tick: u64) {
        // Apply input locally (optimistic)
        self.inputs.push_back((current_tick, input));
    }

    pub fn reconcile(&mut self, server_tick: u64, server_state: Transform) {
        // Compare with local prediction
        // If mismatch, replay unacked inputs from server state
    }
}
```

**Server Authority Model**:
- Server runs authoritative simulation at 20 TPS
- Clients send inputs with timestamps
- Server applies inputs on corresponding tick
- Server broadcasts state deltas to all clients
- Clients predict locally and reconcile on server updates

**Dependencies**: core, ecs, world, quinn (QUIC)

---

### 3.7 Server Crate

**Purpose**: Authoritative game server with headless capability.

**Server Loop**:

```rust
pub struct GameServer {
    world: World,
    ecs: EcsWorld,
    clients: HashMap<u64, ClientConnection>,
    tick: u64,
    event_sink: Box<dyn EventSink>,
}

impl GameServer {
    pub fn run(&mut self) {
        let mut accumulator = Duration::ZERO;
        let mut last_frame = Instant::now();

        loop {
            let now = Instant::now();
            let delta = now - last_frame;
            last_frame = now;
            accumulator += delta;

            // Fixed timestep simulation
            while accumulator >= TICK_DURATION {
                self.tick();
                accumulator -= TICK_DURATION;
            }

            // Network IO
            self.process_network();

            // Sleep to target tick rate
            thread::sleep(Duration::from_millis(10));
        }
    }

    fn tick(&mut self) {
        self.event_sink.on_event(&GameEvent::TickStart { tick: self.tick });

        // 1. Ingest client inputs
        self.apply_client_inputs();

        // 2. World updates (block ticks, lighting)
        self.world.update(self.tick);

        // 3. ECS systems (physics, AI)
        self.ecs.update(self.tick);

        // 4. Emit events
        self.emit_tick_events();

        // 5. Send state to clients
        self.broadcast_state();

        self.event_sink.on_event(&GameEvent::TickEnd { tick: self.tick });
        self.tick += 1;
    }
}
```

**Headless Mode**:
- Runs without window or graphics context
- Enables CI testing and dedicated servers
- Can still generate render snapshots via offscreen buffers

**Dependencies**: core, ecs, world, physics, net, render (optional)

---

### 3.8 Client Crate

**Purpose**: Client application with input, prediction, interpolation, and UI.

**Client Architecture**:

```rust
pub struct GameClient {
    connection: ServerConnection,
    world: World,              // Local world cache
    ecs: EcsWorld,             // Local entity cache
    prediction: PredictionBuffer,
    input_state: InputState,
    renderer: Renderer,
    ui: UIContext,
}

impl GameClient {
    pub fn run(&mut self) {
        // Dual-loop: simulation at 20 TPS, render at 60+ FPS
        let mut sim_accumulator = Duration::ZERO;
        let mut last_frame = Instant::now();

        loop {
            let now = Instant::now();
            let delta = now - last_frame;
            last_frame = now;
            sim_accumulator += delta;

            // Input
            self.process_input();

            // Simulation ticks
            while sim_accumulator >= TICK_DURATION {
                self.tick();
                sim_accumulator -= TICK_DURATION;
            }

            // Render with interpolation
            let alpha = sim_accumulator.as_secs_f32() / TICK_DURATION.as_secs_f32();
            self.render(alpha);

            // Network
            self.process_network_messages();
        }
    }

    fn tick(&mut self) {
        // Send input to server
        let input = self.input_state.current();
        self.connection.send_input(self.tick, input);

        // Predict locally
        self.prediction.predict(input, self.tick);
    }

    fn render(&mut self, interpolation_alpha: f32) {
        // Interpolate between last and current tick
        let interpolated_transforms = self.interpolate_entities(interpolation_alpha);

        // Render scene
        self.renderer.render_frame(&self.world, &interpolated_transforms);

        // Render UI
        self.ui.render(&self.input_state);
    }
}
```

**Input Handling**:

```rust
pub struct InputState {
    keys: HashSet<KeyCode>,
    mouse_pos: Vec2,
    mouse_delta: Vec2,
    scroll: f32,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct PlayerInput {
    movement: Vec3,    // WASD direction
    jump: bool,
    crouch: bool,
    use_item: bool,
    attack: bool,
    camera_yaw: f32,
    camera_pitch: f32,
}
```

**Dependencies**: core, ecs, world, physics, render, net, ui

---

### 3.9 Assets Crate

**Purpose**: Asset loading, validation, and registry management.

**Asset Types**:
- Block definitions (TOML)
- Item definitions (JSON)
- Crafting recipes (JSON)
- Textures (PNG)
- Models (custom format or glTF)
- World generation parameters (TOML)

**Block Registry**:

```rust
pub struct BlockRegistry {
    blocks: Vec<BlockDefinition>,
    name_to_id: HashMap<String, BlockId>,
}

pub struct BlockDefinition {
    id: BlockId,
    name: String,
    opaque: bool,
    transparent: bool,
    collidable: bool,
    solid: bool,
    light_emission: u8,
    light_attenuation: u8,
    hardness: f32,
    tool_type: Option<ToolType>,
    flammable: bool,
    fluid_like: bool,
    render_model: RenderModel,
    textures: BlockTextures,
}

impl BlockRegistry {
    pub fn load_from_pack(path: &Path) -> Result<Self> {
        // Parse TOML definitions
        // Validate consistency (no duplicate IDs)
        // Build lookup tables
    }
}
```

**Recipe System**:

```rust
pub enum Recipe {
    Shaped {
        pattern: Vec<String>,
        key: HashMap<char, BlockId>,
        result: ItemStack,
    },
    Shapeless {
        ingredients: Vec<BlockId>,
        result: ItemStack,
    },
}

pub struct RecipeRegistry {
    recipes: Vec<Recipe>,
}
```

**Dependencies**: core, serde, toml, json

---

### 3.10 Testkit Crate

**Purpose**: Comprehensive testing framework with event streams, world DSL, and replay.

**Event Stream**:

```rust
pub trait EventSink: Send + Sync {
    fn on_event(&self, event: &GameEvent);
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "kind")]
pub enum GameEvent {
    TickStart { tick: u64 },
    TickEnd { tick: u64 },
    BlockPlaced { tick: u64, pos: IVec3, by: String, block: String, state: u16 },
    BlockBroken { tick: u64, pos: IVec3, by: String },
    ChunkGenerated { tick: u64, chunk: IVec2, time_ms: f32 },
    ChunkMeshed { tick: u64, chunk: IVec2, triangles: u32, mesh_sha: String },
    LightingUpdated { tick: u64, region: IVec2, updates: u32 },
    EntitySpawned { tick: u64, id: u64, entity_type: String, pos: Vec3 },
    SnapshotSaved { tick: u64, camera: String, image_sha: String, width: u32, height: u32 },
    Warning { tick: u64, message: String },
    Error { tick: u64, message: String },
}

pub struct JsonlRecorder {
    file: BufWriter<File>,
}

impl EventSink for JsonlRecorder {
    fn on_event(&self, event: &GameEvent) {
        serde_json::to_writer(&mut self.file, event).unwrap();
        writeln!(&mut self.file).unwrap();
    }
}
```

**World Test DSL**:

```rust
pub struct WorldTest {
    world_config: WorldConfig,
    block_fills: Vec<BlockFill>,
    scripts: Vec<ScriptAction>,
    expectations: Vec<Expectation>,
    cameras: Vec<CameraRig>,
}

pub enum Expectation {
    LightLevel { by_tick: u64, pos: IVec3, sky: Option<u8>, block: Option<u8> },
    EventCount { by_tick: u64, event_kind: String, count: CountSpec },
    Snapshot { by_tick: u64, camera: String, sha: String },
    NoErrors { by_tick: u64 },
}

pub struct WorldTestRunner {
    test: WorldTest,
    server: GameServer,
    event_recorder: JsonlRecorder,
}

impl WorldTestRunner {
    pub fn run(&mut self) -> TestResult {
        // Initialize world from test config
        // Execute scripted actions
        // Verify expectations
        // Generate report
    }
}
```

**Replay System**:

```rust
pub struct ReplayLog {
    seed: u64,
    world_params: WorldGenParams,
    inputs: Vec<(u64, PlayerInput)>,
}

pub fn replay(log: &ReplayLog, event_sink: Box<dyn EventSink>) {
    // Recreate deterministic world
    // Apply inputs on correct ticks
    // Emit same event stream
}
```

**Dependencies**: core, ecs, world, server, serde

---

## 4. Data Models & Structures

### 4.1 Voxel Data Layout

**Memory Layout** (per chunk: 16×256×16 = 65,536 voxels):

```
Voxel struct size: 6 bytes
├─ BlockId (u16): 2 bytes
├─ BlockState (u16): 2 bytes
├─ light_sky (u8): 1 byte
└─ light_block (u8): 1 byte

Chunk memory: 65,536 × 6 = 393,216 bytes (~384 KB per chunk)
```

**Indexing**:

```rust
fn index(x: u8, y: u16, z: u8) -> usize {
    (y as usize) * 256 + (z as usize) * 16 + (x as usize)
}
```

**Optimization Considerations**:
- Dense array for cache locality
- Palette compression for repetitive chunks (future optimization)
- Separate lighting data for faster updates (future optimization)

### 4.2 Chunk Storage Strategy

```rust
pub enum ChunkState {
    Unloaded,
    Generating,
    Loaded(Chunk),
    LoadingFromDisk,
}

pub struct ChunkStorage {
    chunks: HashMap<ChunkPos, ChunkState>,
    loader: ChunkLoader,
    generator: WorldGenerator,
    lru_cache: LRUCache<ChunkPos, Chunk>,
}
```

**Loading Priority**:
1. Player position (highest priority)
2. View direction (frustum)
3. Spiral outward from player
4. Unload chunks beyond render distance + margin

### 4.3 Network Message Batching

```rust
pub struct StateBatch {
    tick: u64,
    entity_updates: Vec<EntityUpdate>,
    block_updates: Vec<BlockUpdate>,
    chunk_updates: Vec<ChunkUpdate>,
}

// Delta encoding for position
pub struct EntityUpdate {
    id: u64,
    delta_pos: IVec3,      // Quantized to mm precision
    delta_rot: i16,        // Quantized angle
    flags: u8,             // Bitfield for changed components
}
```

### 4.4 Save File Format

**Directory Structure**:
```
world_name/
├── world.toml           # Metadata, seed, spawn
├── players/
│   ├── uuid1.json       # Player inventory, position, health
│   └── uuid2.json
└── regions/
    ├── r.0.0.rg         # Region file (32×32 chunks)
    ├── r.0.1.rg
    └── r.-1.0.rg
```

**Region File Format** (.rg):

```
[Header: 4 KB]
  ├─ Magic: "MCRG"
  ├─ Version: u32
  ├─ Chunk offsets: [1024 × u32]  (32×32 chunks)
  └─ Chunk sizes: [1024 × u32]

[Chunk Records: Variable]
  ├─ CRC32: u32
  ├─ Uncompressed size: u32
  ├─ Compressed data: [u8] (zstd)
  └─ ...
```

---

## 5. Subsystem Interactions

### 5.1 Game Loop Timing Diagram

```
Frame Timeline (60 FPS = 16.67ms budget)
│
├─ Input (1ms)
│   └─ Poll events, update input state
│
├─ Simulation Tick (2.5ms target × N ticks)
│   ├─ Apply inputs
│   ├─ World updates (lighting, block ticks)
│   ├─ ECS systems (physics, AI)
│   └─ Emit events
│
├─ Network (1ms)
│   ├─ Send client updates
│   └─ Receive server messages
│
├─ Meshing (budget: 5ms)
│   └─ Rebuild dirty chunks (prioritized queue)
│
├─ Rendering (6ms target)
│   ├─ Frustum culling
│   ├─ Draw opaque meshes
│   ├─ Draw transparent meshes
│   └─ Draw UI
│
└─ Sleep/Idle (remaining time)
```

### 5.2 Chunk Lifecycle State Machine

```
         ┌─────────────┐
         │  Unloaded   │
         └──────┬──────┘
                │ Player approaches
                ▼
         ┌─────────────┐
    ┌───►│ Generating  │
    │    └──────┬──────┘
    │           │ Generation complete
    │           ▼
    │    ┌─────────────┐
    │    │   Loaded    │◄──┐ Modifications
    │    └──────┬──────┘   │
    │           │ Mesh dirty│
    │           ▼           │
    │    ┌─────────────┐   │
    └────┤  Meshing    ├───┘
         └──────┬──────┘
                │ Player leaves
                ▼
         ┌─────────────┐
         │  Unloading  │
         └──────┬──────┘
                │ Save to disk
                ▼
         ┌─────────────┐
         │  Unloaded   │
         └─────────────┘
```

### 5.3 Lighting Update Propagation

```
Block Placed/Removed
       │
       ▼
Check light emission
       │
       ├─ If emissive → Add to light queue
       └─ If was emissive → Add to remove queue
       │
       ▼
BFS Light Propagation (max 15 blocks)
       │
       ├─ Propagate to neighbors
       ├─ Attenuate by 1 per step
       └─ Stop at opaque blocks
       │
       ▼
Mark affected chunks as mesh_dirty
       │
       ▼
Queue chunks for remeshing
```

### 5.4 Client-Server Sync Flow

```
Client                          Server
  │                               │
  ├─ Input (tick N) ─────────────►│
  │                               ├─ Apply input on tick N
  ├─ Predict locally             │
  │   (optimistic)                ├─ Run simulation
  │                               │
  │◄─ State update (tick N-2) ────┤
  │                               │
  ├─ Reconcile:                   │
  │   Compare predicted state     │
  │   with server state           │
  │                               │
  ├─ If mismatch:                 │
  │   ├─ Rewind to server state   │
  │   └─ Replay inputs [N-2..N]  │
  │                               │
  └─ Continue prediction ─────────►
```

---

## 6. Network Architecture

### 6.1 Protocol Stack

```
┌─────────────────────────────────┐
│   Game Messages (MessagePayload) │
├─────────────────────────────────┤
│   Serialization (bincode/postcard)│
├─────────────────────────────────┤
│   Framing (length-prefixed)      │
├─────────────────────────────────┤
│   QUIC (quinn)                   │
├─────────────────────────────────┤
│   UDP + TLS                      │
└─────────────────────────────────┘
```

### 6.2 Connection Flow

```
Client                          Server
  │                               │
  ├─ ClientHello ────────────────►│
  │   (username, version)         ├─ Validate version
  │                               ├─ Create player entity
  │                               ├─ Assign player ID
  │◄─ ServerHello ─────────────────┤
  │   (player_id, spawn, tick)    │
  │                               │
  ├─ ChunkRequest (spawn area)───►│
  │                               ├─ Load/generate chunks
  │◄─ ChunkData (stream) ──────────┤
  │◄─ ChunkData ────────────────────┤
  │◄─ ChunkData ────────────────────┤
  │                               │
  ├─ Ready ───────────────────────►│
  │                               ├─ Add to active players
  │◄─ WorldState (tick loop) ──────┤
  │◄─ WorldState ───────────────────┤
  │                               │
```

### 6.3 Bandwidth Optimization

**Techniques**:
1. Delta compression (only send changed fields)
2. Quantization (reduce precision for network)
3. Interest management (only send nearby entities)
4. Chunk streaming (prioritize visible chunks)
5. Batch updates (combine multiple messages per tick)

**Bandwidth Budget** (per client @ 20 TPS):
- Entity updates: ~2 KB/tick (40 entities × 50 bytes)
- Block updates: ~500 bytes/tick (sporadic)
- Chunk streaming: 10 KB/tick (amortized)
- **Total**: ~12-15 KB/tick = 240-300 KB/s downstream

---

## 7. Testing & Validation Strategy

### 7.1 Testing Pyramid

```
                 ┌────────────┐
                 │  Manual    │  (Rare)
                 │  Playtesting│
                 └────────────┘
              ┌──────────────────┐
              │  Integration     │  (CI per commit)
              │  World DSL Tests │
              └──────────────────┘
          ┌────────────────────────────┐
          │  Headless Render Snapshots  │  (Per platform)
          └────────────────────────────┘
      ┌──────────────────────────────────────┐
      │  Property-Based & Fuzz Tests         │
      └──────────────────────────────────────┘
  ┌────────────────────────────────────────────────┐
  │  Unit Tests (per crate, 80%+ coverage)         │
  └────────────────────────────────────────────────┘
```

### 7.2 Test Categories

#### Unit Tests
- Per-crate, per-module
- Mock dependencies
- Fast execution (<1s per crate)
- Coverage target: 80%+

**Examples**:
- Coordinate transformations
- Block registry lookups
- Lighting propagation math
- Greedy meshing correctness
- Network message serialization

#### Integration Tests

**World DSL Tests**:
```toml
# lighting_basic.worldtest.toml
[world]
seed = 1
flat = true

[[blocks.fill]]
from = [-5,64,-5]
to = [5,64,5]
block = "stone"

[[script]]
tick = 1
action = { place = { at=[0,65,0], block="torch" } }

[[expect]]
by_tick = 3
light = { at=[0,65,0], block=14 }

[[expect]]
by_tick = 3
light = { at=[1,65,0], block=13 }
```

**Physics Tests**:
- Player stands on block (no penetration)
- Gravity applies correctly
- Jump height matches expected
- Collision prevents tunneling

#### Snapshot Tests

**Deterministic Rendering**:
- Fixed camera positions
- Locked texture atlas
- No temporal effects
- SHA-256 comparison of rendered images

**Golden Files**:
```
tests/goldens/
├── win_dx12/
│   ├── lighting_basic_overview.sha256
│   └── biome_border.sha256
├── linux_vulkan/
│   ├── lighting_basic_overview.sha256
│   └── biome_border.sha256
└── macos_metal/
    ├── lighting_basic_overview.sha256
    └── biome_border.sha256
```

#### Property-Based Tests

**Using proptest**:

```rust
proptest! {
    #[test]
    fn lighting_monotonic(
        positions in prop::collection::vec(any::<IVec3>(), 1..100)
    ) {
        let mut world = World::new(123);
        place_light_source(&mut world, IVec3::ZERO, 15);

        for pos in positions {
            let light = world.get_light(pos);
            let neighbors = get_neighbors(pos);

            for neighbor in neighbors {
                let neighbor_light = world.get_light(neighbor);
                // Light should never increase away from source
                prop_assert!(neighbor_light <= light + 1);
            }
        }
    }

    #[test]
    fn meshing_produces_valid_geometry(
        voxels in any_chunk_data()
    ) {
        let mesh = greedy_mesh_chunk(&voxels);

        // No degenerate triangles
        prop_assert!(mesh.indices.len() % 3 == 0);

        // All indices valid
        for &idx in &mesh.indices {
            prop_assert!(idx < mesh.vertices.len() as u32);
        }

        // Vertices within chunk bounds
        for vertex in &mesh.vertices {
            prop_assert!(vertex.position[0] >= 0.0 && vertex.position[0] <= 16.0);
            prop_assert!(vertex.position[1] >= 0.0 && vertex.position[1] <= 256.0);
            prop_assert!(vertex.position[2] >= 0.0 && vertex.position[2] <= 16.0);
        }
    }
}
```

#### Fuzz Tests

```rust
// Fuzz chunk deserialization
fuzz_target!(|data: &[u8]| {
    let _ = Chunk::deserialize(data);  // Should never panic
});

// Fuzz recipe parser
fuzz_target!(|data: &[u8]| {
    let _ = Recipe::from_json(data);  // Should never panic
});

// Fuzz network message decoder
fuzz_target!(|data: &[u8]| {
    let _ = NetworkMessage::decode(data);  // Should never panic
});
```

### 7.3 CI/CD Pipeline

```yaml
# .github/workflows/ci.yml (conceptual)
stages:
  - lint
  - unit_test
  - property_test
  - integration_test
  - snapshot_test
  - package

lint:
  - cargo fmt --check
  - cargo clippy --all-targets --all-features -- -D warnings

unit_test:
  matrix: [windows, linux, macos]
  - cargo test --all-features --lib

property_test:
  - cargo test --release --features proptest -- --ignored
  timeout: 10m

integration_test:
  - cargo run -p cli -- worldtest ./tests/scenarios/*.worldtest.toml
  artifacts:
    - events.jsonl
    - metrics.json

snapshot_test:
  matrix:
    - { os: windows, backend: dx12 }
    - { os: linux, backend: vulkan }
    - { os: macos, backend: metal }
  - cargo run -p cli -- worldtest --snapshot-mode ./tests/visual/*.worldtest.toml
  - compare SHA256 with goldens/${{backend}}/
  artifacts:
    - snapshots/*.png
    - diff_reports/*.html

package:
  - cargo build --release --all-targets
  artifacts:
    - game-client.exe / game-client
    - game-server.exe / game-server
```

### 7.4 Event Stream Assertions

**Example Test**:

```rust
#[test]
fn test_torch_placement_emits_correct_events() {
    let mut server = TestServer::new(123);
    let recorder = JsonlRecorder::new("test_output.jsonl");
    server.set_event_sink(Box::new(recorder));

    // Place torch at (0, 65, 0)
    server.apply_action(1, BlockAction::Place {
        pos: IVec3::new(0, 65, 0),
        block: "torch",
    });

    // Run for 5 ticks
    server.run_ticks(5);

    // Parse event stream
    let events = parse_jsonl("test_output.jsonl");

    // Assertions
    assert_event_count(&events, "BlockPlaced", 1);
    assert_event_count(&events, "LightingUpdated", 1..=2);
    assert_no_errors(&events);

    // Verify light values
    let light_at_torch = server.world.get_light(IVec3::new(0, 65, 0));
    assert_eq!(light_at_torch.block, 14);
}
```

---

## 8. Performance & Optimization

### 8.1 Performance Targets

| Metric | Target | Measurement |
|--------|--------|-------------|
| Tick time (CPU) | ≤2.5 ms | Per tick, single-player, 4 chunk radius |
| Frame time (GPU) | ≤6 ms | 60 FPS @ 1080p on entry dGPU |
| Memory usage | <1.5 GB | 9×9 chunk area, 256 height |
| World save rate | ≤100 MB/hour | Compressed with zstd |
| Chunk gen time | ≤8 ms | Per chunk, single-threaded |
| Network bandwidth | ≤300 KB/s | Per client, downstream |

### 8.2 Optimization Strategies

#### CPU Optimizations

**Parallelization**:
- Chunk generation (embarrassingly parallel)
- Lighting updates (per-chunk BFS)
- Greedy meshing (per-chunk independent)
- ECS systems (bevy_ecs parallel scheduling)

**Data Structure Choices**:
- Dense arrays for chunks (cache locality)
- Spatial hashing for entity queries
- LRU cache for recently unloaded chunks
- Priority queue for chunk loading

**Hot Path Optimizations**:
- Inline small functions
- Branch prediction hints
- SIMD for vertex transforms (future)
- Avoid allocations in tight loops

#### GPU Optimizations

**Mesh Optimization**:
- Greedy meshing (reduce quad count by 80-90%)
- Frustum culling (early rejection)
- Occlusion culling (optional, future)
- LOD for distant chunks (future)

**Rendering Pipeline**:
- Instanced rendering for repeated geometry
- Texture atlasing (reduce bind calls)
- Material batching
- Early-Z pass for complex scenes (future)

#### Memory Optimizations

**Chunk Compression**:
- Palette compression for repetitive chunks
- Run-length encoding for air spans
- zstd compression for disk storage

**Streaming**:
- LRU eviction for distant chunks
- Incremental chunk loading (spread over frames)
- Background thread for disk I/O

### 8.3 Profiling & Monitoring

**Built-in Profiling**:

```rust
// Metrics collection
pub struct PerformanceMetrics {
    pub tick_time_us: Vec<u64>,
    pub frame_time_us: Vec<u64>,
    pub chunk_gen_time_us: Vec<u64>,
    pub mesh_time_us: Vec<u64>,
    pub chunk_count: usize,
    pub entity_count: usize,
    pub triangle_count: usize,
    pub memory_usage_mb: f32,
}

impl PerformanceMetrics {
    pub fn report(&self) -> String {
        format!(
            "Tick: {:.2}ms (p95: {:.2}ms) | Frame: {:.2}ms | Chunks: {} | Entities: {}",
            self.tick_time_us.iter().sum::<u64>() as f64 / self.tick_time_us.len() as f64 / 1000.0,
            percentile(&self.tick_time_us, 0.95) as f64 / 1000.0,
            self.frame_time_us.last().unwrap_or(&0) as f64 / 1000.0,
            self.chunk_count,
            self.entity_count,
        )
    }
}
```

**Debug Overlays**:
- F3 debug screen (chunk coords, facing, biome, light level)
- Chunk border visualization
- Mesh statistics
- Network bandwidth graph

**Tracing Integration**:

```rust
use tracing::{info_span, instrument};

#[instrument(skip(self))]
fn generate_chunk(&mut self, pos: ChunkPos) -> Chunk {
    let _span = info_span!("chunk_gen", x = pos.x, z = pos.z).entered();

    // Generation logic...

    info!("Chunk generated in {:.2}ms", elapsed);
}
```

---

## 9. Security & Stability

### 9.1 Security Considerations

#### Network Security

**QUIC/TLS**:
- Encrypted by default
- Prevents packet sniffing
- DDoS mitigation via connection limits

**Input Validation**:
- Bounds checking on all coordinates
- Rate limiting on block actions
- Sanity checks on movement speed
- Reject impossible inputs (e.g., flying in survival)

**Anti-Cheat** (Post-MVP):
- Server-side validation of all actions
- Heuristic detection (speed, reach distance)
- Replay analysis for suspicious behavior

#### Asset Security

**Data Pack Validation**:
- Schema validation for all JSON/TOML
- Texture size limits (prevent OOM)
- Recipe graph validation (prevent infinite loops)
- Block ID collision detection

**WASM Sandboxing**:
- Memory limits (64 MB per module)
- CPU time limits (10 ms per tick)
- No file system access
- No network access
- Whitelisted host functions only

### 9.2 Stability Guarantees

**Error Handling**:
- No panics in release builds (use `Result` everywhere)
- Graceful degradation on resource exhaustion
- Automatic recovery from corrupted chunks
- Transaction-like world modifications

**Save File Integrity**:
- CRC32 validation on load
- Versioned save format with migrations
- Atomic writes (write to temp, then rename)
- Backup old saves before migration

**Network Resilience**:
- Automatic reconnection on disconnect
- Timeout detection (heartbeat messages)
- Graceful handling of out-of-order packets
- State reconciliation after reconnect

---

## 10. Development Roadmap

### 10.1 Milestone A: Engine Core (Weeks 1-6)

**Goal**: Establish foundation with basic rendering and interaction.

**Deliverables**:
- ✅ Workspace structure and build system
- ✅ Core math and coordinate types
- ✅ ECS integration (bevy_ecs)
- ✅ Block registry and asset loading
- ✅ Chunk storage and indexing
- ✅ Basic world generation (superflat + heightmap noise)
- ✅ Greedy meshing algorithm
- ✅ wgpu renderer (opaque blocks only)
- ✅ Camera controller with collision
- ✅ Block placement/breaking with raycasting
- ✅ Event stream infrastructure
- ✅ Testkit foundations

**Acceptance Criteria**:
- Load superflat world with 9×9 chunk area
- Place and break blocks at 60 FPS
- Pass "Superflat Basics" worldtest
- Event stream captures all block actions
- Headless snapshot test produces stable SHA

**Estimated Effort**: 240 hours (6 weeks × 40 hours)

---

### 10.2 Milestone B: Lighting & Save (Weeks 7-10)

**Goal**: Implement lighting system and world persistence.

**Deliverables**:
- ✅ Skylight propagation (BFS flood fill)
- ✅ Block light emission and attenuation
- ✅ Cross-chunk lighting updates
- ✅ Lighting-aware vertex colors in meshing
- ✅ Region file format (.rg)
- ✅ Chunk serialization with zstd compression
- ✅ World save/load with CRC validation
- ✅ Player data persistence
- ✅ Inventory system (36 slots)
- ✅ Crafting system (shaped/shapeless recipes)

**Acceptance Criteria**:
- "Torch Light" worldtest passes
- Removing torch updates lighting within 2 ticks
- Save/load preserves world bit-exactly
- Crafting table with 3-5 basic recipes works
- Event stream logs lighting updates

**Estimated Effort**: 160 hours (4 weeks × 40 hours)

---

### 10.3 Milestone C: Networking (Weeks 11-14)

**Goal**: Enable multiplayer with server authority.

**Deliverables**:
- ✅ QUIC transport integration (quinn)
- ✅ Network protocol (ClientHello, WorldState, etc.)
- ✅ Server authoritative simulation loop
- ✅ Client prediction and reconciliation
- ✅ Chunk streaming (prioritized by distance)
- ✅ Entity interpolation
- ✅ Dedicated server binary (headless)
- ✅ LAN discovery (optional)

**Acceptance Criteria**:
- Two clients connect to server
- Both clients see synchronized block changes
- Client prediction feels responsive (<30 ms perceived lag)
- Event streams match server's authoritative record
- No desync under 100 ms RTT test scenario

**Estimated Effort**: 160 hours (4 weeks × 40 hours)

---

### 10.4 Milestone D: Biomes & Structures (Weeks 15-18)

**Goal**: Rich world generation with biomes, trees, and ores.

**Deliverables**:
- ✅ Biome system (temperature/moisture maps)
- ✅ Multi-biome terrain generation
- ✅ Tree generation (oak, birch)
- ✅ Ore placement (coal, iron, diamond)
- ✅ Cave generation (3D noise)
- ✅ Smooth biome transitions
- ✅ Weather toggle (rain/snow visual effects)
- ✅ Day/night cycle
- ✅ Render snapshot golden files locked

**Acceptance Criteria**:
- Biome borders have no visible seams
- Meshing hashes stable across runs (deterministic)
- "Mega-Forest" performance test passes
- All worldtest scenarios pass
- Visual snapshot tests pass on all platforms

**Estimated Effort**: 160 hours (4 weeks × 40 hours)

---

### 10.5 Post-MVP Enhancements

**Modding API** (Milestone E):
- WASM host API for blocks, items, recipes
- Structure generation hooks
- Tick callbacks and event listeners
- Data pack specification v1.0

**Advanced Features** (Milestone F+):
- Redstone-like circuits
- Complex mob AI (pathfinding, behavior trees)
- Advanced combat system
- Shader mods
- Replay viewer UI
- In-game test console

---

## 11. Risk Analysis & Mitigation

### 11.1 Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| **Cross-platform render variance** | High | Medium | Lock texture atlas hash, disable temporal effects, per-backend goldens |
| **Determinism drift in simulation** | High | Medium | Unit tests for replay, seed audit, integer/fixed-point for branches |
| **Mesh hash instability** | Medium | High | Mesh generation uses only integer math, floating-point only at render time |
| **Network desync under high latency** | High | Medium | Robust reconciliation, test scenarios with artificial lag |
| **Performance regression** | Medium | Medium | Automated perf tests in CI, baseline comparison |
| **Save format breaking changes** | High | Low | Versioned format with migration hooks, extensive backward compat tests |
| **CI GPU availability** | Low | Medium | wgpu headless mode with SwiftShader fallback |

### 11.2 Project Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| **Scope creep** | High | High | Strict MVP definition, defer advanced features to post-MVP milestones |
| **Underestimated complexity** | Medium | Medium | Time buffers in estimates, weekly progress reviews |
| **Key developer unavailability** | High | Low | Knowledge sharing, documentation, bus factor > 1 |
| **Toolchain instability (Rust)** | Low | Low | Pin to stable channel, extensive CI coverage |
| **Third-party dependency issues** | Medium | Low | Vendor critical dependencies, maintain forks if needed |

---

## 12. Appendices

### 12.1 Glossary

| Term | Definition |
|------|------------|
| **Voxel** | Volume element; a 3D pixel representing a block in the world |
| **Chunk** | 16×256×16 region of voxels, the unit of world storage and streaming |
| **Greedy Meshing** | Algorithm to merge adjacent faces into larger quads, reducing geometry |
| **BFS** | Breadth-first search; used for light propagation |
| **DDA** | Digital Differential Analyzer; voxel raycast algorithm |
| **ECS** | Entity-Component-System; data-oriented architecture pattern |
| **QUIC** | Modern transport protocol (UDP + TLS + reliability) |
| **Deterministic** | System that produces identical output given identical input |
| **Headless** | Running without GUI (for testing or dedicated servers) |
| **Event Stream** | Sequence of events emitted by the engine for testing/replay |

### 12.2 References

**Inspiration**:
- Minecraft (Mojang Studios)
- Minetest (open-source voxel engine)
- Veloren (open-source Rust voxel RPG)

**Technical Papers**:
- "Greedy Meshing" - Robert O'Leary
- "A Fast Voxel Traversal Algorithm" - Amanatides & Woo (DDA)
- "Deterministic Lockstep Networking" - Gaffer on Games

**Libraries**:
- [bevy_ecs](https://github.com/bevyengine/bevy/tree/main/crates/bevy_ecs)
- [wgpu](https://github.com/gfx-rs/wgpu)
- [quinn](https://github.com/quinn-rs/quinn)
- [noise-rs](https://github.com/Razaekel/noise-rs)
- [proptest](https://github.com/proptest-rs/proptest)

### 12.3 Open Questions

1. **Lighting Model**: Should we implement smooth lighting (interpolate between vertices) in MVP or defer?
   - **Decision**: Defer to post-MVP; flat lighting is sufficient for testing stability

2. **Fluid Simulation**: Static fluids or simple spread model for MVP?
   - **Decision**: Configurable; simple spread with toggle in world params

3. **Entity Networking**: Full state sync or interest management?
   - **Decision**: Full state sync for MVP (limited player count), interest management post-MVP

4. **Mod API Surface**: Which hooks to expose in v1.0?
   - **Decision**: Block/item registration, recipes, structure gen, tick callbacks

5. **CI Snapshot Storage**: Store PNGs or just SHA-256 hashes?
   - **Decision**: Store SHA-256 in repo, PNGs as artifacts (30-day retention)

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025.11.12 | Design Team | Initial high-level design |

---

**End of Document**
