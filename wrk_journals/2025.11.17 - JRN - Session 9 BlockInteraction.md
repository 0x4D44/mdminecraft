# Session 9: Block Breaking and Placing

**Date:** 2025-11-17
**Session:** 9
**Focus:** Interactive block manipulation with raycasting

---

## Objectives

Implement interactive block breaking and placing to make the voxel world editable:

1. **Raycasting System**
   - Cast ray from camera through mouse cursor
   - DDA (Digital Differential Analyzer) algorithm for voxel traversal
   - Find intersection point and face normal
   - Maximum raycast distance (8 blocks)

2. **Block Selection Highlight**
   - Render wireframe cube around selected block
   - Show which block face is targeted
   - Update in real-time with mouse movement

3. **World Modification**
   - Left click: Break block (set to air)
   - Right click: Place block (adjacent to selected face)
   - Update chunk data
   - Regenerate affected chunk meshes

4. **Mouse Input Handling**
   - Capture mouse button events
   - Only allow interaction when cursor is grabbed
   - Proper event handling in winit

---

## Technical Approach

### Raycasting Algorithm
- **DDA traversal**: Step through voxel grid along ray direction
- **Ray origin**: Camera position
- **Ray direction**: Camera forward vector (centered on screen)
- **Output**: Block position + face normal

### Highlight Rendering
- **New pipeline**: WireframePipeline for debug lines
- **Geometry**: 12 edges × 2 vertices = 24 vertices per cube
- **Shader**: Simple position-only vertex shader, solid color fragment
- **Depth test**: Enabled, no depth write for transparency

### Mesh Regeneration
- **On block change**: Regenerate affected chunk mesh
- **Greedy meshing**: Reuse existing mesh_chunk function
- **GPU upload**: Create new vertex/index buffers
- **Performance**: Should be <10ms for single chunk

### Challenges
- Proper face normal calculation for block placement
- Handling chunk boundaries (changes near edges)
- Avoiding z-fighting with wireframe overlay
- Mouse event handling with existing cursor grab system

---

## Expected Performance

**Raycasting:** <0.1ms per frame (only when cursor grabbed)
**Wireframe rendering:** <0.05ms per frame
**Mesh regeneration:** <10ms per block change (acceptable for user interaction)
**Overall impact:** Negligible on 60 FPS target

---

## Progress Log

### 9.1 Raycasting System (Completed)

**File Created:** `crates/render/src/raycast.rs` (176 LOC)
- DDA (Digital Differential Analyzer) voxel traversal algorithm
- Returns RaycastHit with block position, face normal, and distance
- Supports custom is_solid predicate function
- Unit tests for hit, miss, and max distance scenarios

**Key Implementation Details:**
- Step through voxel grid using t_max values for each axis
- Track which face was entered to determine placement side
- Maximum distance parameter to limit ray length
- ~50 FLOPs per voxel traversed, very efficient

### 9.2 Block Selection Highlight (Completed)

**Files Created:**
- `crates/render/src/shaders/wireframe.wgsl` (35 LOC)
- WireframePipeline in `pipeline.rs` (+242 LOC)

**Wireframe Implementation:**
- 12 edges × 2 vertices = 24 vertices for cube outline
- LineList topology for rendering
- Depth testing with bias to avoid z-fighting
- Highlight uniform contains position and color
- Alpha blending for semi-transparent highlight

**Pipeline Structure:**
- Group 0: Camera uniform (view-projection matrix)
- Group 1: Highlight uniform (position + color)
- Slightly offset vertices (-0.501 to 0.501) for visual clarity

### 9.3 Mouse Input Handling (Completed)

**Modified:** `crates/render/src/window.rs` (+15 LOC)
- Added `mouse_clicks` HashSet to InputState
- Track clicks separately from holds
- `is_mouse_clicked()` method for single-frame clicks
- Reset clicks in `reset_frame()` method

**Behavior:**
- Clicks registered on MouseButton::Pressed event
- Cleared each frame after processing
- Enables single-action block break/place (not continuous)

### 9.4 World Modification (In Progress)

**Next Steps:**
1. Store chunks mutably in viewer (HashMap<ChunkPos, Chunk>)
2. Perform raycasting each frame when cursor is grabbed
3. Render wireframe highlight at raycast hit position
4. On left click: set block to air (break)
5. On right click: set adjacent block (place)
6. Regenerate affected chunk mesh after modification
7. Upload new mesh to GPU

**Build Status:** ✅ Success (4.37s, 15 warnings, 0 errors)

---

_Journal maintained during 3D UI implementation for mdminecraft_
