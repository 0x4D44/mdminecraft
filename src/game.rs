//! Game world state - the actual 3D voxel game

use crate::{
    automation::controller::{AutomationEndpoint, AutomationMsg},
    automation::protocol,
    command_script::CommandScriptPlayer,
    commands,
    config::{load_block_registry, ControlsConfig},
    content_pack_loot, content_pack_spawns, content_packs,
    input::{ActionState, InputProcessor},
    scripted_input::ScriptedInputPlayer,
};
use anyhow::Result;
use glam::IVec3;
use mdminecraft_assets::BlockRegistry;
use mdminecraft_audio::{AudioManager, AudioSettings, SoundId};
use mdminecraft_core::{
    item::{client_item_ids, item_ids, potion_ids},
    DimensionId, Enchantment, EnchantmentType, ItemStack, ItemType, RegistryKey, SimTick,
    ToolMaterial, ToolType,
};
use mdminecraft_render::{
    mesh_chunk_with_voxel_at, raycast, ChunkManager, ControlMode, DebugHud, Frustum, InputContext,
    InputState, ParticleEmitter, ParticleSystem, ParticleVertex, RaycastHit, Renderer,
    RendererConfig, TimeOfDay, UiRenderContext, WindowConfig, WindowManager,
};
#[cfg(feature = "ui3d_billboards")]
use mdminecraft_ui3d::render::{
    BillboardEmitter, BillboardFlags, BillboardInstance, BillboardRenderer,
};
use mdminecraft_world::{
    get_fluid_type, interactive_blocks,
    lighting::{
        init_skylight, recompute_skylight_local as recompute_skylight_local_world,
        stitch_light_seams, LightType,
    },
    local_y_to_world_y, world_y_to_local_y, ArmorPiece, ArmorSlot, BiomeId, BlockEntitiesState,
    BlockEntityKey, BlockId, BlockPropertiesRegistry, BlockState, BrewingStandState, ChestState,
    Chunk, ChunkPos, CropGrowthSystem, CropPosition, DamageKind, DispenserState,
    EnchantingTableState, FluidPos, FluidSimulator, FluidType, FurnaceState, HopperState,
    InteractionManager, Inventory, ItemManager, ItemType as DroppedItemType, Mob, MobSpawner,
    MobType, PlayerArmor, PlayerSave, PlayerTransform, PotionType, Projectile, ProjectileManager,
    RedstonePos, RedstoneSimulator, RegionStore, SimTime, StatusEffectType, StatusEffects,
    SugarCaneGrowthSystem, SugarCanePosition, TerrainGenerator, Voxel, WeatherState, WeatherToggle,
    WorldEntitiesState, WorldMeta, WorldPoint, WorldState, BLOCK_AIR, BLOCK_BOOKSHELF,
    BLOCK_BREWING_STAND, BLOCK_BROWN_MUSHROOM, BLOCK_COBBLESTONE, BLOCK_CRAFTING_TABLE,
    BLOCK_CRYING_OBSIDIAN, BLOCK_ENCHANTING_TABLE, BLOCK_END_PORTAL, BLOCK_END_PORTAL_FRAME,
    BLOCK_FURNACE, BLOCK_FURNACE_LIT, BLOCK_GLOWSTONE, BLOCK_ICE, BLOCK_NETHER_PORTAL,
    BLOCK_OAK_LOG, BLOCK_OAK_PLANKS, BLOCK_OBSIDIAN, BLOCK_RESPAWN_ANCHOR, BLOCK_SNOW,
    BLOCK_SUGAR_CANE, BLOCK_WATER, CHUNK_SIZE_X, CHUNK_SIZE_Y, CHUNK_SIZE_Z, WORLD_MAX_Y,
    WORLD_MIN_Y,
};
use rand::{rngs::StdRng, Rng, SeedableRng};
use serde::Deserialize;
use std::time::Instant;
use std::{
    collections::{BTreeMap, HashMap},
    fs,
    path::Path,
    path::PathBuf,
    sync::{Arc, OnceLock},
};

const MAX_PARTICLES: usize = 8_192;
const MAX_ARROW_PROJECTILES_IN_FLIGHT: usize = 32;
const PRECIPITATION_SPAWN_RATE: f32 = 480.0;
const PRECIPITATION_RADIUS: f32 = 18.0;
const PRECIPITATION_CEILING_OFFSET: f32 = 12.0;
const LIGHTNING_FLASH_TICKS: u8 = 8;
const LIGHTNING_STRIKE_CHANCE_DENOMINATOR: u32 = 180; // ~9s average at 20 TPS
const LIGHTNING_STRIKE_TARGET_RADIUS_BLOCKS: i32 = 64;
const LIGHTNING_HIT_RADIUS_BLOCKS: f64 = 3.0;
const LIGHTNING_DAMAGE: f32 = 5.0; // vanilla-ish: 2.5 hearts
const LIGHTNING_FIRE_TICKS: u16 = 160; // 8s at 20 TPS
const LIGHTNING_FIRE_ATTEMPTS: u8 = 4;
const ICE_FREEZE_INTERVAL_TICKS: u64 = 20; // ~1s at 20 TPS
const ICE_FREEZE_ATTEMPTS_PER_INTERVAL: u8 = 3;
const ICE_FREEZE_CLEAR_INTERVAL_TICKS: u64 = 80; // ~4s at 20 TPS
const ICE_FREEZE_CLEAR_ATTEMPTS_PER_INTERVAL: u8 = 1;
const ICE_FREEZE_RADIUS_BLOCKS: i32 = 32;
const SNOW_ACCUMULATION_INTERVAL_TICKS: u64 = 40; // ~2s at 20 TPS
const SNOW_ACCUMULATION_ATTEMPTS_PER_INTERVAL: u8 = 2;
const SNOW_ACCUMULATION_RADIUS_BLOCKS: i32 = 32;
const WEATHER_ACCUMULATION_MAX_BLOCK_LIGHT: u8 = 11;
const FIRE_EXTINGUISH_INTERVAL_TICKS: u64 = 20; // ~1s at 20 TPS
const FIRE_EXTINGUISH_ATTEMPTS_PER_INTERVAL: u8 = 4;
const FIRE_EXTINGUISH_RADIUS_BLOCKS: i32 = 32;
const FIRE_TICK_INTERVAL_TICKS: u64 = 20; // ~1s at 20 TPS
const FIRE_TICK_ATTEMPTS_PER_INTERVAL: u8 = 6;
const FIRE_TICK_RADIUS_BLOCKS: i32 = 32;
const FIRE_DECAY_AGE_THRESHOLD: u8 = 6;
const FIRE_BURN_SUPPORT_AGE_THRESHOLD: u8 = 10;
const FIRE_SPREAD_CHANCE_DENOMINATOR: u32 = 3;
const WEATHER_MELT_INTERVAL_TICKS: u64 = 60; // ~3s at 20 TPS
const WEATHER_MELT_ATTEMPTS_PER_INTERVAL: u8 = 3;
const WEATHER_MELT_RADIUS_BLOCKS: i32 = 32;
const UNDEAD_SUNLIGHT_MIN_SKY_LIGHT: u8 = 14;
const UNDEAD_SUNLIGHT_FIRE_TICKS: u32 = 40; // ~2s at 20 TPS
const CHICKEN_EGG_MIN_INTERVAL_TICKS: u64 = 6000; // 5 minutes at 20 TPS
const CHICKEN_EGG_INTERVAL_RANGE_TICKS: u64 = 6000; // up to +5 minutes (vanilla-ish 5-10m)
/// Fixed simulation tick rate (20 TPS).
const TICK_RATE: f64 = 1.0 / 20.0;
const NETHER_PORTAL_CHARGE_TICKS: u16 = 80;
const NETHER_PORTAL_COOLDOWN_TICKS: u16 = 100;
const NETHER_PORTAL_SEARCH_RADIUS: i32 = 16;
const WORLDGEN_CHEST_LOOT_SALT: u64 = 0x0043_4845_5354_4C4F_u64; // "CHESTLO"

struct UnsupportedBlockChanges {
    removed: Vec<(IVec3, BlockId)>,
    moved: Vec<IVec3>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub(crate) enum WorldgenChestLootTable {
    Generic,
    Dungeon,
    Mineshaft,
    Ruin,
    Village,
    NetherFortress,
}

impl WorldgenChestLootTable {
    fn from_structure_kind(kind: Option<mdminecraft_world::WorldgenStructureKind>) -> Self {
        match kind {
            Some(mdminecraft_world::WorldgenStructureKind::Village) => Self::Village,
            Some(mdminecraft_world::WorldgenStructureKind::Dungeon) => Self::Dungeon,
            Some(mdminecraft_world::WorldgenStructureKind::Mineshaft) => Self::Mineshaft,
            Some(mdminecraft_world::WorldgenStructureKind::Ruin) => Self::Ruin,
            None => Self::Generic,
        }
    }

    pub(crate) fn parse(token: &str) -> Option<Self> {
        let token = token.trim();
        if token.is_empty() {
            return None;
        }

        let token = token.to_ascii_lowercase();
        let token = token
            .strip_prefix("minecraft:")
            .or_else(|| token.strip_prefix("mdm:"))
            .unwrap_or(&token);

        match token {
            "generic" => Some(Self::Generic),
            "dungeon" => Some(Self::Dungeon),
            "mineshaft" => Some(Self::Mineshaft),
            "ruin" => Some(Self::Ruin),
            "village" => Some(Self::Village),
            "fortress" | "nether_fortress" | "netherfortress" => Some(Self::NetherFortress),
            _ => None,
        }
    }

    const fn salt(self) -> u64 {
        match self {
            Self::Generic => 0x4745_4E45_5249_4300_u64, // "GENERIC\0"
            Self::Dungeon => 0x4455_4E47_454F_4E00_u64, // "DUNGEON\0"
            Self::Mineshaft => 0x4D49_4E45_5348_4654_u64, // "MINESHFT"
            Self::Ruin => 0x5255_494E_0000_0000_u64,    // "RUIN"
            Self::Village => 0x5649_4C4C_4147_4500_u64, // "VILLAGE\0"
            Self::NetherFortress => 0x464F_5254_5245_5353_u64, // "FORTRESS"
        }
    }
}

// Core `ItemType::Item` IDs used by the client for non-legacy items.
// These are intentionally kept separate from the world brewing ingredient IDs
// (see `mdminecraft_core::item::item_ids`) to avoid collisions with legacy
// saves and other in-game item IDs.
pub(crate) const CORE_ITEM_GLASS_BOTTLE: u16 = 2000;
pub(crate) const CORE_ITEM_WATER_BOTTLE: u16 = 2001;
pub(crate) const CORE_ITEM_NETHER_WART: u16 = 2002;
pub(crate) const CORE_ITEM_BLAZE_POWDER: u16 = 2003;
pub(crate) const CORE_ITEM_GUNPOWDER: u16 = 2004;
pub(crate) const CORE_ITEM_WHEAT_SEEDS: u16 = 2005;
pub(crate) const CORE_ITEM_WHEAT: u16 = 2006;
pub(crate) const CORE_ITEM_SPIDER_EYE: u16 = 2007;
pub(crate) const CORE_ITEM_SUGAR: u16 = 2008;
pub(crate) const CORE_ITEM_PAPER: u16 = 2009;
pub(crate) const CORE_ITEM_BOOK: u16 = 2010;
pub(crate) const CORE_ITEM_FERMENTED_SPIDER_EYE: u16 = 2011;
pub(crate) const CORE_ITEM_MAGMA_CREAM: u16 = 2012;
pub(crate) const CORE_ITEM_GHAST_TEAR: u16 = 2013;
pub(crate) const CORE_ITEM_GLISTERING_MELON: u16 = 2014;
pub(crate) const CORE_ITEM_RABBIT_FOOT: u16 = 2015;
pub(crate) const CORE_ITEM_PHANTOM_MEMBRANE: u16 = 2016;
pub(crate) const CORE_ITEM_REDSTONE_DUST: u16 = 2017;
pub(crate) const CORE_ITEM_GLOWSTONE_DUST: u16 = 2018;
pub(crate) const CORE_ITEM_PUFFERFISH: u16 = 2019;
pub(crate) const CORE_ITEM_NETHER_QUARTZ: u16 = 2023;
pub(crate) const CORE_ITEM_BUCKET: u16 = client_item_ids::BUCKET;
pub(crate) const CORE_ITEM_WATER_BUCKET: u16 = client_item_ids::WATER_BUCKET;
pub(crate) const CORE_ITEM_LAVA_BUCKET: u16 = client_item_ids::LAVA_BUCKET;
pub(crate) const CORE_ITEM_FLINT_AND_STEEL: u16 = client_item_ids::FLINT_AND_STEEL;
pub(crate) const CORE_ITEM_ENDER_PEARL: u16 = client_item_ids::ENDER_PEARL;
pub(crate) const CORE_ITEM_EYE_OF_ENDER: u16 = client_item_ids::EYE_OF_ENDER;
use winit::event::{Event, MouseButton, WindowEvent};
use winit::event_loop::EventLoopWindowTarget;
use winit::keyboard::KeyCode;
use winit::window::Window;

/// Game action to communicate with main state machine
pub enum GameAction {
    /// Continue playing
    Continue,
    /// Return to main menu
    ReturnToMenu,
    /// Quit application
    Quit,
}

/// Player state (alive, dead, etc.)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PlayerState {
    /// Player is alive and can move/interact
    Alive,
    /// Player is dead and viewing death screen
    Dead,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PauseMenuView {
    Main,
    Options,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PauseMenuAction {
    None,
    Resume,
    ReturnToMenu,
    Quit,
}

/// Hotbar for item selection
struct Hotbar {
    slots: [Option<ItemStack>; 9],
    selected: usize,
}

/// Main inventory storage (27 slots; excludes hotbar).
struct MainInventory {
    slots: [Option<ItemStack>; 27],
}

impl Hotbar {
    fn new() -> Self {
        Self {
            slots: [
                Some(ItemStack::new(
                    ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Wood),
                    1,
                )),
                Some(ItemStack::new(
                    ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Stone),
                    1,
                )),
                Some(ItemStack::new(
                    ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Iron),
                    1,
                )),
                Some(ItemStack::new(
                    ItemType::Tool(ToolType::Shovel, ToolMaterial::Wood),
                    1,
                )),
                Some(ItemStack::new(ItemType::Item(1), 1)), // Bow
                Some(ItemStack::new(ItemType::Item(2), 64)), // Arrows
                Some(ItemStack::new(ItemType::Block(2), 64)), // Dirt
                Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 64)), // Cobblestone
                Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 64)), // Oak Planks
            ],
            selected: 0,
        }
    }

    fn select_slot(&mut self, slot: usize) {
        if slot < 9 {
            self.selected = slot;
        }
    }

    fn scroll(&mut self, delta: i32) {
        let len = self.slots.len() as i32;
        if len == 0 {
            return;
        }
        let mut idx = self.selected as i32 + delta;
        idx = ((idx % len) + len) % len;
        self.selected = idx as usize;
    }

    fn selected_item(&self) -> Option<&ItemStack> {
        self.slots[self.selected].as_ref()
    }

    fn selected_item_mut(&mut self) -> Option<&mut ItemStack> {
        self.slots[self.selected].as_mut()
    }

    /// Get the tool being held (if any)
    fn selected_tool(&self) -> Option<(ToolType, ToolMaterial)> {
        if let Some(item) = self.selected_item() {
            match item.item_type {
                ItemType::Tool(tool_type, material) => Some((tool_type, material)),
                _ => None,
            }
        } else {
            None
        }
    }

    /// Get the block to place (if selected item is a block)
    fn selected_block(&self) -> Option<BlockId> {
        if let Some(item) = self.selected_item() {
            match item.item_type {
                ItemType::Block(block_id) => Some(block_id),
                // Vanilla-ish: redstone dust places redstone wire.
                ItemType::Item(CORE_ITEM_REDSTONE_DUST) => {
                    Some(mdminecraft_world::redstone_blocks::REDSTONE_WIRE)
                }
                _ => None,
            }
        } else {
            None
        }
    }

    /// Get the food type if selected item is food
    fn selected_food(&self) -> Option<mdminecraft_core::item::FoodType> {
        if let Some(item) = self.selected_item() {
            match item.item_type {
                ItemType::Food(food_type) => Some(food_type),
                _ => None,
            }
        } else {
            None
        }
    }

    /// Get the potion ID if selected item is a potion
    fn selected_potion(&self) -> Option<u16> {
        if let Some(item) = self.selected_item() {
            match item.item_type {
                ItemType::Potion(potion_id) => Some(potion_id),
                _ => None,
            }
        } else {
            None
        }
    }

    /// Get the splash potion ID if the selected item is a splash potion
    fn selected_splash_potion(&self) -> Option<u16> {
        if let Some(item) = self.selected_item() {
            match item.item_type {
                ItemType::SplashPotion(potion_id) => Some(potion_id),
                _ => None,
            }
        } else {
            None
        }
    }

    fn selected_bucket(&self) -> Option<u16> {
        if let Some(item) = self.selected_item() {
            match item.item_type {
                ItemType::Item(id)
                    if matches!(
                        id,
                        CORE_ITEM_BUCKET | CORE_ITEM_WATER_BUCKET | CORE_ITEM_LAVA_BUCKET
                    ) =>
                {
                    Some(id)
                }
                _ => None,
            }
        } else {
            None
        }
    }

    /// Consume one of the selected item (for eating food)
    /// Returns true if item was consumed
    fn consume_selected(&mut self) -> bool {
        if let Some(item) = self.slots[self.selected].as_mut() {
            if item.count > 1 {
                item.count -= 1;
                true
            } else {
                // Remove the item if count becomes 0
                self.slots[self.selected] = None;
                true
            }
        } else {
            false
        }
    }

    fn add_stack(&mut self, mut stack: ItemStack) -> Option<ItemStack> {
        if stack.count == 0 {
            return None;
        }

        // Merge into existing stacks first.
        for existing in self.slots.iter_mut().flatten() {
            if !stacks_match_for_merge(existing, &stack) {
                continue;
            }

            let max = existing.max_stack_size();
            if existing.count >= max {
                continue;
            }

            let space = max - existing.count;
            let to_add = space.min(stack.count);
            existing.count += to_add;
            stack.count -= to_add;

            if stack.count == 0 {
                return None;
            }
        }

        // Then fill empty slots, splitting if needed.
        for slot in &mut self.slots {
            if stack.count == 0 {
                return None;
            }
            if slot.is_some() {
                continue;
            }

            let max = stack.max_stack_size();
            if stack.count <= max {
                *slot = Some(stack);
                return None;
            }

            let mut placed = stack.clone();
            placed.count = max;
            *slot = Some(placed);
            stack.count -= max;
        }

        Some(stack)
    }

    /// Check if the selected item is a bow
    fn has_bow_selected(&self) -> bool {
        if let Some(item) = self.selected_item() {
            matches!(item.item_type, ItemType::Item(1)) // Item ID 1 = Bow
        } else {
            false
        }
    }

    /// Check if player has arrows in hotbar
    fn has_arrows(&self) -> bool {
        self.slots.iter().any(|slot| {
            if let Some(item) = slot {
                matches!(item.item_type, ItemType::Item(2)) // Item ID 2 = Arrow
            } else {
                false
            }
        })
    }

    /// Consume one arrow from inventory
    fn consume_arrow(&mut self) -> bool {
        for slot in &mut self.slots {
            if let Some(item) = slot {
                if matches!(item.item_type, ItemType::Item(2)) {
                    if item.count > 1 {
                        item.count -= 1;
                    } else {
                        *slot = None;
                    }
                    return true;
                }
            }
        }
        false
    }

    fn item_name(&self, item_stack: Option<&ItemStack>, registry: &BlockRegistry) -> String {
        if let Some(stack) = item_stack {
            match stack.item_type {
                ItemType::Tool(tool_type, material) => {
                    format!("{:?} {:?}", material, tool_type)
                }
                ItemType::Block(block_id) => registry
                    .descriptor(block_id)
                    .map(|desc| desc.name.clone())
                    .unwrap_or_else(|| format!("Block({})", block_id)),
                ItemType::Food(food_type) => format!("{:?}", food_type),
                ItemType::Item(id) => match id {
                    1 => "Bow".to_string(),
                    2 => "Arrow".to_string(),
                    3 => "Stick".to_string(),
                    4 => "String".to_string(),
                    5 => "Flint".to_string(),
                    6 => "Feather".to_string(),
                    7 => "Iron Ingot".to_string(),
                    8 => "Coal".to_string(),
                    9 => "Gold Ingot".to_string(),
                    // Iron armor
                    10 => "Iron Helmet".to_string(),
                    11 => "Iron Chestplate".to_string(),
                    12 => "Iron Leggings".to_string(),
                    13 => "Iron Boots".to_string(),
                    14 => "Diamond".to_string(),
                    15 => "Lapis Lazuli".to_string(),
                    16 => "Bone".to_string(),
                    17 => "Emerald".to_string(),
                    18 => "Bone Meal".to_string(),
                    // Leather armor
                    20 => "Leather Helmet".to_string(),
                    21 => "Leather Chestplate".to_string(),
                    22 => "Leather Leggings".to_string(),
                    23 => "Leather Boots".to_string(),
                    // Diamond armor
                    30 => "Diamond Helmet".to_string(),
                    31 => "Diamond Chestplate".to_string(),
                    32 => "Diamond Leggings".to_string(),
                    33 => "Diamond Boots".to_string(),
                    // Resource items
                    100 => "Stick".to_string(),
                    101 => "Feather".to_string(),
                    102 => "Leather".to_string(),
                    103 => "Wool".to_string(),
                    104 => "Egg".to_string(),
                    105 => "Sapling".to_string(),
                    CORE_ITEM_GLASS_BOTTLE => "Glass Bottle".to_string(),
                    CORE_ITEM_WATER_BOTTLE => "Water Bottle".to_string(),
                    CORE_ITEM_NETHER_WART => "Nether Wart".to_string(),
                    CORE_ITEM_BLAZE_POWDER => "Blaze Powder".to_string(),
                    CORE_ITEM_GUNPOWDER => "Gunpowder".to_string(),
                    CORE_ITEM_WHEAT_SEEDS => "Wheat Seeds".to_string(),
                    CORE_ITEM_WHEAT => "Wheat".to_string(),
                    CORE_ITEM_SPIDER_EYE => "Spider Eye".to_string(),
                    CORE_ITEM_FERMENTED_SPIDER_EYE => "Fermented Spider Eye".to_string(),
                    CORE_ITEM_MAGMA_CREAM => "Magma Cream".to_string(),
                    CORE_ITEM_GHAST_TEAR => "Ghast Tear".to_string(),
                    CORE_ITEM_GLISTERING_MELON => "Glistering Melon".to_string(),
                    CORE_ITEM_RABBIT_FOOT => "Rabbit Foot".to_string(),
                    CORE_ITEM_PHANTOM_MEMBRANE => "Phantom Membrane".to_string(),
                    CORE_ITEM_REDSTONE_DUST => "Redstone Dust".to_string(),
                    CORE_ITEM_GLOWSTONE_DUST => "Glowstone Dust".to_string(),
                    CORE_ITEM_PUFFERFISH => "Pufferfish".to_string(),
                    CORE_ITEM_NETHER_QUARTZ => "Nether Quartz".to_string(),
                    CORE_ITEM_BUCKET => "Bucket".to_string(),
                    CORE_ITEM_WATER_BUCKET => "Water Bucket".to_string(),
                    CORE_ITEM_LAVA_BUCKET => "Lava Bucket".to_string(),
                    CORE_ITEM_FLINT_AND_STEEL => "Flint and Steel".to_string(),
                    CORE_ITEM_ENDER_PEARL => "Ender Pearl".to_string(),
                    CORE_ITEM_EYE_OF_ENDER => "Eye of Ender".to_string(),
                    CORE_ITEM_SUGAR => "Sugar".to_string(),
                    CORE_ITEM_PAPER => "Paper".to_string(),
                    CORE_ITEM_BOOK => "Book".to_string(),
                    _ => format!("Item({})", id),
                },
                ItemType::Potion(id) => potion_name(id),
                ItemType::SplashPotion(id) => format!("Splash {}", potion_name(id)),
            }
        } else {
            "Empty".to_string()
        }
    }
}

impl MainInventory {
    fn new() -> Self {
        Self {
            slots: std::array::from_fn(|_| None),
        }
    }

    fn add_stack(&mut self, mut stack: ItemStack) -> Option<ItemStack> {
        if stack.count == 0 {
            return None;
        }

        // Merge into existing stacks first.
        for existing in self.slots.iter_mut().flatten() {
            if !stacks_match_for_merge(existing, &stack) {
                continue;
            }

            let max = existing.max_stack_size();
            if existing.count >= max {
                continue;
            }

            let space = max - existing.count;
            let to_add = space.min(stack.count);
            existing.count += to_add;
            stack.count -= to_add;

            if stack.count == 0 {
                return None;
            }
        }

        // Then fill empty slots, splitting if needed.
        for slot in &mut self.slots {
            if stack.count == 0 {
                return None;
            }
            if slot.is_some() {
                continue;
            }

            let max = stack.max_stack_size();
            if stack.count <= max {
                *slot = Some(stack);
                return None;
            }

            let mut placed = stack.clone();
            placed.count = max;
            *slot = Some(placed);
            stack.count -= max;
        }

        Some(stack)
    }
}

/// AABB for collision detection
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Clone, Copy)]
#[allow(dead_code)]
struct AABB {
    min: glam::Vec3,
    max: glam::Vec3,
}

impl AABB {
    fn from_center_size(center: glam::Vec3, size: glam::Vec3) -> Self {
        let half_size = size * 0.5;
        Self {
            min: center - half_size,
            max: center + half_size,
        }
    }

    fn expand(&self, amount: f32) -> Self {
        let delta = glam::Vec3::splat(amount);
        Self {
            min: self.min - delta,
            max: self.max + delta,
        }
    }

    fn ray_intersects(&self, origin: glam::Vec3, direction: glam::Vec3, max_distance: f32) -> bool {
        let mut t_min = 0.0_f32;
        let mut t_max = max_distance;

        for axis in 0..3 {
            let origin_axis = origin[axis];
            let dir_axis = direction[axis];
            let min_axis = self.min[axis];
            let max_axis = self.max[axis];

            if dir_axis.abs() < 1.0e-8 {
                if origin_axis < min_axis || origin_axis > max_axis {
                    return false;
                }
                continue;
            }

            let inv_dir = 1.0 / dir_axis;
            let mut t1 = (min_axis - origin_axis) * inv_dir;
            let mut t2 = (max_axis - origin_axis) * inv_dir;
            if t1 > t2 {
                std::mem::swap(&mut t1, &mut t2);
            }

            t_min = t_min.max(t1);
            t_max = t_max.min(t2);

            if t_max < t_min {
                return false;
            }
        }

        t_max >= 0.0 && t_min <= max_distance
    }

    fn segment_entry_fraction(&self, from: glam::Vec3, to: glam::Vec3) -> Option<f32> {
        let direction = to - from;
        let mut t_min = 0.0_f32;
        let mut t_max = 1.0_f32;

        for axis in 0..3 {
            let origin_axis = from[axis];
            let dir_axis = direction[axis];
            let min_axis = self.min[axis];
            let max_axis = self.max[axis];

            if dir_axis.abs() < 1.0e-8 {
                if origin_axis < min_axis || origin_axis > max_axis {
                    return None;
                }
                continue;
            }

            let inv_dir = 1.0 / dir_axis;
            let mut t1 = (min_axis - origin_axis) * inv_dir;
            let mut t2 = (max_axis - origin_axis) * inv_dir;
            if t1 > t2 {
                std::mem::swap(&mut t1, &mut t2);
            }

            t_min = t_min.max(t1);
            t_max = t_max.min(t2);

            if t_max < t_min {
                return None;
            }
        }

        if t_max < 0.0 || t_min > 1.0 {
            return None;
        }

        Some(t_min.max(0.0))
    }

    /// Check if this AABB intersects with another
    fn intersects(&self, other: &AABB) -> bool {
        self.min.x < other.max.x
            && self.max.x > other.min.x
            && self.min.y < other.max.y
            && self.max.y > other.min.y
            && self.min.z < other.max.z
            && self.max.z > other.min.z
    }

    /// Offset the AABB by a vector
    fn offset(&self, offset: glam::Vec3) -> Self {
        Self {
            min: self.min + offset,
            max: self.max + offset,
        }
    }
}

#[derive(Clone, Copy, Debug)]
struct AabbSet<const N: usize> {
    items: [Option<AABB>; N],
    len: usize,
}

impl<const N: usize> AabbSet<N> {
    fn empty() -> Self {
        Self {
            items: [None; N],
            len: 0,
        }
    }

    fn single(aabb: AABB) -> Self {
        let mut set = Self::empty();
        set.push(aabb);
        set
    }

    fn push(&mut self, aabb: AABB) {
        debug_assert!(self.len < N);
        if self.len >= N {
            return;
        }
        self.items[self.len] = Some(aabb);
        self.len += 1;
    }

    fn iter(&self) -> impl Iterator<Item = &AABB> {
        self.items[..self.len].iter().flatten()
    }
}

/// Player physics state
struct PlayerPhysics {
    velocity: glam::Vec3,
    on_ground: bool,
    gravity: f32,
    jump_strength: f32,
    terminal_velocity: f32,
    player_height: f32,
    eye_height: f32,
    player_width: f32,
    physics_enabled: bool,
    /// Previous Y position for fall damage calculation
    last_ground_y: f32,
    /// Time since last jump press (for double-jump flight toggle)
    last_jump_press_time: f32,
}

/// Mining progress tracking
struct MiningProgress {
    /// Block position being mined
    block_pos: IVec3,
    /// Time spent mining this block
    time_mining: f32,
    /// Total time required to mine this block
    time_required: f32,
}

/// Helper: given time slices, return how many frames are needed to finish mining.
#[cfg(test)]
fn frames_to_complete(time_required: f32, dt_slices: &[f32]) -> usize {
    let mut acc = 0.0;
    for (i, dt) in dt_slices.iter().enumerate() {
        acc += *dt;
        if acc >= time_required {
            return i + 1;
        }
    }
    dt_slices.len()
}

/// Runtime particle instance stored on the CPU before uploading to the GPU each frame.
struct ParticleInstance {
    position: glam::Vec3,
    velocity: glam::Vec3,
    color: glam::Vec4,
    lifetime: f32,
    age: f32,
    scale: f32,
    gravity: f32,
}

impl ParticleInstance {
    fn new(
        position: glam::Vec3,
        velocity: glam::Vec3,
        color: glam::Vec4,
        lifetime: f32,
        scale: f32,
        gravity: f32,
    ) -> Self {
        Self {
            position,
            velocity,
            color,
            lifetime,
            age: 0.0,
            scale,
            gravity,
        }
    }

    fn update(&mut self, dt: f32) {
        self.velocity.y -= self.gravity * dt;
        self.position += self.velocity * dt;
        self.age += dt;
    }

    fn remaining(&self) -> f32 {
        (self.lifetime - self.age).max(0.0)
    }

    fn is_alive(&self) -> bool {
        self.age < self.lifetime
    }

    fn to_vertex(&self) -> ParticleVertex {
        let mut color = self.color;
        color.w *= (self.remaining() / self.lifetime).clamp(0.0, 1.0);
        ParticleVertex {
            position: self.position.to_array(),
            color: color.to_array(),
            lifetime: self.remaining(),
            scale: self.scale,
        }
    }
}

/// Player health and survival stats
struct PlayerHealth {
    /// Current health (0-20, measured in half-hearts)
    current: f32,
    /// Maximum health
    max: f32,
    /// Health regeneration rate (hearts per second when full hunger)
    regeneration_rate: f32,
    /// Time since last damage (for regeneration delay)
    time_since_damage: f32,
    /// Invulnerability time after taking damage
    invulnerability_time: f32,
    /// Current hunger (0-20, measured in half-shanks)
    hunger: f32,
    /// Maximum hunger
    max_hunger: f32,
    /// Time accumulator for hunger depletion
    hunger_timer: f32,
    /// Time accumulator for starvation damage
    starvation_timer: f32,
    /// Whether player is actively moving (depletes hunger faster)
    is_active: bool,
    /// Remaining air while underwater (ticks, 20 TPS). Vanilla: 300 ticks (~15s).
    air_ticks: u16,
    /// Ticks accumulated since last drowning damage once out of air.
    drowning_timer_ticks: u8,
    /// Remaining on-fire ticks (20 TPS).
    burning_ticks: u16,
    /// Ticks accumulated since last fire damage while burning.
    burning_damage_timer_ticks: u8,
}

impl PlayerHealth {
    fn new() -> Self {
        Self {
            current: 20.0,
            max: 20.0,
            regeneration_rate: 0.5, // Regenerate 0.5 health per second when hunger >= 18
            time_since_damage: 0.0,
            invulnerability_time: 0.0,
            hunger: 20.0,
            max_hunger: 20.0,
            hunger_timer: 0.0,
            starvation_timer: 0.0,
            is_active: false,
            air_ticks: 300,
            drowning_timer_ticks: 0,
            burning_ticks: 0,
            burning_damage_timer_ticks: 0,
        }
    }

    /// Take damage
    fn damage(&mut self, amount: f32) {
        if self.invulnerability_time > 0.0 {
            return; // Still invulnerable
        }

        self.current = (self.current - amount).max(0.0);
        self.time_since_damage = 0.0;
        self.invulnerability_time = 0.5; // 0.5 second invulnerability

        tracing::info!(
            "Took {:.1} damage, health now {:.1}/20",
            amount,
            self.current
        );
    }

    /// Heal health
    fn heal(&mut self, amount: f32) {
        self.current = (self.current + amount).min(self.max);
    }

    /// Check if player is dead
    fn is_dead(&self) -> bool {
        self.current <= 0.0
    }

    /// Eat food and restore hunger
    fn eat(&mut self, hunger_restore: f32) -> bool {
        if self.hunger >= self.max_hunger {
            return false; // Already full
        }
        self.hunger = (self.hunger + hunger_restore).min(self.max_hunger);
        tracing::info!("Ate food, hunger now {:.1}/20", self.hunger);
        true
    }

    /// Update health (regeneration, hunger depletion, starvation)
    fn update(&mut self, dt: f32) {
        self.time_since_damage += dt;

        if self.invulnerability_time > 0.0 {
            self.invulnerability_time -= dt;
        }

        // Hunger depletion
        self.hunger_timer += dt;
        let depletion_interval = if self.is_active { 30.0 } else { 60.0 }; // 30s active, 60s idle
        let depletion_amount = if self.is_active { 1.0 } else { 0.5 };

        if self.hunger_timer >= depletion_interval {
            self.hunger_timer = 0.0;
            self.hunger = (self.hunger - depletion_amount).max(0.0);
        }

        // Starvation damage when hunger is 0
        if self.hunger <= 0.0 {
            self.starvation_timer += dt;
            if self.starvation_timer >= 1.0 {
                self.starvation_timer = 0.0;
                // Bypass invulnerability for starvation
                self.current = (self.current - 1.0).max(0.0);
                tracing::info!("Starvation damage! Health now {:.1}/20", self.current);
            }
        } else {
            self.starvation_timer = 0.0;
        }

        // Regenerate health only when hunger >= 18 and enough time since damage
        if self.hunger >= 18.0 && self.time_since_damage > 3.0 && self.current < self.max {
            self.heal(self.regeneration_rate * dt);
        }
    }

    fn tick_air(
        &mut self,
        underwater: bool,
        max_air_ticks: u16,
        has_water_breathing: bool,
    ) -> bool {
        let max_air_ticks = max_air_ticks.max(1);
        const AIR_REGEN_PER_TICK: u16 = 4;
        const DROWNING_DAMAGE_INTERVAL_TICKS: u8 = 20;

        self.air_ticks = self.air_ticks.min(max_air_ticks);

        if has_water_breathing {
            self.air_ticks = max_air_ticks;
            self.drowning_timer_ticks = 0;
            return false;
        }

        if underwater {
            if self.air_ticks > 0 {
                self.air_ticks = self.air_ticks.saturating_sub(1);
                self.drowning_timer_ticks = 0;
                return false;
            }

            self.drowning_timer_ticks = self
                .drowning_timer_ticks
                .saturating_add(1)
                .min(DROWNING_DAMAGE_INTERVAL_TICKS);
            if self.drowning_timer_ticks >= DROWNING_DAMAGE_INTERVAL_TICKS {
                self.drowning_timer_ticks = 0;
                return true;
            }
            return false;
        }

        self.air_ticks = (self.air_ticks + AIR_REGEN_PER_TICK).min(max_air_ticks);
        self.drowning_timer_ticks = 0;
        false
    }

    fn ignite(&mut self, ticks: u16) {
        self.burning_ticks = self.burning_ticks.max(ticks);
    }

    fn tick_burning(&mut self, extinguish: bool, has_fire_resistance: bool) -> bool {
        const BURNING_DAMAGE_INTERVAL_TICKS: u8 = 20;

        if extinguish {
            self.burning_ticks = 0;
            self.burning_damage_timer_ticks = 0;
            return false;
        }

        if self.burning_ticks == 0 {
            self.burning_damage_timer_ticks = 0;
            return false;
        }

        self.burning_ticks = self.burning_ticks.saturating_sub(1);

        if has_fire_resistance {
            self.burning_damage_timer_ticks = 0;
            return false;
        }

        self.burning_damage_timer_ticks = self
            .burning_damage_timer_ticks
            .saturating_add(1)
            .min(BURNING_DAMAGE_INTERVAL_TICKS);
        if self.burning_damage_timer_ticks >= BURNING_DAMAGE_INTERVAL_TICKS {
            self.burning_damage_timer_ticks = 0;
            return true;
        }

        false
    }

    /// Reset health and hunger to full (for respawn)
    fn reset(&mut self) {
        self.current = self.max;
        self.hunger = self.max_hunger;
        self.time_since_damage = 0.0;
        self.invulnerability_time = 0.0;
        self.hunger_timer = 0.0;
        self.starvation_timer = 0.0;
        self.air_ticks = 300;
        self.drowning_timer_ticks = 0;
        self.burning_ticks = 0;
        self.burning_damage_timer_ticks = 0;
    }

    /// Set active state for hunger depletion rate
    fn set_active(&mut self, active: bool) {
        self.is_active = active;
    }
}

fn apply_instant_status_effect_to_player_health(
    health: &mut PlayerHealth,
    effect_type: StatusEffectType,
    amplifier: u8,
) {
    match effect_type {
        StatusEffectType::InstantHealth => {
            let amount = if amplifier > 0 { 8.0 } else { 4.0 };
            health.heal(amount);
        }
        StatusEffectType::InstantDamage => {
            let amount = if amplifier > 0 { 12.0 } else { 6.0 };
            health.damage(amount);
        }
        _ => {}
    }
}

fn tick_health_over_time_status_effects(
    health: &mut PlayerHealth,
    effects: &StatusEffects,
    regeneration_timer_ticks: &mut u8,
    poison_timer_ticks: &mut u8,
) {
    if let Some(amp) = effects.amplifier(StatusEffectType::Regeneration) {
        let interval = (50u8).saturating_div(amp.saturating_add(1)).max(1);
        *regeneration_timer_ticks = regeneration_timer_ticks.saturating_add(1);
        if *regeneration_timer_ticks >= interval {
            *regeneration_timer_ticks = 0;
            health.heal(1.0);
        }
    } else {
        *regeneration_timer_ticks = 0;
    }

    if let Some(amp) = effects.amplifier(StatusEffectType::Poison) {
        let interval = (25u8).saturating_div(amp.saturating_add(1)).max(1);
        *poison_timer_ticks = poison_timer_ticks.saturating_add(1);
        if *poison_timer_ticks >= interval {
            *poison_timer_ticks = 0;
            if health.current > 1.0 {
                health.damage(1.0);
            }
        }
    } else {
        *poison_timer_ticks = 0;
    }
}

/// Get hunger restoration amount for a food type
fn food_hunger_restore(food_type: mdminecraft_core::item::FoodType) -> f32 {
    use mdminecraft_core::item::FoodType;
    match food_type {
        FoodType::Apple => 4.0,
        FoodType::Bread => 5.0,
        FoodType::RawMeat => 3.0,
        FoodType::CookedMeat => 8.0,
        FoodType::Carrot => 3.0,
        FoodType::Potato => 1.0,
        FoodType::BakedPotato => 5.0,
        FoodType::GoldenCarrot => 6.0,
    }
}

/// Get the display name for a potion ID
fn potion_name(potion_id: u16) -> String {
    match potion_id {
        potion_ids::AWKWARD => "Awkward Potion".to_string(),
        potion_ids::NIGHT_VISION => "Potion of Night Vision".to_string(),
        potion_ids::INVISIBILITY => "Potion of Invisibility".to_string(),
        potion_ids::LEAPING => "Potion of Leaping".to_string(),
        potion_ids::FIRE_RESISTANCE => "Potion of Fire Resistance".to_string(),
        potion_ids::SWIFTNESS => "Potion of Swiftness".to_string(),
        potion_ids::SLOWNESS => "Potion of Slowness".to_string(),
        potion_ids::WATER_BREATHING => "Potion of Water Breathing".to_string(),
        potion_ids::HEALING => "Potion of Healing".to_string(),
        potion_ids::HARMING => "Potion of Harming".to_string(),
        potion_ids::POISON => "Potion of Poison".to_string(),
        potion_ids::REGENERATION => "Potion of Regeneration".to_string(),
        potion_ids::STRENGTH => "Potion of Strength".to_string(),
        potion_ids::WEAKNESS => "Potion of Weakness".to_string(),
        potion_ids::SLOW_FALLING => "Potion of Slow Falling".to_string(),
        potion_ids::NIGHT_VISION_LONG => "Potion of Night Vision (Long)".to_string(),
        potion_ids::INVISIBILITY_LONG => "Potion of Invisibility (Long)".to_string(),
        potion_ids::LEAPING_LONG => "Potion of Leaping (Long)".to_string(),
        potion_ids::LEAPING_STRONG => "Potion of Leaping II".to_string(),
        potion_ids::FIRE_RESISTANCE_LONG => "Potion of Fire Resistance (Long)".to_string(),
        potion_ids::SWIFTNESS_LONG => "Potion of Swiftness (Long)".to_string(),
        potion_ids::SWIFTNESS_STRONG => "Potion of Swiftness II".to_string(),
        potion_ids::SLOWNESS_LONG => "Potion of Slowness (Long)".to_string(),
        potion_ids::WATER_BREATHING_LONG => "Potion of Water Breathing (Long)".to_string(),
        potion_ids::HEALING_STRONG => "Potion of Healing II".to_string(),
        potion_ids::HARMING_STRONG => "Potion of Harming II".to_string(),
        potion_ids::POISON_LONG => "Potion of Poison (Long)".to_string(),
        potion_ids::POISON_STRONG => "Potion of Poison II".to_string(),
        potion_ids::REGENERATION_LONG => "Potion of Regeneration (Long)".to_string(),
        potion_ids::REGENERATION_STRONG => "Potion of Regeneration II".to_string(),
        potion_ids::STRENGTH_LONG => "Potion of Strength (Long)".to_string(),
        potion_ids::STRENGTH_STRONG => "Potion of Strength II".to_string(),
        potion_ids::WEAKNESS_LONG => "Potion of Weakness (Long)".to_string(),
        potion_ids::SLOW_FALLING_LONG => "Potion of Slow Falling (Long)".to_string(),
        _ => format!("Potion({})", potion_id),
    }
}

fn potion_supports_strong_variant(potion: PotionType) -> bool {
    matches!(
        potion,
        PotionType::Swiftness
            | PotionType::Leaping
            | PotionType::Healing
            | PotionType::Harming
            | PotionType::Poison
            | PotionType::Regeneration
            | PotionType::Strength
    )
}

fn potion_id_to_potion_state(potion_id: u16) -> Option<(PotionType, bool, u8)> {
    let (potion_type, extended, amplifier) = match potion_id {
        potion_ids::AWKWARD => (PotionType::Awkward, false, 0),
        potion_ids::NIGHT_VISION => (PotionType::NightVision, false, 0),
        potion_ids::INVISIBILITY => (PotionType::Invisibility, false, 0),
        potion_ids::LEAPING => (PotionType::Leaping, false, 0),
        potion_ids::FIRE_RESISTANCE => (PotionType::FireResistance, false, 0),
        potion_ids::SWIFTNESS => (PotionType::Swiftness, false, 0),
        potion_ids::SLOWNESS => (PotionType::Slowness, false, 0),
        potion_ids::WATER_BREATHING => (PotionType::WaterBreathing, false, 0),
        potion_ids::HEALING => (PotionType::Healing, false, 0),
        potion_ids::HARMING => (PotionType::Harming, false, 0),
        potion_ids::POISON => (PotionType::Poison, false, 0),
        potion_ids::REGENERATION => (PotionType::Regeneration, false, 0),
        potion_ids::STRENGTH => (PotionType::Strength, false, 0),
        potion_ids::WEAKNESS => (PotionType::Weakness, false, 0),
        potion_ids::SLOW_FALLING => (PotionType::SlowFalling, false, 0),

        potion_ids::NIGHT_VISION_LONG => (PotionType::NightVision, true, 0),
        potion_ids::INVISIBILITY_LONG => (PotionType::Invisibility, true, 0),
        potion_ids::LEAPING_LONG => (PotionType::Leaping, true, 0),
        potion_ids::LEAPING_STRONG => (PotionType::Leaping, false, 1),
        potion_ids::FIRE_RESISTANCE_LONG => (PotionType::FireResistance, true, 0),
        potion_ids::SWIFTNESS_LONG => (PotionType::Swiftness, true, 0),
        potion_ids::SWIFTNESS_STRONG => (PotionType::Swiftness, false, 1),
        potion_ids::SLOWNESS_LONG => (PotionType::Slowness, true, 0),
        potion_ids::WATER_BREATHING_LONG => (PotionType::WaterBreathing, true, 0),
        potion_ids::HEALING_STRONG => (PotionType::Healing, false, 1),
        potion_ids::HARMING_STRONG => (PotionType::Harming, false, 1),
        potion_ids::POISON_LONG => (PotionType::Poison, true, 0),
        potion_ids::POISON_STRONG => (PotionType::Poison, false, 1),
        potion_ids::REGENERATION_LONG => (PotionType::Regeneration, true, 0),
        potion_ids::REGENERATION_STRONG => (PotionType::Regeneration, false, 1),
        potion_ids::STRENGTH_LONG => (PotionType::Strength, true, 0),
        potion_ids::STRENGTH_STRONG => (PotionType::Strength, false, 1),
        potion_ids::WEAKNESS_LONG => (PotionType::Weakness, true, 0),
        potion_ids::SLOW_FALLING_LONG => (PotionType::SlowFalling, true, 0),

        _ => return None,
    };

    let extended = extended && potion_type.base_duration_ticks() > 0;
    let amplifier = if potion_supports_strong_variant(potion_type) {
        amplifier.min(1)
    } else {
        0
    };

    Some((potion_type, extended, amplifier))
}

fn potion_state_to_potion_id(potion_type: PotionType, extended: bool, amplifier: u8) -> u16 {
    let extended = extended && potion_type.base_duration_ticks() > 0;
    let amplifier = if potion_supports_strong_variant(potion_type) {
        amplifier.min(1)
    } else {
        0
    };
    let amplifier = if extended { 0 } else { amplifier };

    match (potion_type, extended, amplifier) {
        (PotionType::Awkward, false, 0) => potion_ids::AWKWARD,
        (PotionType::NightVision, false, 0) => potion_ids::NIGHT_VISION,
        (PotionType::NightVision, true, 0) => potion_ids::NIGHT_VISION_LONG,
        (PotionType::Invisibility, false, 0) => potion_ids::INVISIBILITY,
        (PotionType::Invisibility, true, 0) => potion_ids::INVISIBILITY_LONG,
        (PotionType::Leaping, false, 0) => potion_ids::LEAPING,
        (PotionType::Leaping, true, 0) => potion_ids::LEAPING_LONG,
        (PotionType::Leaping, false, 1) => potion_ids::LEAPING_STRONG,
        (PotionType::FireResistance, false, 0) => potion_ids::FIRE_RESISTANCE,
        (PotionType::FireResistance, true, 0) => potion_ids::FIRE_RESISTANCE_LONG,
        (PotionType::Swiftness, false, 0) => potion_ids::SWIFTNESS,
        (PotionType::Swiftness, true, 0) => potion_ids::SWIFTNESS_LONG,
        (PotionType::Swiftness, false, 1) => potion_ids::SWIFTNESS_STRONG,
        (PotionType::Slowness, false, 0) => potion_ids::SLOWNESS,
        (PotionType::Slowness, true, 0) => potion_ids::SLOWNESS_LONG,
        (PotionType::WaterBreathing, false, 0) => potion_ids::WATER_BREATHING,
        (PotionType::WaterBreathing, true, 0) => potion_ids::WATER_BREATHING_LONG,
        (PotionType::Healing, false, 0) => potion_ids::HEALING,
        (PotionType::Healing, false, 1) => potion_ids::HEALING_STRONG,
        (PotionType::Harming, false, 0) => potion_ids::HARMING,
        (PotionType::Harming, false, 1) => potion_ids::HARMING_STRONG,
        (PotionType::Poison, false, 0) => potion_ids::POISON,
        (PotionType::Poison, true, 0) => potion_ids::POISON_LONG,
        (PotionType::Poison, false, 1) => potion_ids::POISON_STRONG,
        (PotionType::Regeneration, false, 0) => potion_ids::REGENERATION,
        (PotionType::Regeneration, true, 0) => potion_ids::REGENERATION_LONG,
        (PotionType::Regeneration, false, 1) => potion_ids::REGENERATION_STRONG,
        (PotionType::Strength, false, 0) => potion_ids::STRENGTH,
        (PotionType::Strength, true, 0) => potion_ids::STRENGTH_LONG,
        (PotionType::Strength, false, 1) => potion_ids::STRENGTH_STRONG,
        (PotionType::Weakness, false, 0) => potion_ids::WEAKNESS,
        (PotionType::Weakness, true, 0) => potion_ids::WEAKNESS_LONG,
        (PotionType::SlowFalling, false, 0) => potion_ids::SLOW_FALLING,
        (PotionType::SlowFalling, true, 0) => potion_ids::SLOW_FALLING_LONG,

        _ => potion_ids::AWKWARD,
    }
}

fn brew_ingredient_label(ingredient_id: u16) -> &'static str {
    match ingredient_id {
        item_ids::NETHER_WART => "Nether Wart",
        item_ids::BLAZE_POWDER => "Blaze Powder",
        item_ids::GHAST_TEAR => "Ghast Tear",
        item_ids::MAGMA_CREAM => "Magma Cream",
        item_ids::SPIDER_EYE => "Spider Eye",
        item_ids::FERMENTED_SPIDER_EYE => "Fermented Spider Eye",
        item_ids::GLISTERING_MELON => "Glistering Melon",
        item_ids::GOLDEN_CARROT => "Golden Carrot",
        item_ids::RABBIT_FOOT => "Rabbit Foot",
        item_ids::PHANTOM_MEMBRANE => "Phantom Membrane",
        item_ids::REDSTONE_DUST => "Redstone Dust",
        item_ids::GLOWSTONE_DUST => "Glowstone Dust",
        item_ids::GUNPOWDER => "Gunpowder",
        item_ids::DRAGON_BREATH => "Dragon Breath",
        item_ids::PUFFERFISH => "Pufferfish",
        item_ids::SUGAR => "Sugar",
        _ => "Unknown",
    }
}

fn core_item_type_to_brew_ingredient_id(item_type: ItemType) -> Option<u16> {
    match item_type {
        ItemType::Item(CORE_ITEM_NETHER_WART) => Some(item_ids::NETHER_WART),
        ItemType::Item(CORE_ITEM_BLAZE_POWDER) => Some(item_ids::BLAZE_POWDER),
        ItemType::Item(CORE_ITEM_GUNPOWDER) => Some(item_ids::GUNPOWDER),
        ItemType::Item(CORE_ITEM_SPIDER_EYE) => Some(item_ids::SPIDER_EYE),
        ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE) => Some(item_ids::FERMENTED_SPIDER_EYE),
        ItemType::Item(CORE_ITEM_SUGAR) => Some(item_ids::SUGAR),
        ItemType::Item(CORE_ITEM_MAGMA_CREAM) => Some(item_ids::MAGMA_CREAM),
        ItemType::Item(CORE_ITEM_GHAST_TEAR) => Some(item_ids::GHAST_TEAR),
        ItemType::Item(CORE_ITEM_GLISTERING_MELON) => Some(item_ids::GLISTERING_MELON),
        ItemType::Item(CORE_ITEM_RABBIT_FOOT) => Some(item_ids::RABBIT_FOOT),
        ItemType::Item(CORE_ITEM_PHANTOM_MEMBRANE) => Some(item_ids::PHANTOM_MEMBRANE),
        ItemType::Item(CORE_ITEM_REDSTONE_DUST) => Some(item_ids::REDSTONE_DUST),
        ItemType::Item(CORE_ITEM_GLOWSTONE_DUST) => Some(item_ids::GLOWSTONE_DUST),
        ItemType::Item(CORE_ITEM_PUFFERFISH) => Some(item_ids::PUFFERFISH),
        ItemType::Food(mdminecraft_core::item::FoodType::GoldenCarrot) => {
            Some(item_ids::GOLDEN_CARROT)
        }
        _ => None,
    }
}

fn brew_ingredient_id_to_core_item_type(ingredient_id: u16) -> Option<ItemType> {
    match ingredient_id {
        item_ids::NETHER_WART => Some(ItemType::Item(CORE_ITEM_NETHER_WART)),
        item_ids::BLAZE_POWDER => Some(ItemType::Item(CORE_ITEM_BLAZE_POWDER)),
        item_ids::GUNPOWDER => Some(ItemType::Item(CORE_ITEM_GUNPOWDER)),
        item_ids::SPIDER_EYE => Some(ItemType::Item(CORE_ITEM_SPIDER_EYE)),
        item_ids::FERMENTED_SPIDER_EYE => Some(ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE)),
        item_ids::SUGAR => Some(ItemType::Item(CORE_ITEM_SUGAR)),
        item_ids::MAGMA_CREAM => Some(ItemType::Item(CORE_ITEM_MAGMA_CREAM)),
        item_ids::GHAST_TEAR => Some(ItemType::Item(CORE_ITEM_GHAST_TEAR)),
        item_ids::GLISTERING_MELON => Some(ItemType::Item(CORE_ITEM_GLISTERING_MELON)),
        item_ids::RABBIT_FOOT => Some(ItemType::Item(CORE_ITEM_RABBIT_FOOT)),
        item_ids::PHANTOM_MEMBRANE => Some(ItemType::Item(CORE_ITEM_PHANTOM_MEMBRANE)),
        item_ids::REDSTONE_DUST => Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
        item_ids::GLOWSTONE_DUST => Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
        item_ids::PUFFERFISH => Some(ItemType::Item(CORE_ITEM_PUFFERFISH)),
        item_ids::GOLDEN_CARROT => Some(ItemType::Food(
            mdminecraft_core::item::FoodType::GoldenCarrot,
        )),
        _ => None,
    }
}

fn core_item_stack_to_bottle(stack: &ItemStack) -> Option<(PotionType, bool, bool, u8)> {
    match stack.item_type {
        ItemType::Item(CORE_ITEM_WATER_BOTTLE) => Some((PotionType::Water, false, false, 0)),
        ItemType::Potion(id) => {
            let (potion_type, extended, amplifier) = potion_id_to_potion_state(id)?;
            Some((potion_type, false, extended, amplifier))
        }
        ItemType::SplashPotion(id) => {
            let (potion_type, extended, amplifier) = potion_id_to_potion_state(id)?;
            Some((potion_type, true, extended, amplifier))
        }
        _ => None,
    }
}

fn bottle_to_core_item_stack(
    potion: PotionType,
    is_splash: bool,
    is_extended: bool,
    amplifier: u8,
) -> ItemStack {
    let potion_item = |id: u16| {
        if is_splash {
            ItemType::SplashPotion(id)
        } else {
            ItemType::Potion(id)
        }
    };

    match potion {
        PotionType::Water => ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1),
        _ => {
            let potion_id = potion_state_to_potion_id(potion, is_extended, amplifier);
            ItemStack::new(potion_item(potion_id), 1)
        }
    }
}

/// Player experience points (visual only - XP not functional yet)
struct PlayerXP {
    /// Current XP points
    current: u32,
    /// Current level
    level: u32,
    /// XP needed to reach next level
    next_level_xp: u32,
}

impl PlayerXP {
    fn new() -> Self {
        Self {
            current: 0,
            level: 0,
            next_level_xp: 7, // First level needs 7 XP
        }
    }

    /// Add XP and handle level ups
    fn add_xp(&mut self, amount: u32) {
        self.current += amount;
        while self.current >= self.next_level_xp {
            self.current -= self.next_level_xp;
            self.level += 1;
            // XP curve: increases with level
            self.next_level_xp = if self.level < 16 {
                2 * self.level + 7
            } else if self.level < 31 {
                5 * self.level - 38
            } else {
                9 * self.level - 158
            };
        }
    }

    /// Get progress to next level (0.0 to 1.0)
    fn progress(&self) -> f32 {
        if self.next_level_xp == 0 {
            0.0
        } else {
            self.current as f32 / self.next_level_xp as f32
        }
    }

    /// Reset XP on death (loses some levels)
    #[allow(dead_code)]
    fn reset(&mut self) {
        // Lose 3 levels on death (minimum 0)
        self.level = self.level.saturating_sub(3);
        self.current = 0;
        // Recalculate next level XP
        self.next_level_xp = if self.level < 16 {
            2 * self.level + 7
        } else if self.level < 31 {
            5 * self.level - 38
        } else {
            9 * self.level - 158
        };
    }

    /// Consume XP levels (for enchanting)
    /// Returns true if levels were successfully consumed
    fn consume_levels(&mut self, levels: u32) -> bool {
        if self.level >= levels {
            self.level -= levels;
            // Recalculate next level XP for current level
            self.next_level_xp = if self.level < 16 {
                2 * self.level + 7
            } else if self.level < 31 {
                5 * self.level - 38
            } else {
                9 * self.level - 158
            };
            // Reset progress within the current level
            self.current = 0;
            true
        } else {
            false
        }
    }
}

/// Experience orb that drops from mobs and is collected by the player
struct XPOrb {
    /// World position
    pos: glam::Vec3,
    /// Velocity
    vel: glam::Vec3,
    /// XP value
    value: u32,
    /// Lifetime in seconds (despawns after 5 minutes)
    lifetime: f32,
    /// Whether orb is on ground
    on_ground: bool,
}

impl XPOrb {
    /// Create a new XP orb at the given position
    fn new(pos: glam::Vec3, value: u32, seed: u64) -> Self {
        let mut rng = StdRng::seed_from_u64(seed);
        // Small deterministic upward and outward velocity for visual scatter.
        let angle = rng.gen_range(0.0..std::f32::consts::TAU);
        let speed = rng.gen_range(0.1..0.2);
        let vel = glam::Vec3::new(
            angle.cos() * speed,
            0.3, // Upward pop
            angle.sin() * speed,
        );

        Self {
            pos,
            vel,
            value,
            lifetime: 300.0, // 5 minutes
            on_ground: false,
        }
    }

    /// Update physics and magnetic attraction to player
    /// Returns true if orb should be removed (despawned or collected)
    fn update(&mut self, dt: f32, player_pos: glam::Vec3) -> bool {
        // Decrement lifetime
        self.lifetime -= dt;
        if self.lifetime <= 0.0 {
            return true; // Despawn
        }

        // Calculate distance to player
        let to_player = player_pos - self.pos;
        let distance = to_player.length();

        // Magnetic attraction when within 2 blocks
        if distance < 2.0 && distance > 0.01 {
            let attraction_strength = 8.0; // Blocks per second
            let attraction = to_player.normalize() * attraction_strength * dt;
            self.vel += attraction;
        }

        // Apply gravity
        if !self.on_ground {
            self.vel.y -= 9.8 * dt; // Gravity
        }

        // Apply velocity
        self.pos += self.vel * dt;

        // Simple ground check (if Y velocity is near zero and position is low)
        if self.vel.y.abs() < 0.1 && self.pos.y < player_pos.y + 1.0 {
            self.on_ground = true;
            self.vel.y = 0.0;
            self.vel *= 0.9; // Friction
        }

        false // Keep orb
    }

    /// Check if player should collect this orb
    fn should_collect(&self, player_pos: glam::Vec3) -> bool {
        let distance = (self.pos - player_pos).length();
        distance < 0.5 // Collection radius
    }
}

/// Ray-AABB intersection test
/// Returns Some(t) where t is the distance along the ray, or None if no intersection
fn ray_aabb_intersect(
    origin: glam::Vec3,
    dir: glam::Vec3,
    min: glam::Vec3,
    max: glam::Vec3,
) -> Option<f32> {
    let inv_dir = glam::Vec3::new(
        if dir.x.abs() < 1e-6 {
            f32::MAX
        } else {
            1.0 / dir.x
        },
        if dir.y.abs() < 1e-6 {
            f32::MAX
        } else {
            1.0 / dir.y
        },
        if dir.z.abs() < 1e-6 {
            f32::MAX
        } else {
            1.0 / dir.z
        },
    );

    let t1 = (min.x - origin.x) * inv_dir.x;
    let t2 = (max.x - origin.x) * inv_dir.x;
    let t3 = (min.y - origin.y) * inv_dir.y;
    let t4 = (max.y - origin.y) * inv_dir.y;
    let t5 = (min.z - origin.z) * inv_dir.z;
    let t6 = (max.z - origin.z) * inv_dir.z;

    let tmin = t1.min(t2).max(t3.min(t4)).max(t5.min(t6));
    let tmax = t1.max(t2).min(t3.max(t4)).min(t5.max(t6));

    if tmax >= tmin && tmax >= 0.0 {
        Some(if tmin >= 0.0 { tmin } else { tmax })
    } else {
        None
    }
}

/// Calculate attack damage based on held item
fn calculate_attack_damage(tool: Option<(ToolType, ToolMaterial)>) -> f32 {
    match tool {
        Some((tool_type, material)) => {
            // Base damage varies by tool type
            let base = match tool_type {
                ToolType::Sword => 4.0,
                ToolType::Axe => 3.0,
                ToolType::Pickaxe => 2.0,
                ToolType::Shovel => 1.5,
                ToolType::Hoe => 1.0,
            };
            // Material multiplier
            let multiplier = match material {
                ToolMaterial::Wood => 1.0,
                ToolMaterial::Stone => 1.25,
                ToolMaterial::Iron => 1.5,
                ToolMaterial::Gold => 1.0, // Gold is fast but weak
                ToolMaterial::Diamond => 1.75,
            };
            base * multiplier
        }
        None => 1.0, // Fist damage
    }
}

impl PlayerPhysics {
    const GROUND_EPS: f32 = 0.001;
    /// Vanilla-ish step height. Uses a power-of-two fraction for determinism.
    const STEP_HEIGHT: f32 = 19.0 / 32.0;

    fn new() -> Self {
        Self {
            velocity: glam::Vec3::ZERO,
            on_ground: false,
            gravity: -20.0,
            jump_strength: 8.0,
            terminal_velocity: -50.0,
            player_height: 1.8,
            eye_height: 1.62,
            player_width: 0.6,
            physics_enabled: true,
            last_ground_y: 100.0, // Initial spawn height
            last_jump_press_time: 10.0,
        }
    }

    fn toggle_physics(&mut self) {
        self.physics_enabled = !self.physics_enabled;
        if !self.physics_enabled {
            self.velocity = glam::Vec3::ZERO;
            self.on_ground = false;
        }
    }

    /// Build an AABB using the camera position (eye). Feet are offset down by `eye_height`.
    fn get_aabb(&self, camera_pos: glam::Vec3) -> AABB {
        let feet = camera_pos - glam::Vec3::new(0.0, self.eye_height, 0.0);
        let size = glam::Vec3::new(self.player_width, self.player_height, self.player_width);
        let center = feet + glam::Vec3::new(0.0, self.player_height * 0.5, 0.0);
        AABB::from_center_size(center, size)
    }
}

#[derive(Debug, Default, Clone)]
struct AutomationHeldInput {
    move_x: f32,
    move_y: f32,
    move_z: f32,
    sprint: bool,
    crouch: bool,
    jump_hold: bool,
    attack_hold: bool,
    use_hold: bool,
}

#[derive(Debug, Default, Clone)]
struct AutomationPulseInput {
    jump_click: bool,
    attack_click: bool,
    use_click: bool,
    hotbar_slot: Option<u8>,
}

struct AutomationRuntime {
    rx: std::sync::mpsc::Receiver<AutomationMsg>,
    connected: bool,
    ever_connected: bool,
    held: AutomationHeldInput,
    pulses: AutomationPulseInput,
}

#[derive(Debug, Clone)]
pub struct ScreenshotConfig {
    pub dir: PathBuf,
    pub every_ticks: Option<u64>,
    pub max: Option<u64>,
}

pub struct GameWorldOptions {
    pub width: u32,
    pub height: u32,
    pub automation: Option<AutomationEndpoint>,
    pub screenshot: Option<ScreenshotConfig>,
}

impl Default for GameWorldOptions {
    fn default() -> Self {
        Self {
            width: 1280,
            height: 720,
            automation: None,
            screenshot: None,
        }
    }
}

#[derive(Debug)]
enum ScreenshotJobKind {
    Periodic,
    PeriodicEvent {
        respond_to: std::sync::mpsc::SyncSender<serde_json::Value>,
    },
    Manual {
        id: Option<protocol::RequestId>,
        respond_to: std::sync::mpsc::SyncSender<serde_json::Value>,
    },
}

#[derive(Debug)]
struct ScreenshotJob {
    kind: ScreenshotJobKind,
    tag: Option<String>,
}

struct ScreenshotRuntime {
    cfg: ScreenshotConfig,
    last_periodic_tick: Option<u64>,
    periodic_captured: u64,
    capture_texture: Option<wgpu::Texture>,
    capture_view: Option<wgpu::TextureView>,
    capture_size: (u32, u32),
    pending: std::collections::VecDeque<ScreenshotJob>,
}

impl ScreenshotRuntime {
    fn new(cfg: ScreenshotConfig, world_seed: u64, size: (u32, u32)) -> Result<Self> {
        std::fs::create_dir_all(&cfg.dir)?;
        let run_path = cfg.dir.join("run.json");
        let run_file = std::fs::File::create(&run_path)?;
        serde_json::to_writer_pretty(
            run_file,
            &serde_json::json!({
                "version": 1,
                "world_seed": world_seed,
                "width": size.0,
                "height": size.1,
                "format": "png",
                "screenshot_every_ticks": cfg.every_ticks,
                "screenshot_max": cfg.max,
            }),
        )?;
        Ok(Self {
            cfg,
            last_periodic_tick: None,
            periodic_captured: 0,
            capture_texture: None,
            capture_view: None,
            capture_size: (0, 0),
            pending: std::collections::VecDeque::new(),
        })
    }

    fn sanitize_tag(tag: &str) -> String {
        let mut out = String::new();
        for ch in tag.chars() {
            if ch.is_ascii_alphanumeric() {
                out.push(ch.to_ascii_lowercase());
            } else if ch == '-' || ch == '_' {
                out.push(ch);
            } else if ch.is_whitespace() {
                out.push('_');
            }
        }
        let out = out.trim_matches(&['-', '_'][..]).to_string();
        if out.is_empty() {
            "untagged".to_string()
        } else if out.len() > 64 {
            out.chars().take(64).collect()
        } else {
            out
        }
    }

    fn path_for(&self, tick: u64, tag: Option<&str>) -> PathBuf {
        let mut base = format!("tick_{tick:08}");
        if let Some(tag) = tag {
            base.push_str("_tag-");
            base.push_str(&Self::sanitize_tag(tag));
        }
        base.push_str(".png");
        let mut path = self.cfg.dir.join(base);
        if path.exists() {
            for idx in 1..=9999u32 {
                let mut name = format!("tick_{tick:08}_n{idx:04}");
                if let Some(tag) = tag {
                    name.push_str("_tag-");
                    name.push_str(&Self::sanitize_tag(tag));
                }
                name.push_str(".png");
                let candidate = self.cfg.dir.join(name);
                if !candidate.exists() {
                    path = candidate;
                    break;
                }
            }
        }
        path
    }
}

/// The game world state
pub struct GameWorld {
    window: Option<Arc<Window>>,
    renderer: Renderer,
    audio: AudioManager,
    chunk_manager: ChunkManager,
    chunks: HashMap<ChunkPos, Chunk>,
    registry: BlockRegistry,
    block_properties: BlockPropertiesRegistry,
    input: InputState,
    last_frame: Instant,
    debug_hud: DebugHud,
    time_of_day: TimeOfDay,
    sim_time: SimTime,
    sim_time_paused: bool,
    selected_block: Option<RaycastHit>,
    hotbar: Hotbar,
    player_physics: PlayerPhysics,
    player_health: PlayerHealth,
    chunks_visible: usize,
    mining_progress: Option<MiningProgress>,
    spawn_point: glam::Vec3,
    spawn_point_dimension: DimensionId,
    active_dimension: DimensionId,
    portal_charge_ticks: u16,
    portal_cooldown_ticks: u16,
    controls: Arc<ControlsConfig>,
    input_processor: InputProcessor,
    #[allow(dead_code)]
    actions: ActionState,
    automation: Option<AutomationRuntime>,
    screenshot: Option<ScreenshotRuntime>,
    screenshot_periodic_event_sink: Option<std::sync::mpsc::SyncSender<serde_json::Value>>,
    scripted_input: Option<ScriptedInputPlayer>,
    command_script: Option<CommandScriptPlayer>,
    particle_emitter: ParticleEmitter,
    particles: Vec<ParticleInstance>,
    weather: WeatherToggle,
    weather_next_change_tick: SimTick,
    precipitation_accumulator: f32,
    rng: StdRng,
    weather_blend: f32,
    lightning_flash_ticks: u8,
    /// Last frame delta time (seconds)
    frame_dt: f32,
    /// Current player state (alive/dead)
    player_state: PlayerState,
    /// Cause of death message for display
    death_message: String,
    /// Whether respawn was requested from death screen
    respawn_requested: bool,
    /// Whether return to menu was requested from death screen
    menu_requested: bool,
    #[cfg(feature = "ui3d_billboards")]
    billboard_renderer: Option<BillboardRenderer>,
    #[cfg(feature = "ui3d_billboards")]
    billboard_emitter: BillboardEmitter,
    /// Dropped item manager for block drops and pickups
    item_manager: ItemManager,
    /// Pack-driven loot overrides for block/mob drops.
    loot_tables: content_pack_loot::LootTables,
    /// Whether the inventory UI is open
    inventory_open: bool,
    /// Whether the villager trading UI is open.
    villager_trade_open: bool,
    /// Currently open villager identifier (if any).
    open_villager_trade_id: Option<u64>,
    /// Currently selected villager trade index.
    selected_villager_trade_idx: usize,
    /// Temporary cursor-held stack for UI drag/drop interactions.
    ui_cursor_stack: Option<ItemStack>,
    /// UI drag state for click-drag stack distribution.
    ui_drag_state: UiDragState,
    /// Main inventory storage (27 slots; excludes hotbar).
    main_inventory: MainInventory,
    /// Mob spawner for passive mobs
    #[allow(dead_code)]
    mob_spawner: MobSpawner,
    /// Active mobs in the world
    mobs: Vec<Mob>,
    /// Next stable mob identifier to assign.
    next_mob_id: u64,
    /// Fluid simulation
    fluid_sim: FluidSimulator,
    /// Redstone simulation
    redstone_sim: RedstoneSimulator,
    /// Farming simulation (crop growth + farmland hydration).
    crop_growth: CropGrowthSystem,
    /// Sugar cane growth simulation.
    sugar_cane_growth: SugarCaneGrowthSystem,
    /// Block interaction manager (doors/trapdoors/etc)
    interaction_manager: InteractionManager,
    /// Pressure plates currently pressed by any entity.
    pressed_pressure_plates: std::collections::BTreeSet<RedstonePos>,
    /// Simulation tick counter
    sim_tick: SimTick,
    /// Time accumulator for fixed timestep loop
    accumulator: f64,
    /// Region store for persistence
    region_store: RegionStore,
    /// World seed used for deterministic world generation.
    world_seed: u64,
    /// Whether the End boss has been defeated in this world.
    end_boss_defeated: bool,
    /// Terrain generator
    terrain_generator: TerrainGenerator,
    /// Render distance (chunks radius)
    render_distance: i32,
    /// Whether the crafting UI is open
    crafting_open: bool,
    /// Crafting grid (3x3)
    crafting_grid: [[Option<ItemStack>; 3]; 3],
    /// Personal crafting grid (2x2) shown in the inventory UI.
    personal_crafting_grid: [[Option<ItemStack>; 2]; 2],
    /// Whether the furnace UI is open
    furnace_open: bool,
    /// Currently open furnace position (if any)
    open_furnace_pos: Option<BlockEntityKey>,
    /// Furnace states by position
    furnaces: BTreeMap<BlockEntityKey, FurnaceState>,
    /// Whether enchanting table UI is open
    enchanting_open: bool,
    /// Currently open enchanting table position (if any)
    open_enchanting_pos: Option<BlockEntityKey>,
    /// Enchanting table states by position
    enchanting_tables: BTreeMap<BlockEntityKey, EnchantingTableState>,
    /// Player armor (helmet, chestplate, leggings, boots)
    player_armor: PlayerArmor,
    /// Projectile manager for arrows and other projectiles
    projectiles: ProjectileManager,
    /// Bow drawing state (charge progress 0.0 to 1.0)
    bow_charge: f32,
    /// Whether the bow is currently being drawn
    bow_drawing: bool,
    /// Attack cooldown timer (seconds remaining until next attack allowed)
    attack_cooldown: f32,
    /// Player experience points
    player_xp: PlayerXP,
    /// Experience orbs in the world
    xp_orbs: Vec<XPOrb>,
    /// Player status effects (potions, etc.)
    status_effects: StatusEffects,
    regeneration_timer_ticks: u8,
    poison_timer_ticks: u8,
    /// Brewing stand states by position
    brewing_stands: BTreeMap<BlockEntityKey, BrewingStandState>,
    /// Whether brewing stand UI is open
    brewing_open: bool,
    /// Currently open brewing stand position (if any)
    open_brewing_pos: Option<BlockEntityKey>,
    /// Chest inventories by position
    chests: BTreeMap<BlockEntityKey, ChestState>,
    /// Whether chest UI is open
    chest_open: bool,
    /// Currently open chest position (if any)
    open_chest_pos: Option<BlockEntityKey>,
    /// Hopper inventories by position
    hoppers: BTreeMap<BlockEntityKey, HopperState>,
    /// Whether hopper UI is open
    hopper_open: bool,
    /// Currently open hopper position (if any)
    open_hopper_pos: Option<BlockEntityKey>,
    /// Dispenser inventories by position
    dispensers: BTreeMap<BlockEntityKey, DispenserState>,
    /// Whether dispenser UI is open
    dispenser_open: bool,
    /// Currently open dispenser position (if any)
    open_dispenser_pos: Option<BlockEntityKey>,
    /// Dropper inventories by position
    droppers: BTreeMap<BlockEntityKey, DispenserState>,
    /// Whether dropper UI is open
    dropper_open: bool,
    /// Currently open dropper position (if any)
    open_dropper_pos: Option<BlockEntityKey>,

    /// Whether the in-game pause menu is open.
    pause_menu_open: bool,
    pause_menu_view: PauseMenuView,
    pause_controls_dirty: bool,
    pending_action: Option<GameAction>,

    /// Whether the command prompt is open.
    command_open: bool,
    command_focus_next_frame: bool,
    command_input: String,
    command_log: std::collections::VecDeque<String>,
}

struct DispenserTickContext<'a> {
    chunks: &'a mut HashMap<ChunkPos, Chunk>,
    crop_growth: &'a mut CropGrowthSystem,
    block_properties: &'a BlockPropertiesRegistry,
    redstone_sim: &'a mut RedstoneSimulator,
    item_manager: &'a mut ItemManager,
    fluid_sim: &'a mut FluidSimulator,
    projectiles: &'a mut ProjectileManager,
    chests: &'a mut BTreeMap<BlockEntityKey, ChestState>,
    hoppers: &'a mut BTreeMap<BlockEntityKey, HopperState>,
    dispensers: &'a mut BTreeMap<BlockEntityKey, DispenserState>,
    droppers: &'a mut BTreeMap<BlockEntityKey, DispenserState>,
}

impl GameWorld {
    #[inline(always)]
    fn flat_directions(camera: &mdminecraft_render::Camera) -> (glam::Vec3, glam::Vec3) {
        let yaw = camera.yaw;
        let forward = glam::Vec3::new(yaw.cos(), 0.0, yaw.sin()).normalize_or_zero();
        let right = glam::Vec3::new(-forward.z, 0.0, forward.x).normalize_or_zero();
        (forward, right)
    }

    fn audio_settings_from_controls(controls: &ControlsConfig) -> AudioSettings {
        AudioSettings {
            master: controls.master_volume.clamp(0.0, 1.0),
            music: controls.music_volume.clamp(0.0, 1.0),
            sfx: controls.sfx_volume.clamp(0.0, 1.0),
            ambient: controls.ambient_volume.clamp(0.0, 1.0),
            muted: controls.audio_muted,
        }
    }

    fn block_entity_key(&self, block_pos: IVec3) -> BlockEntityKey {
        BlockEntityKey {
            dimension: self.active_dimension,
            x: block_pos.x,
            y: block_pos.y,
            z: block_pos.z,
        }
    }

    fn neighbor_chunk_positions(center: ChunkPos) -> [ChunkPos; 4] {
        [
            ChunkPos::new(center.x - 1, center.z),
            ChunkPos::new(center.x + 1, center.z),
            ChunkPos::new(center.x, center.z - 1),
            ChunkPos::new(center.x, center.z + 1),
        ]
    }

    fn srgb_u8_to_linear(channel: u8) -> f32 {
        let c = channel as f32 / 255.0;
        if c <= 0.04045 {
            c / 12.92
        } else {
            ((c + 0.055) / 1.055).powf(2.4)
        }
    }

    fn biome_water_tint_at(&self, world_x: i32, world_z: i32) -> [f32; 3] {
        let biome = self
            .terrain_generator
            .biome_assigner()
            .get_blended_biome(world_x, world_z, 2);
        let water = biome.water_color;
        [
            Self::srgb_u8_to_linear(water.0),
            Self::srgb_u8_to_linear(water.1),
            Self::srgb_u8_to_linear(water.2),
        ]
    }

    fn biome_atmosphere_colors_at(
        &self,
        world_x: i32,
        world_z: i32,
    ) -> ([f32; 3], [f32; 3], [f32; 3]) {
        let biome = self
            .terrain_generator
            .biome_assigner()
            .get_blended_biome(world_x, world_z, 2);
        let sky = biome.sky_color;
        let fog = biome.fog_color;
        let water_fog = biome.water_fog_color;
        (
            [
                Self::srgb_u8_to_linear(sky.0),
                Self::srgb_u8_to_linear(sky.1),
                Self::srgb_u8_to_linear(sky.2),
            ],
            [
                Self::srgb_u8_to_linear(fog.0),
                Self::srgb_u8_to_linear(fog.1),
                Self::srgb_u8_to_linear(fog.2),
            ],
            [
                Self::srgb_u8_to_linear(water_fog.0),
                Self::srgb_u8_to_linear(water_fog.1),
                Self::srgb_u8_to_linear(water_fog.2),
            ],
        )
    }

    fn is_camera_underwater(&self, camera_pos: glam::Vec3) -> bool {
        self.fluid_at_world_pos(camera_pos) == Some(FluidType::Water)
    }

    fn fluid_at_world_pos(&self, world_pos: glam::Vec3) -> Option<FluidType> {
        let block_pos = glam::IVec3::new(
            world_pos.x.floor() as i32,
            world_pos.y.floor() as i32,
            world_pos.z.floor() as i32,
        );
        let voxel = self.get_voxel_at(block_pos)?;

        if let Some(ft) = mdminecraft_world::get_fluid_type(voxel.id) {
            return Some(ft);
        }

        if mdminecraft_world::block_supports_waterlogging(voxel.id)
            && mdminecraft_world::is_waterlogged(voxel.state)
        {
            return Some(FluidType::Water);
        }

        None
    }

    fn camera_eye_and_feet_fluids(
        &self,
        camera_pos: glam::Vec3,
    ) -> (Option<FluidType>, Option<FluidType>) {
        let feet_pos = camera_pos - glam::Vec3::new(0.0, self.player_physics.eye_height, 0.0);
        let feet_sample = feet_pos + glam::Vec3::new(0.0, 0.1, 0.0);
        (
            self.fluid_at_world_pos(camera_pos),
            self.fluid_at_world_pos(feet_sample),
        )
    }

    fn chunk_biome_tints(&self, chunk_pos: ChunkPos) -> ([f32; 3], [f32; 3], [f32; 3]) {
        let sample_x = chunk_pos.x * CHUNK_SIZE_X as i32 + (CHUNK_SIZE_X as i32 / 2);
        let sample_z = chunk_pos.z * CHUNK_SIZE_Z as i32 + (CHUNK_SIZE_Z as i32 / 2);
        let biome = self
            .terrain_generator
            .biome_assigner()
            .get_blended_biome(sample_x, sample_z, 2);
        let grass = biome.grass_color;
        let foliage = biome.foliage_color;
        let water = biome.water_color;
        (
            [
                Self::srgb_u8_to_linear(grass.0),
                Self::srgb_u8_to_linear(grass.1),
                Self::srgb_u8_to_linear(grass.2),
            ],
            [
                Self::srgb_u8_to_linear(foliage.0),
                Self::srgb_u8_to_linear(foliage.1),
                Self::srgb_u8_to_linear(foliage.2),
            ],
            [
                Self::srgb_u8_to_linear(water.0),
                Self::srgb_u8_to_linear(water.1),
                Self::srgb_u8_to_linear(water.2),
            ],
        )
    }

    fn mesh_for_chunk(&self, chunk: &Chunk) -> mdminecraft_render::MeshBuffers {
        let chunks = &self.chunks;
        let meshing_pos = chunk.position();
        let origin_x = meshing_pos.x * CHUNK_SIZE_X as i32;
        let origin_z = meshing_pos.z * CHUNK_SIZE_Z as i32;

        mesh_chunk_with_voxel_at(
            chunk,
            &self.registry,
            self.renderer.atlas_metadata(),
            |wx, wy, wz| {
                let local_y = world_y_to_local_y(wy)?;

                let chunk_x = wx.div_euclid(CHUNK_SIZE_X as i32);
                let chunk_z = wz.div_euclid(CHUNK_SIZE_Z as i32);
                let chunk_pos = ChunkPos::new(chunk_x, chunk_z);

                if chunk_pos == meshing_pos {
                    let local_x = wx - origin_x;
                    let local_z = wz - origin_z;
                    if !(0..CHUNK_SIZE_X as i32).contains(&local_x)
                        || !(0..CHUNK_SIZE_Z as i32).contains(&local_z)
                    {
                        return None;
                    }
                    return Some(chunk.voxel(local_x as usize, local_y, local_z as usize));
                }

                let chunk = chunks.get(&chunk_pos)?;
                let local_x = wx.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = wz.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                Some(chunk.voxel(local_x, local_y, local_z))
            },
        )
    }

    fn upload_chunk_mesh(&mut self, chunk_pos: ChunkPos) -> bool {
        let Some(resources) = self.renderer.render_resources() else {
            return false;
        };
        let Some(chunk) = self.chunks.get(&chunk_pos) else {
            return false;
        };

        let mesh = self.mesh_for_chunk(chunk);
        if mesh.vertices.is_empty()
            || (mesh.indices_opaque.is_empty() && mesh.indices_alpha.is_empty())
        {
            return false;
        }

        let (grass_tint, foliage_tint, water_tint) = self.chunk_biome_tints(chunk_pos);
        let chunk_uniform = mdminecraft_render::ChunkUniform::from_chunk_pos_with_tints(
            chunk_pos,
            grass_tint,
            foliage_tint,
            water_tint,
        );
        let chunk_bind_group = resources
            .pipeline
            .create_chunk_bind_group_with_uniform(resources.device, chunk_uniform);
        self.chunk_manager.add_chunk(
            resources.device,
            resources.queue,
            &mesh,
            chunk_pos,
            chunk_bind_group,
        );
        true
    }

    fn upload_chunk_mesh_and_neighbors(&mut self, chunk_pos: ChunkPos) -> u32 {
        let mut uploads = 0u32;
        if self.upload_chunk_mesh(chunk_pos) {
            uploads += 1;
        }
        for neighbor in Self::neighbor_chunk_positions(chunk_pos) {
            if self.upload_chunk_mesh(neighbor) {
                uploads += 1;
            }
        }
        uploads
    }
    /// Create a new game world
    pub fn new(
        event_loop: &EventLoopWindowTarget<()>,
        controls: Arc<ControlsConfig>,
        scripted_input_path: Option<PathBuf>,
        command_script_path: Option<PathBuf>,
        options: GameWorldOptions,
    ) -> Result<Self> {
        tracing::info!("Initializing game world...");

        let GameWorldOptions {
            width,
            height,
            automation,
            screenshot,
        } = options;

        // Create window
        let window_config = WindowConfig {
            title: "mdminecraft - Game".to_string(),
            width,
            height,
            vsync: true,
        };

        let window_manager = WindowManager::new_with_event_loop(window_config, event_loop)?;
        let window = window_manager.into_window();

        // Create renderer
        let renderer_config = RendererConfig {
            width,
            height,
            headless: false,
        };
        let mut renderer = Renderer::new(renderer_config);

        // Initialize GPU
        pollster::block_on(renderer.initialize_gpu(window.clone()))?;
        #[cfg(feature = "ui3d_billboards")]
        let billboard_renderer = {
            let resources = renderer.render_resources().expect("GPU not initialized");
            let format = renderer
                .surface_format()
                .unwrap_or(wgpu::TextureFormat::Bgra8UnormSrgb);
            match BillboardRenderer::new(
                resources.device,
                format,
                resources.pipeline.camera_bind_group_layout(),
                resources.pipeline.atlas_view(),
                resources.pipeline.atlas_sampler(),
            ) {
                Ok(r) => Some(r),
                Err(err) => {
                    tracing::warn!(?err, "Failed to initialize billboard renderer");
                    None
                }
            }
        };

        // Load block registry
        let registry = load_block_registry();

        // Setup persistence and generator
        let save_path = PathBuf::from("saves/default");
        let region_store = RegionStore::new(&save_path).unwrap_or_else(|_| {
            tracing::warn!("Failed to create save directory, using temporary");
            RegionStore::new(std::env::temp_dir().join("mdminecraft_save")).unwrap()
        });

        let (world_seed, end_boss_defeated, loaded_state) = {
            let meta = if region_store.world_meta_exists() {
                match region_store.load_world_meta() {
                    Ok(meta) => meta,
                    Err(err) => {
                        tracing::warn!(?err, "Failed to load world meta; generating new seed");
                        WorldMeta {
                            world_seed: rand::random(),
                            end_boss_defeated: false,
                        }
                    }
                }
            } else {
                let world_seed = std::env::var("MDM_WORLD_SEED")
                    .ok()
                    .and_then(|raw| raw.parse::<u64>().ok())
                    .unwrap_or_else(rand::random);

                let meta = WorldMeta {
                    world_seed,
                    end_boss_defeated: false,
                };
                if let Err(err) = region_store.save_world_meta(&meta) {
                    tracing::warn!(?err, "Failed to save world meta");
                }
                meta
            };

            let state = if region_store.world_state_exists() {
                match region_store.load_world_state() {
                    Ok(state) => Some(state),
                    Err(err) => {
                        tracing::warn!(?err, "Failed to load world state; starting fresh");
                        None
                    }
                }
            } else {
                None
            };

            (meta.world_seed, meta.end_boss_defeated, state)
        };

        tracing::info!("World Seed: {}", world_seed);
        let terrain_generator = TerrainGenerator::new(world_seed);
        let render_distance = controls.render_distance.clamp(2, 16);

        let chunk_manager = ChunkManager::new();
        let chunks = HashMap::new();
        let rng = StdRng::seed_from_u64(world_seed ^ 0x5eed_a11c);

        let mut sim_tick = SimTick::ZERO;
        let mut sim_time = SimTime::default();
        let mut weather = WeatherToggle::new();
        let mut loaded_player: Option<PlayerSave> = None;
        let mut loaded_entities = WorldEntitiesState::default();
        let mut loaded_block_entities = BlockEntitiesState::default();
        let weather_next_change_tick = if let Some(state) = loaded_state {
            sim_tick = state.tick;
            sim_time = state.sim_time;
            weather = state.weather;
            loaded_player = state.player;
            loaded_entities = state.entities;
            loaded_block_entities = state.block_entities;
            state.weather_next_change_tick
        } else {
            // Deterministic initial schedule (based on seed + tick).
            let delay_ticks = Self::weather_delay_ticks(
                world_seed,
                sim_tick,
                900..2400, // 45..120 seconds at 20 TPS
                0xC0FFEE_u64,
            );
            sim_tick.advance(delay_ticks)
        };

        let initial_dimension = loaded_player
            .as_ref()
            .map(|player| player.transform.dimension)
            .unwrap_or(DimensionId::DEFAULT);
        let initial_spawn_dimension = loaded_player
            .as_ref()
            .map(|player| player.spawn_point.dimension)
            .unwrap_or(DimensionId::DEFAULT);

        if let Some(player) = &loaded_player {
            renderer.camera_mut().position = glam::Vec3::new(
                player.transform.x as f32,
                player.transform.y as f32,
                player.transform.z as f32,
            );
            renderer.camera_mut().yaw = player.transform.yaw;
            renderer.camera_mut().pitch = player.transform.pitch;
        } else {
            renderer.camera_mut().position = glam::Vec3::new(0.0, 100.0, 0.0);
            renderer.camera_mut().yaw = 0.0;
            renderer.camera_mut().pitch = -0.3;
        }

        renderer.camera_mut().fov = controls.fov_degrees.clamp(30.0, 150.0).to_radians();

        let mut audio = AudioManager::new()?;
        audio.update_settings(Self::audio_settings_from_controls(controls.as_ref()));
        let camera_pos = renderer.camera().position;
        audio.set_listener_position([camera_pos.x, camera_pos.y, camera_pos.z]);

        let spawn_table = content_pack_spawns::load_mob_spawn_table_lenient(Path::new(
            content_packs::CONTENT_PACKS_DIR,
        ));
        let loot_tables = content_pack_loot::load_loot_tables_lenient(
            Path::new(content_packs::CONTENT_PACKS_DIR),
            &registry,
        );
        let mob_spawner = MobSpawner::new_with_spawn_table(world_seed, spawn_table);
        let WorldEntitiesState {
            mobs,
            dropped_items,
            projectiles,
        } = loaded_entities;
        let mut mobs = mobs;
        let mut next_mob_id = mobs
            .iter()
            .map(|mob| mob.id)
            .max()
            .unwrap_or(0)
            .saturating_add(1)
            .max(1);
        for mob in &mut mobs {
            if mob.id == 0 {
                mob.id = next_mob_id;
                next_mob_id = next_mob_id.saturating_add(1).max(1);
            }
        }
        let furnaces = loaded_block_entities.furnaces;
        let enchanting_tables = loaded_block_entities.enchanting_tables;
        let brewing_stands = loaded_block_entities.brewing_stands;
        let chests = loaded_block_entities.chests;
        let hoppers = loaded_block_entities.hoppers;
        let dispensers = loaded_block_entities.dispensers;
        let droppers = loaded_block_entities.droppers;

        // Setup state
        let debug_hud = DebugHud::new(); // Zeroed by default

        let input = InputState::new();
        let input_processor = InputProcessor::new(&controls);
        let scripted_input = scripted_input_path
            .as_ref()
            .map(|path| ScriptedInputPlayer::from_path(path))
            .transpose()?;
        let command_script = command_script_path
            .as_ref()
            .map(|path| CommandScriptPlayer::from_path(path))
            .transpose()?;

        let screenshot = match screenshot {
            Some(cfg) => Some(ScreenshotRuntime::new(cfg, world_seed, (width, height))?),
            None => None,
        };

        let mut world = Self {
            window: Some(window),
            renderer,
            audio,
            chunk_manager,
            chunks,
            registry,
            block_properties: BlockPropertiesRegistry::new(),
            input,
            last_frame: Instant::now(),
            debug_hud,
            time_of_day: TimeOfDay::new(),
            sim_time,
            sim_time_paused: false,
            selected_block: None,
            hotbar: Hotbar::new(),
            player_physics: PlayerPhysics::new(),
            player_health: PlayerHealth::new(),
            chunks_visible: 0,
            mining_progress: None,
            spawn_point: glam::Vec3::ZERO, // Temp
            spawn_point_dimension: initial_spawn_dimension,
            active_dimension: initial_dimension,
            portal_charge_ticks: 0,
            portal_cooldown_ticks: 0,
            controls,
            input_processor,
            actions: ActionState::default(),
            automation: automation.map(|AutomationEndpoint { rx }| AutomationRuntime {
                rx,
                connected: false,
                ever_connected: false,
                held: AutomationHeldInput::default(),
                pulses: AutomationPulseInput::default(),
            }),
            screenshot,
            screenshot_periodic_event_sink: None,
            scripted_input,
            command_script,
            particle_emitter: ParticleEmitter::new(),
            particles: Vec::new(),
            weather,
            weather_next_change_tick,
            precipitation_accumulator: 0.0,
            rng,
            weather_blend: 0.0,
            lightning_flash_ticks: 0,
            frame_dt: 0.0,
            player_state: PlayerState::Alive,
            death_message: String::new(),
            respawn_requested: false,
            menu_requested: false,
            #[cfg(feature = "ui3d_billboards")]
            billboard_renderer,
            #[cfg(feature = "ui3d_billboards")]
            billboard_emitter: BillboardEmitter::default(),
            item_manager: dropped_items,
            loot_tables,
            inventory_open: false,
            villager_trade_open: false,
            open_villager_trade_id: None,
            selected_villager_trade_idx: 0,
            ui_cursor_stack: None,
            ui_drag_state: UiDragState::default(),
            main_inventory: MainInventory::new(),
            mob_spawner,
            mobs,
            next_mob_id,
            fluid_sim: FluidSimulator::new(),
            redstone_sim: RedstoneSimulator::new(),
            crop_growth: CropGrowthSystem::new(world_seed),
            sugar_cane_growth: SugarCaneGrowthSystem::new(world_seed),
            interaction_manager: InteractionManager::new(),
            pressed_pressure_plates: std::collections::BTreeSet::new(),
            sim_tick,
            accumulator: 0.0,
            crafting_open: false,
            crafting_grid: Default::default(),
            personal_crafting_grid: Default::default(),
            furnace_open: false,
            open_furnace_pos: None,
            furnaces,
            enchanting_open: false,
            open_enchanting_pos: None,
            enchanting_tables,
            player_armor: PlayerArmor::new(),
            projectiles,
            bow_charge: 0.0,
            bow_drawing: false,
            attack_cooldown: 0.0,
            player_xp: PlayerXP::new(),
            xp_orbs: Vec::new(),
            status_effects: StatusEffects::new(),
            regeneration_timer_ticks: 0,
            poison_timer_ticks: 0,
            brewing_stands,
            brewing_open: false,
            open_brewing_pos: None,
            chests,
            chest_open: false,
            open_chest_pos: None,
            hoppers,
            hopper_open: false,
            open_hopper_pos: None,
            dispensers,
            droppers,
            dispenser_open: false,
            open_dispenser_pos: None,
            dropper_open: false,
            open_dropper_pos: None,
            pause_menu_open: false,
            pause_menu_view: PauseMenuView::Main,
            pause_controls_dirty: false,
            pending_action: None,

            command_open: false,
            command_focus_next_frame: false,
            command_input: String::new(),
            command_log: std::collections::VecDeque::new(),

            // New fields
            region_store,
            world_seed,
            end_boss_defeated,
            terrain_generator,
            render_distance,
        };

        world
            .time_of_day
            .set_time(world.sim_time.time_of_day() as f32);

        // Initial chunk load (bounded): keep startup responsive for automation.
        // Further chunk loading continues during ticks via `fixed_update()` (which calls
        // `update_chunks(1)`).
        world.update_chunks(8);

        let has_loaded_player = loaded_player.is_some();
        let spawn_test_mobs = std::env::var("MDM_DEBUG_SPAWN_TEST_MOBS")
            .ok()
            .is_some_and(|value| value == "1");

        // Spawn passive mobs only for brand-new worlds.
        if !has_loaded_player && world.mobs.is_empty() {
            let mut positions: Vec<_> = world.chunks.keys().copied().collect();
            positions.sort();

            for pos in positions {
                let Some(chunk) = world.chunks.get(&pos) else {
                    continue;
                };
                let chunk_center_x = pos.x * CHUNK_SIZE_X as i32 + CHUNK_SIZE_X as i32 / 2;
                let chunk_center_z = pos.z * CHUNK_SIZE_Z as i32 + CHUNK_SIZE_Z as i32 / 2;
                let biome = world
                    .terrain_generator
                    .biome_assigner()
                    .get_biome(chunk_center_x, chunk_center_z);

                let mut surface_heights = [[0i32; CHUNK_SIZE_X]; CHUNK_SIZE_Z];
                for (local_z, row) in surface_heights.iter_mut().enumerate() {
                    for (local_x, height) in row.iter_mut().enumerate() {
                        for y in (0..CHUNK_SIZE_Y).rev() {
                            let voxel = chunk.voxel(local_x, y, local_z);
                            if voxel.id != BLOCK_AIR {
                                *height = local_y_to_world_y(y);
                                break;
                            }
                        }
                    }
                }

                let mut new_mobs =
                    world
                        .mob_spawner
                        .generate_spawns(pos.x, pos.z, biome, &surface_heights);
                for mob in &mut new_mobs {
                    mob.dimension = world.active_dimension;
                }
                world.assign_mob_ids(&mut new_mobs);
                world.mobs.append(&mut new_mobs);
            }
        }

        if let Some(save) = loaded_player {
            world.apply_player_save(save);
        } else {
            // Determine spawn point
            let spawn_feet = Self::determine_spawn_point(&world.chunks, &world.block_properties)
                .unwrap_or_else(|| glam::Vec3::new(0.0, 100.0, 0.0));
            world.spawn_point = spawn_feet;

            // Setup camera
            world.renderer.camera_mut().position =
                spawn_feet + glam::Vec3::new(0.0, PlayerPhysics::new().eye_height, 0.0);
            world.renderer.camera_mut().yaw = 0.0;
            world.renderer.camera_mut().pitch = -0.3;
            world.player_physics.last_ground_y = spawn_feet.y;

            // Optional debug mob spawn for visibility testing.
            if spawn_test_mobs {
                let test_mob_types = [
                    MobType::Pig,
                    MobType::Cow,
                    MobType::Sheep,
                    MobType::Chicken,
                    MobType::Villager,
                ];
                for (i, mob_type) in test_mob_types.iter().enumerate() {
                    let angle = (i as f32) * std::f32::consts::TAU / test_mob_types.len() as f32;
                    let distance = 8.0; // 8 blocks away from player
                    let mob_x = spawn_feet.x as f64 + (angle.cos() * distance) as f64;
                    let mob_z = spawn_feet.z as f64 + (angle.sin() * distance) as f64;
                    let mob_y = spawn_feet.y as f64 + 1.0; // Spawn at player's ground level + 1

                    let mut mob = Mob::new(mob_x, mob_y, mob_z, *mob_type);
                    mob.dimension = world.active_dimension;
                    world.assign_mob_id(&mut mob);
                    world.mobs.push(mob);
                }
            }
        }

        if let Some(window) = world.window.as_ref() {
            let _ = world.input.enter_gameplay(window);
        } else {
            world.input.context = InputContext::Gameplay;
            world.input.cursor_captured = true;
        }

        Ok(world)
    }

    #[allow(clippy::too_many_arguments)]
    pub fn new_headless(
        controls: Arc<ControlsConfig>,
        scripted_input_path: Option<PathBuf>,
        command_script_path: Option<PathBuf>,
        options: GameWorldOptions,
        save_path: PathBuf,
        world_seed_override: Option<u64>,
        no_render: bool,
        no_audio: bool,
    ) -> Result<Self> {
        tracing::info!("Initializing headless game world...");

        let GameWorldOptions {
            width,
            height,
            automation,
            screenshot,
        } = options;

        let renderer_config = RendererConfig {
            width,
            height,
            headless: true,
        };
        let mut renderer = Renderer::new(renderer_config);
        if !no_render {
            pollster::block_on(renderer.initialize_gpu_headless())?;
        }

        #[cfg(feature = "ui3d_billboards")]
        let billboard_renderer = None;

        // Load block registry
        let registry = load_block_registry();

        // Setup persistence and generator
        let region_store = RegionStore::new(&save_path).unwrap_or_else(|_| {
            tracing::warn!("Failed to create region store, using memory-only world");
            RegionStore::new(&save_path).expect("Failed to create region store")
        });

        let (world_seed, end_boss_defeated, loaded_state) = {
            if region_store.world_meta_exists() {
                let meta = match region_store.load_world_meta() {
                    Ok(meta) => meta,
                    Err(err) => {
                        tracing::warn!(?err, "Failed to load world meta; starting fresh");
                        WorldMeta {
                            world_seed: world_seed_override.unwrap_or_else(rand::random),
                            end_boss_defeated: false,
                        }
                    }
                };

                if let Some(expected_seed) = world_seed_override {
                    if meta.world_seed != expected_seed {
                        anyhow::bail!(
                            "save dir seed mismatch: save has {}, requested {} (use --reset-world)",
                            meta.world_seed,
                            expected_seed
                        );
                    }
                }

                let state = if region_store.world_state_exists() {
                    match region_store.load_world_state() {
                        Ok(state) => Some(state),
                        Err(err) => {
                            tracing::warn!(?err, "Failed to load world state; starting fresh");
                            None
                        }
                    }
                } else {
                    None
                };

                (meta.world_seed, meta.end_boss_defeated, state)
            } else {
                let world_seed = world_seed_override
                    .or_else(|| {
                        std::env::var("MDM_WORLD_SEED")
                            .ok()
                            .and_then(|raw| raw.parse::<u64>().ok())
                    })
                    .unwrap_or_else(rand::random);

                let meta = WorldMeta {
                    world_seed,
                    end_boss_defeated: false,
                };
                if let Err(err) = region_store.save_world_meta(&meta) {
                    tracing::warn!(?err, "Failed to save world meta");
                }

                let state = if region_store.world_state_exists() {
                    match region_store.load_world_state() {
                        Ok(state) => Some(state),
                        Err(err) => {
                            tracing::warn!(?err, "Failed to load world state; starting fresh");
                            None
                        }
                    }
                } else {
                    None
                };

                (world_seed, meta.end_boss_defeated, state)
            }
        };

        tracing::info!("World Seed: {}", world_seed);
        let terrain_generator = TerrainGenerator::new(world_seed);
        let render_distance = controls.render_distance.clamp(2, 16);

        let chunk_manager = ChunkManager::new();
        let chunks = HashMap::new();
        let rng = StdRng::seed_from_u64(world_seed ^ 0x5eed_a11c);

        let mut sim_tick = SimTick::ZERO;
        let mut sim_time = SimTime::default();
        let mut weather = WeatherToggle::new();
        let mut loaded_player: Option<PlayerSave> = None;
        let mut loaded_entities = WorldEntitiesState::default();
        let mut loaded_block_entities = BlockEntitiesState::default();
        let weather_next_change_tick = if let Some(state) = loaded_state {
            sim_tick = state.tick;
            sim_time = state.sim_time;
            weather = state.weather;
            loaded_player = state.player;
            loaded_entities = state.entities;
            loaded_block_entities = state.block_entities;
            state.weather_next_change_tick
        } else {
            // Deterministic initial schedule (based on seed + tick).
            let delay_ticks = Self::weather_delay_ticks(
                world_seed,
                sim_tick,
                900..2400, // 45..120 seconds at 20 TPS
                0xC0FFEE_u64,
            );
            sim_tick.advance(delay_ticks)
        };

        let initial_dimension = loaded_player
            .as_ref()
            .map(|player| player.transform.dimension)
            .unwrap_or(DimensionId::DEFAULT);
        let initial_spawn_dimension = loaded_player
            .as_ref()
            .map(|player| player.spawn_point.dimension)
            .unwrap_or(DimensionId::DEFAULT);

        if let Some(player) = &loaded_player {
            renderer.camera_mut().position = glam::Vec3::new(
                player.transform.x as f32,
                player.transform.y as f32,
                player.transform.z as f32,
            );
            renderer.camera_mut().yaw = player.transform.yaw;
            renderer.camera_mut().pitch = player.transform.pitch;
        } else {
            renderer.camera_mut().position = glam::Vec3::new(0.0, 100.0, 0.0);
            renderer.camera_mut().yaw = 0.0;
            renderer.camera_mut().pitch = -0.3;
        }

        renderer.camera_mut().fov = controls.fov_degrees.clamp(30.0, 150.0).to_radians();

        let mut audio = if no_audio {
            AudioManager::stub()
        } else {
            match AudioManager::new() {
                Ok(audio) => audio,
                Err(err) => {
                    tracing::warn!(%err, "Audio initialization failed; using stub");
                    AudioManager::stub()
                }
            }
        };
        audio.update_settings(Self::audio_settings_from_controls(controls.as_ref()));
        let camera_pos = renderer.camera().position;
        audio.set_listener_position([camera_pos.x, camera_pos.y, camera_pos.z]);

        let spawn_table = content_pack_spawns::load_mob_spawn_table_lenient(Path::new(
            content_packs::CONTENT_PACKS_DIR,
        ));
        let loot_tables = content_pack_loot::load_loot_tables_lenient(
            Path::new(content_packs::CONTENT_PACKS_DIR),
            &registry,
        );
        let mob_spawner = MobSpawner::new_with_spawn_table(world_seed, spawn_table);
        let WorldEntitiesState {
            mobs,
            dropped_items,
            projectiles,
        } = loaded_entities;
        let mut mobs = mobs;
        let mut next_mob_id = mobs
            .iter()
            .map(|mob| mob.id)
            .max()
            .unwrap_or(0)
            .saturating_add(1)
            .max(1);
        for mob in &mut mobs {
            if mob.id == 0 {
                mob.id = next_mob_id;
                next_mob_id = next_mob_id.saturating_add(1).max(1);
            }
        }
        let furnaces = loaded_block_entities.furnaces;
        let enchanting_tables = loaded_block_entities.enchanting_tables;
        let brewing_stands = loaded_block_entities.brewing_stands;
        let chests = loaded_block_entities.chests;
        let hoppers = loaded_block_entities.hoppers;
        let dispensers = loaded_block_entities.dispensers;
        let droppers = loaded_block_entities.droppers;

        // Setup state
        let debug_hud = DebugHud::new(); // Zeroed by default

        let input = InputState::new();
        let input_processor = InputProcessor::new(&controls);
        let scripted_input = scripted_input_path
            .as_ref()
            .map(|path| ScriptedInputPlayer::from_path(path))
            .transpose()?;
        let command_script = command_script_path
            .as_ref()
            .map(|path| CommandScriptPlayer::from_path(path))
            .transpose()?;

        let screenshot = match screenshot {
            Some(cfg) => Some(ScreenshotRuntime::new(cfg, world_seed, (width, height))?),
            None => None,
        };

        let mut world = Self {
            window: None,
            renderer,
            audio,
            chunk_manager,
            chunks,
            registry,
            block_properties: BlockPropertiesRegistry::new(),
            input,
            last_frame: Instant::now(),
            debug_hud,
            time_of_day: TimeOfDay::new(),
            sim_time,
            sim_time_paused: false,
            selected_block: None,
            hotbar: Hotbar::new(),
            player_physics: PlayerPhysics::new(),
            player_health: PlayerHealth::new(),
            chunks_visible: 0,
            mining_progress: None,
            spawn_point: glam::Vec3::ZERO, // Temp
            spawn_point_dimension: initial_spawn_dimension,
            active_dimension: initial_dimension,
            portal_charge_ticks: 0,
            portal_cooldown_ticks: 0,
            controls,
            input_processor,
            actions: ActionState::default(),
            automation: automation.map(|AutomationEndpoint { rx }| AutomationRuntime {
                rx,
                connected: false,
                ever_connected: false,
                held: AutomationHeldInput::default(),
                pulses: AutomationPulseInput::default(),
            }),
            screenshot,
            screenshot_periodic_event_sink: None,
            scripted_input,
            command_script,
            particle_emitter: ParticleEmitter::new(),
            particles: Vec::new(),
            weather,
            weather_next_change_tick,
            precipitation_accumulator: 0.0,
            rng,
            weather_blend: 0.0,
            lightning_flash_ticks: 0,
            frame_dt: 0.0,
            player_state: PlayerState::Alive,
            death_message: String::new(),
            respawn_requested: false,
            menu_requested: false,
            #[cfg(feature = "ui3d_billboards")]
            billboard_renderer,
            #[cfg(feature = "ui3d_billboards")]
            billboard_emitter: BillboardEmitter::default(),
            item_manager: dropped_items,
            loot_tables,
            inventory_open: false,
            villager_trade_open: false,
            open_villager_trade_id: None,
            selected_villager_trade_idx: 0,
            ui_cursor_stack: None,
            ui_drag_state: UiDragState::default(),
            main_inventory: MainInventory::new(),
            mob_spawner,
            mobs,
            next_mob_id,
            fluid_sim: FluidSimulator::new(),
            redstone_sim: RedstoneSimulator::new(),
            crop_growth: CropGrowthSystem::new(world_seed),
            sugar_cane_growth: SugarCaneGrowthSystem::new(world_seed),
            interaction_manager: InteractionManager::new(),
            pressed_pressure_plates: std::collections::BTreeSet::new(),
            sim_tick,
            accumulator: 0.0,
            crafting_open: false,
            crafting_grid: Default::default(),
            personal_crafting_grid: Default::default(),
            furnace_open: false,
            open_furnace_pos: None,
            furnaces,
            enchanting_open: false,
            open_enchanting_pos: None,
            enchanting_tables,
            player_armor: PlayerArmor::new(),
            projectiles,
            bow_charge: 0.0,
            bow_drawing: false,
            attack_cooldown: 0.0,
            player_xp: PlayerXP::new(),
            xp_orbs: Vec::new(),
            status_effects: StatusEffects::new(),
            regeneration_timer_ticks: 0,
            poison_timer_ticks: 0,
            brewing_stands,
            brewing_open: false,
            open_brewing_pos: None,
            chests,
            chest_open: false,
            open_chest_pos: None,
            hoppers,
            hopper_open: false,
            open_hopper_pos: None,
            dispensers,
            droppers,
            dispenser_open: false,
            open_dispenser_pos: None,
            dropper_open: false,
            open_dropper_pos: None,
            pause_menu_open: false,
            pause_menu_view: PauseMenuView::Main,
            pause_controls_dirty: false,
            pending_action: None,

            command_open: false,
            command_focus_next_frame: false,
            command_input: String::new(),
            command_log: std::collections::VecDeque::new(),

            region_store,
            world_seed,
            end_boss_defeated,
            terrain_generator,
            render_distance,
        };

        world
            .time_of_day
            .set_time(world.sim_time.time_of_day() as f32);

        // Initial chunk load (bounded): keep startup responsive for automation.
        // Further chunk loading continues during ticks via `fixed_update()` (which calls
        // `update_chunks(1)`).
        world.update_chunks(8);

        let has_loaded_player = loaded_player.is_some();

        // Spawn passive mobs only for brand-new worlds.
        if !has_loaded_player && world.mobs.is_empty() {
            let mut positions: Vec<_> = world.chunks.keys().copied().collect();
            positions.sort();

            for pos in positions {
                let Some(chunk) = world.chunks.get(&pos) else {
                    continue;
                };
                let chunk_center_x = pos.x * CHUNK_SIZE_X as i32 + CHUNK_SIZE_X as i32 / 2;
                let chunk_center_z = pos.z * CHUNK_SIZE_Z as i32 + CHUNK_SIZE_Z as i32 / 2;
                let biome = world
                    .terrain_generator
                    .biome_assigner()
                    .get_biome(chunk_center_x, chunk_center_z);

                let mut surface_heights = [[0i32; CHUNK_SIZE_X]; CHUNK_SIZE_Z];
                for (local_z, row) in surface_heights.iter_mut().enumerate() {
                    for (local_x, height) in row.iter_mut().enumerate() {
                        for y in (0..CHUNK_SIZE_Y).rev() {
                            let voxel = chunk.voxel(local_x, y, local_z);
                            if voxel.id != BLOCK_AIR {
                                *height = local_y_to_world_y(y);
                                break;
                            }
                        }
                    }
                }

                let mut new_mobs =
                    world
                        .mob_spawner
                        .generate_spawns(pos.x, pos.z, biome, &surface_heights);
                for mob in &mut new_mobs {
                    mob.dimension = world.active_dimension;
                }
                world.assign_mob_ids(&mut new_mobs);
                world.mobs.append(&mut new_mobs);
            }
        }

        if let Some(save) = loaded_player {
            world.apply_player_save(save);
        } else {
            // Determine spawn point
            let spawn_feet = Self::determine_spawn_point(&world.chunks, &world.block_properties)
                .unwrap_or_else(|| glam::Vec3::new(0.0, 100.0, 0.0));
            world.spawn_point = spawn_feet;

            // Setup camera
            world.renderer.camera_mut().position =
                spawn_feet + glam::Vec3::new(0.0, PlayerPhysics::new().eye_height, 0.0);
            world.renderer.camera_mut().yaw = 0.0;
            world.renderer.camera_mut().pitch = -0.3;
            world.player_physics.last_ground_y = spawn_feet.y;
        }

        world.enter_gameplay();

        Ok(world)
    }

    /// Advance the simulation by exactly one deterministic tick (20 TPS) using the current input
    /// state (automation or scripted input).
    ///
    /// This is used by the headless automation harness and intentionally does not depend on
    /// wall-clock time.
    pub fn automation_tick(&mut self) {
        let dt = TICK_RATE as f32;
        self.frame_dt = dt;

        self.apply_automation_input();
        self.process_actions(dt);

        // Update camera from input (only if alive)
        if self.player_state == PlayerState::Alive {
            self.update_camera(dt);
        }

        // Raycast for block selection (only if alive)
        if self.input.cursor_captured && self.player_state == PlayerState::Alive {
            let camera = self.renderer.camera();
            let ray_origin = camera.position;
            let ray_dir = camera.forward();

            self.selected_block = raycast(ray_origin, ray_dir, 8.0, |block_pos| {
                let chunk_x = block_pos.x.div_euclid(16);
                let chunk_z = block_pos.z.div_euclid(16);
                let local_x = block_pos.x.rem_euclid(16) as usize;
                let Some(local_y) = world_y_to_local_y(block_pos.y) else {
                    return false;
                };
                let local_z = block_pos.z.rem_euclid(16) as usize;

                if let Some(chunk) = self.chunks.get(&ChunkPos::new(chunk_x, chunk_z)) {
                    let voxel = chunk.voxel(local_x, local_y, local_z);
                    voxel.id != BLOCK_AIR
                } else {
                    false
                }
            });

            // Handle block breaking/placing
            self.handle_block_interaction(dt);
        } else {
            self.selected_block = None;
        }

        // Advance deterministic sim state.
        self.fixed_update();

        // Sync visual time-of-day from deterministic simulation time for rendering/snapshots.
        self.time_of_day
            .set_time(self.sim_time.time_of_day() as f32);

        // Update visual-only effects at a fixed rate so screenshots are stable.
        self.update_weather(dt);
        self.update_particles(dt);
    }

    pub fn run_headless_free(
        &mut self,
        max_ticks: Option<u64>,
        exit_when_script_finished: bool,
        exit_when_disconnected: bool,
    ) -> Result<()> {
        tracing::info!(
            max_ticks = ?max_ticks,
            exit_when_script_finished,
            exit_when_disconnected,
            "Starting headless free-run"
        );

        let script_was_loaded = self.command_script.is_some();
        loop {
            self.process_automation_messages();

            if exit_when_script_finished && script_was_loaded && self.command_script.is_none() {
                tracing::info!("Command script finished; exiting");
                break;
            }

            if exit_when_disconnected
                && self
                    .automation
                    .as_ref()
                    .is_some_and(|rt| rt.ever_connected && !rt.connected)
            {
                tracing::info!("Automation controller disconnected; exiting");
                break;
            }

            if let Some(max) = max_ticks {
                if self.sim_tick.0 >= max {
                    tracing::info!(tick = self.sim_tick.0, max_ticks = max, "Reached max ticks");
                    break;
                }
            }

            if let Some(action) = self.pending_action.take() {
                if matches!(action, GameAction::Quit | GameAction::ReturnToMenu) {
                    break;
                }
            }

            self.automation_tick();

            if self.headless_should_render() {
                self.render();
            }
        }

        self.persist_world();
        Ok(())
    }

    pub fn run_headless_step(
        &mut self,
        max_ticks: Option<u64>,
        exit_when_script_finished: bool,
        exit_when_disconnected: bool,
    ) -> Result<()> {
        tracing::info!(
            max_ticks = ?max_ticks,
            exit_when_script_finished,
            exit_when_disconnected,
            "Starting headless step mode"
        );

        if self.automation.is_none() {
            anyhow::bail!("headless step mode requires automation control (--automation-listen or --automation-uds)");
        }

        let script_was_loaded = self.command_script.is_some();
        loop {
            if exit_when_script_finished && script_was_loaded && self.command_script.is_none() {
                tracing::info!("Command script finished; exiting");
                break;
            }

            if exit_when_disconnected
                && self
                    .automation
                    .as_ref()
                    .is_some_and(|rt| rt.ever_connected && !rt.connected)
            {
                tracing::info!("Automation controller disconnected; exiting");
                break;
            }

            if let Some(max) = max_ticks {
                if self.sim_tick.0 >= max {
                    tracing::info!(tick = self.sim_tick.0, max_ticks = max, "Reached max ticks");
                    break;
                }
            }

            if let Some(action) = self.pending_action.take() {
                if matches!(action, GameAction::Quit | GameAction::ReturnToMenu) {
                    break;
                }
            }

            let msg = {
                let runtime = self
                    .automation
                    .as_ref()
                    .expect("checked automation presence");
                runtime.rx.recv()
            };

            let msg = match msg {
                Ok(msg) => msg,
                Err(_) => {
                    tracing::info!("Automation channel closed; exiting");
                    break;
                }
            };

            match msg {
                AutomationMsg::Connected => {
                    if let Some(runtime) = self.automation.as_mut() {
                        runtime.connected = true;
                        runtime.ever_connected = true;
                        runtime.held = AutomationHeldInput::default();
                        runtime.pulses = AutomationPulseInput::default();
                    }
                }
                AutomationMsg::Disconnected => {
                    if let Some(runtime) = self.automation.as_mut() {
                        runtime.connected = false;
                        runtime.held = AutomationHeldInput::default();
                        runtime.pulses = AutomationPulseInput::default();
                    }
                }
                AutomationMsg::Request {
                    request,
                    respond_to,
                } => {
                    self.handle_headless_automation_request(
                        request,
                        respond_to,
                        max_ticks,
                        exit_when_disconnected,
                    )?;
                }
            }
        }

        self.persist_world();
        Ok(())
    }

    fn headless_should_render(&self) -> bool {
        if self.renderer.device().is_none() {
            return false;
        }

        let Some(runtime) = self.screenshot.as_ref() else {
            return false;
        };

        if !runtime.pending.is_empty() {
            return true;
        }

        if let Some(every) = runtime.cfg.every_ticks {
            let periodic_allowed = runtime
                .cfg
                .max
                .map(|max| runtime.periodic_captured < max)
                .unwrap_or(true);
            if periodic_allowed
                && every > 0
                && self.sim_tick.0.is_multiple_of(every)
                && runtime.last_periodic_tick != Some(self.sim_tick.0)
            {
                return true;
            }
        }

        false
    }

    fn handle_headless_automation_request(
        &mut self,
        request: protocol::Request,
        respond_to: std::sync::mpsc::SyncSender<serde_json::Value>,
        max_ticks: Option<u64>,
        exit_when_disconnected: bool,
    ) -> Result<()> {
        match request {
            protocol::Request::SetActions(req) => {
                if let Some(runtime) = self.automation.as_mut() {
                    if let Some(value) = req.actions.move_x {
                        runtime.held.move_x = value.clamp(-1.0, 1.0);
                    }
                    if let Some(value) = req.actions.move_y {
                        runtime.held.move_y = value.clamp(-1.0, 1.0);
                    }
                    if let Some(value) = req.actions.move_z {
                        runtime.held.move_z = value.clamp(-1.0, 1.0);
                    }
                    if let Some(value) = req.actions.sprint {
                        runtime.held.sprint = value;
                    }
                    if let Some(value) = req.actions.crouch {
                        runtime.held.crouch = value;
                    }
                    if let Some(value) = req.actions.jump_hold {
                        runtime.held.jump_hold = value;
                    }
                    if let Some(value) = req.actions.attack_hold {
                        runtime.held.attack_hold = value;
                    }
                    if let Some(value) = req.actions.use_hold {
                        runtime.held.use_hold = value;
                    }

                    if let Some(slot) = req.actions.hotbar_slot {
                        runtime.pulses.hotbar_slot = Some(slot.min(8));
                    }
                }

                let _ = respond_to.send(protocol::event_ok(req.id));
            }
            protocol::Request::Pulse(req) => {
                if let Some(runtime) = self.automation.as_mut() {
                    runtime.pulses.jump_click |= req.actions.jump_click;
                    runtime.pulses.attack_click |= req.actions.attack_click;
                    runtime.pulses.use_click |= req.actions.use_click;
                    if let Some(slot) = req.actions.hotbar_slot {
                        runtime.pulses.hotbar_slot = Some(slot.min(8));
                    }
                }

                let _ = respond_to.send(protocol::event_ok(req.id));
            }
            protocol::Request::SetView(req) => {
                let pitch = (req.pitch).clamp(
                    -std::f32::consts::FRAC_PI_2 + 0.001,
                    std::f32::consts::FRAC_PI_2 - 0.001,
                );
                let camera = self.renderer.camera_mut();
                camera.yaw = req.yaw;
                camera.pitch = pitch;

                let _ = respond_to.send(protocol::event_ok(req.id));
            }
            protocol::Request::Command(req) => {
                let tick = self.sim_tick.0;
                let (ok, lines) = match commands::parse_command(&req.line, &self.registry) {
                    Ok(cmd) => {
                        let out = commands::execute_command(self, cmd);
                        (true, out.lines)
                    }
                    Err(err) => (false, vec![format!("Error: {err}")]),
                };

                let _ = respond_to.send(protocol::event_command_result(req.id, tick, ok, lines));
            }
            protocol::Request::GetState(req) => {
                let tick = self.sim_tick.0;
                let camera = self.renderer.camera();
                let pos = [camera.position.x, camera.position.y, camera.position.z];
                let mut mobs_active = 0u32;
                let mut mobs_nearby = 0u32;
                let nearby_radius_sq = 64.0_f32 * 64.0_f32;
                for mob in &self.mobs {
                    if mob.dead || mob.dimension != self.active_dimension {
                        continue;
                    }
                    mobs_active += 1;
                    let dx = mob.x as f32 - camera.position.x;
                    let dy = mob.y as f32 - camera.position.y;
                    let dz = mob.z as f32 - camera.position.z;
                    if dx * dx + dy * dy + dz * dz <= nearby_radius_sq {
                        mobs_nearby += 1;
                    }
                }
                let _ = respond_to.send(protocol::event_state(
                    req.id,
                    tick,
                    self.active_dimension.as_str(),
                    pos,
                    camera.yaw,
                    camera.pitch,
                    self.player_health.current,
                    self.player_health.hunger,
                    self.mobs.len() as u32,
                    mobs_active,
                    mobs_nearby,
                ));
            }
            protocol::Request::Step(req) => {
                self.handle_headless_step(req, respond_to, max_ticks, exit_when_disconnected)?;
            }
            protocol::Request::Screenshot(req) => {
                if self.renderer.device().is_none() {
                    let _ = respond_to.send(protocol::event_error(
                        req.id,
                        protocol::ErrorCode::Unsupported,
                        "render disabled",
                    ));
                } else if let Some(runtime) = self.screenshot.as_mut() {
                    runtime.pending.push_back(ScreenshotJob {
                        kind: ScreenshotJobKind::Manual {
                            id: req.id,
                            respond_to,
                        },
                        tag: req.tag,
                    });
                    if self.headless_should_render() {
                        self.render();
                    }
                } else {
                    let _ = respond_to.send(protocol::event_error(
                        req.id,
                        protocol::ErrorCode::Unsupported,
                        "screenshots disabled (set --screenshot-dir)",
                    ));
                }
            }
            protocol::Request::Shutdown(req) => {
                self.pending_action = Some(GameAction::Quit);
                let _ = respond_to.send(protocol::event_ok(req.id));
            }
            other => {
                let _ = respond_to.send(protocol::event_error(
                    other.request_id(),
                    protocol::ErrorCode::Unsupported,
                    "request not supported",
                ));
            }
        }

        Ok(())
    }

    fn handle_headless_step(
        &mut self,
        req: protocol::StepRequest,
        respond_to: std::sync::mpsc::SyncSender<serde_json::Value>,
        max_ticks: Option<u64>,
        exit_when_disconnected: bool,
    ) -> Result<()> {
        let prev_sink = self
            .screenshot_periodic_event_sink
            .replace(respond_to.clone());

        for _ in 0..req.ticks {
            if exit_when_disconnected
                && self
                    .automation
                    .as_ref()
                    .is_some_and(|rt| rt.ever_connected && !rt.connected)
            {
                break;
            }

            if let Some(max) = max_ticks {
                if self.sim_tick.0 >= max {
                    let _ = respond_to.send(protocol::event_error(
                        req.id,
                        protocol::ErrorCode::Internal,
                        "max ticks reached",
                    ));
                    self.pending_action = Some(GameAction::Quit);
                    self.screenshot_periodic_event_sink = prev_sink;
                    return Ok(());
                }
            }

            self.automation_tick();

            if self.headless_should_render() {
                self.render();
            }
        }

        self.screenshot_periodic_event_sink = prev_sink;

        let _ = respond_to.send(protocol::event_stepped(req.id, self.sim_tick.0));
        Ok(())
    }

    fn column_ground_height(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        world_x: f32,
        world_z: f32,
    ) -> f32 {
        let block_x = world_x.floor() as i32;
        let block_z = world_z.floor() as i32;
        let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
        let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
        let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
        if let Some(chunk) = chunks.get(&chunk_pos) {
            let local_x = block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            for y in (0..CHUNK_SIZE_Y).rev() {
                let voxel = chunk.voxel(local_x, y, local_z);
                if let Some(top_offset) = Self::voxel_collision_top_offset(block_properties, &voxel)
                {
                    return local_y_to_world_y(y) as f32 + top_offset;
                }
            }
        }
        50.0
    }

    fn voxel_collision_top_offset(
        block_properties: &BlockPropertiesRegistry,
        voxel: &Voxel,
    ) -> Option<f32> {
        if !block_properties.get(voxel.id).is_solid {
            return None;
        }

        match mdminecraft_world::get_collision_type(voxel.id, voxel.state) {
            mdminecraft_world::CollisionType::None | mdminecraft_world::CollisionType::Ladder => {
                None
            }
            mdminecraft_world::CollisionType::Door { .. } => None,
            mdminecraft_world::CollisionType::Full => Some(1.0),
            mdminecraft_world::CollisionType::Partial { max_y, .. } => Some(max_y),
            mdminecraft_world::CollisionType::Fence => Some(1.5),
        }
    }

    fn collision_aabbs_for_voxel(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        block_x: i32,
        block_y: i32,
        block_z: i32,
        voxel: &Voxel,
    ) -> AabbSet<8> {
        if !block_properties.get(voxel.id).is_solid {
            return AabbSet::empty();
        }

        let full = || AABB {
            min: glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
            max: glam::Vec3::new(
                block_x as f32 + 1.0,
                block_y as f32 + 1.0,
                block_z as f32 + 1.0,
            ),
        };

        let voxel_at = |x: i32, y: i32, z: i32| -> Option<Voxel> {
            let local_y = world_y_to_local_y(y)?;
            let chunk_x = x.div_euclid(CHUNK_SIZE_X as i32);
            let chunk_z = z.div_euclid(CHUNK_SIZE_Z as i32);
            let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
            let chunk = chunks.get(&chunk_pos)?;
            let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            Some(chunk.voxel(local_x, local_y, local_z))
        };

        match mdminecraft_world::get_collision_type(voxel.id, voxel.state) {
            mdminecraft_world::CollisionType::None | mdminecraft_world::CollisionType::Ladder => {
                if mdminecraft_world::is_fence_gate(voxel.id)
                    && mdminecraft_world::is_fence_gate_open(voxel.state)
                {
                    let thickness = 3.0 / 16.0;
                    let facing = mdminecraft_world::Facing::from_state(voxel.state);

                    // Simplified hinge: gates always swing "left" from their facing direction.
                    let (min, max) = match facing {
                        mdminecraft_world::Facing::North => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + thickness,
                                block_y as f32 + 1.5,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::South => (
                            glam::Vec3::new(
                                block_x as f32 + 1.0 - thickness,
                                block_y as f32,
                                block_z as f32,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.5,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::East => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.5,
                                block_z as f32 + thickness,
                            ),
                        ),
                        mdminecraft_world::Facing::West => (
                            glam::Vec3::new(
                                block_x as f32,
                                block_y as f32,
                                block_z as f32 + 1.0 - thickness,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.5,
                                block_z as f32 + 1.0,
                            ),
                        ),
                    };

                    return AabbSet::single(AABB { min, max });
                }

                if mdminecraft_world::is_trapdoor(voxel.id)
                    && mdminecraft_world::is_trapdoor_open(voxel.state)
                {
                    let thickness = 3.0 / 16.0;
                    let facing = mdminecraft_world::Facing::from_state(voxel.state);

                    let (min, max) = match facing {
                        mdminecraft_world::Facing::North => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + thickness,
                            ),
                        ),
                        mdminecraft_world::Facing::South => (
                            glam::Vec3::new(
                                block_x as f32,
                                block_y as f32,
                                block_z as f32 + 1.0 - thickness,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::East => (
                            glam::Vec3::new(
                                block_x as f32 + 1.0 - thickness,
                                block_y as f32,
                                block_z as f32,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::West => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + thickness,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                    };

                    return AabbSet::single(AABB { min, max });
                }

                AabbSet::empty()
            }
            mdminecraft_world::CollisionType::Door { open } => {
                let thickness = 3.0 / 16.0;
                let facing = mdminecraft_world::Facing::from_state(voxel.state);

                let (min, max) = if open {
                    // Simplified hinge: doors always swing "left" from their facing direction.
                    match facing {
                        mdminecraft_world::Facing::North => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + thickness,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::South => (
                            glam::Vec3::new(
                                block_x as f32 + 1.0 - thickness,
                                block_y as f32,
                                block_z as f32,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::East => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + thickness,
                            ),
                        ),
                        mdminecraft_world::Facing::West => (
                            glam::Vec3::new(
                                block_x as f32,
                                block_y as f32,
                                block_z as f32 + 1.0 - thickness,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                    }
                } else {
                    match facing {
                        mdminecraft_world::Facing::North => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + thickness,
                            ),
                        ),
                        mdminecraft_world::Facing::South => (
                            glam::Vec3::new(
                                block_x as f32,
                                block_y as f32,
                                block_z as f32 + 1.0 - thickness,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::East => (
                            glam::Vec3::new(
                                block_x as f32 + 1.0 - thickness,
                                block_y as f32,
                                block_z as f32,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                        mdminecraft_world::Facing::West => (
                            glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                            glam::Vec3::new(
                                block_x as f32 + thickness,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        ),
                    }
                };

                AabbSet::single(AABB { min, max })
            }
            mdminecraft_world::CollisionType::Full => {
                if voxel.id == mdminecraft_world::interactive_blocks::GLASS_PANE
                    || voxel.id == mdminecraft_world::interactive_blocks::IRON_BARS
                {
                    // Glass pane collision: a thin post, optionally with connecting arms.
                    let thickness = 2.0 / 16.0;
                    let half = thickness * 0.5;

                    let connects_to = |neighbor: Voxel| -> bool {
                        matches!(
                            neighbor.id,
                            mdminecraft_world::interactive_blocks::GLASS_PANE
                                | mdminecraft_world::interactive_blocks::IRON_BARS
                        ) || mdminecraft_world::is_full_cube_block(neighbor.id)
                    };

                    let connect_west =
                        voxel_at(block_x - 1, block_y, block_z).is_some_and(connects_to);
                    let connect_east =
                        voxel_at(block_x + 1, block_y, block_z).is_some_and(connects_to);
                    let connect_north =
                        voxel_at(block_x, block_y, block_z - 1).is_some_and(connects_to);
                    let connect_south =
                        voxel_at(block_x, block_y, block_z + 1).is_some_and(connects_to);

                    let post_min_x = block_x as f32 + 0.5 - half;
                    let post_max_x = block_x as f32 + 0.5 + half;
                    let post_min_z = block_z as f32 + 0.5 - half;
                    let post_max_z = block_z as f32 + 0.5 + half;

                    let any_x = connect_west || connect_east;
                    let any_z = connect_north || connect_south;
                    if !any_x && !any_z {
                        return AabbSet::single(AABB {
                            min: glam::Vec3::new(post_min_x, block_y as f32, post_min_z),
                            max: glam::Vec3::new(post_max_x, block_y as f32 + 1.0, post_max_z),
                        });
                    }

                    let mut set = AabbSet::empty();
                    if any_x {
                        let min_x = if connect_west {
                            block_x as f32
                        } else {
                            post_min_x
                        };
                        let max_x = if connect_east {
                            block_x as f32 + 1.0
                        } else {
                            post_max_x
                        };
                        set.push(AABB {
                            min: glam::Vec3::new(min_x, block_y as f32, post_min_z),
                            max: glam::Vec3::new(max_x, block_y as f32 + 1.0, post_max_z),
                        });
                    }
                    if any_z {
                        let min_z = if connect_north {
                            block_z as f32
                        } else {
                            post_min_z
                        };
                        let max_z = if connect_south {
                            block_z as f32 + 1.0
                        } else {
                            post_max_z
                        };
                        set.push(AABB {
                            min: glam::Vec3::new(post_min_x, block_y as f32, min_z),
                            max: glam::Vec3::new(post_max_x, block_y as f32 + 1.0, max_z),
                        });
                    }
                    return set;
                }

                AabbSet::single(full())
            }
            mdminecraft_world::CollisionType::Partial { min_y, max_y } => {
                if voxel.id == mdminecraft_world::BLOCK_BREWING_STAND {
                    let pad = 4.0 / 16.0;
                    return AabbSet::single(AABB {
                        min: glam::Vec3::new(
                            block_x as f32 + pad,
                            block_y as f32 + min_y,
                            block_z as f32 + pad,
                        ),
                        max: glam::Vec3::new(
                            block_x as f32 + 1.0 - pad,
                            block_y as f32 + max_y,
                            block_z as f32 + 1.0 - pad,
                        ),
                    });
                }

                if mdminecraft_world::is_stairs(voxel.id) {
                    let facing = mdminecraft_world::Facing::from_state(voxel.state);
                    let top = (voxel.state & 0x04) != 0;
                    let shape = mdminecraft_world::stairs_shape_at(
                        block_x, block_y, block_z, *voxel, &voxel_at,
                    );
                    let (footprints, footprint_count) =
                        mdminecraft_world::stairs_step_footprints(facing, shape);

                    let mut set = AabbSet::empty();
                    if top {
                        // Upside-down stairs: full top half + a lower half-footprint step.
                        let upper_min_y = block_y as f32 + max_y;
                        set.push(AABB {
                            min: glam::Vec3::new(block_x as f32, upper_min_y, block_z as f32),
                            max: glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.0,
                                block_z as f32 + 1.0,
                            ),
                        });

                        let lower_min_y = block_y as f32 + min_y;
                        let lower_max_y = block_y as f32 + max_y;
                        for footprint in footprints.iter().take(footprint_count) {
                            set.push(AABB {
                                min: glam::Vec3::new(
                                    block_x as f32 + footprint.min_x,
                                    lower_min_y,
                                    block_z as f32 + footprint.min_z,
                                ),
                                max: glam::Vec3::new(
                                    block_x as f32 + footprint.max_x,
                                    lower_max_y,
                                    block_z as f32 + footprint.max_z,
                                ),
                            });
                        }
                    } else {
                        // Normal stairs: full bottom half + an upper half-footprint step.
                        set.push(AABB {
                            min: glam::Vec3::new(
                                block_x as f32,
                                block_y as f32 + min_y,
                                block_z as f32,
                            ),
                            max: glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + max_y,
                                block_z as f32 + 1.0,
                            ),
                        });

                        let upper_min_y = block_y as f32 + max_y;
                        for footprint in footprints.iter().take(footprint_count) {
                            set.push(AABB {
                                min: glam::Vec3::new(
                                    block_x as f32 + footprint.min_x,
                                    upper_min_y,
                                    block_z as f32 + footprint.min_z,
                                ),
                                max: glam::Vec3::new(
                                    block_x as f32 + footprint.max_x,
                                    block_y as f32 + 1.0,
                                    block_z as f32 + footprint.max_z,
                                ),
                            });
                        }
                    }
                    return set;
                }

                AabbSet::single(AABB {
                    min: glam::Vec3::new(block_x as f32, block_y as f32 + min_y, block_z as f32),
                    max: glam::Vec3::new(
                        block_x as f32 + 1.0,
                        block_y as f32 + max_y,
                        block_z as f32 + 1.0,
                    ),
                })
            }
            mdminecraft_world::CollisionType::Fence => {
                if mdminecraft_world::is_fence_gate(voxel.id) {
                    let thickness = 3.0 / 16.0;
                    let half = thickness * 0.5;
                    let facing = mdminecraft_world::Facing::from_state(voxel.state);

                    let (min, max) = match facing {
                        mdminecraft_world::Facing::North | mdminecraft_world::Facing::South => (
                            glam::Vec3::new(
                                block_x as f32,
                                block_y as f32,
                                block_z as f32 + 0.5 - half,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 1.0,
                                block_y as f32 + 1.5,
                                block_z as f32 + 0.5 + half,
                            ),
                        ),
                        mdminecraft_world::Facing::East | mdminecraft_world::Facing::West => (
                            glam::Vec3::new(
                                block_x as f32 + 0.5 - half,
                                block_y as f32,
                                block_z as f32,
                            ),
                            glam::Vec3::new(
                                block_x as f32 + 0.5 + half,
                                block_y as f32 + 1.5,
                                block_z as f32 + 1.0,
                            ),
                        ),
                    };

                    return AabbSet::single(AABB { min, max });
                }

                let is_wall = matches!(
                    voxel.id,
                    mdminecraft_world::interactive_blocks::COBBLESTONE_WALL
                        | mdminecraft_world::interactive_blocks::STONE_BRICK_WALL
                );

                let connects_to = |neighbor: Voxel| -> bool {
                    if is_wall {
                        matches!(
                            neighbor.id,
                            mdminecraft_world::interactive_blocks::COBBLESTONE_WALL
                                | mdminecraft_world::interactive_blocks::STONE_BRICK_WALL
                        ) || mdminecraft_world::is_fence_gate(neighbor.id)
                            || mdminecraft_world::is_full_cube_block(neighbor.id)
                    } else {
                        mdminecraft_world::is_fence(neighbor.id)
                            || mdminecraft_world::is_fence_gate(neighbor.id)
                            || mdminecraft_world::is_full_cube_block(neighbor.id)
                    }
                };

                let connect_west = voxel_at(block_x - 1, block_y, block_z).is_some_and(connects_to);
                let connect_east = voxel_at(block_x + 1, block_y, block_z).is_some_and(connects_to);
                let connect_north =
                    voxel_at(block_x, block_y, block_z - 1).is_some_and(connects_to);
                let connect_south =
                    voxel_at(block_x, block_y, block_z + 1).is_some_and(connects_to);

                // Fence collision: center post + optional connecting arms (multi-AABB), avoiding
                // over-colliding corners when connected in multiple directions.
                let (post_min_x, post_max_x, post_min_z, post_max_z, arm_thickness) = if matches!(
                    voxel.id,
                    mdminecraft_world::interactive_blocks::COBBLESTONE_WALL
                        | mdminecraft_world::interactive_blocks::STONE_BRICK_WALL
                ) {
                    let thickness = 6.0 / 16.0;
                    let half = thickness * 0.5;
                    (
                        block_x as f32 + 0.5 - half,
                        block_x as f32 + 0.5 + half,
                        block_z as f32 + 0.5 - half,
                        block_z as f32 + 0.5 + half,
                        thickness,
                    )
                } else {
                    (
                        block_x as f32 + 0.375,
                        block_x as f32 + 0.625,
                        block_z as f32 + 0.375,
                        block_z as f32 + 0.625,
                        2.0 / 16.0,
                    )
                };

                let arm_half = arm_thickness * 0.5;
                let arm_min_x = block_x as f32 + 0.5 - arm_half;
                let arm_max_x = block_x as f32 + 0.5 + arm_half;
                let arm_min_z = block_z as f32 + 0.5 - arm_half;
                let arm_max_z = block_z as f32 + 0.5 + arm_half;

                let mut set = AabbSet::empty();
                set.push(AABB {
                    min: glam::Vec3::new(post_min_x, block_y as f32, post_min_z),
                    max: glam::Vec3::new(post_max_x, block_y as f32 + 1.5, post_max_z),
                });

                if connect_west {
                    set.push(AABB {
                        min: glam::Vec3::new(block_x as f32, block_y as f32, arm_min_z),
                        max: glam::Vec3::new(block_x as f32 + 0.5, block_y as f32 + 1.5, arm_max_z),
                    });
                }
                if connect_east {
                    set.push(AABB {
                        min: glam::Vec3::new(block_x as f32 + 0.5, block_y as f32, arm_min_z),
                        max: glam::Vec3::new(block_x as f32 + 1.0, block_y as f32 + 1.5, arm_max_z),
                    });
                }
                if connect_north {
                    set.push(AABB {
                        min: glam::Vec3::new(arm_min_x, block_y as f32, block_z as f32),
                        max: glam::Vec3::new(arm_max_x, block_y as f32 + 1.5, block_z as f32 + 0.5),
                    });
                }
                if connect_south {
                    set.push(AABB {
                        min: glam::Vec3::new(arm_min_x, block_y as f32, block_z as f32 + 0.5),
                        max: glam::Vec3::new(arm_max_x, block_y as f32 + 1.5, block_z as f32 + 1.0),
                    });
                }

                set
            }
        }
    }

    fn block_collision_aabbs_at(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        block_x: i32,
        block_y: i32,
        block_z: i32,
    ) -> AabbSet<8> {
        let Some(local_y) = world_y_to_local_y(block_y) else {
            if block_y < WORLD_MIN_Y {
                return AabbSet::single(AABB {
                    min: glam::Vec3::new(block_x as f32, block_y as f32, block_z as f32),
                    max: glam::Vec3::new(
                        block_x as f32 + 1.0,
                        block_y as f32 + 1.0,
                        block_z as f32 + 1.0,
                    ),
                });
            }

            return AabbSet::empty();
        };

        let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
        let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
        let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
        let Some(chunk) = chunks.get(&chunk_pos) else {
            return AabbSet::empty();
        };
        let local_x = block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        let voxel = chunk.voxel(local_x, local_y, local_z);
        Self::collision_aabbs_for_voxel(chunks, block_properties, block_x, block_y, block_z, &voxel)
    }

    /// Check if an AABB collides with any solid blocks in the world
    fn aabb_collides_with_world(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        aabb: &AABB,
    ) -> bool {
        // Get the range of blocks the AABB might intersect
        let min_x = aabb.min.x.floor() as i32;
        let min_y = aabb.min.y.floor() as i32;
        let min_z = aabb.min.z.floor() as i32;
        let max_x = aabb.max.x.ceil() as i32;
        let max_y = aabb.max.y.ceil() as i32;
        let max_z = aabb.max.z.ceil() as i32;

        for bx in min_x..max_x {
            for by in min_y..max_y {
                for bz in min_z..max_z {
                    let block_aabbs =
                        Self::block_collision_aabbs_at(chunks, block_properties, bx, by, bz);
                    for block_aabb in block_aabbs.iter() {
                        if aabb.intersects(block_aabb) {
                            return true;
                        }
                    }
                }
            }
        }
        false
    }

    fn projectile_point_collides_with_world(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        x: f64,
        y: f64,
        z: f64,
    ) -> bool {
        Self::projectile_point_hits_world(chunks, block_properties, x, y, z).is_some()
    }

    fn button_projectile_aabb(block_x: i32, block_y: i32, block_z: i32, state: u16) -> AABB {
        // Vanilla-ish button hitboxes (approximate): thin rectangles mounted to a face.
        // This is only used for projectile collision, not general movement collision.
        let thickness = 2.0_f32 / 16.0;
        let inset_min = 5.0_f32 / 16.0;
        let inset_max = 11.0_f32 / 16.0;
        let wall_min_y = 6.0_f32 / 16.0;
        let wall_max_y = 10.0_f32 / 16.0;

        let mut min_x = block_x as f32 + inset_min;
        let mut max_x = block_x as f32 + inset_max;
        let mut min_y = block_y as f32;
        let mut max_y = block_y as f32 + thickness;
        let mut min_z = block_z as f32 + inset_min;
        let mut max_z = block_z as f32 + inset_max;

        if mdminecraft_world::is_wall_mounted(state) {
            min_y = block_y as f32 + wall_min_y;
            max_y = block_y as f32 + wall_max_y;
            match mdminecraft_world::wall_mounted_facing(state) {
                mdminecraft_world::Facing::North => {
                    min_z = block_z as f32 + 1.0 - thickness;
                    max_z = block_z as f32 + 1.0;
                }
                mdminecraft_world::Facing::South => {
                    min_z = block_z as f32;
                    max_z = block_z as f32 + thickness;
                }
                mdminecraft_world::Facing::East => {
                    min_x = block_x as f32;
                    max_x = block_x as f32 + thickness;
                }
                mdminecraft_world::Facing::West => {
                    min_x = block_x as f32 + 1.0 - thickness;
                    max_x = block_x as f32 + 1.0;
                }
            }
        } else if mdminecraft_world::is_ceiling_mounted(state) {
            min_y = block_y as f32 + 1.0 - thickness;
            max_y = block_y as f32 + 1.0;
        }

        AABB {
            min: glam::Vec3::new(min_x, min_y, min_z),
            max: glam::Vec3::new(max_x, max_y, max_z),
        }
    }

    fn projectile_point_hits_world(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        x: f64,
        y: f64,
        z: f64,
    ) -> Option<glam::IVec3> {
        let block_x = x.floor() as i32;
        let block_y = y.floor() as i32;
        let block_z = z.floor() as i32;

        if world_y_to_local_y(block_y).is_none() {
            return Some(glam::IVec3::new(block_x, block_y, block_z));
        }

        // Projectiles are treated as points for collision, but we use a tiny AABB to avoid
        // edge-case misses when interacting with thin collision shapes.
        const EPS: f32 = 1.0 / 1024.0;
        let projectile_aabb = AABB {
            min: glam::Vec3::new(x as f32 - EPS, y as f32 - EPS, z as f32 - EPS),
            max: glam::Vec3::new(x as f32 + EPS, y as f32 + EPS, z as f32 + EPS),
        };

        // Check the current block and the block below to handle blocks with collision that
        // extends above their voxel (e.g., fences/walls at 1.5 blocks high).
        for (bx, by, bz) in [(block_x, block_y, block_z), (block_x, block_y - 1, block_z)] {
            let block_aabbs = Self::block_collision_aabbs_at(chunks, block_properties, bx, by, bz);
            for block_aabb in block_aabbs.iter() {
                if projectile_aabb.intersects(block_aabb) {
                    return Some(glam::IVec3::new(bx, by, bz));
                }
            }

            let Some(local_y) = world_y_to_local_y(by) else {
                continue;
            };
            let chunk_pos = ChunkPos::new(
                bx.div_euclid(CHUNK_SIZE_X as i32),
                bz.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let Some(chunk) = chunks.get(&chunk_pos) else {
                continue;
            };
            let local_x = bx.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = bz.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            let voxel = chunk.voxel(local_x, local_y, local_z);

            if matches!(
                voxel.id,
                mdminecraft_world::redstone_blocks::STONE_BUTTON
                    | mdminecraft_world::redstone_blocks::OAK_BUTTON
            ) {
                let button_aabb = Self::button_projectile_aabb(bx, by, bz, voxel.state);
                if projectile_aabb.intersects(&button_aabb) {
                    return Some(glam::IVec3::new(bx, by, bz));
                }
            }
        }

        None
    }

    fn projectile_first_block_hit_along_segment_with_block(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        from: (f64, f64, f64),
        to: (f64, f64, f64),
    ) -> Option<((f64, f64, f64), glam::IVec3)> {
        if let Some(block_pos) =
            Self::projectile_point_hits_world(chunks, block_properties, from.0, from.1, from.2)
        {
            return Some((from, block_pos));
        }

        let dx = to.0 - from.0;
        let dy = to.1 - from.1;
        let dz = to.2 - from.2;
        let dist = (dx * dx + dy * dy + dz * dz).sqrt();
        if dist <= 1.0e-9 {
            return None;
        }

        let steps = ((dist * 64.0).ceil() as u32).clamp(1, 256);
        for step in 1..=steps {
            let t = step as f64 / steps as f64;
            let x = from.0 + dx * t;
            let y = from.1 + dy * t;
            let z = from.2 + dz * t;

            if let Some(block_pos) =
                Self::projectile_point_hits_world(chunks, block_properties, x, y, z)
            {
                return Some(((x, y, z), block_pos));
            }
        }

        None
    }

    fn projectile_first_block_hit_along_segment(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        from: (f64, f64, f64),
        to: (f64, f64, f64),
    ) -> Option<(f64, f64, f64)> {
        Self::projectile_first_block_hit_along_segment_with_block(
            chunks,
            block_properties,
            from,
            to,
        )
        .map(|(hit, _)| hit)
    }

    fn try_activate_button_from_projectile_hit(
        projectile_type: mdminecraft_world::ProjectileType,
        hit_block_pos: glam::IVec3,
        chunks: &mut HashMap<ChunkPos, Chunk>,
        redstone_sim: &mut mdminecraft_world::RedstoneSimulator,
    ) -> bool {
        if projectile_type != mdminecraft_world::ProjectileType::Arrow {
            return false;
        }

        let Some(local_y) = world_y_to_local_y(hit_block_pos.y) else {
            return false;
        };

        let chunk_pos = ChunkPos::new(
            hit_block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            hit_block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let Some(chunk) = chunks.get(&chunk_pos) else {
            return false;
        };
        let local_x = hit_block_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = hit_block_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        let voxel = chunk.voxel(local_x, local_y, local_z);

        if !matches!(
            voxel.id,
            mdminecraft_world::redstone_blocks::STONE_BUTTON
                | mdminecraft_world::redstone_blocks::OAK_BUTTON
        ) {
            return false;
        }

        if mdminecraft_world::is_active(voxel.state) {
            return false;
        }

        redstone_sim.activate_button(
            RedstonePos::new(hit_block_pos.x, hit_block_pos.y, hit_block_pos.z),
            chunks,
        );
        true
    }

    fn line_of_sight_clear(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        from: glam::Vec3,
        to: glam::Vec3,
    ) -> bool {
        let delta = to - from;
        let max_distance = delta.length();
        if max_distance <= 1.0e-5 {
            return true;
        }

        let direction = delta / max_distance;
        let origin = from + direction * 1.0e-4;

        let mut voxel = glam::IVec3::new(
            origin.x.floor() as i32,
            origin.y.floor() as i32,
            origin.z.floor() as i32,
        );

        let step = glam::IVec3::new(
            if direction.x >= 0.0 { 1 } else { -1 },
            if direction.y >= 0.0 { 1 } else { -1 },
            if direction.z >= 0.0 { 1 } else { -1 },
        );

        let delta_t = glam::Vec3::new(
            if direction.x != 0.0 {
                (1.0 / direction.x).abs()
            } else {
                f32::MAX
            },
            if direction.y != 0.0 {
                (1.0 / direction.y).abs()
            } else {
                f32::MAX
            },
            if direction.z != 0.0 {
                (1.0 / direction.z).abs()
            } else {
                f32::MAX
            },
        );

        let mut t_max = glam::Vec3::new(
            if direction.x != 0.0 {
                if direction.x > 0.0 {
                    ((voxel.x + 1) as f32 - origin.x) / direction.x
                } else {
                    (voxel.x as f32 - origin.x) / direction.x
                }
            } else {
                f32::MAX
            },
            if direction.y != 0.0 {
                if direction.y > 0.0 {
                    ((voxel.y + 1) as f32 - origin.y) / direction.y
                } else {
                    (voxel.y as f32 - origin.y) / direction.y
                }
            } else {
                f32::MAX
            },
            if direction.z != 0.0 {
                if direction.z > 0.0 {
                    ((voxel.z + 1) as f32 - origin.z) / direction.z
                } else {
                    (voxel.z as f32 - origin.z) / direction.z
                }
            } else {
                f32::MAX
            },
        );

        let max_steps = (max_distance * 3.0).ceil() as i32 + 1;
        for _ in 0..max_steps {
            for (bx, by, bz) in [(voxel.x, voxel.y, voxel.z), (voxel.x, voxel.y - 1, voxel.z)] {
                let block_aabbs =
                    Self::block_collision_aabbs_at(chunks, block_properties, bx, by, bz);
                for block_aabb in block_aabbs.iter() {
                    if block_aabb.ray_intersects(origin, direction, max_distance) {
                        return false;
                    }
                }
            }

            if t_max.x < t_max.y && t_max.x < t_max.z {
                voxel.x += step.x;
                t_max.x += delta_t.x;
            } else if t_max.y < t_max.z {
                voxel.y += step.y;
                t_max.y += delta_t.y;
            } else {
                voxel.z += step.z;
                t_max.z += delta_t.z;
            }

            if t_max.min_element() > max_distance {
                break;
            }
        }

        true
    }

    fn explosion_exposure(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        origin: glam::Vec3,
        target_aabb: &AABB,
    ) -> f32 {
        const EPS: f32 = 1.0 / 256.0;
        let min = target_aabb.min + glam::Vec3::splat(EPS);
        let max = target_aabb.max - glam::Vec3::splat(EPS);

        let center = (min + max) * 0.5;
        let samples = [
            center,
            glam::Vec3::new(min.x, min.y, min.z),
            glam::Vec3::new(min.x, min.y, max.z),
            glam::Vec3::new(min.x, max.y, min.z),
            glam::Vec3::new(min.x, max.y, max.z),
            glam::Vec3::new(max.x, min.y, min.z),
            glam::Vec3::new(max.x, min.y, max.z),
            glam::Vec3::new(max.x, max.y, min.z),
            glam::Vec3::new(max.x, max.y, max.z),
        ];

        let mut visible = 0u32;
        for sample in samples {
            if Self::line_of_sight_clear(chunks, block_properties, origin, sample) {
                visible += 1;
            }
        }

        visible as f32 / samples.len() as f32
    }

    fn nudge_explosion_origin_out_of_collision(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        origin: glam::Vec3,
        incoming_velocity: glam::Vec3,
    ) -> glam::Vec3 {
        let collides = |pos: glam::Vec3| -> bool {
            Self::projectile_point_collides_with_world(
                chunks,
                block_properties,
                pos.x as f64,
                pos.y as f64,
                pos.z as f64,
            )
        };

        if !collides(origin) {
            return origin;
        }

        let direction = if incoming_velocity.length_squared() > 1.0e-8 {
            incoming_velocity.normalize()
        } else {
            glam::Vec3::Z
        };

        // The projectile sweep can report hit points slightly inside the collided voxel.
        // For explosion visibility sampling, step the origin backward out of collision.
        const STEP: f32 = 1.0 / 64.0;
        let mut adjusted = origin;
        for _ in 0..128 {
            adjusted -= direction * STEP;
            if !collides(adjusted) {
                break;
            }
        }

        adjusted
    }

    fn resolve_mob_world_collisions(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        mob: &mut Mob,
        before_pos: (f64, f64, f64),
    ) {
        if matches!(
            mob.mob_type,
            MobType::Blaze | MobType::Ghast | MobType::EnderDragon
        ) {
            return;
        }

        let desired_pos = (mob.x, mob.y, mob.z);
        let dx = desired_pos.0 - before_pos.0;
        let dy = desired_pos.1 - before_pos.1;
        let dz = desired_pos.2 - before_pos.2;

        mob.x = before_pos.0;
        mob.y = before_pos.1;
        mob.z = before_pos.2;

        let mob_size = mob.mob_type.size();
        let mob_height = mob_size * 2.0;
        let make_aabb = |x: f64, y: f64, z: f64| AABB {
            min: glam::Vec3::new(x as f32 - mob_size, y as f32, z as f32 - mob_size),
            max: glam::Vec3::new(
                x as f32 + mob_size,
                y as f32 + mob_height,
                z as f32 + mob_size,
            ),
        };

        let collides = |x: f64, y: f64, z: f64| {
            let aabb = make_aabb(x, y, z);
            Self::aabb_collides_with_world(chunks, block_properties, &aabb)
        };

        if dy != 0.0 {
            // Step movement to avoid tunneling through thin geometry when velocities are high
            // (e.g., knockback/gravity). Uses a power-of-two step for determinism.
            const MAX_STEP: f64 = 0.25;
            let steps = (dy.abs() / MAX_STEP).ceil() as i32;
            let steps = steps.clamp(1, 64);
            let step = dy / steps as f64;
            for _ in 0..steps {
                let candidate_y = mob.y + step;
                if !collides(mob.x, candidate_y, mob.z) {
                    mob.y = candidate_y;
                } else {
                    mob.vel_y = 0.0;
                    break;
                }
            }
        }

        if dx != 0.0 {
            let candidate_x = mob.x + dx;
            if !collides(candidate_x, mob.y, mob.z) {
                mob.x = candidate_x;
            } else {
                let step_y = mob.y + PlayerPhysics::STEP_HEIGHT as f64;
                if !collides(candidate_x, step_y, mob.z) && !collides(mob.x, step_y, mob.z) {
                    mob.y = step_y;
                    mob.x = candidate_x;
                } else {
                    mob.vel_x = 0.0;
                }
            }
        }

        if dz != 0.0 {
            let candidate_z = mob.z + dz;
            if !collides(mob.x, mob.y, candidate_z) {
                mob.z = candidate_z;
            } else {
                let step_y = mob.y + PlayerPhysics::STEP_HEIGHT as f64;
                if !collides(mob.x, step_y, candidate_z) && !collides(mob.x, step_y, mob.z) {
                    mob.y = step_y;
                    mob.z = candidate_z;
                } else {
                    mob.vel_z = 0.0;
                }
            }
        }

        if mob.vel_y <= 0.0 {
            let block_x = mob.x.floor() as i32;
            let block_z = mob.z.floor() as i32;
            let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
            let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
            let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
            if let Some(chunk) = chunks.get(&chunk_pos) {
                let local_x = block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                let start_world_y = mob.y.floor() as i32;
                let ground_start = start_world_y - 1;
                const MAX_DROP: i32 = 32;
                for offset in 0..=MAX_DROP {
                    let ground_world_y = ground_start - offset;
                    if ground_world_y < WORLD_MIN_Y {
                        break;
                    }
                    let Some(local_y) = world_y_to_local_y(ground_world_y) else {
                        continue;
                    };
                    let ground_voxel = chunk.voxel(local_x, local_y, local_z);
                    let Some(top_offset) =
                        Self::voxel_collision_top_offset(block_properties, &ground_voxel)
                    else {
                        continue;
                    };
                    let foot_y = ground_world_y as f32 + top_offset + PlayerPhysics::GROUND_EPS;
                    if foot_y > mob.y as f32 + PlayerPhysics::GROUND_EPS {
                        continue;
                    }
                    if !collides(mob.x, foot_y as f64, mob.z) {
                        mob.y = foot_y as f64;
                        mob.vel_y = 0.0;
                        break;
                    }
                }
            }
        }

        if collides(mob.x, mob.y, mob.z) {
            mob.x = before_pos.0;
            mob.y = before_pos.1;
            mob.z = before_pos.2;
            mob.vel_x = 0.0;
            mob.vel_y = 0.0;
            mob.vel_z = 0.0;
        }
    }

    fn aabb_touches_ladder(chunks: &HashMap<ChunkPos, Chunk>, aabb: &AABB) -> bool {
        let min_x = aabb.min.x.floor() as i32;
        let min_y = aabb.min.y.floor() as i32;
        let min_z = aabb.min.z.floor() as i32;
        let max_x = aabb.max.x.ceil() as i32;
        let max_y = aabb.max.y.ceil() as i32;
        let max_z = aabb.max.z.ceil() as i32;

        for bx in min_x..max_x {
            for by in min_y..max_y {
                let Some(local_y) = world_y_to_local_y(by) else {
                    continue;
                };
                for bz in min_z..max_z {
                    let chunk_x = bx.div_euclid(CHUNK_SIZE_X as i32);
                    let chunk_z = bz.div_euclid(CHUNK_SIZE_Z as i32);
                    let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
                    let Some(chunk) = chunks.get(&chunk_pos) else {
                        continue;
                    };
                    let local_x = bx.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let local_z = bz.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                    let voxel = chunk.voxel(local_x, local_y, local_z);
                    if matches!(
                        mdminecraft_world::get_collision_type(voxel.id, voxel.state),
                        mdminecraft_world::CollisionType::Ladder
                    ) {
                        return true;
                    }
                }
            }
        }
        false
    }

    /// Move with collision detection, returning the actual position after collision resolution.
    /// Uses sweep testing along each axis separately for wall sliding.
    fn move_with_collision_axis_separated(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        current_aabb: &AABB,
        velocity: glam::Vec3,
    ) -> (glam::Vec3, glam::Vec3) {
        let mut result_offset = glam::Vec3::ZERO;
        let mut result_velocity = velocity;

        // Move along X axis
        if velocity.x != 0.0 {
            let test_aabb =
                current_aabb.offset(glam::Vec3::new(velocity.x, 0.0, 0.0) + result_offset);
            if !Self::aabb_collides_with_world(chunks, block_properties, &test_aabb) {
                result_offset.x += velocity.x;
            } else {
                result_velocity.x = 0.0;
            }
        }

        // Move along Y axis
        if velocity.y != 0.0 {
            let test_aabb =
                current_aabb.offset(glam::Vec3::new(0.0, velocity.y, 0.0) + result_offset);
            if !Self::aabb_collides_with_world(chunks, block_properties, &test_aabb) {
                result_offset.y += velocity.y;
            } else {
                result_velocity.y = 0.0;
            }
        }

        // Move along Z axis
        if velocity.z != 0.0 {
            let test_aabb =
                current_aabb.offset(glam::Vec3::new(0.0, 0.0, velocity.z) + result_offset);
            if !Self::aabb_collides_with_world(chunks, block_properties, &test_aabb) {
                result_offset.z += velocity.z;
            } else {
                result_velocity.z = 0.0;
            }
        }

        (result_offset, result_velocity)
    }

    fn step_down_offset(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        base_aabb: &AABB,
        max_down: f32,
    ) -> f32 {
        const STEP: f32 = 1.0 / 64.0;
        if max_down <= 0.0 {
            return 0.0;
        }

        let mut down = 0.0;
        while down < max_down {
            let next = (down + STEP).min(max_down);
            let test_aabb = base_aabb.offset(glam::Vec3::new(0.0, -next, 0.0));
            if Self::aabb_collides_with_world(chunks, block_properties, &test_aabb) {
                break;
            }
            down = next;
        }
        -down
    }

    /// Move with collision detection, returning the actual position after collision resolution.
    /// Uses axis-separated testing for wall sliding, plus an optional step-up for walking.
    fn move_with_collision(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        current_aabb: &AABB,
        velocity: glam::Vec3,
        step_height: f32,
    ) -> (glam::Vec3, glam::Vec3) {
        let (base_offset, base_velocity) = Self::move_with_collision_axis_separated(
            chunks,
            block_properties,
            current_aabb,
            velocity,
        );

        if step_height <= 0.0 || velocity.y > 0.0 {
            return (base_offset, base_velocity);
        }

        let blocked_x = velocity.x != 0.0 && base_velocity.x == 0.0;
        let blocked_z = velocity.z != 0.0 && base_velocity.z == 0.0;
        if !(blocked_x || blocked_z) {
            return (base_offset, base_velocity);
        }

        // Only step when we're on (or very near) the ground.
        let ground_probe = current_aabb.offset(glam::Vec3::new(0.0, -0.1, 0.0));
        if !Self::aabb_collides_with_world(chunks, block_properties, &ground_probe) {
            return (base_offset, base_velocity);
        }

        let step_up = glam::Vec3::new(0.0, step_height, 0.0);
        let stepped_aabb = current_aabb.offset(step_up);
        if Self::aabb_collides_with_world(chunks, block_properties, &stepped_aabb) {
            return (base_offset, base_velocity);
        }

        // Try the horizontal move from the stepped position (no vertical move in the step attempt).
        let horizontal_velocity = glam::Vec3::new(velocity.x, 0.0, velocity.z);
        let (step_horizontal_offset, step_horizontal_velocity) =
            Self::move_with_collision_axis_separated(
                chunks,
                block_properties,
                &stepped_aabb,
                horizontal_velocity,
            );
        let stepped_after_horizontal = stepped_aabb.offset(step_horizontal_offset);

        // Drop down by up to step height to land on the surface.
        let step_down = Self::step_down_offset(
            chunks,
            block_properties,
            &stepped_after_horizontal,
            step_height,
        );
        let step_offset = step_up + step_horizontal_offset + glam::Vec3::new(0.0, step_down, 0.0);

        let base_h = glam::Vec2::new(base_offset.x, base_offset.z).length_squared();
        let step_h = glam::Vec2::new(step_offset.x, step_offset.z).length_squared();
        if step_h <= base_h {
            return (base_offset, base_velocity);
        }

        let mut result_velocity = base_velocity;
        result_velocity.x = step_horizontal_velocity.x;
        result_velocity.z = step_horizontal_velocity.z;
        (step_offset, result_velocity)
    }

    fn apply_player_knockback_displacement(&mut self, knockback: glam::Vec3, max_horizontal: f32) {
        if knockback.length_squared() <= 1.0e-8 {
            return;
        }
        if self.player_state != PlayerState::Alive || self.player_health.is_dead() {
            return;
        }

        let knockback = {
            let horizontal = glam::Vec2::new(knockback.x, knockback.z);
            let horizontal_len = horizontal.length();
            if horizontal_len > max_horizontal && horizontal_len > 1.0e-8 {
                let scale = max_horizontal / horizontal_len;
                glam::Vec3::new(knockback.x * scale, knockback.y, knockback.z * scale)
            } else {
                knockback
            }
        };

        let camera_pos = self.renderer.camera().position;
        let current_aabb = self.player_physics.get_aabb(camera_pos);
        let (offset, _) = Self::move_with_collision(
            &self.chunks,
            &self.block_properties,
            &current_aabb,
            knockback,
            PlayerPhysics::STEP_HEIGHT,
        );
        if offset.length_squared() > 1.0e-8 {
            self.renderer.camera_mut().position = camera_pos + offset;
        }
    }

    fn determine_spawn_point(
        chunks: &HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
    ) -> Option<glam::Vec3> {
        let origin = ChunkPos::new(0, 0);
        let chunk = chunks.get(&origin)?;
        let base_x = origin.x * CHUNK_SIZE_X as i32;
        let base_z = origin.z * CHUNK_SIZE_Z as i32;
        let mut best: Option<(f32, i32, i32)> = None;

        for local_z in 0..CHUNK_SIZE_Z {
            for local_x in 0..CHUNK_SIZE_X {
                for y in (0..CHUNK_SIZE_Y).rev() {
                    let voxel = chunk.voxel(local_x, y, local_z);
                    let Some(top_offset) =
                        Self::voxel_collision_top_offset(block_properties, &voxel)
                    else {
                        continue;
                    };
                    let top_world_y = local_y_to_world_y(y) as f32 + top_offset;
                    let world_x = base_x + local_x as i32;
                    let world_z = base_z + local_z as i32;
                    if best.is_none_or(|(best_top_y, _, _)| top_world_y > best_top_y) {
                        best = Some((top_world_y, world_x, world_z));
                    }
                    break;
                }
            }
        }

        best.map(|(top_world_y, world_x, world_z)| {
            // Feet rest slightly above block top to avoid initial intersection.
            glam::Vec3::new(
                world_x as f32 + 0.5,
                top_world_y + PlayerPhysics::GROUND_EPS,
                world_z as f32 + 0.5,
            )
        })
    }

    fn player_save(&self) -> PlayerSave {
        let camera = self.renderer.camera();
        PlayerSave {
            transform: PlayerTransform {
                dimension: self.active_dimension,
                x: camera.position.x as f64,
                y: camera.position.y as f64,
                z: camera.position.z as f64,
                yaw: camera.yaw,
                pitch: camera.pitch,
            },
            spawn_point: WorldPoint {
                dimension: self.spawn_point_dimension,
                x: self.spawn_point.x as f64,
                y: self.spawn_point.y as f64,
                z: self.spawn_point.z as f64,
            },
            hotbar: self.hotbar.slots.clone(),
            hotbar_selected: self.hotbar.selected,
            inventory: Self::persisted_inventory_from_main_inventory(&self.main_inventory),
            health: self.player_health.current,
            hunger: self.player_health.hunger,
            xp_level: self.player_xp.level,
            xp_current: self.player_xp.current,
            xp_next_level_xp: self.player_xp.next_level_xp,
            armor: self.player_armor.clone(),
            status_effects: self.status_effects.clone(),
        }
    }

    /// Persistent inventory item-id used for "full core stack encoded in metadata" fallback.
    const PERSISTED_CORE_STACK_SENTINEL_ID: u16 = u16::MAX;

    fn persisted_inventory_from_main_inventory(main_inventory: &MainInventory) -> Inventory {
        let mut inventory = Inventory::new();
        for (idx, slot) in main_inventory.slots.iter().enumerate() {
            let Some(stack) = slot.as_ref() else {
                continue;
            };

            let world_stack = Self::persisted_world_stack_from_core(stack);
            let _ = inventory.set(9 + idx, Some(world_stack));
        }
        inventory
    }

    fn main_inventory_from_persisted_inventory(mut inventory: Inventory) -> MainInventory {
        let mut main = MainInventory::new();

        // Prefer canonical layout: slots 9-35.
        let has_any_main = (9..36).any(|slot| inventory.get(slot).is_some());
        if has_any_main {
            for idx in 0..27 {
                if let Some(world_stack) = inventory.take(9 + idx) {
                    main.slots[idx] = Self::core_stack_from_persisted_world_stack(world_stack);
                }
            }
        } else {
            // Legacy layout fallback: slots 0-26.
            for idx in 0..27 {
                if let Some(world_stack) = inventory.take(idx) {
                    main.slots[idx] = Self::core_stack_from_persisted_world_stack(world_stack);
                }
            }
        }

        main
    }

    fn persisted_world_stack_from_core(stack: &ItemStack) -> mdminecraft_world::ItemStack {
        if stack.count > u8::MAX as u32 {
            return Self::persisted_fallback_world_stack(stack);
        }

        let Some(drop_type) = Self::convert_core_item_type_to_dropped(stack.item_type) else {
            return Self::persisted_fallback_world_stack(stack);
        };

        let mut world_stack = mdminecraft_world::ItemStack::new(drop_type.id(), stack.count as u8);
        world_stack.metadata = encode_inventory_stack_metadata(stack);
        world_stack
    }

    fn persisted_fallback_world_stack(stack: &ItemStack) -> mdminecraft_world::ItemStack {
        let metadata = serde_json::to_vec(stack).unwrap_or_default();
        mdminecraft_world::ItemStack::with_metadata(
            Self::PERSISTED_CORE_STACK_SENTINEL_ID,
            1,
            metadata,
        )
    }

    fn core_stack_from_persisted_world_stack(
        stack: mdminecraft_world::ItemStack,
    ) -> Option<ItemStack> {
        if stack.item_id == Self::PERSISTED_CORE_STACK_SENTINEL_ID {
            let bytes = stack.metadata.as_ref()?;
            return serde_json::from_slice::<ItemStack>(bytes).ok();
        }

        let drop_type = DroppedItemType::from_id(stack.item_id)?;
        let core_item_type = Self::convert_dropped_item_type(drop_type)?;
        let mut core_stack = ItemStack::new(core_item_type, stack.count as u32);

        if let Some(metadata) = stack.metadata.as_ref() {
            apply_inventory_stack_metadata(&mut core_stack, metadata);
        }

        Some(core_stack)
    }

    fn apply_player_save(&mut self, save: PlayerSave) {
        self.spawn_point = glam::Vec3::new(
            save.spawn_point.x as f32,
            save.spawn_point.y as f32,
            save.spawn_point.z as f32,
        );
        self.spawn_point_dimension = save.spawn_point.dimension;
        self.active_dimension = save.transform.dimension;

        self.hotbar.slots = save.hotbar;
        self.hotbar.selected = save.hotbar_selected.min(8);

        // Migrate legacy item IDs that were previously used for dropped-item conversions.
        for slot in self.hotbar.slots.iter_mut().flatten() {
            if let ItemType::Item(id) = slot.item_type {
                match id {
                    100 => slot.item_type = ItemType::Item(3), // Stick
                    101 => slot.item_type = ItemType::Item(6), // Feather
                    _ => {}
                }
            }
        }
        self.main_inventory = Self::main_inventory_from_persisted_inventory(save.inventory);

        self.player_health.current = save.health.clamp(0.0, self.player_health.max);
        self.player_health.hunger = save.hunger.clamp(0.0, self.player_health.max_hunger);
        self.player_health.time_since_damage = 0.0;
        self.player_health.invulnerability_time = 0.0;
        self.player_health.hunger_timer = 0.0;
        self.player_health.starvation_timer = 0.0;
        self.player_health.is_active = false;

        if self.player_health.is_dead() {
            self.player_health.reset();
        }

        self.player_xp.level = save.xp_level;
        self.player_xp.current = save.xp_current;
        self.player_xp.next_level_xp = save.xp_next_level_xp;

        self.player_armor = save.armor;
        self.status_effects = save.status_effects;

        self.renderer.camera_mut().position = glam::Vec3::new(
            save.transform.x as f32,
            save.transform.y as f32,
            save.transform.z as f32,
        );
        self.renderer.camera_mut().yaw = save.transform.yaw;
        self.renderer.camera_mut().pitch = save.transform.pitch;

        self.player_physics.velocity = glam::Vec3::ZERO;
        self.player_physics.on_ground = false;
        self.player_physics.last_ground_y = self.spawn_point.y;

        self.player_state = PlayerState::Alive;
        self.death_message.clear();
        self.respawn_requested = false;
        self.menu_requested = false;
    }

    fn assign_mob_id(&mut self, mob: &mut Mob) {
        if mob.id != 0 {
            return;
        }

        mob.id = self.next_mob_id;
        self.next_mob_id = self.next_mob_id.saturating_add(1).max(1);
    }

    fn assign_mob_ids(&mut self, mobs: &mut [Mob]) {
        for mob in mobs {
            self.assign_mob_id(mob);
        }
    }

    fn world_entities_state(&self) -> WorldEntitiesState {
        WorldEntitiesState {
            mobs: self.mobs.clone(),
            dropped_items: self.item_manager.clone(),
            projectiles: self.projectiles.clone(),
        }
    }

    fn block_entities_state(&self) -> BlockEntitiesState {
        BlockEntitiesState {
            furnaces: self.furnaces.clone(),
            enchanting_tables: self.enchanting_tables.clone(),
            brewing_stands: self.brewing_stands.clone(),
            chests: self.chests.clone(),
            hoppers: self.hoppers.clone(),
            dispensers: self.dispensers.clone(),
            droppers: self.droppers.clone(),
        }
    }

    fn stash_ui_items_for_save(&mut self) {
        let mut returned: Vec<ItemStack> = Vec::new();

        if let Some(stack) = self.ui_cursor_stack.take() {
            returned.push(stack);
        }

        for row in &mut self.personal_crafting_grid {
            for slot in row.iter_mut() {
                if let Some(stack) = slot.take() {
                    returned.push(stack);
                }
            }
        }

        for row in &mut self.crafting_grid {
            for slot in row.iter_mut() {
                if let Some(stack) = slot.take() {
                    returned.push(stack);
                }
            }
        }

        for stack in returned {
            self.return_stack_to_storage_or_spill(stack);
        }
    }

    fn persist_world(&mut self) {
        self.stash_ui_items_for_save();
        self.persist_loaded_chunks();

        let meta = WorldMeta {
            world_seed: self.world_seed,
            end_boss_defeated: self.end_boss_defeated,
        };
        if let Err(err) = self.region_store.save_world_meta(&meta) {
            tracing::warn!(?err, "Failed to save world meta");
        }

        let state = WorldState {
            tick: self.sim_tick,
            sim_time: self.sim_time,
            weather: self.weather,
            weather_next_change_tick: self.weather_next_change_tick,
            player: Some(self.player_save()),
            entities: self.world_entities_state(),
            block_entities: self.block_entities_state(),
        };
        if let Err(err) = self.region_store.save_world_state(&state) {
            tracing::warn!(?err, "Failed to save world state");
        }
    }

    fn persist_loaded_chunks(&mut self) {
        for (pos, chunk) in &self.chunks {
            if let Err(err) = self
                .region_store
                .save_chunk_in_dimension(self.active_dimension, chunk)
            {
                tracing::error!(?pos, ?err, "Failed to save chunk");
            }
        }
    }

    /// Handle an event
    pub fn handle_event(
        &mut self,
        event: &Event<()>,
        _event_loop: &EventLoopWindowTarget<()>,
    ) -> GameAction {
        // Let UI handle events first
        if let Event::WindowEvent { ref event, .. } = event {
            if let Some(mut ui) = self.renderer.ui_mut() {
                if let Some(window) = self.window.as_ref() {
                    ui.handle_event(window, event);
                }
            }
            self.input.handle_event(event);
        }

        if let Event::DeviceEvent { ref event, .. } = event {
            self.input.handle_device_event(event);
        }

        match event {
            Event::WindowEvent { event, window_id } => {
                let Some(window) = self.window.as_ref() else {
                    return GameAction::Continue;
                };
                if *window_id != window.id() {
                    return GameAction::Continue;
                }

                match event {
                    WindowEvent::CloseRequested => {
                        self.persist_world();
                        return GameAction::Quit;
                    }
                    WindowEvent::Focused(focused) => {
                        if *focused {
                            // Regained focus - recapture cursor if we were in gameplay mode
                            let _ = self.input.handle_focus_regained(window);
                        }
                    }
                    WindowEvent::KeyboardInput { event, .. } => {
                        if let winit::keyboard::PhysicalKey::Code(KeyCode::Escape) =
                            event.physical_key
                        {
                            if event.state.is_pressed() {
                                self.handle_escape_pressed();
                                return GameAction::Continue;
                            }
                        }

                        self.handle_keyboard_input(event);
                    }
                    WindowEvent::Resized(new_size) => {
                        self.renderer.resize((new_size.width, new_size.height));
                    }
                    WindowEvent::RedrawRequested => {
                        self.update_and_render();

                        // Check for death screen actions after render
                        if let Some(action) = self.check_death_screen_actions() {
                            if matches!(action, GameAction::ReturnToMenu | GameAction::Quit) {
                                self.persist_world();
                            }
                            return action;
                        }

                        if let Some(action) = self.pending_action.take() {
                            if matches!(action, GameAction::ReturnToMenu | GameAction::Quit) {
                                self.persist_world();
                            }
                            return action;
                        }
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                if let Some(window) = self.window.as_ref() {
                    window.request_redraw();
                }
            }
            _ => {}
        }

        GameAction::Continue
    }

    fn handle_keyboard_input(&mut self, event: &winit::event::KeyEvent) {
        use winit::keyboard::PhysicalKey;

        if !event.state.is_pressed() {
            return;
        }

        if self.pause_menu_open {
            return;
        }

        if self.command_open {
            return;
        }

        match event.physical_key {
            PhysicalKey::Code(KeyCode::F3) => {
                self.debug_hud.toggle();
            }
            PhysicalKey::Code(KeyCode::Slash) => {
                self.open_command_prompt("/");
            }
            PhysicalKey::Code(KeyCode::KeyT) => {
                self.open_command_prompt("");
            }
            PhysicalKey::Code(KeyCode::KeyF) => {
                self.player_physics.toggle_physics();
                tracing::info!(
                    "Physics mode: {}",
                    if self.player_physics.physics_enabled {
                        "ENABLED"
                    } else {
                        "DISABLED (fly mode)"
                    }
                );
            }
            PhysicalKey::Code(KeyCode::KeyP) => {
                self.sim_time_paused = !self.sim_time_paused;
                tracing::info!(
                    paused = self.sim_time_paused,
                    "Simulation day/night progression toggled"
                );
            }
            PhysicalKey::Code(KeyCode::BracketLeft) => {
                // Increase ticks per day to slow down the day/night cycle.
                self.sim_time.ticks_per_day =
                    (self.sim_time.ticks_per_day.saturating_mul(3) / 2).min(240_000);
                tracing::info!(
                    ticks_per_day = self.sim_time.ticks_per_day,
                    "Simulation day length increased"
                );
            }
            PhysicalKey::Code(KeyCode::BracketRight) => {
                // Decrease ticks per day to speed up the day/night cycle.
                self.sim_time.ticks_per_day =
                    ((self.sim_time.ticks_per_day.saturating_mul(2)) / 3).max(2_400);
                tracing::info!(
                    ticks_per_day = self.sim_time.ticks_per_day,
                    "Simulation day length decreased"
                );
            }
            PhysicalKey::Code(KeyCode::KeyO) => {
                self.weather.toggle();
                let delay_ticks = Self::weather_delay_ticks(
                    self.world_seed,
                    self.sim_tick,
                    900..2400, // 45..120 seconds at 20 TPS
                    0xB16B_00B5_u64,
                );
                self.weather_next_change_tick = self.sim_tick.advance(delay_ticks);
                tracing::info!(state = ?self.weather.state, "Weather toggled");
            }
            PhysicalKey::Code(KeyCode::KeyE) => {
                if self.villager_trade_open {
                    self.close_villager_trade();
                } else if self.chest_open {
                    self.close_chest();
                } else if self.brewing_open {
                    self.close_brewing_stand();
                } else if self.enchanting_open {
                    self.close_enchanting_table();
                } else if self.furnace_open {
                    self.close_furnace();
                } else if self.crafting_open {
                    self.close_crafting();
                } else {
                    self.toggle_inventory();
                }
            }
            PhysicalKey::Code(KeyCode::Escape) => {
                if self.crafting_open {
                    self.close_crafting();
                } else if self.inventory_open {
                    self.toggle_inventory();
                } else if self.brewing_open {
                    self.close_brewing_stand();
                }
            }
            _ => {}
        }
    }

    fn process_automation_messages(&mut self) {
        loop {
            let msg = {
                let Some(runtime) = self.automation.as_ref() else {
                    return;
                };
                runtime.rx.try_recv()
            };

            match msg {
                Ok(msg) => match msg {
                    AutomationMsg::Connected => {
                        if let Some(runtime) = self.automation.as_mut() {
                            runtime.connected = true;
                            runtime.ever_connected = true;
                            runtime.held = AutomationHeldInput::default();
                            runtime.pulses = AutomationPulseInput::default();
                        }
                    }
                    AutomationMsg::Disconnected => {
                        if let Some(runtime) = self.automation.as_mut() {
                            runtime.connected = false;
                            runtime.held = AutomationHeldInput::default();
                            runtime.pulses = AutomationPulseInput::default();
                        }
                    }
                    AutomationMsg::Request {
                        request,
                        respond_to,
                    } => match request {
                        protocol::Request::SetActions(req) => {
                            if let Some(runtime) = self.automation.as_mut() {
                                if let Some(value) = req.actions.move_x {
                                    runtime.held.move_x = value.clamp(-1.0, 1.0);
                                }
                                if let Some(value) = req.actions.move_y {
                                    runtime.held.move_y = value.clamp(-1.0, 1.0);
                                }
                                if let Some(value) = req.actions.move_z {
                                    runtime.held.move_z = value.clamp(-1.0, 1.0);
                                }
                                if let Some(value) = req.actions.sprint {
                                    runtime.held.sprint = value;
                                }
                                if let Some(value) = req.actions.crouch {
                                    runtime.held.crouch = value;
                                }
                                if let Some(value) = req.actions.jump_hold {
                                    runtime.held.jump_hold = value;
                                }
                                if let Some(value) = req.actions.attack_hold {
                                    runtime.held.attack_hold = value;
                                }
                                if let Some(value) = req.actions.use_hold {
                                    runtime.held.use_hold = value;
                                }
                                if let Some(slot) = req.actions.hotbar_slot {
                                    runtime.pulses.hotbar_slot = Some(slot.min(8));
                                }
                            }

                            let _ = respond_to.send(protocol::event_ok(req.id));
                        }
                        protocol::Request::Pulse(req) => {
                            if let Some(runtime) = self.automation.as_mut() {
                                runtime.pulses.jump_click |= req.actions.jump_click;
                                runtime.pulses.attack_click |= req.actions.attack_click;
                                runtime.pulses.use_click |= req.actions.use_click;
                                if let Some(slot) = req.actions.hotbar_slot {
                                    runtime.pulses.hotbar_slot = Some(slot.min(8));
                                }
                            }

                            let _ = respond_to.send(protocol::event_ok(req.id));
                        }
                        protocol::Request::SetView(req) => {
                            let pitch = (req.pitch).clamp(
                                -std::f32::consts::FRAC_PI_2 + 0.001,
                                std::f32::consts::FRAC_PI_2 - 0.001,
                            );
                            let camera = self.renderer.camera_mut();
                            camera.yaw = req.yaw;
                            camera.pitch = pitch;

                            let _ = respond_to.send(protocol::event_ok(req.id));
                        }
                        protocol::Request::Command(req) => {
                            let tick = self.sim_tick.0;
                            let (ok, lines) =
                                match commands::parse_command(&req.line, &self.registry) {
                                    Ok(cmd) => {
                                        let out = commands::execute_command(self, cmd);
                                        (true, out.lines)
                                    }
                                    Err(err) => (false, vec![format!("Error: {err}")]),
                                };

                            let _ = respond_to
                                .send(protocol::event_command_result(req.id, tick, ok, lines));
                        }
                        protocol::Request::GetState(req) => {
                            let tick = self.sim_tick.0;
                            let camera = self.renderer.camera();
                            let pos = [camera.position.x, camera.position.y, camera.position.z];
                            let mut mobs_active = 0u32;
                            let mut mobs_nearby = 0u32;
                            let nearby_radius_sq = 64.0_f32 * 64.0_f32;
                            for mob in &self.mobs {
                                if mob.dead || mob.dimension != self.active_dimension {
                                    continue;
                                }
                                mobs_active += 1;
                                let dx = mob.x as f32 - camera.position.x;
                                let dy = mob.y as f32 - camera.position.y;
                                let dz = mob.z as f32 - camera.position.z;
                                if dx * dx + dy * dy + dz * dz <= nearby_radius_sq {
                                    mobs_nearby += 1;
                                }
                            }
                            let _ = respond_to.send(protocol::event_state(
                                req.id,
                                tick,
                                self.active_dimension.as_str(),
                                pos,
                                camera.yaw,
                                camera.pitch,
                                self.player_health.current,
                                self.player_health.hunger,
                                self.mobs.len() as u32,
                                mobs_active,
                                mobs_nearby,
                            ));
                        }
                        protocol::Request::Step(req) => {
                            let _ = respond_to.send(protocol::event_error(
                                req.id,
                                protocol::ErrorCode::Unsupported,
                                "step is only available in headless step mode",
                            ));
                        }
                        protocol::Request::Screenshot(req) => {
                            if self.renderer.device().is_none() {
                                let _ = respond_to.send(protocol::event_error(
                                    req.id,
                                    protocol::ErrorCode::Unsupported,
                                    "render disabled",
                                ));
                            } else if let Some(runtime) = self.screenshot.as_mut() {
                                runtime.pending.push_back(ScreenshotJob {
                                    kind: ScreenshotJobKind::Manual {
                                        id: req.id,
                                        respond_to,
                                    },
                                    tag: req.tag,
                                });
                            } else {
                                let _ = respond_to.send(protocol::event_error(
                                    req.id,
                                    protocol::ErrorCode::Unsupported,
                                    "screenshots disabled (set --screenshot-dir)",
                                ));
                            }
                        }
                        protocol::Request::Shutdown(req) => {
                            self.pending_action = Some(GameAction::Quit);
                            let _ = respond_to.send(protocol::event_ok(req.id));
                        }
                        other => {
                            let _ = respond_to.send(protocol::event_error(
                                other.request_id(),
                                protocol::ErrorCode::Unsupported,
                                "request not supported",
                            ));
                        }
                    },
                },
                Err(std::sync::mpsc::TryRecvError::Empty) => break,
                Err(std::sync::mpsc::TryRecvError::Disconnected) => {
                    if let Some(runtime) = self.automation.as_mut() {
                        runtime.connected = false;
                        runtime.held = AutomationHeldInput::default();
                        runtime.pulses = AutomationPulseInput::default();
                    }
                    break;
                }
            }
        }
    }

    fn apply_automation_input(&mut self) {
        let Some(runtime) = self.automation.as_mut() else {
            return;
        };
        if !runtime.connected {
            return;
        }

        use winit::keyboard::KeyCode;

        self.input.context = InputContext::Gameplay;
        self.input.cursor_captured = true;
        self.input.keys_pressed.clear();
        self.input.keys_just_pressed.clear();
        self.input.mouse_buttons.clear();
        self.input.mouse_clicks.clear();
        self.input.mouse_delta = (0.0, 0.0);
        self.input.raw_mouse_delta = (0.0, 0.0);
        self.input.scroll_delta = 0.0;

        if runtime.held.move_y > 0.5 {
            self.input.keys_pressed.insert(KeyCode::KeyW);
        } else if runtime.held.move_y < -0.5 {
            self.input.keys_pressed.insert(KeyCode::KeyS);
        }

        if runtime.held.move_x > 0.5 {
            self.input.keys_pressed.insert(KeyCode::KeyD);
        } else if runtime.held.move_x < -0.5 {
            self.input.keys_pressed.insert(KeyCode::KeyA);
        }

        if runtime.held.move_z > 0.5 {
            self.input.keys_pressed.insert(KeyCode::Space);
        } else if runtime.held.move_z < -0.5 {
            self.input.keys_pressed.insert(KeyCode::ShiftLeft);
        }

        if runtime.held.sprint {
            self.input.keys_pressed.insert(KeyCode::ControlLeft);
        }
        if runtime.held.crouch {
            self.input.keys_pressed.insert(KeyCode::ShiftLeft);
        }
        if runtime.held.jump_hold {
            self.input.keys_pressed.insert(KeyCode::Space);
        }

        if runtime.held.attack_hold {
            self.input.mouse_buttons.insert(MouseButton::Left);
        }
        if runtime.held.use_hold {
            self.input.mouse_buttons.insert(MouseButton::Right);
        }

        if runtime.pulses.jump_click {
            self.input.keys_pressed.insert(KeyCode::Space);
            self.input.keys_just_pressed.insert(KeyCode::Space);
        }
        if runtime.pulses.attack_click {
            self.input.mouse_buttons.insert(MouseButton::Left);
            self.input.mouse_clicks.insert(MouseButton::Left);
        }
        if runtime.pulses.use_click {
            self.input.mouse_buttons.insert(MouseButton::Right);
            self.input.mouse_clicks.insert(MouseButton::Right);
        }
        if let Some(slot) = runtime.pulses.hotbar_slot {
            if let Some(key) = match slot {
                0 => Some(KeyCode::Digit1),
                1 => Some(KeyCode::Digit2),
                2 => Some(KeyCode::Digit3),
                3 => Some(KeyCode::Digit4),
                4 => Some(KeyCode::Digit5),
                5 => Some(KeyCode::Digit6),
                6 => Some(KeyCode::Digit7),
                7 => Some(KeyCode::Digit8),
                8 => Some(KeyCode::Digit9),
                _ => None,
            } {
                self.input.keys_pressed.insert(key);
                self.input.keys_just_pressed.insert(key);
            }
        }

        runtime.pulses = AutomationPulseInput::default();
    }

    fn process_actions(&mut self, dt: f32) {
        let automation_connected = self.automation.as_ref().is_some_and(|rt| rt.connected);
        let actions = if automation_connected {
            let snapshot = self.input.snapshot_view();
            self.input_processor.process(&snapshot)
        } else if let Some(player) = self.scripted_input.as_mut() {
            player.advance(dt)
        } else {
            let snapshot = self.input.snapshot_view();
            self.input_processor.process(&snapshot)
        };
        self.apply_actions(&actions);
        self.actions = actions;
    }

    fn apply_actions(&mut self, actions: &ActionState) {
        if actions.toggle_cursor {
            if self.input.cursor_captured {
                self.enter_ui_overlay();
            } else {
                self.enter_gameplay();
            }
        }

        if actions.toggle_fly {
            self.player_physics.toggle_physics();
            tracing::info!(
                "Physics mode: {}",
                if self.player_physics.physics_enabled {
                    "ENABLED"
                } else {
                    "DISABLED (fly mode)"
                }
            );
        }

        if actions.context != InputContext::Gameplay {
            return;
        }

        if let Some(slot) = actions.hotbar_slot {
            self.hotbar.select_slot(slot as usize);
        } else if actions.hotbar_scroll != 0 {
            self.hotbar.scroll(actions.hotbar_scroll);
        }

        if actions.drop_item {
            self.drop_selected_hotbar_item(actions.drop_stack);
        }
    }

    fn enter_menu(&mut self) {
        if let Some(window) = self.window.as_ref() {
            let _ = self.input.enter_menu(window);
        } else {
            self.input.context = InputContext::Menu;
            self.input.cursor_captured = false;
        }
    }

    fn enter_gameplay(&mut self) {
        if let Some(window) = self.window.as_ref() {
            let _ = self.input.enter_gameplay(window);
        } else {
            self.input.context = InputContext::Gameplay;
            self.input.cursor_captured = true;
        }
    }

    fn enter_ui_overlay(&mut self) {
        if let Some(window) = self.window.as_ref() {
            let _ = self.input.enter_ui_overlay(window);
        } else {
            self.input.context = InputContext::UiOverlay;
            self.input.cursor_captured = false;
        }
    }

    fn weather_intensity(&self) -> f32 {
        self.weather_blend
    }

    fn lightning_flash_intensity(&self) -> f32 {
        if self.lightning_flash_ticks == 0 {
            return 0.0;
        }

        let age = LIGHTNING_FLASH_TICKS.saturating_sub(self.lightning_flash_ticks);
        match age {
            0 => 1.0,
            1 => 0.0,
            2 => 0.7,
            3 => 0.0,
            4 => 0.4,
            5 => 0.2,
            6 => 0.1,
            _ => 0.0,
        }
    }

    fn weather_state_label(&self) -> &'static str {
        match self.weather.state {
            WeatherState::Clear => "Clear",
            WeatherState::Precipitation => "Precipitation",
            WeatherState::Thunderstorm => "Thunderstorm",
        }
    }

    fn weather_delay_ticks(
        world_seed: u64,
        tick: SimTick,
        range: std::ops::Range<u64>,
        salt: u64,
    ) -> u64 {
        let seed = world_seed ^ tick.0.wrapping_mul(0x9E37_79B9_7F4A_7C15) ^ salt;
        let mut rng = StdRng::seed_from_u64(seed);
        rng.gen_range(range)
    }

    fn tick_weather(&mut self) {
        if self.sim_tick < self.weather_next_change_tick {
            return;
        }

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xD6E8_FEB8_6659_FD93)
            ^ 0x0057_4541_5448_4552_u64;
        let mut rng = StdRng::seed_from_u64(seed);

        let delay_ticks = rng.gen_range(1200..3000); // 60..150 seconds at 20 TPS
        self.weather_next_change_tick = self.sim_tick.advance(delay_ticks);

        let target_state = match self.weather.state {
            WeatherState::Clear => {
                if rng.gen_bool(0.55) {
                    if rng.gen_bool(0.12) {
                        WeatherState::Thunderstorm
                    } else {
                        WeatherState::Precipitation
                    }
                } else {
                    WeatherState::Clear
                }
            }
            WeatherState::Precipitation => {
                let roll: f32 = rng.gen();
                if roll < 0.70 {
                    WeatherState::Clear
                } else if roll < 0.82 {
                    WeatherState::Thunderstorm
                } else {
                    WeatherState::Precipitation
                }
            }
            WeatherState::Thunderstorm => {
                let roll: f32 = rng.gen();
                if roll < 0.58 {
                    WeatherState::Precipitation
                } else if roll < 0.76 {
                    WeatherState::Thunderstorm
                } else {
                    WeatherState::Clear
                }
            }
        };

        if target_state != self.weather.state {
            let previous = self.weather.state;
            self.weather.set_state(target_state);
            tracing::info!(?previous, ?target_state, "Weather changed");
        }
    }

    fn tick_lightning(&mut self) {
        self.lightning_flash_ticks = self.lightning_flash_ticks.saturating_sub(1);

        if self.active_dimension != DimensionId::Overworld {
            return;
        }

        if !self.weather.is_thundering() {
            return;
        }

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xA24B_AED4_963E_E407)
            ^ 0x004C_4947_4854_4E47_u64; // "LIGHTNG"
        let mut rng = StdRng::seed_from_u64(seed);

        if rng.gen_ratio(1, LIGHTNING_STRIKE_CHANCE_DENOMINATOR) {
            self.lightning_flash_ticks = LIGHTNING_FLASH_TICKS;
            self.trigger_lightning_strike(&mut rng);
        }
    }

    fn trigger_lightning_strike(&mut self, rng: &mut StdRng) {
        let camera_pos = self.renderer.camera().position;
        let base_x = camera_pos.x.floor() as i32;
        let base_z = camera_pos.z.floor() as i32;

        let strike_x = base_x
            + rng.gen_range(
                -LIGHTNING_STRIKE_TARGET_RADIUS_BLOCKS..=LIGHTNING_STRIKE_TARGET_RADIUS_BLOCKS,
            );
        let strike_z = base_z
            + rng.gen_range(
                -LIGHTNING_STRIKE_TARGET_RADIUS_BLOCKS..=LIGHTNING_STRIKE_TARGET_RADIUS_BLOCKS,
            );

        let Some(top_y) = self.column_highest_non_air_y(strike_x, strike_z) else {
            return;
        };

        let strike_y = (top_y.saturating_add(1)).clamp(WORLD_MIN_Y, WORLD_MAX_Y);
        let strike_pos = (
            strike_x as f64 + 0.5,
            strike_y as f64,
            strike_z as f64 + 0.5,
        );

        self.apply_lightning_strike(strike_pos);
    }

    fn column_highest_non_air_y(&self, world_x: i32, world_z: i32) -> Option<i32> {
        let chunk_pos = ChunkPos::new(
            world_x.div_euclid(CHUNK_SIZE_X as i32),
            world_z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let chunk = self.chunks.get(&chunk_pos)?;

        let local_x = world_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = world_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        for local_y in (0..CHUNK_SIZE_Y).rev() {
            let voxel = chunk.voxel(local_x, local_y, local_z);
            if voxel.id != BLOCK_AIR {
                return Some(local_y_to_world_y(local_y));
            }
        }

        None
    }

    fn apply_lightning_strike(&mut self, strike_pos: (f64, f64, f64)) {
        let (strike_x, strike_y, strike_z) = strike_pos;
        let hit_radius_sq = LIGHTNING_HIT_RADIUS_BLOCKS * LIGHTNING_HIT_RADIUS_BLOCKS;
        let strike_block = IVec3::new(
            strike_x.floor() as i32,
            strike_y.floor() as i32,
            strike_z.floor() as i32,
        );

        let mut charged_creepers = 0usize;
        let mut hit_mobs = 0usize;

        for mob in &mut self.mobs {
            if mob.dead || mob.dimension != self.active_dimension {
                continue;
            }

            let dx = mob.x - strike_x;
            let dy = mob.y - strike_y;
            let dz = mob.z - strike_z;
            if (dx * dx + dy * dy + dz * dz) > hit_radius_sq {
                continue;
            }

            if mob.mob_type == MobType::Creeper && !mob.charged {
                mob.charged = true;
                charged_creepers += 1;
            }

            mob.set_on_fire(u32::from(LIGHTNING_FIRE_TICKS));
            mob.damage(LIGHTNING_DAMAGE);
            hit_mobs += 1;
        }

        if self.player_state == PlayerState::Alive && !self.player_health.is_dead() {
            let camera_pos = self.renderer.camera().position;
            let dx = camera_pos.x as f64 - strike_x;
            let dy = camera_pos.y as f64 - strike_y;
            let dz = camera_pos.z as f64 - strike_z;
            if (dx * dx + dy * dy + dz * dz) <= hit_radius_sq {
                self.player_health.ignite(LIGHTNING_FIRE_TICKS);
                let actual_damage = self
                    .player_armor
                    .take_damage(LIGHTNING_DAMAGE, DamageKind::Generic);
                self.player_health.damage(actual_damage);
                if self.player_health.is_dead() {
                    self.handle_death("Struck by lightning");
                }
            }
        }

        let mix_i32 = |value: i32| u64::from(u32::from_le_bytes(value.to_le_bytes()));
        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xD682_61A3_49FC_3F9F)
            ^ 0x4C_4954_4649_5245_u64 // "LITFIRE"
            ^ mix_i32(strike_block.x).wrapping_mul(0x9E37_79B1)
            ^ mix_i32(strike_block.y).wrapping_mul(0x85EB_CA6B)
            ^ mix_i32(strike_block.z).wrapping_mul(0xC2B2_AE35);
        let mut rng = StdRng::seed_from_u64(seed);

        let mut changed_positions = Vec::new();
        let _ = self.try_place_fire_block(strike_block, &mut changed_positions);
        for _ in 0..LIGHTNING_FIRE_ATTEMPTS {
            let dx = rng.gen_range(-1..=1);
            let dz = rng.gen_range(-1..=1);
            let pos = strike_block + IVec3::new(dx, 0, dz);
            let _ = self.try_place_fire_block(pos, &mut changed_positions);
        }
        if !changed_positions.is_empty() {
            self.refresh_after_voxel_changes(&changed_positions);
        }

        if hit_mobs > 0 || charged_creepers > 0 {
            tracing::debug!(
                x = strike_x,
                y = strike_y,
                z = strike_z,
                hit_mobs,
                charged_creepers,
                "Lightning strike applied"
            );
        }
    }

    fn tick_ice_freezing(&mut self) -> std::collections::BTreeSet<ChunkPos> {
        let mut frozen_chunks = std::collections::BTreeSet::new();
        let mut removed_fluids = Vec::new();

        if self.active_dimension != DimensionId::Overworld {
            return frozen_chunks;
        }

        let is_precipitating = self.weather.is_precipitating();
        let (interval_ticks, attempts_per_interval) = if is_precipitating {
            (ICE_FREEZE_INTERVAL_TICKS, ICE_FREEZE_ATTEMPTS_PER_INTERVAL)
        } else {
            (
                ICE_FREEZE_CLEAR_INTERVAL_TICKS,
                ICE_FREEZE_CLEAR_ATTEMPTS_PER_INTERVAL,
            )
        };

        if !self.sim_tick.0.is_multiple_of(interval_ticks) {
            return frozen_chunks;
        }

        let camera_pos = self.renderer.camera().position;
        let base_x = camera_pos.x.floor() as i32;
        let base_z = camera_pos.z.floor() as i32;

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xB2D1_8D9E_84C9_1A77)
            ^ 0x0046_5245_455A_455F_u64; // "FREEZE_"
        let mut rng = StdRng::seed_from_u64(seed);

        let biome_assigner = self.terrain_generator.biome_assigner();

        for _attempt in 0..attempts_per_interval {
            let x = base_x + rng.gen_range(-ICE_FREEZE_RADIUS_BLOCKS..=ICE_FREEZE_RADIUS_BLOCKS);
            let z = base_z + rng.gen_range(-ICE_FREEZE_RADIUS_BLOCKS..=ICE_FREEZE_RADIUS_BLOCKS);

            let Some(top_y) = self.column_highest_non_air_y(x, z) else {
                continue;
            };

            let biome = biome_assigner.get_blended_biome(x, z, 2);
            let elevation_bias = ((top_y as f32 - 64.0).max(0.0) / 600.0).clamp(0.0, 1.0);
            let effective_temperature = biome.temperature - elevation_bias;

            // Vanilla-ish: ice forms in cold biomes (faster while snowing).
            if effective_temperature >= 0.25 {
                continue;
            }

            let chunk_pos = ChunkPos::new(
                x.div_euclid(CHUNK_SIZE_X as i32),
                z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                continue;
            };
            let Some(local_y) = world_y_to_local_y(top_y) else {
                continue;
            };
            let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

            let voxel = chunk.voxel(local_x, local_y, local_z);
            if voxel.id != BLOCK_WATER {
                continue;
            }
            if voxel.light_block > WEATHER_ACCUMULATION_MAX_BLOCK_LIGHT {
                continue;
            }

            // Replace the topmost water source with ice.
            chunk.set_voxel(
                local_x,
                local_y,
                local_z,
                Voxel {
                    id: BLOCK_ICE,
                    state: 0,
                    ..voxel
                },
            );
            frozen_chunks.insert(chunk_pos);
            removed_fluids.push(FluidPos::new(x, top_y, z));
        }

        for pos in removed_fluids {
            self.fluid_sim.on_fluid_removed(pos, &self.chunks);
        }

        frozen_chunks
    }

    fn tick_snow_accumulation(&mut self) -> std::collections::BTreeSet<ChunkPos> {
        let mut snowy_chunks = std::collections::BTreeSet::new();

        if self.active_dimension != DimensionId::Overworld {
            return snowy_chunks;
        }

        if !self.weather.is_precipitating() {
            return snowy_chunks;
        }

        if !self
            .sim_tick
            .0
            .is_multiple_of(SNOW_ACCUMULATION_INTERVAL_TICKS)
        {
            return snowy_chunks;
        }

        let camera_pos = self.renderer.camera().position;
        let base_x = camera_pos.x.floor() as i32;
        let base_z = camera_pos.z.floor() as i32;

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xC0EE_D00D_8F9B_1A21)
            ^ 0x0053_4E4F_5741_4343_u64; // "SNOWACC"
        let mut rng = StdRng::seed_from_u64(seed);

        let biome_assigner = self.terrain_generator.biome_assigner();

        for _attempt in 0..SNOW_ACCUMULATION_ATTEMPTS_PER_INTERVAL {
            let x = base_x
                + rng.gen_range(-SNOW_ACCUMULATION_RADIUS_BLOCKS..=SNOW_ACCUMULATION_RADIUS_BLOCKS);
            let z = base_z
                + rng.gen_range(-SNOW_ACCUMULATION_RADIUS_BLOCKS..=SNOW_ACCUMULATION_RADIUS_BLOCKS);

            let Some(top_y) = self.column_highest_non_air_y(x, z) else {
                continue;
            };

            let biome = biome_assigner.get_blended_biome(x, z, 2);
            let elevation_bias = ((top_y as f32 - 64.0).max(0.0) / 600.0).clamp(0.0, 1.0);
            let effective_temperature = biome.temperature - elevation_bias;
            if effective_temperature >= 0.25 {
                continue;
            }

            let chunk_pos = ChunkPos::new(
                x.div_euclid(CHUNK_SIZE_X as i32),
                z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let Some(chunk) = self.chunks.get(&chunk_pos) else {
                continue;
            };
            let Some(local_y) = world_y_to_local_y(top_y) else {
                continue;
            };
            let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            let voxel = chunk.voxel(local_x, local_y, local_z);

            if voxel.id == BLOCK_WATER {
                continue;
            }

            if voxel.id == BLOCK_SNOW {
                let layers = mdminecraft_world::snow_layers(voxel.state);
                if layers < mdminecraft_world::SNOW_LAYERS_MAX {
                    let place_y = top_y + 1;
                    let Some(place_local_y) = world_y_to_local_y(place_y) else {
                        continue;
                    };
                    let above = chunk.voxel(local_x, place_local_y, local_z);
                    if above.id != BLOCK_AIR {
                        continue;
                    }
                    if above.light_block > WEATHER_ACCUMULATION_MAX_BLOCK_LIGHT {
                        continue;
                    }

                    let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                        continue;
                    };
                    chunk.set_voxel(
                        local_x,
                        local_y,
                        local_z,
                        Voxel {
                            state: mdminecraft_world::set_snow_layers(
                                voxel.state,
                                layers.saturating_add(1),
                            ),
                            ..voxel
                        },
                    );
                    snowy_chunks.insert(chunk_pos);
                    continue;
                }
            }

            let Some(top_offset) = Self::voxel_collision_top_offset(&self.block_properties, &voxel)
            else {
                continue;
            };
            if !(0.999..=1.001).contains(&top_offset) {
                continue;
            }

            let place_y = top_y + 1;
            let Some(place_local_y) = world_y_to_local_y(place_y) else {
                continue;
            };
            let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                continue;
            };
            let above = chunk.voxel(local_x, place_local_y, local_z);
            if above.id != BLOCK_AIR {
                continue;
            }
            if above.light_block > WEATHER_ACCUMULATION_MAX_BLOCK_LIGHT {
                continue;
            }

            chunk.set_voxel(
                local_x,
                place_local_y,
                local_z,
                Voxel {
                    id: BLOCK_SNOW,
                    state: mdminecraft_world::set_snow_layers(0, 1),
                    ..above
                },
            );
            snowy_chunks.insert(chunk_pos);
        }

        snowy_chunks
    }

    fn tick_weather_melting(&mut self) -> std::collections::BTreeSet<ChunkPos> {
        let mut melted_chunks = std::collections::BTreeSet::new();
        let mut placed_fluids = Vec::new();

        if self.active_dimension != DimensionId::Overworld {
            return melted_chunks;
        }

        if !self.sim_tick.0.is_multiple_of(WEATHER_MELT_INTERVAL_TICKS) {
            return melted_chunks;
        }

        let camera_pos = self.renderer.camera().position;
        let base_x = camera_pos.x.floor() as i32;
        let base_z = camera_pos.z.floor() as i32;

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xE5A1_47B1_0C8D_5F33)
            ^ 0x004D_454C_545F_5F5F_u64; // "MELT__"
        let mut rng = StdRng::seed_from_u64(seed);
        let biome_assigner = self.terrain_generator.biome_assigner();

        for _attempt in 0..WEATHER_MELT_ATTEMPTS_PER_INTERVAL {
            let x =
                base_x + rng.gen_range(-WEATHER_MELT_RADIUS_BLOCKS..=WEATHER_MELT_RADIUS_BLOCKS);
            let z =
                base_z + rng.gen_range(-WEATHER_MELT_RADIUS_BLOCKS..=WEATHER_MELT_RADIUS_BLOCKS);

            let Some(top_y) = self.column_highest_non_air_y(x, z) else {
                continue;
            };

            let biome = biome_assigner.get_blended_biome(x, z, 2);
            let elevation_bias = ((top_y as f32 - 64.0).max(0.0) / 600.0).clamp(0.0, 1.0);
            let effective_temperature = biome.temperature - elevation_bias;
            let warm_enough_for_sun_melt = effective_temperature >= 0.25;

            let chunk_pos = ChunkPos::new(
                x.div_euclid(CHUNK_SIZE_X as i32),
                z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                continue;
            };
            let Some(local_y) = world_y_to_local_y(top_y) else {
                continue;
            };
            let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            let voxel = chunk.voxel(local_x, local_y, local_z);

            let strong_block_light = voxel.light_block > WEATHER_ACCUMULATION_MAX_BLOCK_LIGHT;
            let effective_skylight = self.sim_time.effective_skylight() as u16;
            let scaled_sky = ((voxel.light_sky as u16) * effective_skylight + 7) / 15;
            let strong_sky_light = scaled_sky > u16::from(WEATHER_ACCUMULATION_MAX_BLOCK_LIGHT);

            if !(strong_block_light || (strong_sky_light && warm_enough_for_sun_melt)) {
                continue;
            }

            match voxel.id {
                BLOCK_ICE => {
                    chunk.set_voxel(
                        local_x,
                        local_y,
                        local_z,
                        Voxel {
                            id: BLOCK_WATER,
                            state: 0,
                            ..voxel
                        },
                    );
                    melted_chunks.insert(chunk_pos);
                    placed_fluids.push(FluidPos::new(x, top_y, z));
                }
                BLOCK_SNOW => {
                    let layers = mdminecraft_world::snow_layers(voxel.state);
                    if layers <= 1 {
                        chunk.set_voxel(
                            local_x,
                            local_y,
                            local_z,
                            Voxel {
                                id: BLOCK_AIR,
                                state: 0,
                                ..voxel
                            },
                        );
                        melted_chunks.insert(chunk_pos);
                    } else {
                        chunk.set_voxel(
                            local_x,
                            local_y,
                            local_z,
                            Voxel {
                                state: mdminecraft_world::set_snow_layers(
                                    voxel.state,
                                    layers.saturating_sub(1),
                                ),
                                ..voxel
                            },
                        );
                        melted_chunks.insert(chunk_pos);
                    }
                }
                _ => {}
            }
        }

        for pos in placed_fluids {
            self.fluid_sim.on_fluid_placed(pos, FluidType::Water);
        }

        melted_chunks
    }

    fn tick_fire_decay_and_spread(&mut self) -> std::collections::BTreeSet<ChunkPos> {
        let mut dirty_chunks = std::collections::BTreeSet::new();
        let mut geometry_changes = Vec::new();

        if !self.sim_tick.0.is_multiple_of(FIRE_TICK_INTERVAL_TICKS) {
            return dirty_chunks;
        }

        // Vanilla-ish: rain generally prevents fire from spreading and tends to extinguish it.
        // Block extinguish is handled by `tick_fire_extinguish`.
        if self.active_dimension == DimensionId::Overworld && self.weather.is_precipitating() {
            return dirty_chunks;
        }

        let camera_pos = self.renderer.camera().position;
        let base_x = camera_pos.x.floor() as i32;
        let base_z = camera_pos.z.floor() as i32;

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0xA2B7_E2D3_6C04_19B1)
            ^ 0x4649_5245_5449_434B_u64; // "FIRETICK"
        let mut rng = StdRng::seed_from_u64(seed);

        let chunk_and_local = |pos: IVec3| -> Option<(ChunkPos, usize, usize, usize)> {
            let local_y = world_y_to_local_y(pos.y)?;
            let chunk_pos = ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            Some((chunk_pos, local_x, local_y, local_z))
        };

        for _attempt in 0..FIRE_TICK_ATTEMPTS_PER_INTERVAL {
            let x = base_x + rng.gen_range(-FIRE_TICK_RADIUS_BLOCKS..=FIRE_TICK_RADIUS_BLOCKS);
            let z = base_z + rng.gen_range(-FIRE_TICK_RADIUS_BLOCKS..=FIRE_TICK_RADIUS_BLOCKS);

            let Some(top_y) = self.column_highest_non_air_y(x, z) else {
                continue;
            };

            let fire_pos = IVec3::new(x, top_y, z);
            let Some((chunk_pos, local_x, local_y, local_z)) = chunk_and_local(fire_pos) else {
                continue;
            };

            let Some(fire_voxel) = self
                .chunks
                .get(&chunk_pos)
                .map(|chunk| chunk.voxel(local_x, local_y, local_z))
            else {
                continue;
            };
            if fire_voxel.id != mdminecraft_world::BLOCK_FIRE {
                continue;
            }

            let support_pos = IVec3::new(fire_pos.x, fire_pos.y - 1, fire_pos.z);
            let Some(support_voxel) = self.get_voxel_at(support_pos) else {
                continue;
            };
            if !self.block_properties.get(support_voxel.id).is_solid {
                // Should be rare due to support checks, but keep stable if it happens.
                if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                    chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
                }
                geometry_changes.push(fire_pos);
                dirty_chunks.insert(chunk_pos);
                continue;
            }

            let mut has_fuel = mdminecraft_world::is_flammable(support_voxel.id);
            if !has_fuel {
                for (dx, dz) in [(1, 0), (-1, 0), (0, 1), (0, -1)] {
                    let neighbor_support =
                        IVec3::new(fire_pos.x + dx, fire_pos.y - 1, fire_pos.z + dz);
                    let Some(neighbor_voxel) = self.get_voxel_at(neighbor_support) else {
                        continue;
                    };
                    if mdminecraft_world::is_flammable(neighbor_voxel.id) {
                        has_fuel = true;
                        break;
                    }
                }
            }

            let current_age = mdminecraft_world::fire_age(fire_voxel.state);
            let next_age = current_age
                .saturating_add(1)
                .min(mdminecraft_world::FIRE_AGE_MAX);

            if !has_fuel && next_age >= FIRE_DECAY_AGE_THRESHOLD {
                if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                    chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
                }
                geometry_changes.push(fire_pos);
                dirty_chunks.insert(chunk_pos);
                continue;
            }

            let new_state = mdminecraft_world::set_fire_age(fire_voxel.state, next_age);
            if new_state != fire_voxel.state {
                if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                    chunk.set_voxel(
                        local_x,
                        local_y,
                        local_z,
                        Voxel {
                            state: new_state,
                            ..fire_voxel
                        },
                    );
                }
                dirty_chunks.insert(chunk_pos);
            }

            if mdminecraft_world::is_flammable(support_voxel.id)
                && next_age >= FIRE_BURN_SUPPORT_AGE_THRESHOLD
            {
                let Some((support_chunk_pos, support_x, support_y, support_z)) =
                    chunk_and_local(support_pos)
                else {
                    continue;
                };
                if let Some(chunk) = self.chunks.get_mut(&support_chunk_pos) {
                    chunk.set_voxel(support_x, support_y, support_z, Voxel::default());
                }
                geometry_changes.push(support_pos);
                dirty_chunks.insert(support_chunk_pos);
                continue;
            }

            if !mdminecraft_world::is_flammable(support_voxel.id) {
                continue;
            }

            for (dx, dz) in [(1, 0), (-1, 0), (0, 1), (0, -1)] {
                if !rng.gen_ratio(1, FIRE_SPREAD_CHANCE_DENOMINATOR) {
                    continue;
                }

                let target_pos = IVec3::new(fire_pos.x + dx, fire_pos.y, fire_pos.z + dz);
                let target_support = IVec3::new(target_pos.x, target_pos.y - 1, target_pos.z);
                let Some(target_support_voxel) = self.get_voxel_at(target_support) else {
                    continue;
                };
                if !mdminecraft_world::is_flammable(target_support_voxel.id) {
                    continue;
                }

                if self.try_place_fire_block(target_pos, &mut geometry_changes) {
                    dirty_chunks.insert(ChunkPos::new(
                        target_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                        target_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                    ));
                }
            }
        }

        if geometry_changes.is_empty() {
            return dirty_chunks;
        }

        let support_changes = Self::remove_unsupported_blocks(
            &mut self.chunks,
            &self.block_properties,
            geometry_changes.iter().copied(),
        );

        for (pos, removed_id) in support_changes.removed {
            dirty_chunks.insert(ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            ));
            self.on_block_entity_removed(pos, removed_id);
            self.schedule_redstone_updates_around(pos);
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
        }
        for pos in support_changes.moved {
            dirty_chunks.insert(ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            ));
            self.schedule_redstone_updates_around(pos);
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
        }

        for pos in geometry_changes {
            self.schedule_redstone_updates_around(pos);
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
        }

        dirty_chunks
    }

    fn tick_fire_extinguish(&mut self) -> std::collections::BTreeSet<ChunkPos> {
        let mut dirty_chunks = std::collections::BTreeSet::new();

        if self.active_dimension != DimensionId::Overworld {
            return dirty_chunks;
        }
        if !self.weather.is_precipitating() {
            return dirty_chunks;
        }
        if !self
            .sim_tick
            .0
            .is_multiple_of(FIRE_EXTINGUISH_INTERVAL_TICKS)
        {
            return dirty_chunks;
        }

        let camera_pos = self.renderer.camera().position;
        let base_x = camera_pos.x.floor() as i32;
        let base_z = camera_pos.z.floor() as i32;

        let seed = self.world_seed
            ^ self.sim_tick.0.wrapping_mul(0x6A5D_39E3_2C1B_8C71)
            ^ 0x4649_5245_5845_545F_u64; // "FIREXET_"
        let mut rng = StdRng::seed_from_u64(seed);
        let biome_assigner = self.terrain_generator.biome_assigner();

        for _attempt in 0..FIRE_EXTINGUISH_ATTEMPTS_PER_INTERVAL {
            let x = base_x
                + rng.gen_range(-FIRE_EXTINGUISH_RADIUS_BLOCKS..=FIRE_EXTINGUISH_RADIUS_BLOCKS);
            let z = base_z
                + rng.gen_range(-FIRE_EXTINGUISH_RADIUS_BLOCKS..=FIRE_EXTINGUISH_RADIUS_BLOCKS);

            let Some(top_y) = self.column_highest_non_air_y(x, z) else {
                continue;
            };

            let biome = biome_assigner.get_blended_biome(x, z, 2);
            if biome.id == BiomeId::Desert {
                continue;
            }

            let chunk_pos = ChunkPos::new(
                x.div_euclid(CHUNK_SIZE_X as i32),
                z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                continue;
            };
            let Some(local_y) = world_y_to_local_y(top_y) else {
                continue;
            };
            let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

            let voxel = chunk.voxel(local_x, local_y, local_z);
            if voxel.id != mdminecraft_world::BLOCK_FIRE {
                continue;
            }
            if !Self::column_is_clear_to_sky(chunk, local_x, local_y, local_z) {
                continue;
            }

            chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
            dirty_chunks.insert(chunk_pos);
        }

        dirty_chunks
    }

    fn update_weather(&mut self, dt: f32) {
        if self.weather.is_precipitating()
            && self.active_dimension == DimensionId::Overworld
            && !self.is_camera_underwater(self.renderer.camera().position)
        {
            self.spawn_precipitation_particles(dt);
        } else {
            self.precipitation_accumulator = 0.0;
        }

        // Smoothly blend precipitation intensity for shaders/HUD
        let target = if self.weather.is_precipitating() {
            1.0
        } else {
            0.0
        };
        let smoothing = 1.0 - (-dt * 3.0).exp();
        self.weather_blend += (target - self.weather_blend) * smoothing;
    }

    fn spawn_precipitation_particles(&mut self, dt: f32) {
        let camera_pos = self.renderer.camera().position;
        let sample_x = camera_pos.x.floor() as i32;
        let sample_z = camera_pos.z.floor() as i32;
        let biome = self
            .terrain_generator
            .biome_assigner()
            .get_blended_biome(sample_x, sample_z, 2);
        if biome.id == BiomeId::Desert {
            // Vanilla deserts do not precipitate even while global weather is rainy.
            self.precipitation_accumulator = 0.0;
            return;
        }

        self.precipitation_accumulator += PRECIPITATION_SPAWN_RATE * dt;
        let elevation_bias = ((camera_pos.y - 64.0).max(0.0) / 600.0).clamp(0.0, 1.0);
        let effective_temperature = biome.temperature - elevation_bias;
        let is_snow = effective_temperature < 0.25;

        while self.precipitation_accumulator >= 1.0 {
            self.precipitation_accumulator -= 1.0;

            let offset_x = self
                .rng
                .gen_range(-PRECIPITATION_RADIUS..PRECIPITATION_RADIUS);
            let offset_z = self
                .rng
                .gen_range(-PRECIPITATION_RADIUS..PRECIPITATION_RADIUS);
            let spawn_height =
                camera_pos.y + PRECIPITATION_CEILING_OFFSET + self.rng.gen_range(0.0..4.0);
            let position = glam::Vec3::new(
                camera_pos.x + offset_x,
                spawn_height,
                camera_pos.z + offset_z,
            );

            // Suppress precipitation under cover: if there's a block between the camera and the
            // particle spawn height, that drop would hit a roof before reaching the player.
            let column_x = position.x.floor() as i32;
            let column_z = position.z.floor() as i32;
            let start_y = (camera_pos.y.floor() as i32 + 1).clamp(WORLD_MIN_Y, WORLD_MAX_Y);
            let end_y = (spawn_height.floor() as i32).clamp(start_y, WORLD_MAX_Y);
            let mut blocked = false;
            for y in start_y..=end_y {
                if self
                    .get_block_at(IVec3::new(column_x, y, column_z))
                    .is_some_and(|id| id != BLOCK_AIR)
                {
                    blocked = true;
                    break;
                }
            }
            if blocked {
                continue;
            }

            let wind = glam::Vec3::new(
                self.rng.gen_range(-2.0..2.0),
                0.0,
                self.rng.gen_range(-2.0..2.0),
            );

            let (velocity, color, lifetime, scale, gravity) = if is_snow {
                (
                    glam::Vec3::new(wind.x * 0.4, -5.0, wind.z * 0.4),
                    glam::Vec4::new(0.95, 0.97, 1.0, 0.9),
                    self.rng.gen_range(2.5..3.5),
                    self.rng.gen_range(6.0..10.0),
                    6.0,
                )
            } else {
                (
                    glam::Vec3::new(wind.x * 0.2, -28.0, wind.z * 0.2),
                    glam::Vec4::new(0.5, 0.65, 1.0, 0.6),
                    self.rng.gen_range(1.0..1.6),
                    self.rng.gen_range(5.0..7.0),
                    38.0,
                )
            };

            self.particles.push(ParticleInstance::new(
                position, velocity, color, lifetime, scale, gravity,
            ));
        }

        self.enforce_particle_budget();
    }

    /// Apply Mending enchantment effect: use XP to repair tools with Mending.
    ///
    /// Returns the amount of XP that should go to the player (after Mending uses some).
    /// In vanilla Minecraft, 1 XP restores 2 durability.
    fn apply_mending(&mut self, xp_amount: u32) -> u32 {
        let mut remaining_xp = xp_amount;

        // Check each hotbar slot for tools with Mending that need repair
        for slot in &mut self.hotbar.slots {
            if remaining_xp == 0 {
                break;
            }

            if let Some(stack) = slot {
                // Only process tools with durability and Mending enchantment
                if let Some(current_dur) = stack.durability {
                    if stack.has_enchantment(EnchantmentType::Mending) {
                        // Calculate max durability for this tool
                        let max_dur = stack.max_durability().unwrap_or(0);

                        if current_dur < max_dur {
                            // Each XP restores 2 durability
                            let missing_dur = max_dur - current_dur;
                            let xp_needed = missing_dur.div_ceil(2); // Ceiling division
                            let xp_to_use = remaining_xp.min(xp_needed);
                            let dur_restored = xp_to_use * 2;

                            // Apply repair
                            stack.durability = Some((current_dur + dur_restored).min(max_dur));
                            remaining_xp -= xp_to_use;

                            tracing::debug!(
                                "Mending restored {} durability to {:?} (used {} XP)",
                                dur_restored,
                                stack.item_type,
                                xp_to_use
                            );
                        }
                    }
                }
            }
        }

        // Repair equipped armor with Mending (vanilla-ish; simplified deterministic order).
        remaining_xp = self.player_armor.repair_with_mending(remaining_xp);

        remaining_xp
    }

    fn spawn_block_break_particles(&mut self, block_center: glam::Vec3, block_id: BlockId) {
        if block_id == BLOCK_AIR {
            return;
        }

        let color = self.block_color(block_id);
        for _ in 0..24 {
            let offset = glam::Vec3::new(
                self.rng.gen_range(-0.45..0.45),
                self.rng.gen_range(-0.45..0.45),
                self.rng.gen_range(-0.45..0.45),
            );
            let velocity = glam::Vec3::new(
                self.rng.gen_range(-2.2..2.2),
                self.rng.gen_range(1.6..4.0),
                self.rng.gen_range(-2.2..2.2),
            );
            let lifetime = self.rng.gen_range(0.6..1.2);
            let scale = self.rng.gen_range(5.0..9.0);
            self.particles.push(ParticleInstance::new(
                block_center + offset,
                velocity,
                color,
                lifetime,
                scale,
                14.0,
            ));
        }

        self.enforce_particle_budget();
    }

    fn block_color(&self, block_id: BlockId) -> glam::Vec4 {
        if let Some(descriptor) = self.registry.descriptor(block_id) {
            match descriptor.name.as_str() {
                "stone" => glam::Vec4::new(0.6, 0.62, 0.66, 1.0),
                "dirt" => glam::Vec4::new(0.42, 0.28, 0.16, 1.0),
                "grass" => glam::Vec4::new(0.32, 0.62, 0.2, 1.0),
                "sand" => glam::Vec4::new(0.93, 0.86, 0.64, 1.0),
                "gravel" => glam::Vec4::new(0.55, 0.55, 0.55, 1.0),
                "water" => glam::Vec4::new(0.25, 0.35, 0.9, 0.5),
                "ice" => glam::Vec4::new(0.66, 0.82, 1.0, 0.8),
                "snow" => glam::Vec4::new(0.95, 0.95, 1.0, 1.0),
                "clay" => glam::Vec4::new(0.68, 0.64, 0.72, 1.0),
                "bedrock" => glam::Vec4::new(0.3, 0.3, 0.3, 1.0),
                _ => glam::Vec4::new(0.8, 0.8, 0.8, 1.0),
            }
        } else {
            glam::Vec4::new(0.8, 0.8, 0.8, 1.0)
        }
    }

    fn update_particles(&mut self, dt: f32) {
        for particle in &mut self.particles {
            particle.update(dt);
        }
        self.particles.retain(|particle| particle.is_alive());
    }

    fn enforce_particle_budget(&mut self) {
        if self.particles.len() > MAX_PARTICLES {
            let overflow = self.particles.len() - MAX_PARTICLES;
            self.particles.drain(0..overflow);
        }
    }

    fn populate_particle_emitter(&mut self) {
        self.particle_emitter.clear();
        for particle in &self.particles {
            if !particle.is_alive() {
                continue;
            }
            self.particle_emitter.spawn(particle.to_vertex());
        }

        // Headless-only: render simple mob markers via particles so screenshots have an
        // observable "something is there" signal even when billboard rendering is disabled.
        //
        // Note: the particle pipeline uses point rendering, and WGSL doesn't allow controlling
        // point size on all backends. To keep markers visible, we draw a small column + ring of
        // points per mob.
        if self.window.is_none() {
            const HEADLESS_MOB_MARKER_SCALE: f32 = 2.5;
            const HEADLESS_MOB_MARKER_MIN_SCALE: f32 = 1.5;
            const HEADLESS_MOB_MARKER_MAX_SCALE: f32 = 5.0;
            const HEADLESS_MOB_MARKER_REF_DIST: f32 = 48.0;
            const HEADLESS_MOB_MARKER_MAX_DIST: f32 = 128.0;
            let camera_pos = self.renderer.camera().position;
            let mut remaining = MAX_PARTICLES.saturating_sub(self.particle_emitter.vertices.len());
            for mob in &self.mobs {
                if mob.dimension != self.active_dimension || mob.dead {
                    continue;
                }

                let height: f32 = match mob.mob_type {
                    MobType::Chicken | MobType::Spider => 0.5,
                    MobType::Ghast => 4.0,
                    MobType::EnderDragon => 6.0,
                    _ => 1.8,
                };

                let color = match mob.mob_type {
                    MobType::Zombie => glam::Vec4::new(0.0, 0.5, 0.0, 0.9),
                    MobType::Skeleton => glam::Vec4::new(0.8, 0.8, 0.8, 0.9),
                    MobType::Creeper => {
                        if mob.charged {
                            glam::Vec4::new(0.2, 0.8, 1.0, 0.95)
                        } else {
                            glam::Vec4::new(0.0, 0.8, 0.0, 0.9)
                        }
                    }
                    MobType::Spider => glam::Vec4::new(0.1, 0.1, 0.1, 0.9),
                    MobType::Pig => glam::Vec4::new(1.0, 0.6, 0.6, 0.9),
                    MobType::Cow => glam::Vec4::new(0.3, 0.2, 0.1, 0.9),
                    MobType::Sheep => glam::Vec4::new(0.9, 0.9, 0.9, 0.9),
                    MobType::Chicken => glam::Vec4::new(1.0, 1.0, 1.0, 0.9),
                    MobType::Villager => glam::Vec4::new(0.7, 0.6, 0.4, 0.9),
                    MobType::EnderDragon => glam::Vec4::new(0.5, 0.0, 0.7, 0.95),
                    MobType::Blaze => glam::Vec4::new(1.0, 0.6, 0.0, 0.95),
                    MobType::Ghast => glam::Vec4::new(0.9, 0.9, 0.95, 0.9),
                };

                const COLUMN_POINTS: usize = 18;
                const RING_POINTS: usize = 12;
                const POINTS_PER_MOB: usize = COLUMN_POINTS + RING_POINTS;
                if remaining < POINTS_PER_MOB {
                    break;
                }
                remaining -= POINTS_PER_MOB;

                let mob_x = mob.x as f32;
                let mob_y = mob.y as f32;
                let mob_z = mob.z as f32;
                let mob_pos = glam::Vec3::new(mob_x, mob_y, mob_z);
                let dist = (mob_pos - camera_pos).length().max(1.0);
                if dist > HEADLESS_MOB_MARKER_MAX_DIST {
                    continue;
                }
                let marker_scale = (HEADLESS_MOB_MARKER_SCALE * (HEADLESS_MOB_MARKER_REF_DIST / dist))
                    .clamp(HEADLESS_MOB_MARKER_MIN_SCALE, HEADLESS_MOB_MARKER_MAX_SCALE);

                for i in 0..COLUMN_POINTS {
                    let t = if COLUMN_POINTS <= 1 {
                        0.0
                    } else {
                        i as f32 / (COLUMN_POINTS as f32 - 1.0)
                    };
                    let pos = glam::Vec3::new(mob_x, mob_y + t * height.max(0.5), mob_z);
                    self.particle_emitter
                        .spawn(mdminecraft_render::ParticleVertex {
                            position: pos.to_array(),
                            color: color.to_array(),
                            lifetime: 1.0,
                            scale: marker_scale,
                        });
                }

                let ring_y = mob_y + height * 0.6;
                let radius = 0.45;
                for i in 0..RING_POINTS {
                    let angle = i as f32 * std::f32::consts::TAU / (RING_POINTS as f32);
                    let pos = glam::Vec3::new(
                        mob_x + angle.cos() * radius,
                        ring_y,
                        mob_z + angle.sin() * radius,
                    );
                    self.particle_emitter
                        .spawn(mdminecraft_render::ParticleVertex {
                            position: pos.to_array(),
                            color: color.to_array(),
                            lifetime: 1.0,
                            scale: marker_scale,
                        });
                }
            }
        }
        self.debug_hud.particle_count = self.particle_emitter.vertices.len();
        self.debug_hud.particle_budget = MAX_PARTICLES;
    }

    #[cfg(feature = "ui3d_billboards")]
    fn populate_billboards(&mut self) {
        self.billboard_emitter.clear();

        if let Some(hit) = self.selected_block {
            let pos = glam::Vec3::new(
                hit.block_pos.x as f32 + 0.5,
                hit.block_pos.y as f32 + 0.5,
                hit.block_pos.z as f32 + 0.5,
            );

            self.billboard_emitter.submit(
                1,
                BillboardInstance {
                    position: pos.to_array(),
                    size: [0.6, 0.6],
                    color: [1.0, 1.0, 1.0, 0.35],
                    flags: (BillboardFlags::OVERLAY_NO_DEPTH | BillboardFlags::EMISSIVE).bits(),
                    ..Default::default()
                },
            );
        }

        // Render mobs
        for mob in &self.mobs {
            if mob.dimension != self.active_dimension || mob.dead {
                continue;
            }

            let height = match mob.mob_type {
                MobType::Chicken | MobType::Spider => 0.5,
                MobType::Ghast => 4.0,
                MobType::EnderDragon => 6.0,
                _ => 1.8,
            };

            let center_pos =
                glam::Vec3::new(mob.x as f32, mob.y as f32 + height * 0.5, mob.z as f32);

            let color = match mob.mob_type {
                MobType::Zombie => [0.0, 0.5, 0.0, 1.0],
                MobType::Skeleton => [0.8, 0.8, 0.8, 1.0],
                MobType::Creeper => {
                    if mob.charged {
                        // Charged creepers have a distinctive blue glow in vanilla; approximate via tint.
                        [0.2, 0.8, 1.0, 1.0]
                    } else {
                        [0.0, 0.8, 0.0, 1.0]
                    }
                }
                MobType::Spider => [0.1, 0.1, 0.1, 1.0],
                MobType::Pig => [1.0, 0.6, 0.6, 1.0],
                MobType::Cow => [0.3, 0.2, 0.1, 1.0],
                MobType::Sheep => [0.9, 0.9, 0.9, 1.0],
                MobType::Chicken => [1.0, 1.0, 1.0, 1.0],
                MobType::Villager => [0.7, 0.6, 0.4, 1.0],
                MobType::EnderDragon => [0.5, 0.0, 0.7, 1.0],
                MobType::Blaze => [1.0, 0.6, 0.0, 1.0],
                MobType::Ghast => [0.9, 0.9, 0.95, 1.0],
            };

            let size = match mob.mob_type {
                MobType::Chicken => [0.5, 0.5],
                MobType::Spider => [1.0, 0.5],
                MobType::EnderDragon => [3.0, 2.0],
                MobType::Ghast => [2.0, 2.0],
                _ => [0.6, 1.8],
            };

            self.billboard_emitter.submit(
                0,
                BillboardInstance {
                    position: center_pos.to_array(),
                    size,
                    color,
                    flags: 0,
                    ..Default::default()
                },
            );
        }
    }

    fn current_control_mode(&self) -> ControlMode {
        match self.actions.context {
            InputContext::Gameplay => {
                if self.player_physics.physics_enabled {
                    ControlMode::GameplayPhysics
                } else {
                    ControlMode::GameplayFly
                }
            }
            InputContext::UiOverlay => ControlMode::UiOverlay,
            InputContext::Menu => ControlMode::Menu,
        }
    }

    fn apply_mouse_look(
        camera: &mut mdminecraft_render::Camera,
        actions: &ActionState,
        controls: &ControlsConfig,
        cursor_captured: bool,
    ) {
        if !cursor_captured || actions.context != InputContext::Gameplay {
            return;
        }

        let mut look = if actions.look_delta.0.abs() > f32::EPSILON
            || actions.look_delta.1.abs() > f32::EPSILON
        {
            actions.look_delta
        } else {
            actions.raw_look_delta
        };

        let sensitivity = controls.mouse_sensitivity.max(0.0001);
        look.0 *= sensitivity;
        let invert = if controls.invert_y { -1.0 } else { 1.0 };
        look.1 = look.1 * sensitivity * invert;

        if look.0 != 0.0 || look.1 != 0.0 {
            // Note: yaw is negated in view_matrix(), so we use positive look.0 here
            // to get the expected mouse direction (move right  look right)
            camera.rotate(look.0, -look.1);
        }
    }

    fn apply_physics_movement(&mut self, actions: &ActionState, dt: f32) {
        let camera_snapshot = self.renderer.camera().clone();
        let mut camera_pos = camera_snapshot.position;
        let (forward_h, right_h) = Self::flat_directions(&camera_snapshot);

        let (eye_fluid, feet_fluid) = self.camera_eye_and_feet_fluids(camera_pos);
        let eye_in_water = eye_fluid == Some(FluidType::Water);
        let in_water = eye_in_water || feet_fluid == Some(FluidType::Water);
        let in_lava = eye_fluid == Some(FluidType::Lava) || feet_fluid == Some(FluidType::Lava);
        let depth_strider_level = if in_water {
            self.player_armor
                .total_enchantment_level(EnchantmentType::DepthStrider)
                .min(3)
        } else {
            0
        };

        let mut fall_damage: Option<f32> = None;

        {
            let physics = &mut self.player_physics;

            // Handle double-jump to toggle fly mode
            if actions.jump_pressed {
                if physics.last_jump_press_time < 0.3 {
                    physics.toggle_physics();
                    physics.last_jump_press_time = 10.0; // Reset
                    tracing::info!(
                        "Physics mode: {}",
                        if physics.physics_enabled {
                            "ENABLED"
                        } else {
                            "DISABLED (fly mode)"
                        }
                    );
                } else {
                    physics.last_jump_press_time = 0.0;
                }
            } else {
                physics.last_jump_press_time += dt;
            }

            let on_ladder = Self::aabb_touches_ladder(&self.chunks, &physics.get_aabb(camera_pos));
            if on_ladder {
                // Vanilla-ish: ladders cancel gravity and clamp vertical speed.
                let climb_speed = 3.0;
                if actions.jump {
                    physics.velocity.y = climb_speed;
                } else if actions.crouch {
                    physics.velocity.y = -climb_speed;
                } else {
                    physics.velocity.y = physics.velocity.y.clamp(-1.0, 0.0);
                }
            } else if in_water || in_lava {
                let (swim_speed, gravity_multiplier, terminal_velocity, drag) = if in_lava {
                    (2.0, 0.1, -2.0, 0.85)
                } else {
                    (4.0, 0.2, -4.0, 0.9)
                };

                // Vanilla-ish: fluids allow swimming up/down (simplified).
                if actions.jump {
                    physics.velocity.y = swim_speed;
                } else if actions.crouch {
                    physics.velocity.y = -swim_speed;
                } else {
                    physics.velocity.y += physics.gravity * gravity_multiplier * dt;
                    physics.velocity.y = physics.velocity.y.max(terminal_velocity);
                }

                physics.velocity.y *= drag;
            } else {
                // Apply gravity
                let mut gravity = physics.gravity;
                let mut terminal_velocity = physics.terminal_velocity;
                if self.status_effects.has(StatusEffectType::SlowFalling)
                    && physics.velocity.y < 0.0
                {
                    gravity *= 0.2;
                    terminal_velocity = -3.0;
                }

                physics.velocity.y += gravity * dt;
                if physics.velocity.y < terminal_velocity {
                    physics.velocity.y = terminal_velocity;
                }
            }

            // Calculate horizontal movement
            let mut axis = glam::Vec2::new(actions.move_x, actions.move_y);
            if axis.length_squared() > 1.0 {
                axis = axis.normalize();
            }

            let mut move_speed = if actions.sprint { 6.0 } else { 4.3 };
            if actions.crouch {
                move_speed *= 0.5;
            }
            move_speed *= self.status_effects.speed_multiplier();
            if in_lava {
                move_speed *= 0.3;
            } else if in_water {
                let base = 0.6;
                let bonus = 0.13 * depth_strider_level as f32;
                move_speed *= (base + bonus).min(1.0);
            }

            // Build movement velocity vector
            let mut move_velocity = glam::Vec3::ZERO;
            if axis.length_squared() > 0.0 {
                let move_dir = forward_h * axis.y + right_h * axis.x;
                move_velocity = move_dir * move_speed * dt;
            }
            move_velocity.y = physics.velocity.y * dt;

            // Get current AABB and apply movement with collision
            let current_aabb = physics.get_aabb(camera_pos);
            let (offset, new_velocity) = Self::move_with_collision(
                &self.chunks,
                &self.block_properties,
                &current_aabb,
                move_velocity,
                PlayerPhysics::STEP_HEIGHT,
            );

            camera_pos += offset;

            // Update velocity based on collision results (for Y axis mainly)
            let was_on_ground = physics.on_ground;
            let was_falling = physics.velocity.y < 0.0;

            if new_velocity.y == 0.0 && physics.velocity.y != 0.0 {
                // We hit something vertically
                if was_falling {
                    // Hit ground
                    let player_aabb = physics.get_aabb(camera_pos);
                    let ground_y = player_aabb.min.y;

                    if !was_on_ground {
                        fall_damage = Some(physics.last_ground_y - ground_y);
                    }

                    physics.on_ground = true;
                    physics.last_ground_y = ground_y;
                }
                physics.velocity.y = 0.0;
            } else {
                physics.on_ground = false;
            }

            // Check if standing on ground (for jump detection)
            let feet_check_aabb = physics
                .get_aabb(camera_pos)
                .offset(glam::Vec3::new(0.0, -0.1, 0.0));
            if Self::aabb_collides_with_world(
                &self.chunks,
                &self.block_properties,
                &feet_check_aabb,
            ) {
                physics.on_ground = true;
                physics.last_ground_y = physics.get_aabb(camera_pos).min.y;
            }

            if actions.jump && physics.on_ground && !in_water && !in_lava {
                let jump_boost = self
                    .status_effects
                    .amplifier(StatusEffectType::JumpBoost)
                    .map(|amp| 1.0 + 0.2 * (amp + 1) as f32)
                    .unwrap_or(1.0);
                physics.velocity.y = physics.jump_strength * jump_boost;
                physics.on_ground = false;
            }
        }

        if let Some(dist) = fall_damage {
            let (eye_fluid, feet_fluid) = self.camera_eye_and_feet_fluids(camera_pos);
            let in_water =
                eye_fluid == Some(FluidType::Water) || feet_fluid == Some(FluidType::Water);
            if in_water {
                // Vanilla-ish: landing in water negates fall damage.
            } else if !self.status_effects.has(StatusEffectType::SlowFalling) {
                self.calculate_fall_damage(dist);
            }
        }

        self.renderer.camera_mut().position = camera_pos;
    }

    fn apply_fly_movement(&mut self, actions: &ActionState, dt: f32) {
        // Handle double-jump to toggle fly mode (exit fly)
        if actions.jump_pressed {
            let physics = &mut self.player_physics;
            if physics.last_jump_press_time < 0.3 {
                physics.toggle_physics();
                physics.last_jump_press_time = 10.0; // Reset
                tracing::info!("Physics mode: ENABLED");
            } else {
                physics.last_jump_press_time = 0.0;
            }
        } else {
            self.player_physics.last_jump_press_time += dt;
        }

        let (forward, right, position) = {
            let camera = self.renderer.camera();
            let (f, r) = Self::flat_directions(camera);
            (f, r, camera.position)
        };

        let mut movement = glam::Vec3::ZERO;
        if actions.move_y.abs() > f32::EPSILON || actions.move_x.abs() > f32::EPSILON {
            movement += forward * actions.move_y;
            movement += right * actions.move_x;
        }
        if actions.move_z.abs() > f32::EPSILON {
            movement += glam::Vec3::Y * actions.move_z;
        }

        if movement.length_squared() > 0.0 {
            let mut speed = if actions.sprint { 20.0 } else { 10.0 };
            speed *= self.status_effects.speed_multiplier();
            let velocity = movement.normalize() * speed * dt;

            // Apply collision detection for fly mode (like original Minecraft)
            let current_aabb = self.player_physics.get_aabb(position);
            let (offset, _) = Self::move_with_collision(
                &self.chunks,
                &self.block_properties,
                &current_aabb,
                velocity,
                0.0,
            );

            self.renderer.camera_mut().position = position + offset;
        }
    }

    fn fixed_update(&mut self) {
        // Update world chunks
        self.update_chunks(1);

        // Increment tick
        self.sim_tick = self.sim_tick.advance(1);
        if !self.sim_time_paused {
            self.sim_time.advance();
        }

        let (scripted_commands, script_finished) =
            if let Some(script) = self.command_script.as_mut() {
                let commands = script.drain_ready_commands(self.sim_tick);
                let finished = script.is_finished();
                (commands, finished)
            } else {
                (Vec::new(), false)
            };
        for command in scripted_commands {
            self.run_command_line(command);
        }
        if script_finished {
            self.command_script = None;
        }

        self.tick_weather();
        self.tick_lightning();
        let dt = TICK_RATE as f32;

        // Tick player survival systems (deterministic, once per sim tick).
        self.tick_player_survival(dt);

        // Update dropped items and handle pickup
        self.update_dropped_items();

        // Update furnaces
        self.update_furnaces(dt);

        // Update brewing stands
        self.update_brewing_stands(dt);

        // Update mobs
        self.update_mobs(dt);

        let mut mesh_refresh = std::collections::BTreeSet::new();

        // Update farming (crops + farmland hydration).
        self.crop_growth.tick(self.sim_tick.0, &mut self.chunks);
        for chunk_pos in self.crop_growth.take_dirty_chunks() {
            mesh_refresh.insert(chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(chunk_pos) {
                mesh_refresh.insert(neighbor);
            }
        }

        // Update sugar cane growth.
        self.sugar_cane_growth
            .tick(self.sim_tick.0, &mut self.chunks);
        for chunk_pos in self.sugar_cane_growth.take_dirty_chunks() {
            mesh_refresh.insert(chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(chunk_pos) {
                mesh_refresh.insert(neighbor);
            }
        }

        // Update fluids
        self.fluid_sim.tick(&mut self.chunks);
        let dirty_fluids = self.fluid_sim.take_dirty_chunks();
        let dirty_fluid_lighting = self.fluid_sim.take_dirty_light_chunks();
        for chunk_pos in dirty_fluids {
            mesh_refresh.extend(self.recompute_skylight_local(chunk_pos));
            mesh_refresh.insert(chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(chunk_pos) {
                mesh_refresh.insert(neighbor);
            }
        }
        for chunk_pos in dirty_fluid_lighting {
            let affected = mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                chunk_pos,
            );
            mesh_refresh.extend(affected);
        }

        // Vanilla-ish weather: water can freeze into ice, snow can accumulate, and both melt under strong block-light.
        let mut dirty_weather_geometry_chunks = self.tick_ice_freezing();
        dirty_weather_geometry_chunks.extend(self.tick_snow_accumulation());
        dirty_weather_geometry_chunks.extend(self.tick_weather_melting());
        dirty_weather_geometry_chunks.extend(self.tick_fire_decay_and_spread());
        dirty_weather_geometry_chunks.extend(self.tick_fire_extinguish());

        for chunk_pos in &dirty_weather_geometry_chunks {
            mesh_refresh.extend(self.recompute_skylight_local(*chunk_pos));
            mesh_refresh.insert(*chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(*chunk_pos) {
                mesh_refresh.insert(neighbor);
            }
        }
        for chunk_pos in dirty_weather_geometry_chunks {
            let affected = mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                chunk_pos,
            );
            mesh_refresh.extend(affected);
        }

        // Update redstone
        self.update_pressure_plates();
        self.redstone_sim.tick(&mut self.chunks);
        let dirty_redstone_geometry_positions = self.redstone_sim.take_dirty_geometry_positions();
        let dirty_redstone_geometry_chunks = self.redstone_sim.take_dirty_geometry_chunks();
        let dirty_redstone = self.redstone_sim.take_dirty_chunks();
        let dirty_redstone_lighting = self.redstone_sim.take_dirty_light_chunks();
        for chunk_pos in dirty_redstone {
            mesh_refresh.insert(chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(chunk_pos) {
                mesh_refresh.insert(neighbor);
            }
        }

        // Piston-style block movement (and other geometry changes triggered by redstone) should
        // wake the fluid sim so water/lava reacts on the next tick.
        for pos in dirty_redstone_geometry_positions {
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
        }

        // Geometry changes can affect skylight and block-light occlusion; recompute both locally.
        for chunk_pos in &dirty_redstone_geometry_chunks {
            mesh_refresh.extend(self.recompute_skylight_local(*chunk_pos));
            mesh_refresh.insert(*chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(*chunk_pos) {
                mesh_refresh.insert(neighbor);
            }
        }
        for chunk_pos in dirty_redstone_geometry_chunks {
            let affected = mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                chunk_pos,
            );
            mesh_refresh.extend(affected);
        }

        for chunk_pos in dirty_redstone_lighting {
            let affected = mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                chunk_pos,
            );
            mesh_refresh.extend(affected);
        }
        for chunk_pos in mesh_refresh {
            let _ = self.upload_chunk_mesh(chunk_pos);
        }

        // Update hoppers (item transport). Run after redstone so lock bits are up-to-date.
        self.update_hoppers();
        self.update_dispensers_and_droppers();

        // Update projectiles (arrows)
        self.update_projectiles();

        // Portal travel (dimension switching).
        self.tick_nether_portal_travel();

        // Check for death
        if self.player_health.is_dead() && self.player_state != PlayerState::Dead {
            self.handle_death("You died!");
        }
    }

    fn tick_player_survival(&mut self, dt: f32) {
        if self.player_state != PlayerState::Alive {
            return;
        }

        // Core survival stats (hunger/regen) and timers. Use fixed dt to avoid FPS dependence.
        self.player_health.update(dt);

        // Tick status effects in sim-time (20 TPS).
        self.update_status_effects(dt);

        tick_health_over_time_status_effects(
            &mut self.player_health,
            &self.status_effects,
            &mut self.regeneration_timer_ticks,
            &mut self.poison_timer_ticks,
        );

        let camera_pos = self.renderer.camera().position;
        let (eye_fluid, feet_fluid) = self.camera_eye_and_feet_fluids(camera_pos);

        let has_water_breathing = self.status_effects.has(StatusEffectType::WaterBreathing);
        let has_fire_resistance = self.status_effects.has(StatusEffectType::FireResistance);

        let eye_in_water = eye_fluid == Some(FluidType::Water);
        let in_water = eye_in_water || feet_fluid == Some(FluidType::Water);
        let in_lava = eye_fluid == Some(FluidType::Lava) || feet_fluid == Some(FluidType::Lava);
        let in_fire = {
            let feet_pos = camera_pos - glam::Vec3::new(0.0, self.player_physics.eye_height, 0.0);
            let feet_sample = feet_pos + glam::Vec3::new(0.0, 0.1, 0.0);
            let eye_block = IVec3::new(
                camera_pos.x.floor() as i32,
                camera_pos.y.floor() as i32,
                camera_pos.z.floor() as i32,
            );
            let feet_block = IVec3::new(
                feet_sample.x.floor() as i32,
                feet_sample.y.floor() as i32,
                feet_sample.z.floor() as i32,
            );
            self.get_voxel_at(eye_block)
                .is_some_and(|voxel| voxel.id == mdminecraft_world::BLOCK_FIRE)
                || self
                    .get_voxel_at(feet_block)
                    .is_some_and(|voxel| voxel.id == mdminecraft_world::BLOCK_FIRE)
        };
        let mut in_precipitation = false;
        if self.active_dimension == DimensionId::Overworld && self.weather.is_precipitating() {
            let block_x = camera_pos.x.floor() as i32;
            let block_y = camera_pos.y.floor() as i32;
            let block_z = camera_pos.z.floor() as i32;
            let chunk_pos = ChunkPos::new(
                block_x.div_euclid(CHUNK_SIZE_X as i32),
                block_z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            if let (Some(chunk), Some(local_y)) =
                (self.chunks.get(&chunk_pos), world_y_to_local_y(block_y))
            {
                let local_x = block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                let biome = self
                    .terrain_generator
                    .biome_assigner()
                    .get_blended_biome(block_x, block_z, 2);
                if biome.id != BiomeId::Desert
                    && Self::column_is_clear_to_sky(chunk, local_x, local_y, local_z)
                {
                    in_precipitation = true;
                }
            }
        }

        // Drowning (vanilla-ish): 15s air, then periodic damage while underwater.
        let respiration_level = self
            .player_armor
            .total_enchantment_level(EnchantmentType::Respiration)
            .min(3);
        let max_air_ticks = 300u16.saturating_mul(1 + u16::from(respiration_level));
        if self
            .player_health
            .tick_air(eye_in_water, max_air_ticks, has_water_breathing)
        {
            self.player_health.damage(2.0);
        }

        // Lava contact + ignition (vanilla-ish; simplified).
        if in_lava && !has_fire_resistance {
            let damage = self.player_armor.reduce_damage(4.0, DamageKind::Fire);
            self.player_health.damage(damage);
            self.player_health.ignite(300);
        }

        // Fire contact + ignition (vanilla-ish; simplified).
        if in_fire && !has_fire_resistance {
            self.player_health.ignite(LIGHTNING_FIRE_TICKS);
        }

        // Burning DOT.
        if self
            .player_health
            .tick_burning(in_water || in_precipitation, has_fire_resistance)
        {
            let damage = self.player_armor.reduce_damage(1.0, DamageKind::Fire);
            self.player_health.damage(damage);
        }

        // XP orbs (physics + collection).
        let mut collected_xp = 0u32;
        self.xp_orbs.retain_mut(|orb| {
            if orb.update(dt, camera_pos) {
                return false;
            }
            if orb.should_collect(camera_pos) {
                collected_xp = collected_xp.saturating_add(orb.value);
                return false;
            }
            true
        });
        if collected_xp > 0 {
            let remaining_xp = self.apply_mending(collected_xp);
            if remaining_xp > 0 {
                self.player_xp.add_xp(remaining_xp);
            }
        }
    }

    fn tick_nether_portal_travel(&mut self) {
        if self.player_state != PlayerState::Alive || self.player_health.is_dead() {
            self.portal_charge_ticks = 0;
            self.portal_cooldown_ticks = 0;
            return;
        }

        self.portal_cooldown_ticks = self.portal_cooldown_ticks.saturating_sub(1);

        if let Some((_pos, axis)) = self.player_portal_contact() {
            if self.portal_cooldown_ticks > 0 {
                self.portal_charge_ticks = 0;
                return;
            }

            self.portal_charge_ticks = self.portal_charge_ticks.saturating_add(1);
            if self.portal_charge_ticks < NETHER_PORTAL_CHARGE_TICKS {
                return;
            }

            self.portal_charge_ticks = 0;
            self.portal_cooldown_ticks = NETHER_PORTAL_COOLDOWN_TICKS;
            if let Err(err) = self.travel_through_nether_portal(axis) {
                tracing::warn!("Nether portal travel failed: {err:#}");
            }
            return;
        }

        self.portal_charge_ticks = 0;

        let Some(_pos) = self.player_end_portal_contact() else {
            return;
        };

        if self.portal_cooldown_ticks > 0 {
            return;
        }

        self.portal_cooldown_ticks = NETHER_PORTAL_COOLDOWN_TICKS;
        if let Err(err) = self.travel_through_end_portal() {
            tracing::warn!("End portal travel failed: {err:#}");
        }
    }

    fn player_portal_contact(&self) -> Option<(IVec3, PortalAxis)> {
        let camera_pos = self.renderer.camera().position;
        let eye_pos = IVec3::new(
            camera_pos.x.floor() as i32,
            camera_pos.y.floor() as i32,
            camera_pos.z.floor() as i32,
        );
        if let Some(voxel) = self.get_voxel_at(eye_pos) {
            if voxel.id == BLOCK_NETHER_PORTAL {
                return Some((eye_pos, portal_axis_from_state(voxel.state)));
            }
        }

        let feet_pos = camera_pos - glam::Vec3::new(0.0, self.player_physics.eye_height, 0.0);
        let feet_sample = feet_pos + glam::Vec3::new(0.0, 0.1, 0.0);
        let feet_block = IVec3::new(
            feet_sample.x.floor() as i32,
            feet_sample.y.floor() as i32,
            feet_sample.z.floor() as i32,
        );
        if let Some(voxel) = self.get_voxel_at(feet_block) {
            if voxel.id == BLOCK_NETHER_PORTAL {
                return Some((feet_block, portal_axis_from_state(voxel.state)));
            }
        }

        None
    }

    fn player_end_portal_contact(&self) -> Option<IVec3> {
        let camera_pos = self.renderer.camera().position;
        let eye_pos = IVec3::new(
            camera_pos.x.floor() as i32,
            camera_pos.y.floor() as i32,
            camera_pos.z.floor() as i32,
        );
        if let Some(voxel) = self.get_voxel_at(eye_pos) {
            if voxel.id == BLOCK_END_PORTAL {
                return Some(eye_pos);
            }
        }

        let feet_pos = camera_pos - glam::Vec3::new(0.0, self.player_physics.eye_height, 0.0);
        let feet_sample = feet_pos + glam::Vec3::new(0.0, 0.1, 0.0);
        let feet_block = IVec3::new(
            feet_sample.x.floor() as i32,
            feet_sample.y.floor() as i32,
            feet_sample.z.floor() as i32,
        );
        if let Some(voxel) = self.get_voxel_at(feet_block) {
            if voxel.id == BLOCK_END_PORTAL {
                return Some(feet_block);
            }
        }

        None
    }

    fn travel_through_nether_portal(&mut self, preferred_axis: PortalAxis) -> anyhow::Result<()> {
        let from = self.active_dimension;
        let target = match from {
            DimensionId::Overworld => DimensionId::Nether,
            DimensionId::Nether => DimensionId::Overworld,
            _ => return Ok(()),
        };

        let camera = self.renderer.camera();
        let mut target_x = camera.position.x;
        let mut target_z = camera.position.z;
        match (from, target) {
            (DimensionId::Overworld, DimensionId::Nether) => {
                target_x /= 8.0;
                target_z /= 8.0;
            }
            (DimensionId::Nether, DimensionId::Overworld) => {
                target_x *= 8.0;
                target_z *= 8.0;
            }
            _ => {}
        }

        self.switch_dimension(target)?;

        if let Some(feet) = self.ensure_or_create_portal_near(target_x, target_z, preferred_axis) {
            let eye_height = self.player_physics.eye_height;
            let camera = self.renderer.camera_mut();
            camera.position = feet + glam::Vec3::new(0.0, eye_height, 0.0);
            self.player_physics.velocity = glam::Vec3::ZERO;
            self.player_physics.on_ground = false;
            self.player_physics.last_ground_y = feet.y;
        }

        Ok(())
    }

    fn travel_through_end_portal(&mut self) -> anyhow::Result<()> {
        let from = self.active_dimension;
        let target = match from {
            DimensionId::Overworld => DimensionId::End,
            DimensionId::End => DimensionId::Overworld,
            _ => return Ok(()),
        };

        let eye_height = self.player_physics.eye_height;
        if target == DimensionId::End {
            self.renderer.camera_mut().position = glam::Vec3::new(0.0, 80.0 + eye_height, 0.0);
        } else {
            self.renderer.camera_mut().position =
                self.spawn_point + glam::Vec3::new(0.0, eye_height, 0.0);
        }

        self.switch_dimension(target)?;
        Ok(())
    }

    fn ensure_or_create_portal_near(
        &mut self,
        target_x: f32,
        target_z: f32,
        preferred_axis: PortalAxis,
    ) -> Option<glam::Vec3> {
        let camera_pos = self.renderer.camera().position;
        let center_y = (camera_pos.y - self.player_physics.eye_height)
            .floor()
            .clamp(WORLD_MIN_Y as f32, WORLD_MAX_Y as f32) as i32;
        let center = IVec3::new(target_x.floor() as i32, center_y, target_z.floor() as i32);

        if let Some((portal_block, _axis)) =
            self.find_portal_block_near(center, NETHER_PORTAL_SEARCH_RADIUS)
        {
            let mut bottom = portal_block;
            while bottom.y > WORLD_MIN_Y {
                let below = bottom + IVec3::new(0, -1, 0);
                if self.get_block_at(below) != Some(BLOCK_NETHER_PORTAL) {
                    break;
                }
                bottom.y -= 1;
            }

            return Some(glam::Vec3::new(
                bottom.x as f32 + 0.5,
                bottom.y as f32 + PlayerPhysics::GROUND_EPS,
                bottom.z as f32 + 0.5,
            ));
        }

        let spawn_feet = self
            .find_safe_spawn_near(target_x, target_z)
            .unwrap_or_else(|| {
                camera_pos - glam::Vec3::new(0.0, self.player_physics.eye_height, 0.0)
            });

        let base_x = spawn_feet.x.floor() as i32;
        let base_y = (spawn_feet.y.floor() as i32).saturating_sub(1);
        let base_z = spawn_feet.z.floor() as i32;

        let axis_order = match preferred_axis {
            PortalAxis::X => [PortalAxis::X, PortalAxis::Z],
            PortalAxis::Z => [PortalAxis::Z, PortalAxis::X],
        };

        for axis in axis_order {
            for dist in 0..=NETHER_PORTAL_SEARCH_RADIUS {
                for dz in -dist..=dist {
                    for dx in -dist..=dist {
                        if dx.abs() != dist && dz.abs() != dist {
                            continue;
                        }

                        let origin = match axis {
                            PortalAxis::X => IVec3::new(base_x + dx - 1, base_y, base_z + dz),
                            PortalAxis::Z => IVec3::new(base_x + dx, base_y, base_z + dz - 1),
                        };

                        let Some(changed) = self.try_place_generated_portal(origin, axis) else {
                            continue;
                        };

                        self.refresh_after_voxel_changes(&changed);

                        return Some(match axis {
                            PortalAxis::X => glam::Vec3::new(
                                origin.x as f32 + 1.5,
                                origin.y as f32 + 1.0 + PlayerPhysics::GROUND_EPS,
                                origin.z as f32 + 0.5,
                            ),
                            PortalAxis::Z => glam::Vec3::new(
                                origin.x as f32 + 0.5,
                                origin.y as f32 + 1.0 + PlayerPhysics::GROUND_EPS,
                                origin.z as f32 + 1.5,
                            ),
                        });
                    }
                }
            }
        }

        None
    }

    fn find_portal_block_near(&self, center: IVec3, radius: i32) -> Option<(IVec3, PortalAxis)> {
        let center_y = center.y;

        for dist in 0..=radius {
            for dz in -dist..=dist {
                for dx in -dist..=dist {
                    if dx.abs() != dist && dz.abs() != dist {
                        continue;
                    }

                    let x = center.x + dx;
                    let z = center.z + dz;

                    for dy in -16..=16 {
                        let y = center_y + dy;
                        if world_y_to_local_y(y).is_none() {
                            continue;
                        }

                        let pos = IVec3::new(x, y, z);
                        let Some(voxel) = self.get_voxel_at(pos) else {
                            continue;
                        };
                        if voxel.id == BLOCK_NETHER_PORTAL {
                            return Some((pos, portal_axis_from_state(voxel.state)));
                        }
                    }
                }
            }
        }

        None
    }

    fn try_place_generated_portal(
        &mut self,
        origin: IVec3,
        axis: PortalAxis,
    ) -> Option<Vec<IVec3>> {
        if origin.y < WORLD_MIN_Y + 1 || origin.y + 4 > WORLD_MAX_Y {
            return None;
        }

        let portal_state = axis.to_state();
        let mut changed = Vec::with_capacity(64);

        let set_voxel =
            |chunks: &mut HashMap<ChunkPos, Chunk>, pos: IVec3, voxel: Voxel| -> Option<()> {
                let chunk_pos = ChunkPos::new(
                    pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                let chunk = chunks.get_mut(&chunk_pos)?;
                let local_y = world_y_to_local_y(pos.y)?;
                let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                chunk.set_voxel(local_x, local_y, local_z, voxel);
                Some(())
            };

        let check_pos = |pos: IVec3| -> Option<()> {
            let voxel = self.get_voxel_at(pos)?;
            if get_fluid_type(voxel.id).is_some() {
                return None;
            }
            Some(())
        };

        // Validate region (frame + portal interior + clearance on both sides of the plane).
        for w in 0..4 {
            for h in 0..5 {
                let pos = match axis {
                    PortalAxis::X => IVec3::new(origin.x + w, origin.y + h, origin.z),
                    PortalAxis::Z => IVec3::new(origin.x, origin.y + h, origin.z + w),
                };
                check_pos(pos)?;
            }
        }

        for w in 1..=2 {
            for h in 1..=3 {
                let interior = match axis {
                    PortalAxis::X => IVec3::new(origin.x + w, origin.y + h, origin.z),
                    PortalAxis::Z => IVec3::new(origin.x, origin.y + h, origin.z + w),
                };

                let (side_a, side_b) = match axis {
                    PortalAxis::X => (
                        interior + IVec3::new(0, 0, -1),
                        interior + IVec3::new(0, 0, 1),
                    ),
                    PortalAxis::Z => (
                        interior + IVec3::new(-1, 0, 0),
                        interior + IVec3::new(1, 0, 0),
                    ),
                };
                check_pos(side_a)?;
                check_pos(side_b)?;
            }
        }

        for w in 0..4 {
            for h in 0..5 {
                let pos = match axis {
                    PortalAxis::X => IVec3::new(origin.x + w, origin.y + h, origin.z),
                    PortalAxis::Z => IVec3::new(origin.x, origin.y + h, origin.z + w),
                };

                let is_border = w == 0 || w == 3 || h == 0 || h == 4;
                let (id, state) = if is_border {
                    (BLOCK_OBSIDIAN, 0)
                } else {
                    (BLOCK_NETHER_PORTAL, portal_state)
                };

                set_voxel(
                    &mut self.chunks,
                    pos,
                    Voxel {
                        id,
                        state,
                        light_sky: 0,
                        light_block: 0,
                    },
                )?;
                changed.push(pos);
            }
        }

        for w in 1..=2 {
            for h in 1..=3 {
                let interior = match axis {
                    PortalAxis::X => IVec3::new(origin.x + w, origin.y + h, origin.z),
                    PortalAxis::Z => IVec3::new(origin.x, origin.y + h, origin.z + w),
                };

                let (side_a, side_b) = match axis {
                    PortalAxis::X => (
                        interior + IVec3::new(0, 0, -1),
                        interior + IVec3::new(0, 0, 1),
                    ),
                    PortalAxis::Z => (
                        interior + IVec3::new(-1, 0, 0),
                        interior + IVec3::new(1, 0, 0),
                    ),
                };

                for pos in [side_a, side_b] {
                    set_voxel(&mut self.chunks, pos, Voxel::default())?;
                    changed.push(pos);
                }
            }
        }

        Some(changed)
    }

    fn update_chunks(&mut self, max_load: usize) {
        let camera_pos = self.renderer.camera().position;
        let center_chunk_x = (camera_pos.x / 16.0).floor() as i32;
        let center_chunk_z = (camera_pos.z / 16.0).floor() as i32;
        let radius = self.render_distance;

        // Unload chunks
        let mut chunks_to_unload = Vec::new();
        for pos in self.chunks.keys() {
            let dx = pos.x - center_chunk_x;
            let dz = pos.z - center_chunk_z;
            if dx * dx + dz * dz > (radius + 2) * (radius + 2) {
                chunks_to_unload.push(*pos);
            }
        }

        let mut neighbor_mesh_refresh = std::collections::BTreeSet::new();
        for pos in chunks_to_unload {
            self.crop_growth.unregister_chunk(pos);
            self.sugar_cane_growth.unregister_chunk(pos);
            if let Some(chunk) = self.chunks.remove(&pos) {
                if let Err(e) = self
                    .region_store
                    .save_chunk_in_dimension(self.active_dimension, &chunk)
                {
                    tracing::error!("Failed to save chunk {:?}: {}", pos, e);
                }
            }
            self.chunk_manager.remove_chunk(&pos);
            for neighbor in Self::neighbor_chunk_positions(pos) {
                neighbor_mesh_refresh.insert(neighbor);
            }
        }
        for pos in neighbor_mesh_refresh {
            let _ = self.upload_chunk_mesh(pos);
        }

        // Load chunks
        let mut chunks_to_load = Vec::new();
        for x in -radius..=radius {
            for z in -radius..=radius {
                if x * x + z * z > radius * radius {
                    continue;
                }
                let chunk_pos = ChunkPos::new(center_chunk_x + x, center_chunk_z + z);
                if !self.chunks.contains_key(&chunk_pos) {
                    chunks_to_load.push(chunk_pos);
                }
            }
        }

        // Sort by distance to center to load nearest first
        chunks_to_load.sort_by_key(|pos| {
            let dx = pos.x - center_chunk_x;
            let dz = pos.z - center_chunk_z;
            dx * dx + dz * dz
        });

        // Apply limit
        if chunks_to_load.len() > max_load {
            chunks_to_load.truncate(max_load);
        }

        // Load limited number per frame to avoid lag (e.g. 2 chunks)
        // But for initial load we might want more.
        // For now, load all to ensure correctness, optimization later.
        for pos in chunks_to_load {
            let (chunk, chunk_was_generated) = if let Ok(loaded) = self
                .region_store
                .load_chunk_in_dimension(self.active_dimension, pos)
            {
                (loaded, false)
            } else {
                (
                    self.terrain_generator
                        .generate_chunk_in_dimension(self.active_dimension, pos),
                    true,
                )
            };

            let mut crops_to_register = Vec::new();
            let mut sugar_cane_bases_to_register = Vec::new();
            let mut worldgen_chests = std::collections::BTreeSet::<BlockEntityKey>::new();
            for y in 0..CHUNK_SIZE_Y {
                for z in 0..CHUNK_SIZE_Z {
                    for x in 0..CHUNK_SIZE_X {
                        let voxel = chunk.voxel(x, y, z);
                        if chunk_was_generated && voxel.id == interactive_blocks::CHEST {
                            let world_x = pos.x * CHUNK_SIZE_X as i32 + x as i32;
                            let world_z = pos.z * CHUNK_SIZE_Z as i32 + z as i32;
                            worldgen_chests.insert(BlockEntityKey {
                                dimension: self.active_dimension,
                                x: world_x,
                                y: local_y_to_world_y(y),
                                z: world_z,
                            });
                        }
                        if !mdminecraft_world::CropType::is_crop(voxel.id) {
                            if voxel.id == mdminecraft_world::BLOCK_SUGAR_CANE {
                                if y == 0 {
                                    continue;
                                }
                                let below = chunk.voxel(x, y - 1, z);
                                if below.id != mdminecraft_world::BLOCK_SUGAR_CANE {
                                    sugar_cane_bases_to_register.push(SugarCanePosition {
                                        chunk: pos,
                                        x: x as u8,
                                        y: y as u8,
                                        z: z as u8,
                                    });
                                }
                            }
                            continue;
                        }

                        crops_to_register.push(CropPosition {
                            chunk: pos,
                            x: x as u8,
                            y: y as u8,
                            z: z as u8,
                        });
                    }
                }
            }

            self.chunks.insert(pos, chunk);
            if chunk_was_generated {
                for key in worldgen_chests {
                    self.populate_worldgen_chest(key);
                }

                if self.active_dimension == DimensionId::Overworld {
                    let mut village_villagers =
                        mdminecraft_world::village_villager_spawns_for_chunk(
                            self.world_seed,
                            pos,
                            self.terrain_generator.biome_assigner(),
                        );
                    for villager in &mut village_villagers {
                        villager.dimension = self.active_dimension;
                    }
                    self.assign_mob_ids(&mut village_villagers);
                    self.mobs.append(&mut village_villagers);
                }

                if self.active_dimension == DimensionId::Nether {
                    let mut fortress_blazes =
                        mdminecraft_world::fortress_blaze_spawns_for_chunk(self.world_seed, pos);
                    for mob in &mut fortress_blazes {
                        mob.dimension = self.active_dimension;
                    }
                    self.assign_mob_ids(&mut fortress_blazes);
                    self.mobs.append(&mut fortress_blazes);

                    if let Some(chunk) = self.chunks.get(&pos) {
                        // Spawn rare ghasts during chunk generation so the Nether feels alive even
                        // without additional periodic spawn rules.
                        let seed = self.world_seed
                            ^ (pos.x as u64).wrapping_mul(0x9E37_79B9_7F4A_7C15)
                            ^ (pos.z as u64).wrapping_mul(0xBF58_476D_1CE4_E5B9)
                            ^ 0x4748_4153_5453_504E_u64; // "GHASTSPN"
                        let mut rng = StdRng::seed_from_u64(seed);

                        if rng.gen_ratio(1, 12) {
                            for _attempt in 0..16 {
                                let local_x = rng.gen_range(2..=13);
                                let local_z = rng.gen_range(2..=13);
                                let local_y = rng.gen_range(40..=200);

                                let mut clear = true;
                                for dy in 0..=3 {
                                    for dz in -1..=1 {
                                        for dx in -1..=1 {
                                            let x = (local_x + dx) as usize;
                                            let y = (local_y + dy) as usize;
                                            let z = (local_z + dz) as usize;
                                            if chunk.voxel(x, y, z).id != BLOCK_AIR {
                                                clear = false;
                                                break;
                                            }
                                        }
                                        if !clear {
                                            break;
                                        }
                                    }
                                    if !clear {
                                        break;
                                    }
                                }

                                if !clear {
                                    continue;
                                }

                                let world_x = pos.x * CHUNK_SIZE_X as i32 + local_x;
                                let world_z = pos.z * CHUNK_SIZE_Z as i32 + local_z;

                                let mut ghast = Mob::new(
                                    world_x as f64 + 0.5,
                                    local_y_to_world_y(local_y as usize) as f64,
                                    world_z as f64 + 0.5,
                                    MobType::Ghast,
                                );
                                ghast.dimension = self.active_dimension;
                                self.assign_mob_id(&mut ghast);
                                self.mobs.push(ghast);
                                break;
                            }
                        }
                    }
                }
            }
            self.refresh_container_signals_for_loaded_chunk(pos);
            for crop in crops_to_register {
                self.crop_growth.register_crop(crop);
            }
            for base in sugar_cane_bases_to_register {
                self.sugar_cane_growth.register_base(base);
            }
            self.init_chunk_skylight(pos);
            let affected = mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                pos,
            );
            let mut mesh_refresh = std::collections::BTreeSet::new();
            mesh_refresh.insert(pos);
            mesh_refresh.extend(Self::neighbor_chunk_positions(pos));
            mesh_refresh.extend(affected);
            for chunk_pos in mesh_refresh {
                let _ = self.upload_chunk_mesh(chunk_pos);
            }

            // Spawn passive mobs only when generating a brand-new chunk.
            // Loading an existing chunk should not create additional mobs, because mobs persist in
            // `world.state`.
            if chunk_was_generated && self.active_dimension == DimensionId::Overworld {
                const PASSIVE_MOB_CAP: usize = 60;
                let loaded_passive_count = self
                    .mobs
                    .iter()
                    .filter(|mob| {
                        if mob.dimension != self.active_dimension || mob.dead || mob.is_hostile() {
                            return false;
                        }

                        let block_x = mob.x.floor() as i32;
                        let block_z = mob.z.floor() as i32;
                        let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
                        let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
                        self.chunks.contains_key(&ChunkPos::new(chunk_x, chunk_z))
                    })
                    .count();
                if loaded_passive_count >= PASSIVE_MOB_CAP {
                    continue;
                }
                let Some(chunk) = self.chunks.get(&pos) else {
                    continue;
                };

                let chunk_center_x = pos.x * CHUNK_SIZE_X as i32 + CHUNK_SIZE_X as i32 / 2;
                let chunk_center_z = pos.z * CHUNK_SIZE_Z as i32 + CHUNK_SIZE_Z as i32 / 2;
                let biome = self
                    .terrain_generator
                    .biome_assigner()
                    .get_biome(chunk_center_x, chunk_center_z);

                let mut surface_heights = [[0i32; CHUNK_SIZE_X]; CHUNK_SIZE_Z];
                for (local_z, row) in surface_heights.iter_mut().enumerate() {
                    for (local_x, height) in row.iter_mut().enumerate() {
                        for y in (0..CHUNK_SIZE_Y).rev() {
                            let voxel = chunk.voxel(local_x, y, local_z);
                            if voxel.id != BLOCK_AIR {
                                *height = local_y_to_world_y(y);
                                break;
                            }
                        }
                    }
                }

                let mut new_mobs =
                    self.mob_spawner
                        .generate_spawns(pos.x, pos.z, biome, &surface_heights);
                for mob in &mut new_mobs {
                    mob.dimension = self.active_dimension;
                }
                self.assign_mob_ids(&mut new_mobs);
                if !new_mobs.is_empty() {
                    tracing::info!(
                        chunk_x = pos.x,
                        chunk_z = pos.z,
                        new_mob_count = new_mobs.len(),
                        total_mobs = self.mobs.len() + new_mobs.len(),
                        "Adding mobs to world"
                    );
                }
                self.mobs.append(&mut new_mobs);
            }
        }
    }

    fn ensure_chunk_loaded_for_command(&mut self, chunk_pos: ChunkPos) {
        if self.chunks.contains_key(&chunk_pos) {
            return;
        }

        let (chunk, chunk_was_generated) = if let Ok(loaded) = self
            .region_store
            .load_chunk_in_dimension(self.active_dimension, chunk_pos)
        {
            (loaded, false)
        } else {
            (
                self.terrain_generator
                    .generate_chunk_in_dimension(self.active_dimension, chunk_pos),
                true,
            )
        };

        let mut crops_to_register = Vec::new();
        let mut sugar_cane_bases_to_register = Vec::new();
        let mut worldgen_chests = std::collections::BTreeSet::<BlockEntityKey>::new();
        for y in 0..CHUNK_SIZE_Y {
            for z in 0..CHUNK_SIZE_Z {
                for x in 0..CHUNK_SIZE_X {
                    let voxel = chunk.voxel(x, y, z);
                    if chunk_was_generated && voxel.id == interactive_blocks::CHEST {
                        let world_x = chunk_pos.x * CHUNK_SIZE_X as i32 + x as i32;
                        let world_z = chunk_pos.z * CHUNK_SIZE_Z as i32 + z as i32;
                        worldgen_chests.insert(BlockEntityKey {
                            dimension: self.active_dimension,
                            x: world_x,
                            y: local_y_to_world_y(y),
                            z: world_z,
                        });
                    }
                    if !mdminecraft_world::CropType::is_crop(voxel.id) {
                        if voxel.id == mdminecraft_world::BLOCK_SUGAR_CANE {
                            if y == 0 {
                                continue;
                            }
                            let below = chunk.voxel(x, y - 1, z);
                            if below.id != mdminecraft_world::BLOCK_SUGAR_CANE {
                                sugar_cane_bases_to_register.push(SugarCanePosition {
                                    chunk: chunk_pos,
                                    x: x as u8,
                                    y: y as u8,
                                    z: z as u8,
                                });
                            }
                        }
                        continue;
                    }

                    crops_to_register.push(CropPosition {
                        chunk: chunk_pos,
                        x: x as u8,
                        y: y as u8,
                        z: z as u8,
                    });
                }
            }
        }

        self.chunks.insert(chunk_pos, chunk);
        if chunk_was_generated {
            for key in worldgen_chests {
                self.populate_worldgen_chest(key);
            }
        }
        self.refresh_container_signals_for_loaded_chunk(chunk_pos);
        for crop in crops_to_register {
            self.crop_growth.register_crop(crop);
        }
        for base in sugar_cane_bases_to_register {
            self.sugar_cane_growth.register_base(base);
        }
    }

    fn refresh_container_signals_for_loaded_chunk(&mut self, chunk_pos: ChunkPos) {
        let chunk_x = chunk_pos.x;
        let chunk_z = chunk_pos.z;

        for (key, chest) in &self.chests {
            if key.dimension != self.active_dimension {
                continue;
            }

            let key_chunk_x = key.x.div_euclid(CHUNK_SIZE_X as i32);
            let key_chunk_z = key.z.div_euclid(CHUNK_SIZE_Z as i32);
            if key_chunk_x != chunk_x || key_chunk_z != chunk_z {
                continue;
            }

            mdminecraft_world::update_container_signal(
                &mut self.chunks,
                &mut self.redstone_sim,
                RedstonePos::new(key.x, key.y, key.z),
                &chest.slots,
            );
        }

        for (key, hopper) in &self.hoppers {
            if key.dimension != self.active_dimension {
                continue;
            }

            let key_chunk_x = key.x.div_euclid(CHUNK_SIZE_X as i32);
            let key_chunk_z = key.z.div_euclid(CHUNK_SIZE_Z as i32);
            if key_chunk_x != chunk_x || key_chunk_z != chunk_z {
                continue;
            }

            mdminecraft_world::update_container_signal(
                &mut self.chunks,
                &mut self.redstone_sim,
                RedstonePos::new(key.x, key.y, key.z),
                &hopper.slots,
            );
        }

        for (key, dispenser) in &self.dispensers {
            if key.dimension != self.active_dimension {
                continue;
            }

            let key_chunk_x = key.x.div_euclid(CHUNK_SIZE_X as i32);
            let key_chunk_z = key.z.div_euclid(CHUNK_SIZE_Z as i32);
            if key_chunk_x != chunk_x || key_chunk_z != chunk_z {
                continue;
            }

            mdminecraft_world::update_container_signal(
                &mut self.chunks,
                &mut self.redstone_sim,
                RedstonePos::new(key.x, key.y, key.z),
                &dispenser.slots,
            );
        }

        for (key, dropper) in &self.droppers {
            if key.dimension != self.active_dimension {
                continue;
            }

            let key_chunk_x = key.x.div_euclid(CHUNK_SIZE_X as i32);
            let key_chunk_z = key.z.div_euclid(CHUNK_SIZE_Z as i32);
            if key_chunk_x != chunk_x || key_chunk_z != chunk_z {
                continue;
            }

            mdminecraft_world::update_container_signal(
                &mut self.chunks,
                &mut self.redstone_sim,
                RedstonePos::new(key.x, key.y, key.z),
                &dropper.slots,
            );
        }
    }

    fn populate_worldgen_chest(&mut self, key: BlockEntityKey) {
        let chest = self.chests.entry(key).or_default();
        Self::populate_worldgen_chest_loot(chest, self.world_seed, key, &self.loot_tables);
    }

    fn populate_worldgen_chest_loot(
        chest: &mut ChestState,
        world_seed: u64,
        key: BlockEntityKey,
        loot_tables: &content_pack_loot::LootTables,
    ) {
        if chest.slots.iter().any(|slot| slot.is_some()) {
            return;
        }

        let loot_table = Self::worldgen_chest_loot_table_for_key(world_seed, key);

        let seed = world_seed
            ^ (key.x as u64).wrapping_mul(0xB529_7A4D_8B9D_7B3D)
            ^ (key.y as u64).wrapping_mul(0x68E3_1DA4_BB37_12C1)
            ^ (key.z as u64).wrapping_mul(0x1D8E_4E27_C47D_124F)
            ^ WORLDGEN_CHEST_LOOT_SALT
            ^ loot_table.salt();
        let mut rng = StdRng::seed_from_u64(seed);
        let override_table = loot_tables.worldgen_chests.get(&loot_table);

        let mut empty_slots: Vec<usize> = (0..chest.slots.len())
            .filter(|idx| chest.slots[*idx].is_none())
            .collect();

        let roll_count = rng.gen_range(2..=5);
        for _ in 0..roll_count {
            if empty_slots.is_empty() {
                break;
            }

            let idx = rng.gen_range(0..empty_slots.len());
            let slot = empty_slots.swap_remove(idx);
            chest.slots[slot] = Some(Self::roll_worldgen_chest_stack(
                &mut rng,
                loot_table,
                override_table,
            ));
        }
    }

    fn worldgen_chest_loot_table_for_key(
        world_seed: u64,
        key: BlockEntityKey,
    ) -> WorldgenChestLootTable {
        match key.dimension {
            DimensionId::Overworld => {
                let structure_kind =
                    mdminecraft_world::worldgen_structure_kind_at(world_seed, key.x, key.y, key.z);
                WorldgenChestLootTable::from_structure_kind(structure_kind)
            }
            DimensionId::Nether => {
                if mdminecraft_world::nether_fortress_contains(world_seed, key.x, key.y, key.z) {
                    WorldgenChestLootTable::NetherFortress
                } else {
                    WorldgenChestLootTable::Generic
                }
            }
            _ => WorldgenChestLootTable::Generic,
        }
    }

    fn roll_worldgen_chest_stack(
        rng: &mut StdRng,
        loot_table: WorldgenChestLootTable,
        override_table: Option<&content_pack_loot::WorldgenChestLootTableDefinition>,
    ) -> ItemStack {
        if let Some(table) = override_table {
            return table.roll_stack(rng);
        }

        let roll = rng.gen_range(0..100);
        match loot_table {
            WorldgenChestLootTable::Generic => match roll {
                0..=6 => ItemStack::new(ItemType::Item(14), 1),
                7..=18 => ItemStack::new(ItemType::Item(7), rng.gen_range(1..=3)),
                19..=30 => ItemStack::new(ItemType::Item(9), rng.gen_range(1..=3)),
                31..=44 => ItemStack::new(ItemType::Item(8), rng.gen_range(2..=6)),
                45..=56 => ItemStack::new(ItemType::Item(15), rng.gen_range(1..=4)),
                57..=67 => {
                    ItemStack::new(ItemType::Food(mdminecraft_core::item::FoodType::Bread), 1)
                }
                68..=78 => ItemStack::new(ItemType::Item(4), rng.gen_range(1..=4)),
                79..=90 => ItemStack::new(ItemType::Item(16), rng.gen_range(1..=4)),
                _ => ItemStack::new(ItemType::Item(2), rng.gen_range(1..=4)),
            },
            WorldgenChestLootTable::Dungeon => match roll {
                0..=29 => ItemStack::new(ItemType::Item(16), rng.gen_range(2..=6)),
                30..=49 => ItemStack::new(ItemType::Item(4), rng.gen_range(2..=6)),
                50..=64 => ItemStack::new(ItemType::Item(7), rng.gen_range(1..=3)),
                65..=74 => ItemStack::new(ItemType::Item(8), rng.gen_range(2..=6)),
                75..=82 => ItemStack::new(ItemType::Item(15), rng.gen_range(1..=4)),
                83..=88 => ItemStack::new(ItemType::Item(9), rng.gen_range(1..=2)),
                89..=94 => ItemStack::new(ItemType::Item(14), 1),
                95..=97 => ItemStack::new(ItemType::Item(2), rng.gen_range(1..=4)),
                _ => ItemStack::new(ItemType::Food(mdminecraft_core::item::FoodType::Bread), 1),
            },
            WorldgenChestLootTable::Mineshaft => match roll {
                0..=29 => ItemStack::new(ItemType::Item(8), rng.gen_range(2..=8)),
                30..=49 => ItemStack::new(ItemType::Item(7), rng.gen_range(1..=3)),
                50..=64 => ItemStack::new(ItemType::Item(4), rng.gen_range(1..=4)),
                65..=74 => {
                    ItemStack::new(ItemType::Food(mdminecraft_core::item::FoodType::Bread), 1)
                }
                75..=84 => ItemStack::new(ItemType::Item(9), rng.gen_range(1..=2)),
                85..=92 => ItemStack::new(ItemType::Item(15), rng.gen_range(1..=4)),
                _ => ItemStack::new(ItemType::Item(14), 1),
            },
            WorldgenChestLootTable::Ruin => match roll {
                0..=24 => ItemStack::new(ItemType::Item(8), rng.gen_range(2..=6)),
                25..=39 => {
                    ItemStack::new(ItemType::Food(mdminecraft_core::item::FoodType::Bread), 1)
                }
                40..=54 => {
                    ItemStack::new(ItemType::Item(CORE_ITEM_WHEAT_SEEDS), rng.gen_range(2..=6))
                }
                55..=69 => ItemStack::new(ItemType::Item(7), rng.gen_range(1..=3)),
                70..=79 => ItemStack::new(ItemType::Item(15), rng.gen_range(1..=4)),
                80..=86 => ItemStack::new(ItemType::Item(9), rng.gen_range(1..=2)),
                87..=93 => ItemStack::new(ItemType::Item(4), rng.gen_range(1..=4)),
                94..=98 => ItemStack::new(ItemType::Item(16), rng.gen_range(1..=4)),
                _ => ItemStack::new(ItemType::Item(14), 1),
            },
            WorldgenChestLootTable::Village => match roll {
                0..=34 => ItemStack::new(
                    ItemType::Food(mdminecraft_core::item::FoodType::Bread),
                    rng.gen_range(1..=3),
                ),
                35..=59 => ItemStack::new(
                    ItemType::Food(mdminecraft_core::item::FoodType::Apple),
                    rng.gen_range(1..=3),
                ),
                60..=79 => {
                    ItemStack::new(ItemType::Item(CORE_ITEM_WHEAT_SEEDS), rng.gen_range(2..=6))
                }
                80..=91 => ItemStack::new(ItemType::Item(8), rng.gen_range(2..=6)),
                92..=97 => ItemStack::new(ItemType::Item(7), rng.gen_range(1..=2)),
                _ => ItemStack::new(ItemType::Item(9), 1),
            },
            WorldgenChestLootTable::NetherFortress => match roll {
                0..=19 => {
                    ItemStack::new(ItemType::Item(CORE_ITEM_NETHER_WART), rng.gen_range(2..=6))
                }
                20..=39 => ItemStack::new(
                    ItemType::Item(CORE_ITEM_NETHER_QUARTZ),
                    rng.gen_range(2..=8),
                ),
                40..=57 => ItemStack::new(ItemType::Item(9), rng.gen_range(1..=4)),
                58..=71 => ItemStack::new(ItemType::Item(7), rng.gen_range(1..=4)),
                72..=82 => {
                    ItemStack::new(ItemType::Item(CORE_ITEM_BLAZE_POWDER), rng.gen_range(1..=3))
                }
                83..=91 => ItemStack::new(
                    ItemType::Item(CORE_ITEM_GLOWSTONE_DUST),
                    rng.gen_range(2..=6),
                ),
                92..=96 => ItemStack::new(ItemType::Item(14), 1),
                _ => ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), rng.gen_range(1..=2)),
            },
        }
    }

    fn update_and_render(&mut self) {
        let now = Instant::now();
        let dt = (now - self.last_frame).as_secs_f64();
        self.last_frame = now;
        self.frame_dt = dt as f32;
        self.debug_hud.chunk_uploads_last_frame = 0;

        // Cap dt to avoid spiral of death
        let dt = dt.min(0.25);

        self.process_automation_messages();
        self.apply_automation_input();

        if self.pause_menu_open {
            // Prevent accumulator buildup while paused so unpausing doesn't "fast-forward".
            self.accumulator = 0.0;
        } else {
            self.accumulator += dt;

            while self.accumulator >= TICK_RATE {
                self.fixed_update();
                self.accumulator -= TICK_RATE;
            }
        }

        // Process input and camera every frame for responsiveness
        self.process_actions(self.frame_dt);

        // Sync visual time-of-day from deterministic simulation time.
        self.time_of_day
            .set_time(self.sim_time.time_of_day() as f32);

        // Update environment and effects (visual)
        self.update_weather(self.frame_dt);
        self.update_particles(self.frame_dt);
        self.debug_hud.particle_count = self.particles.len();

        // Update debug HUD
        self.debug_hud.update_fps(self.frame_dt);
        let camera = self.renderer.camera();
        self.debug_hud.camera_pos = [camera.position.x, camera.position.y, camera.position.z];
        self.debug_hud.camera_rot = [camera.yaw, camera.pitch];
        self.debug_hud.chunks_visible = self.chunks_visible;
        self.debug_hud.control_mode = self.current_control_mode();
        self.debug_hud.cursor_captured = self.input.cursor_captured;
        self.debug_hud.mouse_sensitivity = self.controls.mouse_sensitivity;
        self.debug_hud.weather_state = self.weather_state_label().to_string();
        self.debug_hud.weather_intensity = self.weather_intensity();

        // Update camera from input (only if alive)
        if self.player_state == PlayerState::Alive {
            self.update_camera(self.frame_dt);
        }

        // Raycast for block selection (only if alive)
        if self.input.cursor_captured && self.player_state == PlayerState::Alive {
            let camera = self.renderer.camera();
            let ray_origin = camera.position;
            let ray_dir = camera.forward();

            self.selected_block = raycast(ray_origin, ray_dir, 8.0, |block_pos| {
                let chunk_x = block_pos.x.div_euclid(16);
                let chunk_z = block_pos.z.div_euclid(16);
                let local_x = block_pos.x.rem_euclid(16) as usize;
                let Some(local_y) = world_y_to_local_y(block_pos.y) else {
                    return false;
                };
                let local_z = block_pos.z.rem_euclid(16) as usize;

                if let Some(chunk) = self.chunks.get(&ChunkPos::new(chunk_x, chunk_z)) {
                    let voxel = chunk.voxel(local_x, local_y, local_z);
                    voxel.id != BLOCK_AIR
                } else {
                    false
                }
            });

            // Handle block breaking/placing
            self.handle_block_interaction(self.frame_dt);
        } else {
            self.selected_block = None;
        }

        // Render
        self.render();
    }

    fn update_camera(&mut self, dt: f32) {
        let actions = self.actions.clone();

        {
            let cursor_captured = self.input.cursor_captured;
            let camera = self.renderer.camera_mut();
            Self::apply_mouse_look(camera, &actions, &self.controls, cursor_captured);
        }

        if actions.context != InputContext::Gameplay {
            return;
        }

        if self.player_physics.physics_enabled {
            self.apply_physics_movement(&actions, dt);
        } else {
            self.apply_fly_movement(&actions, dt);
        }

        // Update player activity state for hunger depletion
        let is_moving = actions.move_x.abs() > 0.01 || actions.move_y.abs() > 0.01;
        self.player_health.set_active(is_moving || actions.sprint);
    }

    fn player_has_arrows(&self) -> bool {
        if self.hotbar.has_arrows() {
            return true;
        }

        self.main_inventory.slots.iter().any(|slot| {
            slot.as_ref()
                .is_some_and(|item| matches!(item.item_type, ItemType::Item(2)))
        })
    }

    fn player_consume_arrow(&mut self) -> bool {
        if self.hotbar.consume_arrow() {
            return true;
        }

        for slot in &mut self.main_inventory.slots {
            let Some(item) = slot.as_mut() else {
                continue;
            };

            if !matches!(item.item_type, ItemType::Item(2)) {
                continue;
            }

            if item.count > 1 {
                item.count -= 1;
            } else {
                *slot = None;
            }
            return true;
        }

        false
    }

    fn handle_block_interaction(&mut self, dt: f32) {
        // Handle bow charging and shooting (before other interactions)
        if self.hotbar.has_bow_selected() && self.player_has_arrows() {
            if self.input.is_mouse_pressed(MouseButton::Right) {
                // Charging bow
                if !self.bow_drawing {
                    self.bow_drawing = true;
                    self.bow_charge = 0.0;
                }
                // Increase charge over time (max 1.0 at 1 second)
                self.bow_charge = (self.bow_charge + dt).min(1.0);
            } else if self.bow_drawing {
                // Released - shoot arrow!
                if self.bow_charge >= 0.1 {
                    let (power_level, punch_level, flame, infinity) =
                        if let Some(item) = self.hotbar.selected_item() {
                            (
                                item.enchantment_level(EnchantmentType::Power),
                                item.enchantment_level(EnchantmentType::Punch),
                                item.enchantment_level(EnchantmentType::Flame) > 0,
                                item.enchantment_level(EnchantmentType::Infinity) > 0,
                            )
                        } else {
                            (0, 0, false, false)
                        };

                    // Consume an arrow unless Infinity is present (still requires at least one arrow).
                    if infinity || self.player_consume_arrow() {
                        // Get camera position and direction
                        let camera = self.renderer.camera();
                        let base_y = (camera.position.y - 1.5) as f64;

                        let mut arrow = Projectile::shoot_arrow(
                            camera.position.x as f64,
                            base_y,
                            camera.position.z as f64,
                            camera.yaw,
                            camera.pitch,
                            self.bow_charge,
                        );
                        arrow.power_level = power_level;
                        arrow.punch_level = punch_level;
                        arrow.flame = flame;
                        arrow.can_pick_up = !infinity;
                        self.projectiles.spawn(self.active_dimension, arrow);
                        tracing::debug!("Shot arrow with charge {:.2}", self.bow_charge);

                        // Using a bow consumes durability (vanilla-ish).
                        if let Some(item) = self.hotbar.selected_item_mut() {
                            if matches!(item.item_type, ItemType::Item(1)) {
                                if item.durability.is_none() {
                                    item.durability = item.max_durability();
                                }
                                item.damage_durability(1);
                                if item.is_broken() {
                                    self.hotbar.slots[self.hotbar.selected] = None;
                                }
                            }
                        }
                    }
                }
                self.bow_drawing = false;
                self.bow_charge = 0.0;
            }
            // Skip other interactions while drawing bow
            if self.bow_drawing {
                return;
            }
        } else {
            // Not holding bow, reset bow state
            self.bow_drawing = false;
            self.bow_charge = 0.0;
        }

        // Update attack cooldown timer (counts down to 0)
        self.attack_cooldown = (self.attack_cooldown - dt).max(0.0);

        // Left click: try to attack a mob first (on click, not hold)
        // Only attack if cooldown has reached 0
        if self.input.is_mouse_clicked(MouseButton::Left)
            && self.attack_cooldown <= 0.0
            && self.try_attack_mob()
        {
            // Attacked a mob successfully - set cooldown to 0.6 seconds
            self.attack_cooldown = 0.6;
            // Don't mine
            self.mining_progress = None;
            return;
        }

        if self.input.is_mouse_clicked(MouseButton::Right) && self.try_open_villager_trade() {
            self.mining_progress = None;
            return;
        }

        if let Some(hit) = self.selected_block {
            // Left click/hold: mine block
            if self.input.is_mouse_pressed(MouseButton::Left) {
                self.handle_mining(hit, dt);
            } else {
                // Reset mining progress if not holding left click
                self.mining_progress = None;
            }

            // Right click: equip armor, eat food, interact with block, or place block
            if self.input.is_mouse_clicked(MouseButton::Right) {
                if self.try_interact_with_target_block(hit) {
                    return;
                }

                // First, check if we're holding armor and try to equip it
                let mut equipped_armor = false;
                if let Some(stack) = self.hotbar.slots[self.hotbar.selected].clone() {
                    if let Some(armor_piece) = armor_piece_from_core_stack(&stack) {
                        // Equip the armor piece.
                        let old_piece = self.player_armor.equip(armor_piece);

                        // Consume the item from hotbar.
                        let _ = self.hotbar.consume_selected();
                        equipped_armor = true;
                        tracing::info!("Equipped armor");

                        // Return any replaced armor back to player storage (or spill to world).
                        if let Some(old_piece) = old_piece {
                            if let Some(old_stack) = armor_piece_to_core_stack(&old_piece) {
                                self.return_stack_to_storage_or_spill(old_stack);
                            } else {
                                tracing::warn!(
                                    item = ?old_piece.item_type,
                                    "Replaced armor could not be represented as a core stack"
                                );
                            }
                        }
                    }
                }

                if equipped_armor {
                    // Skip other interactions when equipping armor
                } else if let Some(food_type) = self.hotbar.selected_food() {
                    // Check if we're holding food and try to eat it
                    let hunger_restore = food_hunger_restore(food_type);
                    if self.player_health.eat(hunger_restore) {
                        self.hotbar.consume_selected();
                        // Skip other interactions when eating
                    }
                } else if let Some(potion_id) = self.hotbar.selected_potion() {
                    // Check if we're holding a potion and try to drink it
                    if self.drink_potion(potion_id) {
                        self.hotbar.consume_selected();
                        self.return_stack_to_storage_or_spill(ItemStack::new(
                            ItemType::Item(CORE_ITEM_GLASS_BOTTLE),
                            1,
                        ));
                        // Skip other interactions when drinking
                    }
                } else if let Some(potion_id) = self.hotbar.selected_splash_potion() {
                    // Check if we're holding a splash potion and throw it
                    self.throw_splash_potion(potion_id);
                    self.hotbar.consume_selected();
                    // Skip other interactions when throwing
                } else if self
                    .hotbar
                    .selected_item()
                    .is_some_and(|stack| stack.item_type == ItemType::Item(CORE_ITEM_ENDER_PEARL))
                {
                    self.throw_ender_pearl();
                    self.hotbar.consume_selected();
                } else if self
                    .hotbar
                    .selected_item()
                    .is_some_and(|stack| stack.item_type == ItemType::Item(104))
                {
                    self.throw_egg();
                    self.hotbar.consume_selected();
                } else if self.try_use_bucket(hit) {
                    // Skip other interactions when using buckets
                } else if self.try_use_flint_and_steel(hit) {
                    // Skip other interactions when using flint and steel
                } else {
                    self.handle_block_placement(hit);
                }
            }
        } else {
            // No block selected, reset mining progress
            self.mining_progress = None;
        }
    }

    fn try_use_bucket(&mut self, hit: RaycastHit) -> bool {
        let Some(bucket_id) = self.hotbar.selected_bucket() else {
            return false;
        };

        let Some((new_bucket_id, changed_positions)) = try_bucket_interaction(
            self.active_dimension,
            bucket_id,
            hit,
            &mut self.chunks,
            &mut self.fluid_sim,
        ) else {
            return false;
        };

        // Transform the held bucket.
        if let Some(selected) = self.hotbar.selected_item_mut() {
            if selected.count > 1 {
                selected.count -= 1;
                self.return_stack_to_storage_or_spill(ItemStack::new(
                    ItemType::Item(new_bucket_id),
                    1,
                ));
            } else {
                self.hotbar.slots[self.hotbar.selected] =
                    Some(ItemStack::new(ItemType::Item(new_bucket_id), 1));
            }
        }

        self.refresh_after_voxel_changes(&changed_positions);

        true
    }

    fn try_use_flint_and_steel(&mut self, hit: RaycastHit) -> bool {
        let Some(stack) = self.hotbar.selected_item() else {
            return false;
        };

        if !matches!(stack.item_type, ItemType::Item(CORE_ITEM_FLINT_AND_STEEL)) {
            return false;
        }

        let ignite_pos = hit.block_pos + hit.face_normal;
        if world_y_to_local_y(ignite_pos.y).is_none() {
            return false;
        }

        if let Some(changed_positions) = try_activate_nether_portal(&mut self.chunks, ignite_pos) {
            if !changed_positions.is_empty() {
                if let Some(item) = self.hotbar.selected_item_mut() {
                    if matches!(item.item_type, ItemType::Item(CORE_ITEM_FLINT_AND_STEEL)) {
                        if item.durability.is_none() {
                            item.durability = item.max_durability();
                        }
                        item.damage_durability(1);
                        if item.is_broken() {
                            self.hotbar.slots[self.hotbar.selected] = None;
                        }
                    }
                }
            }
            self.refresh_after_voxel_changes(&changed_positions);
            return true;
        }

        let mut changed_positions = Vec::new();
        if self.try_place_fire_block(ignite_pos, &mut changed_positions) {
            if !changed_positions.is_empty() {
                if let Some(item) = self.hotbar.selected_item_mut() {
                    if matches!(item.item_type, ItemType::Item(CORE_ITEM_FLINT_AND_STEEL)) {
                        if item.durability.is_none() {
                            item.durability = item.max_durability();
                        }
                        item.damage_durability(1);
                        if item.is_broken() {
                            self.hotbar.slots[self.hotbar.selected] = None;
                        }
                    }
                }
            }
            self.refresh_after_voxel_changes(&changed_positions);
            return true;
        }

        false
    }

    fn try_place_fire_block(&mut self, pos: IVec3, changed_positions: &mut Vec<IVec3>) -> bool {
        let local_y = match world_y_to_local_y(pos.y) {
            Some(local_y) => local_y,
            None => return false,
        };

        let support_pos = IVec3::new(pos.x, pos.y - 1, pos.z);
        let Some(support_voxel) = self.get_voxel_at(support_pos) else {
            return false;
        };
        if !self.block_properties.get(support_voxel.id).is_solid {
            return false;
        }

        let chunk_pos = ChunkPos::new(
            pos.x.div_euclid(CHUNK_SIZE_X as i32),
            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
            return false;
        };
        let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        let voxel = chunk.voxel(local_x, local_y, local_z);

        if voxel.id == mdminecraft_world::BLOCK_FIRE {
            return true;
        }

        if voxel.id != BLOCK_AIR {
            return false;
        }

        chunk.set_voxel(
            local_x,
            local_y,
            local_z,
            Voxel {
                id: mdminecraft_world::BLOCK_FIRE,
                state: 0,
                light_sky: 0,
                light_block: 0,
            },
        );
        changed_positions.push(pos);
        true
    }

    fn try_use_eye_of_ender_on_end_portal_frame(&mut self, frame_pos: IVec3) -> Option<Vec<IVec3>> {
        if self.active_dimension != DimensionId::Overworld {
            return None;
        }

        let selected = self.hotbar.selected;
        let stack = self.hotbar.slots[selected].as_ref()?;
        if stack.item_type != ItemType::Item(CORE_ITEM_EYE_OF_ENDER) || stack.count == 0 {
            return None;
        }

        let chunk_pos = ChunkPos::new(
            frame_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            frame_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let local_x = frame_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_y = world_y_to_local_y(frame_pos.y)?;
        let local_z = frame_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        let frame_voxel = self
            .chunks
            .get(&chunk_pos)
            .map(|chunk| chunk.voxel(local_x, local_y, local_z))?;
        if frame_voxel.id != BLOCK_END_PORTAL_FRAME {
            return None;
        }

        let has_eye = (frame_voxel.state & 0x01) != 0;
        if has_eye {
            return Some(Vec::new());
        }

        {
            let chunk = self.chunks.get_mut(&chunk_pos)?;
            chunk.set_voxel(
                local_x,
                local_y,
                local_z,
                Voxel {
                    state: frame_voxel.state | 0x01,
                    ..frame_voxel
                },
            );
        }

        // Consume one eye of ender.
        if let Some(selected_stack) = self.hotbar.slots[selected].as_mut() {
            if selected_stack.count > 1 {
                selected_stack.count -= 1;
            } else {
                self.hotbar.slots[selected] = None;
            }
        }

        let mut changed = vec![frame_pos];
        if let Some(mut portal_positions) = try_activate_end_portal(&mut self.chunks, frame_pos) {
            changed.append(&mut portal_positions);
        }

        Some(changed)
    }

    fn refresh_after_voxel_changes(&mut self, changed_positions: &[IVec3]) {
        if changed_positions.is_empty() {
            return;
        }

        let mut dirty_chunks = std::collections::BTreeSet::new();
        for pos in changed_positions {
            dirty_chunks.insert(ChunkPos::new(pos.x.div_euclid(16), pos.z.div_euclid(16)));
        }

        let mut skylight_affected = std::collections::BTreeSet::new();
        for pos in &dirty_chunks {
            skylight_affected.extend(self.recompute_skylight_local(*pos));
        }

        let mut affected = std::collections::BTreeSet::new();
        for pos in &dirty_chunks {
            affected.extend(mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                *pos,
            ));
        }

        let mut mesh_refresh = std::collections::BTreeSet::new();
        for pos in &dirty_chunks {
            mesh_refresh.insert(*pos);
            mesh_refresh.extend(Self::neighbor_chunk_positions(*pos));
        }
        mesh_refresh.extend(skylight_affected);
        mesh_refresh.extend(affected);
        for pos in mesh_refresh {
            let _ = self.upload_chunk_mesh(pos);
        }
    }

    fn try_sleep_in_bed(&mut self, bed_pos: IVec3) {
        if self.player_state != PlayerState::Alive {
            return;
        }

        if matches!(
            self.active_dimension,
            DimensionId::Nether | DimensionId::End
        ) {
            self.trigger_bed_explosion(bed_pos);
            return;
        }

        // Time: 0.0-0.25 NightDawn, 0.75-1.0 DuskNight
        let time = self.sim_time.time_of_day() as f32;
        let is_night = !(0.25..=0.75).contains(&time);

        if !is_night {
            tracing::info!("Tried to sleep, but it's not night");
            return;
        }

        let bed_center_x = bed_pos.x as f64 + 0.5;
        let bed_center_y = bed_pos.y as f64 + 0.5;
        let bed_center_z = bed_pos.z as f64 + 0.5;

        // Vanilla checks a radius around the bed. Keep simple: any living hostile within 8 blocks.
        let monsters_nearby = self.mobs.iter().any(|mob| {
            mob.dimension == self.active_dimension
                && !mob.dead
                && mob.is_hostile()
                && mob.distance_to(bed_center_x, bed_center_y, bed_center_z) <= 8.0
        });
        if monsters_nearby {
            tracing::info!("Tried to sleep, but monsters are nearby");
            return;
        }

        // Set spawn point to the block above the bed (feet position).
        self.spawn_point = glam::Vec3::new(
            bed_pos.x as f32 + 0.5,
            bed_pos.y as f32 + 1.0,
            bed_pos.z as f32 + 0.5,
        );
        self.spawn_point_dimension = DimensionId::Overworld;
        self.player_physics.last_ground_y = self.spawn_point.y;

        // Advance simulation time to sunrise (time_of_day = 0.25).
        let ticks_per_day = self.sim_time.ticks_per_day.max(1);
        let target_tick_in_day = (ticks_per_day as f64 * 0.25).round() as u64;
        let tick_in_day = self.sim_time.tick.0 % ticks_per_day;
        let advance = if tick_in_day < target_tick_in_day {
            target_tick_in_day - tick_in_day
        } else {
            (ticks_per_day - tick_in_day) + target_tick_in_day
        };
        self.sim_time.tick = self.sim_time.tick.advance(advance);

        // Vanilla clears weather after sleeping; keep it simple.
        self.weather.set_state(WeatherState::Clear);

        tracing::info!(
            "Slept in bed at {:?} (spawn set), advanced time by {} ticks",
            bed_pos,
            advance
        );
    }

    fn interact_respawn_anchor(&mut self, anchor_pos: IVec3) {
        if self.player_state != PlayerState::Alive {
            return;
        }

        // Vanilla-ish: respawn anchors explode outside the Nether/End.
        if self.active_dimension == DimensionId::Overworld {
            self.trigger_respawn_anchor_explosion(anchor_pos);
            return;
        }

        let selected = self.hotbar.selected;
        let holding_charge_item = self.hotbar.slots[selected].as_ref().is_some_and(|stack| {
            stack.count > 0
                && matches!(
                    stack.item_type,
                    ItemType::Item(CORE_ITEM_GLOWSTONE_DUST) | ItemType::Block(BLOCK_GLOWSTONE)
                )
        });

        let Some(local_y) = world_y_to_local_y(anchor_pos.y) else {
            return;
        };

        let chunk_pos = ChunkPos::new(anchor_pos.x.div_euclid(16), anchor_pos.z.div_euclid(16));
        let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
            return;
        };

        let local_x = anchor_pos.x.rem_euclid(16) as usize;
        let local_z = anchor_pos.z.rem_euclid(16) as usize;
        let voxel = chunk.voxel(local_x, local_y, local_z);
        if voxel.id != BLOCK_RESPAWN_ANCHOR {
            return;
        }

        let charges = mdminecraft_world::respawn_anchor_charges(voxel.state);
        if holding_charge_item {
            if charges >= mdminecraft_world::RESPAWN_ANCHOR_MAX_CHARGES {
                return;
            }

            let next = charges.saturating_add(1);
            let new_state = mdminecraft_world::set_respawn_anchor_charges(voxel.state, next);
            chunk.set_voxel(
                local_x,
                local_y,
                local_z,
                Voxel {
                    state: new_state,
                    ..voxel
                },
            );

            if let Some(stack) = self.hotbar.slots[selected].as_mut() {
                stack.count = stack.count.saturating_sub(1);
                if stack.count == 0 {
                    self.hotbar.slots[selected] = None;
                }
            }

            self.refresh_after_voxel_changes(&[anchor_pos]);
            tracing::info!("Charged respawn anchor at {:?} to {}", anchor_pos, next);
            return;
        }

        if charges == 0 {
            tracing::info!(
                "Tried to set respawn anchor at {:?}, but it's uncharged",
                anchor_pos
            );
            return;
        }

        self.spawn_point = glam::Vec3::new(
            anchor_pos.x as f32 + 0.5,
            anchor_pos.y as f32 + 1.0,
            anchor_pos.z as f32 + 0.5,
        );
        self.spawn_point_dimension = self.active_dimension;
        self.player_physics.last_ground_y = self.spawn_point.y;
        tracing::info!(
            "Set respawn point to respawn anchor at {:?} in {:?}",
            anchor_pos,
            self.active_dimension
        );
    }

    fn trigger_bed_explosion(&mut self, bed_pos: IVec3) {
        let ex = bed_pos.x as f64 + 0.5;
        let ey = bed_pos.y as f64 + 0.5;
        let ez = bed_pos.z as f64 + 0.5;
        let radius = 5.0_f32;

        self.audio.play_sfx(SoundId::Explosion);
        self.destroy_blocks_in_radius(ex, ey, ez, radius);

        if self.player_state != PlayerState::Alive {
            return;
        }

        let player_pos = self.renderer.camera().position;
        let dx = player_pos.x as f64 - ex;
        let dy = player_pos.y as f64 - ey;
        let dz = player_pos.z as f64 - ez;
        let dist = (dx * dx + dy * dy + dz * dz).sqrt() as f32;

        let damage = if dist >= radius {
            0.0
        } else {
            (1.0 - dist / radius).clamp(0.0, 1.0) * 18.0
        };

        if damage > 0.0 {
            let actual_damage = self.player_armor.take_damage(damage, DamageKind::Blast);
            self.player_health.damage(actual_damage);
            if self.player_health.is_dead() {
                self.handle_death("Intentional Game Design");
            }
        }
    }

    fn trigger_respawn_anchor_explosion(&mut self, anchor_pos: IVec3) {
        // Match the existing "bed explosion" parameters (vanilla-ish).
        let ex = anchor_pos.x as f64 + 0.5;
        let ey = anchor_pos.y as f64 + 0.5;
        let ez = anchor_pos.z as f64 + 0.5;
        let radius = 5.0_f32;

        self.audio.play_sfx(SoundId::Explosion);
        self.destroy_blocks_in_radius(ex, ey, ez, radius);

        if self.player_state != PlayerState::Alive {
            return;
        }

        let player_pos = self.renderer.camera().position;
        let dx = player_pos.x as f64 - ex;
        let dy = player_pos.y as f64 - ey;
        let dz = player_pos.z as f64 - ez;
        let dist = (dx * dx + dy * dy + dz * dz).sqrt() as f32;

        let damage = if dist >= radius {
            0.0
        } else {
            (1.0 - dist / radius).clamp(0.0, 1.0) * 18.0
        };

        if damage > 0.0 {
            let actual_damage = self.player_armor.take_damage(damage, DamageKind::Blast);
            self.player_health.damage(actual_damage);
            if self.player_health.is_dead() {
                self.handle_death("Intentional Game Design");
            }
        }
    }

    fn try_fill_glass_bottle_from_water(&mut self) -> bool {
        let selected = self.hotbar.selected;
        let Some(stack) = self.hotbar.slots[selected].as_ref() else {
            return false;
        };

        if stack.item_type != ItemType::Item(CORE_ITEM_GLASS_BOTTLE) || stack.count == 0 {
            return false;
        }

        // Vanilla-ish behavior: after filling, the player holds the filled bottle and any
        // remaining empty bottles move to inventory (or spill if full).
        let remaining_empty = stack.count.saturating_sub(1);
        self.hotbar.slots[selected] =
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1));

        if remaining_empty > 0 {
            self.return_stack_to_storage_or_spill(ItemStack::new(
                ItemType::Item(CORE_ITEM_GLASS_BOTTLE),
                remaining_empty,
            ));
        }

        true
    }

    fn try_till_farmland(
        &mut self,
        block_id: BlockId,
        chunk_pos: ChunkPos,
        local_x: usize,
        local_y: usize,
        local_z: usize,
    ) -> bool {
        let Some((tool, _material)) = self.hotbar.selected_tool() else {
            return false;
        };
        if tool != ToolType::Hoe {
            return false;
        }

        if !mdminecraft_world::can_till(block_id) {
            return false;
        }

        if local_y + 1 >= CHUNK_SIZE_Y {
            return false;
        }

        let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
            return false;
        };

        if chunk.voxel(local_x, local_y + 1, local_z).id != BLOCK_AIR {
            return false;
        }

        let mut voxel = chunk.voxel(local_x, local_y, local_z);
        voxel.id = mdminecraft_world::farming_blocks::FARMLAND;
        voxel.state = 0;
        chunk.set_voxel(local_x, local_y, local_z, voxel);

        // Using a hoe consumes durability.
        if let Some(item) = self.hotbar.selected_item_mut() {
            if matches!(item.item_type, ItemType::Tool(ToolType::Hoe, _)) {
                item.damage_durability(1);
                if item.is_broken() {
                    self.hotbar.slots[self.hotbar.selected] = None;
                }
            }
        }

        self.debug_hud.chunk_uploads_last_frame += self.upload_chunk_mesh_and_neighbors(chunk_pos);
        true
    }

    fn try_plant_crop(
        &mut self,
        block_id: BlockId,
        chunk_pos: ChunkPos,
        local_x: usize,
        local_y: usize,
        local_z: usize,
    ) -> bool {
        let Some(stack) = self.hotbar.selected_item() else {
            return false;
        };
        if stack.count == 0 {
            return false;
        }

        let crop_type = match stack.item_type {
            ItemType::Item(CORE_ITEM_WHEAT_SEEDS) => mdminecraft_world::CropType::Wheat,
            ItemType::Food(mdminecraft_core::item::FoodType::Carrot) => {
                mdminecraft_world::CropType::Carrots
            }
            ItemType::Food(mdminecraft_core::item::FoodType::Potato) => {
                mdminecraft_world::CropType::Potatoes
            }
            _ => return false,
        };

        if !mdminecraft_world::is_farmland(block_id) {
            return false;
        }

        if local_y + 1 >= CHUNK_SIZE_Y {
            return true;
        }

        let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
            return true;
        };

        let above = chunk.voxel(local_x, local_y + 1, local_z);
        if above.id != BLOCK_AIR {
            return true;
        }

        chunk.set_voxel(
            local_x,
            local_y + 1,
            local_z,
            Voxel {
                id: crop_type.base_block_id(),
                state: 0,
                light_sky: above.light_sky,
                light_block: above.light_block,
            },
        );

        self.crop_growth.register_crop(CropPosition {
            chunk: chunk_pos,
            x: local_x as u8,
            y: (local_y + 1) as u8,
            z: local_z as u8,
        });

        let _ = self.hotbar.consume_selected();

        self.debug_hud.chunk_uploads_last_frame += self.upload_chunk_mesh_and_neighbors(chunk_pos);
        true
    }

    fn try_apply_bone_meal_to_crop(&mut self, block_pos: IVec3) -> bool {
        let Some(stack) = self.hotbar.selected_item() else {
            return false;
        };
        if stack.count == 0 {
            return false;
        }

        // Item(18) = Bone Meal.
        if stack.item_type != ItemType::Item(18) {
            return false;
        }

        if !Self::apply_bone_meal_to_crop_at(
            self.world_seed,
            self.sim_tick.0,
            block_pos,
            &mut self.chunks,
            &mut self.crop_growth,
        ) {
            return false;
        }

        let _ = self.hotbar.consume_selected();

        let chunk_pos = ChunkPos::new(
            block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        self.debug_hud.chunk_uploads_last_frame += self.upload_chunk_mesh_and_neighbors(chunk_pos);
        true
    }

    fn apply_bone_meal_to_crop_at(
        world_seed: u64,
        tick: u64,
        block_pos: IVec3,
        chunks: &mut HashMap<ChunkPos, Chunk>,
        crop_growth: &mut CropGrowthSystem,
    ) -> bool {
        let Some(local_y) = world_y_to_local_y(block_pos.y) else {
            return false;
        };

        let chunk_pos = ChunkPos::new(
            block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let local_x = block_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = block_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        let Some(chunk) = chunks.get_mut(&chunk_pos) else {
            return false;
        };
        let voxel = chunk.voxel(local_x, local_y, local_z);

        let Some((crop_type, stage)) = mdminecraft_world::CropType::from_block_id(voxel.id) else {
            return false;
        };
        if stage >= crop_type.max_stage() {
            return false;
        }

        let delta = Self::bone_meal_crop_growth_delta(
            world_seed,
            tick,
            block_pos.x,
            block_pos.y,
            block_pos.z,
            stage,
        );
        let new_stage = stage.saturating_add(delta).min(crop_type.max_stage());
        let new_block_id = crop_type.block_id_at_stage(new_stage);

        chunk.set_voxel(
            local_x,
            local_y,
            local_z,
            Voxel {
                id: new_block_id,
                state: 0,
                light_sky: voxel.light_sky,
                light_block: voxel.light_block,
            },
        );

        let pos = CropPosition {
            chunk: chunk_pos,
            x: local_x as u8,
            y: local_y as u8,
            z: local_z as u8,
        };
        if new_stage >= crop_type.max_stage() {
            crop_growth.unregister_crop(pos);
        } else {
            crop_growth.register_crop(pos);
        }

        true
    }

    fn try_interact_with_target_block(&mut self, hit: RaycastHit) -> bool {
        let chunk_x = hit.block_pos.x.div_euclid(CHUNK_SIZE_X as i32);
        let chunk_z = hit.block_pos.z.div_euclid(CHUNK_SIZE_Z as i32);
        let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
        let local_x = hit.block_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let Some(local_y) = world_y_to_local_y(hit.block_pos.y) else {
            return false;
        };
        let local_z = hit.block_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        let block_id = self
            .chunks
            .get(&chunk_pos)
            .map(|chunk| chunk.voxel(local_x, local_y, local_z).id);

        if let Some(id) = block_id {
            if self.try_till_farmland(id, chunk_pos, local_x, local_y, local_z) {
                return true;
            }
            if self.try_plant_crop(id, chunk_pos, local_x, local_y, local_z) {
                return true;
            }
            if self.try_apply_bone_meal_to_crop(hit.block_pos) {
                return true;
            }
        }

        let is_water_here = self
            .chunks
            .get(&chunk_pos)
            .map(|chunk| {
                let voxel = chunk.voxel(local_x, local_y, local_z);
                get_fluid_type(voxel.id) == Some(FluidType::Water)
                    || (mdminecraft_world::block_supports_waterlogging(voxel.id)
                        && mdminecraft_world::is_waterlogged(voxel.state))
            })
            .unwrap_or(false);

        if is_water_here && self.try_fill_glass_bottle_from_water() {
            return true;
        }

        match block_id {
            Some(BLOCK_END_PORTAL_FRAME) => {
                let Some(changed_positions) =
                    self.try_use_eye_of_ender_on_end_portal_frame(hit.block_pos)
                else {
                    return false;
                };
                self.refresh_after_voxel_changes(&changed_positions);
                true
            }
            Some(BLOCK_CRAFTING_TABLE) => {
                self.open_crafting();
                true
            }
            Some(BLOCK_FURNACE) | Some(BLOCK_FURNACE_LIT) => {
                self.open_furnace(hit.block_pos);
                true
            }
            Some(BLOCK_ENCHANTING_TABLE) => {
                self.open_enchanting_table(hit.block_pos);
                true
            }
            Some(BLOCK_BREWING_STAND) => {
                self.open_brewing_stand(hit.block_pos);
                true
            }
            Some(interactive_blocks::CHEST) => {
                self.open_chest(hit.block_pos);
                true
            }
            Some(mdminecraft_world::mechanical_blocks::HOPPER) => {
                self.open_hopper(hit.block_pos);
                true
            }
            Some(mdminecraft_world::mechanical_blocks::DISPENSER) => {
                self.open_dispenser(hit.block_pos);
                true
            }
            Some(mdminecraft_world::mechanical_blocks::DROPPER) => {
                self.open_dropper(hit.block_pos);
                true
            }
            Some(interactive_blocks::BED_HEAD) | Some(interactive_blocks::BED_FOOT) => {
                self.try_sleep_in_bed(hit.block_pos);
                true
            }
            Some(BLOCK_RESPAWN_ANCHOR) => {
                self.interact_respawn_anchor(hit.block_pos);
                true
            }
            Some(id)
                if mdminecraft_world::is_door(id)
                    || mdminecraft_world::is_trapdoor(id)
                    || mdminecraft_world::is_fence_gate(id) =>
            {
                let result = self.interaction_manager.interact(
                    chunk_pos,
                    local_x,
                    local_y,
                    local_z,
                    &mut self.chunks,
                );
                if result == mdminecraft_world::InteractionResult::None {
                    return false;
                }

                let mut mesh_refresh = std::collections::BTreeSet::new();
                for dirty in self.interaction_manager.take_dirty_chunks() {
                    mesh_refresh.insert(dirty);
                    for neighbor in Self::neighbor_chunk_positions(dirty) {
                        mesh_refresh.insert(neighbor);
                    }
                }
                for dirty_chunk in mesh_refresh {
                    self.debug_hud.chunk_uploads_last_frame +=
                        self.upload_chunk_mesh(dirty_chunk) as u32;
                }
                true
            }
            Some(mdminecraft_world::redstone_blocks::LEVER) => {
                self.redstone_sim.toggle_lever(
                    RedstonePos::new(hit.block_pos.x, hit.block_pos.y, hit.block_pos.z),
                    &mut self.chunks,
                );
                self.debug_hud.chunk_uploads_last_frame +=
                    self.upload_chunk_mesh_and_neighbors(chunk_pos);
                true
            }
            Some(mdminecraft_world::redstone_blocks::STONE_BUTTON)
            | Some(mdminecraft_world::redstone_blocks::OAK_BUTTON) => {
                self.redstone_sim.activate_button(
                    RedstonePos::new(hit.block_pos.x, hit.block_pos.y, hit.block_pos.z),
                    &mut self.chunks,
                );
                self.debug_hud.chunk_uploads_last_frame +=
                    self.upload_chunk_mesh_and_neighbors(chunk_pos);
                true
            }
            Some(mdminecraft_world::redstone_blocks::REDSTONE_REPEATER) => {
                let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                    return false;
                };
                if local_y >= CHUNK_SIZE_Y {
                    return false;
                }

                let voxel = chunk.voxel(local_x, local_y, local_z);
                let current = mdminecraft_world::repeater_delay_ticks(voxel.state);
                let next = if current >= 4 { 1 } else { current + 1 };
                let new_state = mdminecraft_world::set_repeater_delay_ticks(voxel.state, next);

                chunk.set_voxel(
                    local_x,
                    local_y,
                    local_z,
                    Voxel {
                        state: new_state,
                        ..voxel
                    },
                );

                self.schedule_redstone_updates_around(hit.block_pos);
                self.debug_hud.chunk_uploads_last_frame +=
                    self.upload_chunk_mesh_and_neighbors(chunk_pos);
                true
            }
            Some(mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR) => {
                let Some(chunk) = self.chunks.get_mut(&chunk_pos) else {
                    return false;
                };
                if local_y >= CHUNK_SIZE_Y {
                    return false;
                }

                let voxel = chunk.voxel(local_x, local_y, local_z);
                let subtract = mdminecraft_world::is_comparator_subtract_mode(voxel.state);
                let new_state =
                    mdminecraft_world::set_comparator_subtract_mode(voxel.state, !subtract);

                chunk.set_voxel(
                    local_x,
                    local_y,
                    local_z,
                    Voxel {
                        state: new_state,
                        ..voxel
                    },
                );

                self.schedule_redstone_updates_around(hit.block_pos);
                self.debug_hud.chunk_uploads_last_frame +=
                    self.upload_chunk_mesh_and_neighbors(chunk_pos);
                true
            }
            _ => false,
        }
    }

    fn handle_mining(&mut self, hit: RaycastHit, dt: f32) {
        let chunk_x = hit.block_pos.x.div_euclid(16);
        let chunk_z = hit.block_pos.z.div_euclid(16);
        let chunk_pos = ChunkPos::new(chunk_x, chunk_z);

        // Get the block we're trying to mine
        let block_id = if let Some(chunk) = self.chunks.get(&chunk_pos) {
            let local_x = hit.block_pos.x.rem_euclid(16) as usize;
            let Some(local_y) = world_y_to_local_y(hit.block_pos.y) else {
                return;
            };
            let local_z = hit.block_pos.z.rem_euclid(16) as usize;

            chunk.voxel(local_x, local_y, local_z).id
        } else {
            return;
        };

        // Get block properties
        let block_props = self.block_properties.get(block_id);

        // Check if we're starting to mine a new block
        let mining_new_block = self
            .mining_progress
            .as_ref()
            .map(|p| p.block_pos != hit.block_pos)
            .unwrap_or(true);

        if mining_new_block {
            // Calculate mining time based on tool and block properties
            let tool = self.hotbar.selected_tool();
            let (eye_fluid, feet_fluid) =
                self.camera_eye_and_feet_fluids(self.renderer.camera().position);
            let in_water =
                eye_fluid == Some(FluidType::Water) || feet_fluid == Some(FluidType::Water);
            let has_aqua_affinity = self
                .player_armor
                .total_enchantment_level(EnchantmentType::AquaAffinity)
                > 0;
            let apply_water_penalty = in_water && !has_aqua_affinity;

            let mut mining_time = block_props.calculate_mining_time(tool, apply_water_penalty);

            // Apply Efficiency enchantment bonus
            // Each level of Efficiency adds 26% mining speed (Minecraft formula: (level^2 + 1) bonus)
            // Simplified: multiply speed by 1 + (0.26 * level)
            if let Some(item) = self.hotbar.selected_item() {
                let efficiency_level = item.enchantment_level(EnchantmentType::Efficiency);
                if efficiency_level > 0 {
                    let speed_bonus = 1.0 + 0.26 * efficiency_level as f32;
                    mining_time /= speed_bonus;
                    tracing::debug!(
                        "Efficiency {} applied: speed bonus {:.0}%",
                        efficiency_level,
                        (speed_bonus - 1.0) * 100.0
                    );
                }
            }

            self.mining_progress = Some(MiningProgress {
                block_pos: hit.block_pos,
                time_mining: 0.0,
                time_required: mining_time,
            });

            tracing::debug!(
                "Started mining block {} at {:?} (requires {:.2}s)",
                block_id,
                hit.block_pos,
                mining_time
            );
        }

        // Update mining progress
        if let Some(progress) = &mut self.mining_progress {
            progress.time_mining += dt;

            let percent = (progress.time_mining / progress.time_required * 100.0).min(100.0);
            self.debug_hud.mining_progress = Some(percent);

            // Check if mining is complete
            if progress.time_mining >= progress.time_required {
                // Mine the block!
                let mut spawn_particles_at: Option<glam::Vec3> = None;
                let mut mined = false;
                let mut removed_extra: Option<IVec3> = None;
                let mut mined_block_state: Option<BlockState> = None;
                let mut left_water = false;

                if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                    let local_x = hit.block_pos.x.rem_euclid(16) as usize;
                    let Some(local_y) = world_y_to_local_y(hit.block_pos.y) else {
                        return;
                    };
                    let local_z = hit.block_pos.z.rem_euclid(16) as usize;

                    // Check if tool can harvest this block
                    let tool = self.hotbar.selected_tool();
                    let can_harvest = block_props.can_harvest(tool);

                    if can_harvest {
                        tracing::info!(
                            "Successfully mined block {} at {:?}",
                            block_id,
                            hit.block_pos
                        );
                    } else {
                        tracing::warn!(
                            "Mined block {} but cannot harvest (wrong tool tier)",
                            block_id
                        );
                    }

                    let mined_voxel = chunk.voxel(local_x, local_y, local_z);
                    mined_block_state = Some(mined_voxel.state);

                    left_water = self.active_dimension != DimensionId::Nether
                        && mdminecraft_world::block_supports_waterlogging(mined_voxel.id)
                        && mdminecraft_world::is_waterlogged(mined_voxel.state);

                    // Remove the block (leave water behind when waterlogged).
                    if left_water {
                        chunk.set_voxel(
                            local_x,
                            local_y,
                            local_z,
                            Voxel {
                                id: FluidType::Water.source_block_id(),
                                state: 0,
                                light_sky: 0,
                                light_block: 0,
                            },
                        );
                    } else {
                        chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
                    }

                    if mdminecraft_world::CropType::is_crop(block_id) {
                        self.crop_growth.unregister_crop(CropPosition {
                            chunk: chunk_pos,
                            x: local_x as u8,
                            y: local_y as u8,
                            z: local_z as u8,
                        });
                    }

                    removed_extra = Self::try_remove_other_door_half(
                        chunk, local_x, local_y, local_z, block_id,
                    )
                    .map(|other_local_y| {
                        IVec3::new(
                            hit.block_pos.x,
                            local_y_to_world_y(other_local_y),
                            hit.block_pos.z,
                        )
                    });
                    spawn_particles_at = Some(glam::Vec3::new(
                        hit.block_pos.x as f32 + 0.5,
                        hit.block_pos.y as f32 + 0.5,
                        hit.block_pos.z as f32 + 0.5,
                    ));
                    mined = true;
                }

                if mined && removed_extra.is_none() && mdminecraft_world::is_bed(block_id) {
                    if let Some(state) = mined_block_state {
                        removed_extra = Self::try_remove_other_bed_half(
                            &mut self.chunks,
                            hit.block_pos,
                            block_id,
                            state,
                        );
                    }
                }

                if mined
                    && removed_extra.is_none()
                    && matches!(
                        block_id,
                        mdminecraft_world::mechanical_blocks::PISTON
                            | mdminecraft_world::mechanical_blocks::PISTON_HEAD
                    )
                {
                    if let Some(state) = mined_block_state {
                        removed_extra = Self::try_remove_other_piston_part(
                            &mut self.chunks,
                            hit.block_pos,
                            block_id,
                            state,
                        );
                    }
                }

                if mined {
                    // Notify fluid sim to update neighbors.
                    if left_water {
                        self.fluid_sim.on_fluid_placed(
                            FluidPos::new(hit.block_pos.x, hit.block_pos.y, hit.block_pos.z),
                            FluidType::Water,
                        );
                    } else {
                        self.fluid_sim.on_fluid_removed(
                            FluidPos::new(hit.block_pos.x, hit.block_pos.y, hit.block_pos.z),
                            &self.chunks,
                        );
                    }
                    if let Some(extra) = removed_extra {
                        self.fluid_sim.on_fluid_removed(
                            FluidPos::new(extra.x, extra.y, extra.z),
                            &self.chunks,
                        );
                    }

                    // Damage tool durability
                    if let Some(item) = self.hotbar.selected_item_mut() {
                        if matches!(item.item_type, ItemType::Tool(_, _)) {
                            item.damage_durability(1);
                            if item.is_broken() {
                                tracing::info!("Tool broke!");
                                // Remove the broken tool
                                self.hotbar.slots[self.hotbar.selected] = None;
                            }
                        }
                    }
                }

                if mined {
                    self.on_block_entity_removed(hit.block_pos, block_id);

                    let mut changed_positions = vec![hit.block_pos];
                    if let Some(extra) = removed_extra {
                        changed_positions.push(extra);
                    }

                    let support_changes = Self::remove_unsupported_blocks(
                        &mut self.chunks,
                        &self.block_properties,
                        changed_positions,
                    );

                    for (pos, removed_block_id) in &support_changes.removed {
                        if !mdminecraft_world::CropType::is_crop(*removed_block_id) {
                            continue;
                        }

                        let removed_chunk = ChunkPos::new(
                            pos.x.div_euclid(CHUNK_SIZE_X as i32),
                            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                        );
                        self.crop_growth.unregister_crop(CropPosition {
                            chunk: removed_chunk,
                            x: pos.x.rem_euclid(CHUNK_SIZE_X as i32) as u8,
                            y: pos.y as u8,
                            z: pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as u8,
                        });
                    }

                    // Notify redstone sim for any neighbor-dependent updates.
                    self.schedule_redstone_updates_around(hit.block_pos);
                    if let Some(extra) = removed_extra {
                        self.schedule_redstone_updates_around(extra);
                    }
                    for (pos, _) in &support_changes.removed {
                        self.schedule_redstone_updates_around(*pos);
                    }
                    for pos in &support_changes.moved {
                        self.schedule_redstone_updates_around(*pos);
                    }

                    let mut affected_chunks = std::collections::BTreeSet::new();
                    affected_chunks.insert(chunk_pos);
                    if let Some(extra) = removed_extra {
                        affected_chunks.insert(ChunkPos::new(
                            extra.x.div_euclid(CHUNK_SIZE_X as i32),
                            extra.z.div_euclid(CHUNK_SIZE_Z as i32),
                        ));
                    }
                    for (pos, removed_block_id) in &support_changes.removed {
                        self.on_block_entity_removed(*pos, *removed_block_id);

                        affected_chunks.insert(ChunkPos::new(
                            pos.x.div_euclid(CHUNK_SIZE_X as i32),
                            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                        ));

                        self.fluid_sim
                            .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);

                        let should_drop = if mdminecraft_world::is_door_upper(*removed_block_id) {
                            let lower_pos = IVec3::new(pos.x, pos.y - 1, pos.z);
                            !support_changes.removed.iter().any(|(other_pos, other_id)| {
                                *other_pos == lower_pos
                                    && mdminecraft_world::is_door_lower(*other_id)
                            })
                        } else {
                            *removed_block_id != interactive_blocks::BED_HEAD
                        };

                        if should_drop {
                            let drop_x = pos.x as f64 + 0.5;
                            let drop_y = pos.y as f64 + 0.5;
                            let drop_z = pos.z as f64 + 0.5;

                            if let Some(table) = self.loot_tables.block.get(removed_block_id) {
                                let mut rng = {
                                    let pos_seed = (pos.x as u64)
                                        ^ ((pos.y as u64).rotate_left(21))
                                        ^ ((pos.z as u64).rotate_left(42));
                                    let seed = self.world_seed
                                        ^ self.sim_tick.0.wrapping_mul(0x9E37_79B9_7F4A_7C15)
                                        ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
                                        ^ 0x10B1_0B15_EA4E_102E_u64;
                                    StdRng::seed_from_u64(seed)
                                };

                                for (drop_type, count) in table.roll(&mut rng) {
                                    self.item_manager.spawn_item(
                                        self.active_dimension,
                                        drop_x,
                                        drop_y,
                                        drop_z,
                                        drop_type,
                                        count,
                                    );
                                }
                            } else if let Some((drop_type, count)) =
                                DroppedItemType::from_block(*removed_block_id)
                            {
                                self.item_manager.spawn_item(
                                    self.active_dimension,
                                    drop_x,
                                    drop_y,
                                    drop_z,
                                    drop_type,
                                    count,
                                );
                            }
                        }
                    }

                    for pos in &support_changes.moved {
                        affected_chunks.insert(ChunkPos::new(
                            pos.x.div_euclid(CHUNK_SIZE_X as i32),
                            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                        ));
                        self.fluid_sim
                            .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
                    }

                    let mut mesh_refresh = std::collections::BTreeSet::new();
                    for dirty_chunk in affected_chunks {
                        mesh_refresh.extend(self.recompute_skylight_local(dirty_chunk));
                        mesh_refresh.insert(dirty_chunk);
                        mesh_refresh.extend(Self::neighbor_chunk_positions(dirty_chunk));

                        let affected = mdminecraft_world::recompute_block_light_local(
                            &mut self.chunks,
                            &self.registry,
                            dirty_chunk,
                        );
                        mesh_refresh.extend(affected);
                    }

                    for chunk_pos in mesh_refresh {
                        if self.upload_chunk_mesh(chunk_pos) {
                            self.debug_hud.chunk_uploads_last_frame += 1;
                        }
                    }

                    // Spawn dropped item if harvested successfully
                    let tool = self.hotbar.selected_tool();
                    let can_harvest = self.block_properties.get(block_id).can_harvest(tool);
                    if can_harvest {
                        let drop_x = hit.block_pos.x as f64 + 0.5;
                        let drop_y = hit.block_pos.y as f64 + 0.5;
                        let drop_z = hit.block_pos.z as f64 + 0.5;

                        // Check for Silk Touch and Fortune enchantments on the tool
                        let (has_silk_touch, fortune_level) =
                            if let Some(stack) = &self.hotbar.slots[self.hotbar.selected] {
                                let silk_touch = stack.has_enchantment(EnchantmentType::SilkTouch);
                                let fortune = stack.enchantment_level(EnchantmentType::Fortune);
                                (silk_touch, fortune)
                            } else {
                                (false, 0)
                            };

                        let mut rng = {
                            let pos_seed = (hit.block_pos.x as u64)
                                ^ ((hit.block_pos.y as u64).rotate_left(21))
                                ^ ((hit.block_pos.z as u64).rotate_left(42));
                            let seed = self.world_seed
                                ^ self.sim_tick.0.wrapping_mul(0x9E37_79B9_7F4A_7C15)
                                ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
                                ^ 0xDBA0_11A5_115D_1EAF_u64;
                            StdRng::seed_from_u64(seed)
                        };

                        if let Some(table) = self.loot_tables.block.get(&block_id) {
                            for (drop_type, count) in table.roll(&mut rng) {
                                self.item_manager.spawn_item(
                                    self.active_dimension,
                                    drop_x,
                                    drop_y,
                                    drop_z,
                                    drop_type,
                                    count,
                                );
                            }
                        } else {
                            let random = (rng.gen::<u32>() as f64) / (u32::MAX as f64);

                            let is_leaf_block = matches!(
                                block_id,
                                mdminecraft_world::tree_blocks::LEAVES
                                    | mdminecraft_world::tree_blocks::BIRCH_LEAVES
                                    | mdminecraft_world::tree_blocks::PINE_LEAVES
                            );

                            // Determine what to drop based on enchantments.
                            let drop = if is_leaf_block {
                                if has_silk_touch {
                                    DroppedItemType::silk_touch_drop(block_id)
                                } else {
                                    DroppedItemType::from_leaves_random(block_id, random)
                                }
                            } else if has_silk_touch {
                                DroppedItemType::silk_touch_drop(block_id)
                            } else if fortune_level > 0 {
                                DroppedItemType::fortune_drop(block_id, fortune_level, random)
                            } else {
                                DroppedItemType::from_block(block_id)
                            };

                            if let Some((drop_type, count)) = drop {
                                self.item_manager.spawn_item(
                                    self.active_dimension,
                                    drop_x,
                                    drop_y,
                                    drop_z,
                                    drop_type,
                                    count,
                                );
                                tracing::debug!(
                                    "Dropped {:?} x{} at ({:.1}, {:.1}, {:.1}){}",
                                    drop_type,
                                    count,
                                    drop_x,
                                    drop_y,
                                    drop_z,
                                    if has_silk_touch {
                                        " (Silk Touch)"
                                    } else if fortune_level > 0 {
                                        " (Fortune)"
                                    } else {
                                        ""
                                    }
                                );

                                // Vanilla-ish: breaking grass can drop seeds.
                                if block_id == mdminecraft_world::BLOCK_GRASS && !has_silk_touch {
                                    // Keep a simple 1/8 chance; deterministic via the per-block RNG.
                                    if random < 0.125 {
                                        self.item_manager.spawn_item(
                                            self.active_dimension,
                                            drop_x,
                                            drop_y,
                                            drop_z,
                                            DroppedItemType::WheatSeeds,
                                            1,
                                        );
                                    }
                                }

                                // Vanilla-ish: mature wheat drops extra seeds in addition to wheat.
                                if block_id == mdminecraft_world::farming_blocks::WHEAT_7 {
                                    let extra_seeds = ((random * 3.0).floor() as u32).min(2);
                                    let seeds = 1 + extra_seeds;
                                    self.item_manager.spawn_item(
                                        self.active_dimension,
                                        drop_x,
                                        drop_y,
                                        drop_z,
                                        DroppedItemType::WheatSeeds,
                                        seeds,
                                    );
                                }

                                // Vanilla-ish: mature carrots/potatoes drop extra produce in addition to the base drop.
                                if block_id == mdminecraft_world::farming_blocks::CARROTS_3 {
                                    let extra = ((random * 4.0).floor() as u32).min(3);
                                    if extra > 0 {
                                        self.item_manager.spawn_item(
                                            self.active_dimension,
                                            drop_x,
                                            drop_y,
                                            drop_z,
                                            DroppedItemType::Carrot,
                                            extra,
                                        );
                                    }
                                }
                                if block_id == mdminecraft_world::farming_blocks::POTATOES_3 {
                                    let extra = ((random * 4.0).floor() as u32).min(3);
                                    if extra > 0 {
                                        self.item_manager.spawn_item(
                                            self.active_dimension,
                                            drop_x,
                                            drop_y,
                                            drop_z,
                                            DroppedItemType::Potato,
                                            extra,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }

                if let Some(center) = spawn_particles_at {
                    self.spawn_block_break_particles(center, block_id);
                }

                // Reset mining progress
                self.mining_progress = None;
                self.debug_hud.mining_progress = None;
            }
        }
    }

    fn handle_block_placement(&mut self, hit: RaycastHit) {
        // Only place if we have a block selected
        if let Some(block_id) = self.hotbar.selected_block() {
            let hit_local_y = (hit.hit_pos.y - hit.block_pos.y as f32).clamp(0.0, 1.0);
            let Some(place_state) = Self::placement_state_for_block(
                block_id,
                self.renderer.camera().yaw,
                hit.face_normal,
                hit_local_y,
            ) else {
                return;
            };

            let mut place_block_id = block_id;
            let mut place_state = place_state;
            let mut allow_replace_existing_slab = false;
            let mut allow_replace_existing_snow = false;
            let mut place_pos = IVec3::new(
                hit.block_pos.x + hit.face_normal.x,
                hit.block_pos.y + hit.face_normal.y,
                hit.block_pos.z + hit.face_normal.z,
            );

            if mdminecraft_world::is_slab(block_id) {
                if let Some(double_slab_id) = Self::double_slab_block_id(block_id) {
                    let support_chunk_pos = ChunkPos::new(
                        hit.block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                        hit.block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                    );
                    if let Some(chunk) = self.chunks.get(&support_chunk_pos) {
                        let local_x = hit.block_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                        let Some(local_y) = world_y_to_local_y(hit.block_pos.y) else {
                            return;
                        };
                        let local_z = hit.block_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                        let existing = chunk.voxel(local_x, local_y, local_z);
                        if existing.id == block_id
                            && Self::should_merge_slab(existing.state, hit.face_normal, hit_local_y)
                        {
                            place_pos = hit.block_pos;
                            place_block_id = double_slab_id;
                            place_state = 0;
                            allow_replace_existing_slab = true;
                        }
                    }
                }
            }

            if block_id == BLOCK_SNOW && hit.face_normal == IVec3::new(0, 1, 0) {
                let support_chunk_pos = ChunkPos::new(
                    hit.block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    hit.block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                if let Some(chunk) = self.chunks.get(&support_chunk_pos) {
                    let local_x = hit.block_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let Some(local_y) = world_y_to_local_y(hit.block_pos.y) else {
                        return;
                    };
                    let local_z = hit.block_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                    let existing = chunk.voxel(local_x, local_y, local_z);
                    if existing.id == BLOCK_SNOW {
                        let layers = mdminecraft_world::snow_layers(existing.state);
                        if layers < mdminecraft_world::SNOW_LAYERS_MAX {
                            place_pos = hit.block_pos;
                            place_block_id = block_id;
                            place_state = mdminecraft_world::set_snow_layers(
                                existing.state,
                                layers.saturating_add(1),
                            );
                            allow_replace_existing_snow = true;
                        }
                    }
                }
            }

            if matches!(
                block_id,
                interactive_blocks::LADDER
                    | interactive_blocks::TORCH
                    | mdminecraft_world::redstone_blocks::REDSTONE_TORCH
                    | mdminecraft_world::redstone_blocks::LEVER
                    | mdminecraft_world::redstone_blocks::STONE_BUTTON
                    | mdminecraft_world::redstone_blocks::OAK_BUTTON
                    | mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE
                    | mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE
                    | mdminecraft_world::redstone_blocks::REDSTONE_WIRE
                    | mdminecraft_world::redstone_blocks::REDSTONE_REPEATER
                    | mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR
            ) {
                let support_chunk_pos = ChunkPos::new(
                    hit.block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    hit.block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                let Some(chunk) = self.chunks.get(&support_chunk_pos) else {
                    return;
                };

                let local_x = hit.block_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let Some(local_y) = world_y_to_local_y(hit.block_pos.y) else {
                    return;
                };
                let local_z = hit.block_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                let support_voxel = chunk.voxel(local_x, local_y, local_z);
                if !self.block_properties.get(support_voxel.id).is_solid {
                    return;
                }
            }

            if block_id == mdminecraft_world::BLOCK_SUGAR_CANE {
                // Vanilla-ish: sugar cane must be placed on top of a valid support block.
                if hit.face_normal != IVec3::new(0, 1, 0) {
                    return;
                }

                let support_pos = hit.block_pos;
                let Some(support_id) = self.get_block_at(support_pos) else {
                    return;
                };

                // Sugar cane can always be stacked on sugar cane.
                if support_id != mdminecraft_world::BLOCK_SUGAR_CANE {
                    // Otherwise the base must be on dirt/grass/sand and adjacent to water.
                    if !matches!(
                        support_id,
                        mdminecraft_world::BLOCK_DIRT
                            | mdminecraft_world::BLOCK_GRASS
                            | mdminecraft_world::BLOCK_SAND
                    ) {
                        return;
                    }

                    let is_water_at = |pos: IVec3| -> bool {
                        let Some(voxel) = self.get_voxel_at(pos) else {
                            return false;
                        };

                        get_fluid_type(voxel.id) == Some(FluidType::Water)
                            || (mdminecraft_world::block_supports_waterlogging(voxel.id)
                                && mdminecraft_world::is_waterlogged(voxel.state))
                    };

                    let has_adjacent_water = [
                        IVec3::new(1, 0, 0),
                        IVec3::new(-1, 0, 0),
                        IVec3::new(0, 0, 1),
                        IVec3::new(0, 0, -1),
                    ]
                    .into_iter()
                    .any(|offset| is_water_at(support_pos + offset));

                    if !has_adjacent_water {
                        return;
                    }
                }
            }

            if block_id == mdminecraft_world::BLOCK_BROWN_MUSHROOM {
                // Vanilla-ish: mushrooms are placed on the top face of a solid block.
                if hit.face_normal != IVec3::new(0, 1, 0) {
                    return;
                }

                let support_pos = hit.block_pos;
                let Some(support_id) = self.get_block_at(support_pos) else {
                    return;
                };

                if !self.block_properties.get(support_id).is_solid {
                    return;
                }
            }

            let chunk_x = place_pos.x.div_euclid(16);
            let chunk_z = place_pos.z.div_euclid(16);
            let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
            let mut spawn_particles_at: Option<glam::Vec3> = None;
            let mut placed = false;
            let mut placed_waterlogged = false;
            let mut placed_extra: Option<IVec3> = None;

            if block_id == interactive_blocks::BED_FOOT {
                if let Some(extra) = self.try_place_bed(place_pos, place_state) {
                    placed_extra = Some(extra);
                    spawn_particles_at = Some(glam::Vec3::new(
                        place_pos.x as f32 + 0.5,
                        place_pos.y as f32 + 0.5,
                        place_pos.z as f32 + 0.5,
                    ));
                    placed = true;
                }
            } else if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                let local_x = place_pos.x.rem_euclid(16) as usize;
                let Some(local_y) = world_y_to_local_y(place_pos.y) else {
                    return;
                };
                let local_z = place_pos.z.rem_euclid(16) as usize;

                let current = chunk.voxel(local_x, local_y, local_z);
                let can_place_into_water =
                    mdminecraft_world::block_supports_waterlogging(place_block_id)
                        && get_fluid_type(current.id) == Some(FluidType::Water);

                if current.id == BLOCK_AIR
                    || can_place_into_water
                    || (allow_replace_existing_slab
                        && current.id == block_id
                        && place_block_id != block_id)
                    || (allow_replace_existing_snow
                        && current.id == block_id
                        && place_block_id == block_id)
                {
                    if can_place_into_water && self.active_dimension != DimensionId::Nether {
                        place_state = mdminecraft_world::set_waterlogged(place_state, true);
                        placed_waterlogged = true;
                    }

                    if mdminecraft_world::is_door_lower(block_id) {
                        if Self::try_place_door(
                            chunk,
                            local_x,
                            local_y,
                            local_z,
                            block_id,
                            place_state,
                        ) {
                            placed_extra =
                                Some(IVec3::new(place_pos.x, place_pos.y + 1, place_pos.z));
                            spawn_particles_at = Some(glam::Vec3::new(
                                place_pos.x as f32 + 0.5,
                                place_pos.y as f32 + 0.5,
                                place_pos.z as f32 + 0.5,
                            ));
                            placed = true;
                        }
                    } else {
                        let new_voxel = Voxel {
                            id: place_block_id,
                            state: place_state,
                            light_sky: 0,
                            light_block: 0,
                        };
                        chunk.set_voxel(local_x, local_y, local_z, new_voxel);
                        spawn_particles_at = Some(glam::Vec3::new(
                            place_pos.x as f32 + 0.5,
                            place_pos.y as f32 + 0.5,
                            place_pos.z as f32 + 0.5,
                        ));
                        placed = true;

                        if block_id == mdminecraft_world::BLOCK_SUGAR_CANE {
                            // Register the base of the column so it can grow deterministically.
                            let mut base_y = local_y;
                            while base_y > 0
                                && chunk.voxel(local_x, base_y - 1, local_z).id
                                    == mdminecraft_world::BLOCK_SUGAR_CANE
                            {
                                base_y -= 1;
                            }

                            self.sugar_cane_growth.register_base(SugarCanePosition {
                                chunk: chunk_pos,
                                x: local_x as u8,
                                y: base_y as u8,
                                z: local_z as u8,
                            });
                        }
                    }
                }
            }

            if placed {
                // Initialize block-entity state for blocks that need it even when never opened.
                if place_block_id == mdminecraft_world::mechanical_blocks::HOPPER {
                    let key = self.block_entity_key(place_pos);
                    self.hoppers.entry(key).or_default();
                }
                if place_block_id == mdminecraft_world::mechanical_blocks::DISPENSER {
                    let key = self.block_entity_key(place_pos);
                    self.dispensers.entry(key).or_default();
                }
                if place_block_id == mdminecraft_world::mechanical_blocks::DROPPER {
                    let key = self.block_entity_key(place_pos);
                    self.droppers.entry(key).or_default();
                }

                // Notify fluid sim.
                if placed_waterlogged {
                    self.fluid_sim.on_fluid_placed(
                        FluidPos::new(place_pos.x, place_pos.y, place_pos.z),
                        FluidType::Water,
                    );
                } else {
                    // Treat as removal to wake neighbors who might be flowing here.
                    self.fluid_sim.on_fluid_removed(
                        FluidPos::new(place_pos.x, place_pos.y, place_pos.z),
                        &self.chunks,
                    );
                }
                if let Some(extra) = placed_extra {
                    self.fluid_sim
                        .on_fluid_removed(FluidPos::new(extra.x, extra.y, extra.z), &self.chunks);
                }

                // Notify redstone sim for any neighbor-dependent updates.
                self.schedule_redstone_updates_around(place_pos);
                if let Some(extra) = placed_extra {
                    self.schedule_redstone_updates_around(extra);
                }

                // Decrease block count.
                if let Some(item) = self.hotbar.selected_item_mut() {
                    if item.count > 0 {
                        item.count -= 1;
                        if item.count == 0 {
                            self.hotbar.slots[self.hotbar.selected] = None;
                        }
                    }
                }
            }

            if placed {
                let mut dirty_chunks = std::collections::BTreeSet::new();
                dirty_chunks.insert(chunk_pos);
                if let Some(extra) = placed_extra {
                    dirty_chunks.insert(ChunkPos::new(
                        extra.x.div_euclid(16),
                        extra.z.div_euclid(16),
                    ));
                }

                // Update lighting (skylight + seams) for any affected chunks (including
                // cross-chunk multi-block placements like beds).
                let mut skylight_affected = std::collections::BTreeSet::new();
                for pos in &dirty_chunks {
                    skylight_affected.extend(self.recompute_skylight_local(*pos));
                }

                // Update blocklight and refresh affected meshes.
                let mut affected = std::collections::BTreeSet::new();
                for pos in &dirty_chunks {
                    affected.extend(mdminecraft_world::recompute_block_light_local(
                        &mut self.chunks,
                        &self.registry,
                        *pos,
                    ));
                }

                // Refresh the changed chunk + neighbors (geometry/connectivity) and any chunks
                // touched by lighting updates (includes diagonals).
                let mut mesh_refresh = std::collections::BTreeSet::new();
                for pos in &dirty_chunks {
                    mesh_refresh.insert(*pos);
                    mesh_refresh.extend(Self::neighbor_chunk_positions(*pos));
                }
                mesh_refresh.extend(skylight_affected);
                mesh_refresh.extend(affected);
                for pos in mesh_refresh {
                    if self.upload_chunk_mesh(pos) {
                        self.debug_hud.chunk_uploads_last_frame += 1;
                    }
                }
            }

            if let Some(center) = spawn_particles_at {
                self.spawn_block_break_particles(center, block_id);
            }
        }
    }

    fn placement_state_for_block(
        block_id: BlockId,
        camera_yaw: f32,
        face_normal: IVec3,
        hit_local_y: f32,
    ) -> Option<BlockState> {
        if matches!(
            block_id,
            interactive_blocks::TORCH | mdminecraft_world::redstone_blocks::REDSTONE_TORCH
        ) {
            if face_normal.y == 1 {
                return Some(0);
            }
            // Torches cannot be mounted on ceilings.
            if face_normal.y == -1 {
                return None;
            }

            let facing = match (face_normal.x, face_normal.z) {
                (1, 0) => mdminecraft_world::Facing::East,
                (-1, 0) => mdminecraft_world::Facing::West,
                (0, 1) => mdminecraft_world::Facing::South,
                (0, -1) => mdminecraft_world::Facing::North,
                _ => return None,
            };
            return Some(mdminecraft_world::torch_wall_state(facing));
        }

        if matches!(
            block_id,
            mdminecraft_world::redstone_blocks::LEVER
                | mdminecraft_world::redstone_blocks::STONE_BUTTON
                | mdminecraft_world::redstone_blocks::OAK_BUTTON
        ) {
            if face_normal.y == 1 {
                return Some(0);
            }
            if face_normal.y == -1 {
                return Some(mdminecraft_world::ceiling_mount_state());
            }

            let facing = match (face_normal.x, face_normal.z) {
                (1, 0) => mdminecraft_world::Facing::East,
                (-1, 0) => mdminecraft_world::Facing::West,
                (0, 1) => mdminecraft_world::Facing::South,
                (0, -1) => mdminecraft_world::Facing::North,
                _ => return None,
            };
            return Some(mdminecraft_world::wall_mount_state(facing));
        }

        if matches!(
            block_id,
            mdminecraft_world::mechanical_blocks::PISTON
                | mdminecraft_world::mechanical_blocks::DISPENSER
                | mdminecraft_world::mechanical_blocks::DROPPER
        ) {
            // Vanilla-ish: these blocks can be placed on top faces or side faces with horizontal
            // orientation. Ceiling placement is not supported yet.
            if face_normal.y == -1 {
                return None;
            }

            let facing = if face_normal.y == 1 {
                mdminecraft_world::Facing::from_yaw(camera_yaw)
            } else {
                match (face_normal.x, face_normal.z) {
                    (1, 0) => mdminecraft_world::Facing::West,
                    (-1, 0) => mdminecraft_world::Facing::East,
                    (0, 1) => mdminecraft_world::Facing::North,
                    (0, -1) => mdminecraft_world::Facing::South,
                    _ => return None,
                }
            };

            let mut state = 0;
            if block_id == mdminecraft_world::mechanical_blocks::PISTON {
                state = mdminecraft_world::set_piston_facing(state, facing);
                return Some(state);
            }
            if block_id == mdminecraft_world::mechanical_blocks::DISPENSER {
                state = mdminecraft_world::set_dispenser_facing(state, facing);
                return Some(state);
            }
            if block_id == mdminecraft_world::mechanical_blocks::DROPPER {
                state = mdminecraft_world::set_dropper_facing(state, facing);
                return Some(state);
            }
        }

        if block_id == mdminecraft_world::mechanical_blocks::HOPPER {
            // Vanilla-ish: hoppers can be placed on a top face (output down) or a side face
            // (output into the clicked block). Ceiling placement is also supported (hanging hopper
            // output is still "down").

            let mut state = 0;
            if face_normal.y == 1 || face_normal.y == -1 {
                // Placing on top (or hanging from a ceiling) outputs down into the block below.
                state = mdminecraft_world::set_hopper_outputs_down(state, true);
                // Keep a deterministic horizontal facing for visuals/consistency.
                state = mdminecraft_world::set_hopper_facing(
                    state,
                    mdminecraft_world::Facing::from_yaw(camera_yaw),
                );
                return Some(state);
            }

            let facing = match (face_normal.x, face_normal.z) {
                (1, 0) => mdminecraft_world::Facing::West,
                (-1, 0) => mdminecraft_world::Facing::East,
                (0, 1) => mdminecraft_world::Facing::North,
                (0, -1) => mdminecraft_world::Facing::South,
                _ => return None,
            };
            state = mdminecraft_world::set_hopper_facing(state, facing);
            return Some(state);
        }

        if matches!(
            block_id,
            mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE
                | mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE
                | mdminecraft_world::redstone_blocks::REDSTONE_WIRE
                | mdminecraft_world::redstone_blocks::REDSTONE_REPEATER
                | mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR
                | mdminecraft_world::redstone_blocks::REDSTONE_OBSERVER
        ) {
            if face_normal.y != 1 {
                return None;
            }
            if block_id == mdminecraft_world::redstone_blocks::REDSTONE_REPEATER {
                let mut state = 0;
                state = mdminecraft_world::set_repeater_facing(
                    state,
                    mdminecraft_world::Facing::from_yaw(camera_yaw),
                );
                state = mdminecraft_world::set_repeater_delay_ticks(state, 1);
                return Some(state);
            }
            if block_id == mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR {
                let mut state = 0;
                state = mdminecraft_world::set_comparator_facing(
                    state,
                    mdminecraft_world::Facing::from_yaw(camera_yaw),
                );
                state = mdminecraft_world::set_comparator_subtract_mode(state, false);
                state = mdminecraft_world::set_comparator_output_power(state, 0);
                return Some(state);
            }
            if block_id == mdminecraft_world::redstone_blocks::REDSTONE_OBSERVER {
                let mut state = 0;
                state = mdminecraft_world::set_observer_facing(
                    state,
                    mdminecraft_world::Facing::from_yaw(camera_yaw),
                );
                return Some(state);
            }
            return Some(0);
        }

        if mdminecraft_world::is_slab(block_id) {
            let top = if face_normal.y < 0 {
                true
            } else if face_normal.y > 0 {
                false
            } else {
                hit_local_y >= 0.5
            };

            let pos = if top {
                mdminecraft_world::SlabPosition::Top
            } else {
                mdminecraft_world::SlabPosition::Bottom
            };
            return Some(pos.to_state(0));
        }

        if mdminecraft_world::is_ladder(block_id) {
            let facing = match (face_normal.x, face_normal.z) {
                (-1, 0) => mdminecraft_world::Facing::East,
                (1, 0) => mdminecraft_world::Facing::West,
                (0, -1) => mdminecraft_world::Facing::South,
                (0, 1) => mdminecraft_world::Facing::North,
                _ => return None,
            };
            return Some(facing.to_state());
        }

        if mdminecraft_world::is_trapdoor(block_id) {
            let top = if face_normal.y < 0 {
                true
            } else if face_normal.y > 0 {
                false
            } else {
                hit_local_y >= 0.5
            };
            let mut state = mdminecraft_world::Facing::from_yaw(camera_yaw).to_state();
            state = mdminecraft_world::set_trapdoor_top(state, top);
            return Some(state);
        }

        if mdminecraft_world::is_stairs(block_id) {
            let top = if face_normal.y < 0 {
                true
            } else if face_normal.y > 0 {
                false
            } else {
                hit_local_y >= 0.5
            };
            let mut state = mdminecraft_world::Facing::from_yaw(camera_yaw).to_state();
            if top {
                state |= 0x04;
            } else {
                state &= !0x04;
            }
            return Some(state);
        }

        if block_id == interactive_blocks::BED_HEAD {
            // Beds should always be placed via their foot block, which spawns both halves.
            return None;
        }

        if block_id == interactive_blocks::BED_FOOT {
            return Some(mdminecraft_world::Facing::from_yaw(camera_yaw).to_state());
        }

        if mdminecraft_world::is_door(block_id) {
            // Only lower halves are placeable; doors must be placed on a top face.
            if !mdminecraft_world::is_door_lower(block_id) {
                return None;
            }
            if face_normal.y != 1 {
                return None;
            }
            return Some(mdminecraft_world::Facing::from_yaw(camera_yaw).to_state());
        }

        if mdminecraft_world::is_fence_gate(block_id) {
            return Some(mdminecraft_world::Facing::from_yaw(camera_yaw).to_state());
        }

        Some(0)
    }

    fn double_slab_block_id(slab_id: BlockId) -> Option<BlockId> {
        match slab_id {
            interactive_blocks::STONE_SLAB => Some(mdminecraft_world::BLOCK_DOUBLE_STONE_SLAB),
            interactive_blocks::OAK_SLAB => Some(mdminecraft_world::BLOCK_DOUBLE_OAK_SLAB),
            interactive_blocks::STONE_BRICK_SLAB => {
                Some(mdminecraft_world::BLOCK_DOUBLE_STONE_BRICK_SLAB)
            }
            _ => None,
        }
    }

    fn should_merge_slab(existing_state: BlockState, face_normal: IVec3, hit_local_y: f32) -> bool {
        let existing_is_top = matches!(
            mdminecraft_world::SlabPosition::from_state(existing_state),
            mdminecraft_world::SlabPosition::Top
        );

        if face_normal.y > 0 {
            // Clicking the top face merges only with a bottom slab.
            !existing_is_top
        } else if face_normal.y < 0 {
            // Clicking the bottom face merges only with a top slab.
            existing_is_top
        } else {
            // Clicking the side merges if we target the missing half.
            let desired_top = hit_local_y >= 0.5;
            desired_top != existing_is_top
        }
    }

    fn schedule_redstone_updates_around(&mut self, pos: IVec3) {
        let center = RedstonePos::new(pos.x, pos.y, pos.z);
        self.redstone_sim.schedule_update(center);
        for neighbor in center.neighbors() {
            self.redstone_sim.schedule_update(neighbor);
        }
    }

    fn collect_pressed_pressure_plates(
        chunks: &HashMap<ChunkPos, Chunk>,
        active_dimension: DimensionId,
        player: Option<(glam::Vec3, f32)>,
        mobs: &[Mob],
        item_manager: &ItemManager,
    ) -> std::collections::BTreeSet<RedstonePos> {
        fn block_id_at(chunks: &HashMap<ChunkPos, Chunk>, pos: IVec3) -> Option<BlockId> {
            let chunk_pos = ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let chunk = chunks.get(&chunk_pos)?;

            let local_y = world_y_to_local_y(pos.y)?;
            let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

            Some(chunk.voxel(local_x, local_y, local_z).id)
        }

        // The player/mob feet Y often lands exactly on voxel boundaries. Sample slightly above to
        // reliably detect top-mounted blocks like pressure plates.
        const FOOT_EPS: f32 = 0.05;

        let mut pressed = std::collections::BTreeSet::new();

        if let Some((eye_pos, eye_height)) = player {
            let feet_pos = eye_pos - glam::Vec3::new(0.0, eye_height, 0.0);
            let sample = feet_pos + glam::Vec3::new(0.0, FOOT_EPS, 0.0);
            let pos = IVec3::new(
                sample.x.floor() as i32,
                sample.y.floor() as i32,
                sample.z.floor() as i32,
            );
            if matches!(
                block_id_at(chunks, pos),
                Some(
                    mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE
                        | mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE
                )
            ) {
                pressed.insert(RedstonePos::new(pos.x, pos.y, pos.z));
            }
        }

        for mob in mobs {
            if mob.dimension != active_dimension || mob.dead {
                continue;
            }

            let sample_y = mob.y + FOOT_EPS as f64;
            let pos = IVec3::new(
                mob.x.floor() as i32,
                sample_y.floor() as i32,
                mob.z.floor() as i32,
            );

            if matches!(
                block_id_at(chunks, pos),
                Some(
                    mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE
                        | mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE
                )
            ) {
                pressed.insert(RedstonePos::new(pos.x, pos.y, pos.z));
            }
        }

        // Vanilla-ish: wooden plates trigger on dropped items; stone plates do not.
        for item in item_manager.iter() {
            if item.dimension != active_dimension || !item.on_ground {
                continue;
            }
            let pos = IVec3::new(
                item.x.floor() as i32,
                item.y.floor() as i32,
                item.z.floor() as i32,
            );
            if block_id_at(chunks, pos)
                == Some(mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE)
            {
                pressed.insert(RedstonePos::new(pos.x, pos.y, pos.z));
            }
        }

        pressed
    }

    fn apply_pressure_plate_transitions(
        previous: &std::collections::BTreeSet<RedstonePos>,
        next: &std::collections::BTreeSet<RedstonePos>,
        redstone_sim: &mut RedstoneSimulator,
        chunks: &mut HashMap<ChunkPos, Chunk>,
    ) {
        for pos in previous.difference(next) {
            redstone_sim.update_pressure_plate(*pos, false, chunks);
        }
        for pos in next.difference(previous) {
            redstone_sim.update_pressure_plate(*pos, true, chunks);
        }
    }

    fn update_pressure_plates(&mut self) {
        let player = (self.player_state == PlayerState::Alive).then(|| {
            (
                self.renderer.camera().position,
                self.player_physics.eye_height,
            )
        });

        let pressed = Self::collect_pressed_pressure_plates(
            &self.chunks,
            self.active_dimension,
            player,
            &self.mobs,
            &self.item_manager,
        );

        if pressed == self.pressed_pressure_plates {
            return;
        }

        Self::apply_pressure_plate_transitions(
            &self.pressed_pressure_plates,
            &pressed,
            &mut self.redstone_sim,
            &mut self.chunks,
        );

        self.pressed_pressure_plates = pressed;
    }

    fn door_upper_id(lower_id: BlockId) -> Option<BlockId> {
        match lower_id {
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER => {
                Some(mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER)
            }
            mdminecraft_world::interactive_blocks::IRON_DOOR_LOWER => {
                Some(mdminecraft_world::interactive_blocks::IRON_DOOR_UPPER)
            }
            _ => None,
        }
    }

    fn try_place_door(
        chunk: &mut Chunk,
        local_x: usize,
        local_y: usize,
        local_z: usize,
        lower_id: BlockId,
        state: BlockState,
    ) -> bool {
        let Some(upper_id) = Self::door_upper_id(lower_id) else {
            return false;
        };
        if local_y + 1 >= CHUNK_SIZE_Y {
            return false;
        }
        if chunk.voxel(local_x, local_y, local_z).id != BLOCK_AIR {
            return false;
        }
        if chunk.voxel(local_x, local_y + 1, local_z).id != BLOCK_AIR {
            return false;
        }

        chunk.set_voxel(
            local_x,
            local_y,
            local_z,
            Voxel {
                id: lower_id,
                state,
                light_sky: 0,
                light_block: 0,
            },
        );
        chunk.set_voxel(
            local_x,
            local_y + 1,
            local_z,
            Voxel {
                id: upper_id,
                state,
                light_sky: 0,
                light_block: 0,
            },
        );
        true
    }

    fn bed_other_half_pos(
        pos: IVec3,
        bed_id: BlockId,
        state: BlockState,
    ) -> Option<(IVec3, BlockId)> {
        if !mdminecraft_world::is_bed(bed_id) {
            return None;
        }

        let facing = mdminecraft_world::Facing::from_state(state);
        let (dx, dz) = facing.offset();

        match bed_id {
            interactive_blocks::BED_FOOT => Some((
                IVec3::new(pos.x + dx, pos.y, pos.z + dz),
                interactive_blocks::BED_HEAD,
            )),
            interactive_blocks::BED_HEAD => Some((
                IVec3::new(pos.x - dx, pos.y, pos.z - dz),
                interactive_blocks::BED_FOOT,
            )),
            _ => None,
        }
    }

    fn try_place_bed(&mut self, foot_pos: IVec3, state: BlockState) -> Option<IVec3> {
        let foot_local_y = world_y_to_local_y(foot_pos.y)?;

        let (head_pos, _) =
            Self::bed_other_half_pos(foot_pos, interactive_blocks::BED_FOOT, state)?;

        // Require space for both halves.
        if self.get_block_at(foot_pos) != Some(BLOCK_AIR) {
            return None;
        }
        if self.get_block_at(head_pos) != Some(BLOCK_AIR) {
            return None;
        }

        // Require solid support below both halves.
        for pos in [foot_pos, head_pos] {
            let support_pos = IVec3::new(pos.x, pos.y - 1, pos.z);
            let support_id = self.get_block_at(support_pos)?;
            if !self.block_properties.get(support_id).is_solid {
                return None;
            }
        }

        let foot_chunk_pos = ChunkPos::new(
            foot_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            foot_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let head_chunk_pos = ChunkPos::new(
            head_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            head_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );

        let foot_local_x = foot_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let foot_local_z = foot_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        let head_local_x = head_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let head_local_y = foot_local_y;
        let head_local_z = head_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        if foot_chunk_pos == head_chunk_pos {
            let chunk = self.chunks.get_mut(&foot_chunk_pos)?;
            chunk.set_voxel(
                foot_local_x,
                foot_local_y,
                foot_local_z,
                Voxel {
                    id: interactive_blocks::BED_FOOT,
                    state,
                    light_sky: 0,
                    light_block: 0,
                },
            );
            chunk.set_voxel(
                head_local_x,
                head_local_y,
                head_local_z,
                Voxel {
                    id: interactive_blocks::BED_HEAD,
                    state,
                    light_sky: 0,
                    light_block: 0,
                },
            );
        } else {
            {
                let foot_chunk = self.chunks.get_mut(&foot_chunk_pos)?;
                foot_chunk.set_voxel(
                    foot_local_x,
                    foot_local_y,
                    foot_local_z,
                    Voxel {
                        id: interactive_blocks::BED_FOOT,
                        state,
                        light_sky: 0,
                        light_block: 0,
                    },
                );
            }
            {
                let head_chunk = self.chunks.get_mut(&head_chunk_pos)?;
                head_chunk.set_voxel(
                    head_local_x,
                    head_local_y,
                    head_local_z,
                    Voxel {
                        id: interactive_blocks::BED_HEAD,
                        state,
                        light_sky: 0,
                        light_block: 0,
                    },
                );
            }
        }

        Some(head_pos)
    }

    fn try_remove_other_door_half(
        chunk: &mut Chunk,
        local_x: usize,
        local_y: usize,
        local_z: usize,
        door_id: BlockId,
    ) -> Option<usize> {
        if !mdminecraft_world::is_door(door_id) {
            return None;
        }

        let other_local_y = if mdminecraft_world::is_door_lower(door_id) {
            local_y.checked_add(1)?
        } else {
            local_y.checked_sub(1)?
        };
        if other_local_y >= CHUNK_SIZE_Y {
            return None;
        }

        let other_voxel = chunk.voxel(local_x, other_local_y, local_z);
        if mdminecraft_world::is_door(other_voxel.id) {
            chunk.set_voxel(local_x, other_local_y, local_z, Voxel::default());
            Some(other_local_y)
        } else {
            None
        }
    }

    fn try_remove_other_bed_half(
        chunks: &mut HashMap<ChunkPos, Chunk>,
        bed_pos: IVec3,
        bed_id: BlockId,
        bed_state: BlockState,
    ) -> Option<IVec3> {
        let (other_pos, expected_other_id) = Self::bed_other_half_pos(bed_pos, bed_id, bed_state)?;
        let local_y = world_y_to_local_y(other_pos.y)?;

        let other_chunk_pos = ChunkPos::new(
            other_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            other_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let chunk = chunks.get_mut(&other_chunk_pos)?;

        let local_x = other_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = other_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        let other_voxel = chunk.voxel(local_x, local_y, local_z);
        if other_voxel.id != expected_other_id {
            return None;
        }

        chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
        Some(other_pos)
    }

    fn try_remove_other_piston_part(
        chunks: &mut HashMap<ChunkPos, Chunk>,
        piston_pos: IVec3,
        piston_id: BlockId,
        piston_state: BlockState,
    ) -> Option<IVec3> {
        let facing = mdminecraft_world::piston_facing(piston_state);
        let (dx, dz) = facing.offset();

        let (other_pos, expected_other_id) =
            if piston_id == mdminecraft_world::mechanical_blocks::PISTON {
                (
                    IVec3::new(piston_pos.x + dx, piston_pos.y, piston_pos.z + dz),
                    mdminecraft_world::mechanical_blocks::PISTON_HEAD,
                )
            } else if piston_id == mdminecraft_world::mechanical_blocks::PISTON_HEAD {
                (
                    IVec3::new(piston_pos.x - dx, piston_pos.y, piston_pos.z - dz),
                    mdminecraft_world::mechanical_blocks::PISTON,
                )
            } else {
                return None;
            };

        let local_y = world_y_to_local_y(other_pos.y)?;

        let other_chunk_pos = ChunkPos::new(
            other_pos.x.div_euclid(CHUNK_SIZE_X as i32),
            other_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let chunk = chunks.get_mut(&other_chunk_pos)?;

        let local_x = other_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = other_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        let other_voxel = chunk.voxel(local_x, local_y, local_z);
        if other_voxel.id != expected_other_id {
            return None;
        }

        chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
        Some(other_pos)
    }

    fn remove_unsupported_blocks(
        chunks: &mut HashMap<ChunkPos, Chunk>,
        block_properties: &BlockPropertiesRegistry,
        changed_positions: impl IntoIterator<Item = IVec3>,
    ) -> UnsupportedBlockChanges {
        let mut queue: std::collections::VecDeque<IVec3> = changed_positions.into_iter().collect();
        let mut removed = Vec::new();
        let mut moved = Vec::new();

        let voxel_at = |chunks: &HashMap<ChunkPos, Chunk>, pos: IVec3| -> Option<Voxel> {
            let local_y = world_y_to_local_y(pos.y)?;

            let chunk_pos = ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let chunk = chunks.get(&chunk_pos)?;
            let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            Some(chunk.voxel(local_x, local_y, local_z))
        };

        let is_solid_at = |chunks: &HashMap<ChunkPos, Chunk>, pos: IVec3| -> bool {
            voxel_at(chunks, pos).is_some_and(|voxel| block_properties.get(voxel.id).is_solid)
        };

        let set_voxel_at =
            |chunks: &mut HashMap<ChunkPos, Chunk>, pos: IVec3, voxel: Voxel| -> bool {
                let Some(local_y) = world_y_to_local_y(pos.y) else {
                    return false;
                };
                let chunk_pos = ChunkPos::new(
                    pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                let Some(chunk) = chunks.get_mut(&chunk_pos) else {
                    return false;
                };
                let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                chunk.set_voxel(local_x, local_y, local_z, voxel);
                true
            };
        let can_set_voxel_at = |chunks: &HashMap<ChunkPos, Chunk>, pos: IVec3| -> bool {
            if world_y_to_local_y(pos.y).is_none() {
                return false;
            }
            let chunk_pos = ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            chunks.contains_key(&chunk_pos)
        };

        let neighbor_offsets = [
            IVec3::ZERO,
            IVec3::new(0, 1, 0),
            IVec3::new(0, -1, 0),
            IVec3::new(1, 0, 0),
            IVec3::new(-1, 0, 0),
            IVec3::new(0, 0, 1),
            IVec3::new(0, 0, -1),
        ];

        while let Some(pos) = queue.pop_front() {
            for offset in neighbor_offsets {
                let candidate = pos + offset;
                let Some(voxel) = voxel_at(chunks, candidate) else {
                    continue;
                };
                if voxel.id == BLOCK_AIR {
                    continue;
                }

                if matches!(
                    voxel.id,
                    mdminecraft_world::BLOCK_SAND | mdminecraft_world::BLOCK_GRAVEL
                ) {
                    let below_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                    if !is_solid_at(chunks, below_pos) {
                        let mut fall_y = candidate.y - 1;
                        while fall_y >= WORLD_MIN_Y {
                            let check_pos = IVec3::new(candidate.x, fall_y, candidate.z);
                            if is_solid_at(chunks, check_pos) {
                                break;
                            }
                            fall_y -= 1;
                        }

                        if fall_y < WORLD_MIN_Y {
                            if set_voxel_at(chunks, candidate, Voxel::default()) {
                                removed.push((candidate, voxel.id));
                                queue.push_back(candidate);
                            }
                            continue;
                        }

                        let target_pos = IVec3::new(candidate.x, fall_y + 1, candidate.z);
                        if target_pos != candidate
                            && can_set_voxel_at(chunks, candidate)
                            && can_set_voxel_at(chunks, target_pos)
                            && set_voxel_at(chunks, candidate, Voxel::default())
                            && set_voxel_at(chunks, target_pos, voxel)
                        {
                            moved.push(candidate);
                            moved.push(target_pos);
                            queue.push_back(candidate);
                            queue.push_back(target_pos);
                        }
                        continue;
                    }
                }

                let unsupported = match voxel.id {
                    interactive_blocks::LADDER => {
                        let facing = mdminecraft_world::Facing::from_state(voxel.state);
                        let (dx, dz) = facing.offset();
                        let support_pos =
                            IVec3::new(candidate.x + dx, candidate.y, candidate.z + dz);
                        !is_solid_at(chunks, support_pos)
                    }
                    id if mdminecraft_world::is_door(id) => {
                        if mdminecraft_world::is_door_lower(id) {
                            let support_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                            if !is_solid_at(chunks, support_pos) {
                                true
                            } else {
                                let upper_pos =
                                    IVec3::new(candidate.x, candidate.y + 1, candidate.z);
                                let expected_upper = match id {
                                    mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER => {
                                        Some(mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER)
                                    }
                                    mdminecraft_world::interactive_blocks::IRON_DOOR_LOWER => {
                                        Some(mdminecraft_world::interactive_blocks::IRON_DOOR_UPPER)
                                    }
                                    _ => None,
                                };
                                match expected_upper {
                                    Some(expected_upper) => voxel_at(chunks, upper_pos)
                                        .is_none_or(|upper| upper.id != expected_upper),
                                    None => true,
                                }
                            }
                        } else {
                            let lower_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                            let expected_lower = match id {
                                mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER => {
                                    Some(mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER)
                                }
                                mdminecraft_world::interactive_blocks::IRON_DOOR_UPPER => {
                                    Some(mdminecraft_world::interactive_blocks::IRON_DOOR_LOWER)
                                }
                                _ => None,
                            };
                            match expected_lower {
                                Some(expected_lower) => voxel_at(chunks, lower_pos)
                                    .is_none_or(|lower| lower.id != expected_lower),
                                None => true,
                            }
                        }
                    }
                    id if mdminecraft_world::is_bed(id) => {
                        let support_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                        if !is_solid_at(chunks, support_pos) {
                            true
                        } else {
                            match Self::bed_other_half_pos(candidate, id, voxel.state) {
                                Some((other_pos, expected_other_id)) => voxel_at(chunks, other_pos)
                                    .is_none_or(|other| other.id != expected_other_id),
                                None => true,
                            }
                        }
                    }
                    id if mdminecraft_world::CropType::is_crop(id) => {
                        let below_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                        voxel_at(chunks, below_pos)
                            .is_none_or(|below| !mdminecraft_world::is_farmland(below.id))
                    }
                    id if id == mdminecraft_world::BLOCK_SUGAR_CANE => {
                        let below_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                        voxel_at(chunks, below_pos).is_none_or(|below| {
                            below.id != mdminecraft_world::BLOCK_SUGAR_CANE
                                && !matches!(
                                    below.id,
                                    mdminecraft_world::BLOCK_DIRT
                                        | mdminecraft_world::BLOCK_GRASS
                                        | mdminecraft_world::BLOCK_SAND
                                )
                        })
                    }
                    id if id == mdminecraft_world::BLOCK_BROWN_MUSHROOM => {
                        let below_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                        !is_solid_at(chunks, below_pos)
                    }
                    interactive_blocks::TORCH
                    | mdminecraft_world::redstone_blocks::REDSTONE_TORCH => {
                        let support_pos = if mdminecraft_world::is_torch_wall(voxel.state) {
                            let facing = mdminecraft_world::torch_facing(voxel.state);
                            let (dx, dz) = facing.offset();
                            IVec3::new(candidate.x - dx, candidate.y, candidate.z - dz)
                        } else {
                            IVec3::new(candidate.x, candidate.y - 1, candidate.z)
                        };
                        !is_solid_at(chunks, support_pos)
                    }
                    mdminecraft_world::redstone_blocks::LEVER
                    | mdminecraft_world::redstone_blocks::STONE_BUTTON
                    | mdminecraft_world::redstone_blocks::OAK_BUTTON => {
                        let support_pos = if mdminecraft_world::is_wall_mounted(voxel.state) {
                            let facing = mdminecraft_world::wall_mounted_facing(voxel.state);
                            let (dx, dz) = facing.offset();
                            IVec3::new(candidate.x - dx, candidate.y, candidate.z - dz)
                        } else if mdminecraft_world::is_ceiling_mounted(voxel.state) {
                            IVec3::new(candidate.x, candidate.y + 1, candidate.z)
                        } else {
                            IVec3::new(candidate.x, candidate.y - 1, candidate.z)
                        };
                        !is_solid_at(chunks, support_pos)
                    }
                    mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE
                    | mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE
                    | mdminecraft_world::redstone_blocks::REDSTONE_WIRE
                    | mdminecraft_world::redstone_blocks::REDSTONE_REPEATER
                    | mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR => {
                        let support_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                        !is_solid_at(chunks, support_pos)
                    }
                    mdminecraft_world::BLOCK_FIRE => {
                        let support_pos = IVec3::new(candidate.x, candidate.y - 1, candidate.z);
                        !is_solid_at(chunks, support_pos)
                    }
                    _ => false,
                };

                if !unsupported {
                    continue;
                }

                if set_voxel_at(chunks, candidate, Voxel::default()) {
                    removed.push((candidate, voxel.id));
                    queue.push_back(candidate);
                }
            }
        }

        UnsupportedBlockChanges { removed, moved }
    }

    /// Initialize skylight for a chunk and stitch across neighboring seams.
    ///
    /// This is intended for newly loaded/generated chunks. For geometry edits (which can
    /// decrease skylight), use [`Self::recompute_skylight_local`] instead.
    fn init_chunk_skylight(&mut self, chunk_pos: ChunkPos) {
        if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
            let _ = init_skylight(chunk, &self.registry);
        }

        let neighbors = [
            chunk_pos,
            ChunkPos::new(chunk_pos.x + 1, chunk_pos.z),
            ChunkPos::new(chunk_pos.x - 1, chunk_pos.z),
            ChunkPos::new(chunk_pos.x, chunk_pos.z + 1),
            ChunkPos::new(chunk_pos.x, chunk_pos.z - 1),
        ];

        for pos in neighbors {
            if self.chunks.contains_key(&pos) {
                let _ =
                    stitch_light_seams(&mut self.chunks, &self.registry, pos, LightType::Skylight);
            }
        }
    }

    /// Recompute skylight for a local neighborhood around `center`.
    ///
    /// This handles both increases and decreases by clearing and reinitializing skylight for a
    /// small neighborhood and then stitching seams to import skylight from nearby chunks.
    fn recompute_skylight_local(
        &mut self,
        center: ChunkPos,
    ) -> std::collections::BTreeSet<ChunkPos> {
        recompute_skylight_local_world(&mut self.chunks, &self.registry, center)
    }

    fn render(&mut self) {
        let camera_pos = self.renderer.camera().position;
        self.audio
            .set_listener_position([camera_pos.x, camera_pos.y, camera_pos.z]);

        let mut close_inventory_requested = false;
        let mut close_crafting_requested = false;
        let mut close_furnace_requested = false;
        let mut close_enchanting_requested = false;
        let mut close_brewing_requested = false;
        let mut close_chest_requested = false;
        let mut close_hopper_requested = false;
        let mut close_dispenser_requested = false;
        let mut close_dropper_requested = false;
        let mut close_villager_trade_requested = false;
        let mut command_close_requested = false;
        let mut command_submit: Option<String> = None;
        let mut enchanting_result: Option<EnchantingResult> = None;
        let mut spill_items: Vec<ItemStack> = Vec::new();
        let mut pause_action = PauseMenuAction::None;
        let initial_fov_degrees = self.renderer.camera().fov.to_degrees();
        let mut fov_degrees = initial_fov_degrees;
        let initial_render_distance = self.render_distance;
        let mut render_distance = initial_render_distance;
        let mut input_bindings_changed = false;
        let initial_controls = Arc::clone(&self.controls);

        let tick = self.sim_tick.0;
        let periodic_event_sink = self.screenshot_periodic_event_sink.clone();
        let mut screenshot_jobs: Vec<ScreenshotJob> = Vec::new();
        if let Some(runtime) = self.screenshot.as_mut() {
            if let Some(every) = runtime.cfg.every_ticks {
                let periodic_allowed = runtime
                    .cfg
                    .max
                    .map(|max| runtime.periodic_captured < max)
                    .unwrap_or(true);
                if periodic_allowed
                    && every > 0
                    && tick.is_multiple_of(every)
                    && runtime.last_periodic_tick != Some(tick)
                {
                    runtime.last_periodic_tick = Some(tick);
                    screenshot_jobs.push(ScreenshotJob {
                        kind: match periodic_event_sink.as_ref() {
                            Some(sink) => ScreenshotJobKind::PeriodicEvent {
                                respond_to: sink.clone(),
                            },
                            None => ScreenshotJobKind::Periodic,
                        },
                        tag: None,
                    });
                }
            }

            while let Some(job) = runtime.pending.pop_front() {
                screenshot_jobs.push(job);
            }
        }

        if let Some(frame) = self.renderer.begin_frame() {
            let screenshot_jobs = std::mem::take(&mut screenshot_jobs);
            let weather_intensity = self.weather_intensity();
            let night_vision_strength = self
                .status_effects
                .get(StatusEffectType::NightVision)
                .map(|effect| {
                    // Vanilla fades at the end; keep it simple but avoid a hard cutoff.
                    if effect.duration_ticks < 200 {
                        effect.duration_ticks as f32 / 200.0
                    } else {
                        1.0
                    }
                })
                .unwrap_or(0.0);
            self.populate_particle_emitter();
            #[cfg(feature = "ui3d_billboards")]
            self.populate_billboards();

            let resources = self.renderer.render_resources().unwrap();
            let wants_capture = !screenshot_jobs.is_empty();
            let render_size = (self.renderer.config().width, self.renderer.config().height);
            let surface_format = self
                .renderer
                .surface_format()
                .unwrap_or(wgpu::TextureFormat::Bgra8UnormSrgb);
            let mut target_view: &wgpu::TextureView = &frame.view;
            let mut capture_texture: Option<&wgpu::Texture> = None;
            let mut screenshot_readback: Option<mdminecraft_render::TextureReadback> = None;

            if wants_capture {
                if let Some(runtime) = self.screenshot.as_mut() {
                    if runtime.capture_texture.is_none() || runtime.capture_size != render_size {
                        let texture = resources.device.create_texture(&wgpu::TextureDescriptor {
                            label: Some("Screenshot Capture Texture"),
                            size: wgpu::Extent3d {
                                width: render_size.0,
                                height: render_size.1,
                                depth_or_array_layers: 1,
                            },
                            mip_level_count: 1,
                            sample_count: 1,
                            dimension: wgpu::TextureDimension::D2,
                            format: surface_format,
                            usage: wgpu::TextureUsages::RENDER_ATTACHMENT
                                | wgpu::TextureUsages::COPY_SRC,
                            view_formats: &[],
                        });
                        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
                        runtime.capture_size = render_size;
                        runtime.capture_texture = Some(texture);
                        runtime.capture_view = Some(view);
                    }
                }

                if let Some(runtime) = self.screenshot.as_ref() {
                    target_view = runtime
                        .capture_view
                        .as_ref()
                        .expect("screenshot capture view missing");
                    capture_texture = runtime.capture_texture.as_ref();
                }
            }
            let particle_system = if self.particle_emitter.vertices.is_empty() {
                None
            } else {
                Some(ParticleSystem::from_emitter(
                    resources.device,
                    &self.particle_emitter,
                ))
            };

            let camera = self.renderer.camera();

            let weather_intensity_visual = if self.active_dimension == DimensionId::Overworld {
                weather_intensity
            } else {
                0.0
            };

            let mut time_uniform = mdminecraft_render::TimeUniform::from_time_of_day(
                &self.time_of_day,
                weather_intensity_visual,
                night_vision_strength,
            );
            time_uniform.time[1] = self.active_dimension.as_u8() as f32;
            // Use a deterministic simulation-time surface for visual animation (fluids, portals).
            time_uniform.time[3] = self.sim_tick.0 as f32 / 20.0;

            let sample_x = camera.position.x.floor() as i32;
            let sample_z = camera.position.z.floor() as i32;
            let mut overworld_water_fog_tint: Option<[f32; 3]> = None;

            if self.active_dimension == DimensionId::Overworld {
                let (sky_tint, _fog_tint, water_fog_tint) =
                    self.biome_atmosphere_colors_at(sample_x, sample_z);
                time_uniform.sky_color = [sky_tint[0], sky_tint[1], sky_tint[2], 1.0];
                overworld_water_fog_tint = Some(water_fog_tint);
            }

            if self.is_camera_underwater(camera.position) {
                time_uniform.time[2] = 1.0;
                let (water_tint, fog_strength) = match overworld_water_fog_tint {
                    Some(water_fog_tint) => (water_fog_tint, 1.0),
                    None => (self.biome_water_tint_at(sample_x, sample_z), 0.6),
                };
                time_uniform.fog_color = [
                    (water_tint[0] * fog_strength).min(1.0),
                    (water_tint[1] * fog_strength).min(1.0),
                    (water_tint[2] * fog_strength).min(1.0),
                    1.0,
                ];
                let base_end = 18.0;
                let max_end = 56.0;
                let fog_end = base_end + (max_end - base_end) * night_vision_strength;
                time_uniform.fog_params[0] = 0.0;
                time_uniform.fog_params[1] = fog_end;
                time_uniform.fog_params[3] = 0.0;
                time_uniform.sky_color = time_uniform.fog_color;
            } else {
                time_uniform.time[2] = 0.0;
                match self.active_dimension {
                    DimensionId::Nether => {
                        time_uniform.fog_color = [0.22, 0.05, 0.03, 1.0];
                        time_uniform.fog_params[0] = 12.0;
                        time_uniform.fog_params[1] = 64.0;
                        time_uniform.fog_params[3] = 0.0;
                    }
                    DimensionId::End => {
                        time_uniform.fog_color = [0.05, 0.02, 0.08, 1.0];
                        time_uniform.fog_params[0] = 24.0;
                        time_uniform.fog_params[1] = 96.0;
                        time_uniform.fog_params[3] = 0.0;
                    }
                    DimensionId::Overworld => {}
                }
            }

            let thunder_strength = if self.active_dimension == DimensionId::Overworld
                && self.weather.is_thundering()
                && !self.is_camera_underwater(camera.position)
            {
                weather_intensity
            } else {
                0.0
            };
            time_uniform.fog_color[3] = thunder_strength;

            let lightning_flash = if self.active_dimension == DimensionId::Overworld
                && self.weather.is_thundering()
                && !self.is_camera_underwater(camera.position)
            {
                self.lightning_flash_intensity()
            } else {
                0.0
            };
            time_uniform.sky_color[3] = lightning_flash;

            // Update time uniforms
            resources
                .skybox_pipeline
                .update_time_with_uniform(resources.queue, time_uniform);
            resources
                .pipeline
                .update_time_with_uniform(resources.queue, time_uniform);

            let mut encoder =
                resources
                    .device
                    .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                        label: Some("Render Encoder"),
                    });

            // Render skybox
            {
                let mut render_pass = resources
                    .skybox_pipeline
                    .begin_render_pass(&mut encoder, target_view);
                render_pass.set_pipeline(resources.skybox_pipeline.pipeline());
                render_pass.set_bind_group(0, resources.skybox_pipeline.time_bind_group(), &[]);
                render_pass.set_bind_group(1, resources.skybox_pipeline.camera_bind_group(), &[]);
                render_pass.draw(0..3, 0..1);
            }

            // Create frustum for culling
            let view_proj = camera.projection_matrix() * camera.view_matrix();
            let frustum = Frustum::from_matrix(&view_proj);

            // Render voxels with frustum culling
            self.chunks_visible = 0;
            {
                let mut render_pass = resources
                    .pipeline
                    .begin_render_pass(&mut encoder, target_view);

                render_pass.set_pipeline(resources.pipeline.pipeline());
                render_pass.set_bind_group(0, resources.pipeline.camera_bind_group(), &[]);
                render_pass.set_bind_group(2, resources.pipeline.texture_bind_group(), &[]);

                for chunk_data in self.chunk_manager.chunks() {
                    if !frustum.is_chunk_visible(chunk_data.chunk_pos) {
                        continue;
                    }

                    self.chunks_visible += 1;

                    let Some(index_buffer) = chunk_data.opaque_index_buffer.as_ref() else {
                        continue;
                    };

                    render_pass.set_bind_group(1, &chunk_data.chunk_bind_group, &[]);
                    render_pass.set_vertex_buffer(0, chunk_data.vertex_buffer.slice(..));
                    render_pass.set_index_buffer(index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                    render_pass.draw_indexed(0..chunk_data.opaque_index_count, 0, 0..1);
                }
            }

            // Render fluids (alpha-blended) after opaque voxels.
            {
                let mut render_pass = resources
                    .pipeline
                    .begin_fluid_render_pass(&mut encoder, target_view);

                render_pass.set_pipeline(resources.pipeline.fluid_pipeline());
                render_pass.set_bind_group(0, resources.pipeline.camera_bind_group(), &[]);
                render_pass.set_bind_group(2, resources.pipeline.texture_bind_group(), &[]);

                let cam_pos = camera.position;
                let mut fluid_chunks: Vec<_> = self
                    .chunk_manager
                    .chunks()
                    .filter(|chunk_data| {
                        chunk_data.alpha_index_count != 0
                            && frustum.is_chunk_visible(chunk_data.chunk_pos)
                    })
                    .collect();

                fluid_chunks.sort_by(|a, b| {
                    let ax = (a.chunk_pos.x * 16) as f32 + 8.0 - cam_pos.x;
                    let az = (a.chunk_pos.z * 16) as f32 + 8.0 - cam_pos.z;
                    let bx = (b.chunk_pos.x * 16) as f32 + 8.0 - cam_pos.x;
                    let bz = (b.chunk_pos.z * 16) as f32 + 8.0 - cam_pos.z;
                    let dist_a = ax * ax + az * az;
                    let dist_b = bx * bx + bz * bz;
                    let dist_order = dist_b.total_cmp(&dist_a);
                    if dist_order != std::cmp::Ordering::Equal {
                        dist_order
                    } else {
                        (b.chunk_pos.x, b.chunk_pos.z).cmp(&(a.chunk_pos.x, a.chunk_pos.z))
                    }
                });

                for chunk_data in fluid_chunks {
                    let index_buffer = chunk_data
                        .alpha_index_buffer
                        .as_ref()
                        .expect("alpha_index_buffer present");
                    render_pass.set_bind_group(1, &chunk_data.chunk_bind_group, &[]);
                    render_pass.set_vertex_buffer(0, chunk_data.vertex_buffer.slice(..));
                    render_pass.set_index_buffer(index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                    render_pass.draw_indexed(0..chunk_data.alpha_index_count, 0, 0..1);
                }
            }

            if let Some(system) = particle_system.as_ref() {
                let depth_view = resources.pipeline.depth_view();
                let mut render_pass = resources.particle_pipeline.begin_render_pass(
                    &mut encoder,
                    target_view,
                    depth_view,
                );
                render_pass.set_pipeline(resources.particle_pipeline.pipeline());
                render_pass.set_bind_group(0, resources.pipeline.camera_bind_group(), &[]);
                render_pass.set_bind_group(
                    1,
                    resources.particle_pipeline.globals_bind_group(),
                    &[],
                );
                system.render(
                    &mut render_pass,
                    resources.particle_pipeline.quad_vertex_buffer(),
                );
            }

            // Render wireframe highlight (if block selected)
            if let Some(hit) = self.selected_block {
                let highlight_pos = [
                    hit.block_pos.x as f32,
                    hit.block_pos.y as f32,
                    hit.block_pos.z as f32,
                ];
                let highlight_color = [0.0, 0.0, 0.0, 0.8];
                resources.wireframe_pipeline.update_highlight(
                    resources.queue,
                    highlight_pos,
                    highlight_color,
                );

                let depth_view = resources.pipeline.depth_view();
                let mut render_pass = resources.wireframe_pipeline.begin_render_pass(
                    &mut encoder,
                    target_view,
                    depth_view,
                );

                render_pass.set_pipeline(resources.wireframe_pipeline.pipeline());
                render_pass.set_bind_group(0, resources.pipeline.camera_bind_group(), &[]);
                render_pass.set_bind_group(
                    1,
                    resources.wireframe_pipeline.highlight_bind_group(),
                    &[],
                );
                render_pass
                    .set_vertex_buffer(0, resources.wireframe_pipeline.vertex_buffer().slice(..));
                render_pass.draw(0..24, 0..1);
            }

            #[cfg(feature = "ui3d_billboards")]
            if let Some(renderer) = self.billboard_renderer.as_mut() {
                let depth_view = resources.pipeline.depth_view();
                if let Err(err) = renderer.render(
                    resources.device,
                    resources.queue,
                    &mut encoder,
                    target_view,
                    depth_view,
                    resources.pipeline.camera_bind_group(),
                    &mut self.billboard_emitter,
                ) {
                    tracing::warn!(?err, "Billboard rendering failed");
                }
            }

            // Render UI overlay
            let is_dead = self.player_state == PlayerState::Dead;
            let death_msg = self.death_message.clone();
            let inventory_open = self.inventory_open;
            let villager_trade_open = self.villager_trade_open;
            let open_villager_trade_id = self.open_villager_trade_id;
            let crafting_open = self.crafting_open;
            let furnace_open = self.furnace_open;
            let enchanting_open = self.enchanting_open;
            let chest_open = self.chest_open;
            let hopper_open = self.hopper_open;
            let dispenser_open = self.dispenser_open;
            let dropper_open = self.dropper_open;
            let command_open = self.command_open;
            let mut respawn_clicked = false;
            let mut menu_clicked = false;

            if let Some(mut ui) = self.renderer.ui_mut() {
                let screen_descriptor = egui_wgpu::ScreenDescriptor {
                    size_in_pixels: [render_size.0, render_size.1],
                    pixels_per_point: 1.0,
                };

                ui.render(
                    UiRenderContext {
                        device: resources.device,
                        queue: resources.queue,
                        encoder: &mut encoder,
                        view: target_view,
                        screen: screen_descriptor,
                    },
                    self.window.as_ref().expect("window missing"),
                    |ctx| {
                        self.debug_hud.render(ctx);
                        render_hotbar(ctx, &self.hotbar, &self.registry);
                        render_xp_bar(ctx, &self.player_xp);
                        if let Some(dragon) = self.mobs.iter().find(|mob| {
                            mob.dimension == self.active_dimension
                                && mob.mob_type == MobType::EnderDragon
                                && !mob.dead
                        }) {
                            render_boss_bar(
                                ctx,
                                "Ender Dragon",
                                dragon.health,
                                dragon.mob_type.max_health(),
                            );
                        }
                        render_health_bar(ctx, &self.player_health);
                        render_hunger_bar(ctx, &self.player_health);
                        render_armor_bar(ctx, &self.player_armor);
                        render_tool_durability(ctx, &self.hotbar);
                        render_status_effects_overlay(ctx, &self.status_effects);

                        // Show inventory if open
                        if inventory_open {
                            let (close, items) = render_inventory(
                                ctx,
                                &mut self.hotbar,
                                &mut self.main_inventory,
                                &mut self.player_armor,
                                &mut self.personal_crafting_grid,
                                &mut self.ui_cursor_stack,
                                &mut self.ui_drag_state,
                                &self.registry,
                            );
                            close_inventory_requested = close;
                            spill_items.extend(items);
                        }

                        if villager_trade_open {
                            if let Some(villager_id) = open_villager_trade_id {
                                let villager_exists = self.mobs.iter().any(|mob| {
                                    mob.dimension == self.active_dimension
                                        && mob.id == villager_id
                                        && mob.mob_type == MobType::Villager
                                });
                                if villager_exists {
                                    let (profession, offers) =
                                        villager_trade_offers(self.world_seed, villager_id);
                                    let (close, spill) = render_villager_trade(
                                        ctx,
                                        profession,
                                        &offers,
                                        &mut self.selected_villager_trade_idx,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &self.registry,
                                    );
                                    close_villager_trade_requested = close;
                                    if let Some(stack) = spill {
                                        spill_items.push(stack);
                                    }
                                } else {
                                    close_villager_trade_requested = true;
                                }
                            } else {
                                close_villager_trade_requested = true;
                            }
                        }

                        // Show crafting if open
                        if crafting_open {
                            let (close, items) = render_crafting(
                                ctx,
                                &mut self.crafting_grid,
                                &mut self.hotbar,
                                &mut self.main_inventory,
                                &mut self.ui_cursor_stack,
                                &mut self.ui_drag_state,
                                &self.registry,
                            );
                            close_crafting_requested = close;
                            spill_items.extend(items);
                        }

                        // Show furnace if open
                        if furnace_open {
                            if let Some(pos) = self.open_furnace_pos {
                                if let Some(furnace) = self.furnaces.get_mut(&pos) {
                                    close_furnace_requested = render_furnace(
                                        ctx,
                                        furnace,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );
                                }
                            }
                        }

                        // Show enchanting table if open
                        if enchanting_open {
                            if let Some(pos) = self.open_enchanting_pos {
                                if let Some(table) = self.enchanting_tables.get_mut(&pos) {
                                    let result = render_enchanting_table(
                                        ctx,
                                        table,
                                        &self.player_xp,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );
                                    close_enchanting_requested = result.close_requested;
                                    if result.enchantment_applied.is_some() {
                                        enchanting_result = Some(result);
                                    }
                                }
                            }
                        }

                        // Show brewing stand if open
                        if self.brewing_open {
                            if let Some(pos) = self.open_brewing_pos {
                                if let Some(stand) = self.brewing_stands.get_mut(&pos) {
                                    close_brewing_requested = render_brewing_stand(
                                        ctx,
                                        stand,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );
                                }
                            }
                        }

                        // Show chest if open
                        if chest_open {
                            if let Some(pos) = self.open_chest_pos {
                                if let Some(chest) = self.chests.get_mut(&pos) {
                                    close_chest_requested = render_chest(
                                        ctx,
                                        chest,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );

                                    mdminecraft_world::update_container_signal(
                                        &mut self.chunks,
                                        &mut self.redstone_sim,
                                        RedstonePos::new(pos.x, pos.y, pos.z),
                                        &chest.slots,
                                    );
                                }
                            }
                        }

                        // Show hopper if open
                        if hopper_open {
                            if let Some(pos) = self.open_hopper_pos {
                                if let Some(hopper) = self.hoppers.get_mut(&pos) {
                                    close_hopper_requested = render_hopper(
                                        ctx,
                                        hopper,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );

                                    mdminecraft_world::update_container_signal(
                                        &mut self.chunks,
                                        &mut self.redstone_sim,
                                        RedstonePos::new(pos.x, pos.y, pos.z),
                                        &hopper.slots,
                                    );
                                }
                            }
                        }

                        // Show dispenser if open
                        if dispenser_open {
                            if let Some(pos) = self.open_dispenser_pos {
                                if let Some(dispenser) = self.dispensers.get_mut(&pos) {
                                    close_dispenser_requested = render_dispenser(
                                        ctx,
                                        dispenser,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );

                                    mdminecraft_world::update_container_signal(
                                        &mut self.chunks,
                                        &mut self.redstone_sim,
                                        RedstonePos::new(pos.x, pos.y, pos.z),
                                        &dispenser.slots,
                                    );
                                }
                            }
                        }

                        // Show dropper if open
                        if dropper_open {
                            if let Some(pos) = self.open_dropper_pos {
                                if let Some(dropper) = self.droppers.get_mut(&pos) {
                                    close_dropper_requested = render_dropper(
                                        ctx,
                                        dropper,
                                        &mut self.hotbar,
                                        &mut self.main_inventory,
                                        &mut self.ui_cursor_stack,
                                        &mut self.ui_drag_state,
                                    );

                                    mdminecraft_world::update_container_signal(
                                        &mut self.chunks,
                                        &mut self.redstone_sim,
                                        RedstonePos::new(pos.x, pos.y, pos.z),
                                        &dropper.slots,
                                    );
                                }
                            }
                        }

                        if command_open && !is_dead {
                            egui::Area::new("command_prompt")
                                .anchor(egui::Align2::LEFT_BOTTOM, egui::vec2(10.0, -10.0))
                                .order(egui::Order::Foreground)
                                .show(ctx, |ui| {
                                    egui::Frame::none()
                                        .fill(egui::Color32::from_rgba_unmultiplied(0, 0, 0, 210))
                                        .inner_margin(egui::Margin::same(8.0))
                                        .rounding(egui::Rounding::same(4.0))
                                        .show(ui, |ui| {
                                            let lines: Vec<_> = self
                                                .command_log
                                                .iter()
                                                .rev()
                                                .take(10)
                                                .cloned()
                                                .collect();
                                            for line in lines.into_iter().rev() {
                                                ui.label(
                                                    egui::RichText::new(line)
                                                        .size(12.0)
                                                        .color(egui::Color32::LIGHT_GRAY),
                                                );
                                            }

                                            ui.add_space(4.0);
                                            let response = ui.add(
                                                egui::TextEdit::singleline(&mut self.command_input)
                                                    .desired_width(520.0)
                                                    .hint_text("Enter command (e.g. /help)"),
                                            );
                                            if self.command_focus_next_frame {
                                                response.request_focus();
                                                self.command_focus_next_frame = false;
                                            }

                                            let enter_pressed =
                                                ui.input(|i| i.key_pressed(egui::Key::Enter));
                                            let esc_pressed =
                                                ui.input(|i| i.key_pressed(egui::Key::Escape));

                                            if enter_pressed {
                                                command_submit = Some(self.command_input.clone());
                                                self.command_input.clear();
                                            }
                                            if esc_pressed {
                                                command_close_requested = true;
                                            }
                                        });
                                });
                        }

                        // Show pause menu if open (singleplayer pause).
                        if self.pause_menu_open && !is_dead {
                            pause_action = render_pause_menu(
                                ctx,
                                &mut self.pause_menu_view,
                                &mut self.controls,
                                &mut self.pause_controls_dirty,
                                &mut fov_degrees,
                                &mut render_distance,
                                &mut input_bindings_changed,
                            );
                        }

                        // Show death screen if player is dead
                        if is_dead {
                            let (respawn, menu) = render_death_screen(ctx, &death_msg);
                            respawn_clicked = respawn;
                            menu_clicked = menu;
                        }
                    },
                );
            }

            // Handle death screen button clicks
            if respawn_clicked {
                self.respawn_requested = true;
            }
            if menu_clicked {
                self.menu_requested = true;
            }

            if wants_capture {
                let capture_texture = capture_texture.expect("screenshot capture texture missing");
                screenshot_readback = Some(mdminecraft_render::record_texture_readback(
                    resources.device,
                    &mut encoder,
                    capture_texture,
                    surface_format,
                    render_size,
                ));
                if let Some(surface_texture) = frame.surface_texture() {
                    encoder.copy_texture_to_texture(
                        wgpu::ImageCopyTexture {
                            texture: capture_texture,
                            mip_level: 0,
                            origin: wgpu::Origin3d::ZERO,
                            aspect: wgpu::TextureAspect::All,
                        },
                        wgpu::ImageCopyTexture {
                            texture: surface_texture,
                            mip_level: 0,
                            origin: wgpu::Origin3d::ZERO,
                            aspect: wgpu::TextureAspect::All,
                        },
                        wgpu::Extent3d {
                            width: render_size.0,
                            height: render_size.1,
                            depth_or_array_layers: 1,
                        },
                    );
                }
            }

            resources.queue.submit(std::iter::once(encoder.finish()));
            frame.present();

            if let Some(readback) = screenshot_readback {
                match readback.read_rgba8(resources.device) {
                    Ok(rgba) => {
                        let mut errors = Vec::new();
                        if let Some(runtime) = self.screenshot.as_mut() {
                            for job in screenshot_jobs {
                                let tag = job.tag.as_deref();
                                let path = runtime.path_for(tick, tag);
                                match mdminecraft_render::write_png(&path, render_size, &rgba) {
                                    Ok(()) => match job.kind {
                                        ScreenshotJobKind::Periodic => {
                                            runtime.periodic_captured =
                                                runtime.periodic_captured.saturating_add(1);
                                        }
                                        ScreenshotJobKind::PeriodicEvent { respond_to } => {
                                            runtime.periodic_captured =
                                                runtime.periodic_captured.saturating_add(1);
                                            let _ = respond_to.send(protocol::event_screenshot(
                                                None,
                                                tick,
                                                path.display().to_string(),
                                                render_size.0,
                                                render_size.1,
                                            ));
                                        }
                                        ScreenshotJobKind::Manual { id, respond_to } => {
                                            let _ = respond_to.send(protocol::event_screenshot(
                                                id,
                                                tick,
                                                path.display().to_string(),
                                                render_size.0,
                                                render_size.1,
                                            ));
                                        }
                                    },
                                    Err(err) => {
                                        errors.push(err);
                                        if let ScreenshotJobKind::Manual { id, respond_to } =
                                            job.kind
                                        {
                                            let _ = respond_to.send(protocol::event_error(
                                                id,
                                                protocol::ErrorCode::Internal,
                                                "failed to write screenshot",
                                            ));
                                        }
                                    }
                                }
                            }
                        } else {
                            for job in screenshot_jobs {
                                if let ScreenshotJobKind::Manual { id, respond_to } = job.kind {
                                    let _ = respond_to.send(protocol::event_error(
                                        id,
                                        protocol::ErrorCode::Internal,
                                        "screenshots disabled",
                                    ));
                                }
                            }
                        }

                        if let Some(err) = errors.into_iter().next() {
                            tracing::warn!(?err, "Screenshot write failed");
                        }
                    }
                    Err(err) => {
                        tracing::warn!(?err, "Screenshot readback failed");
                        for job in screenshot_jobs {
                            if let ScreenshotJobKind::Manual { id, respond_to } = job.kind {
                                let _ = respond_to.send(protocol::event_error(
                                    id,
                                    protocol::ErrorCode::Internal,
                                    "failed to capture screenshot",
                                ));
                            }
                        }
                    }
                }
            } else {
                for job in screenshot_jobs {
                    if let ScreenshotJobKind::Manual { id, respond_to } = job.kind {
                        let _ = respond_to.send(protocol::event_error(
                            id,
                            protocol::ErrorCode::Internal,
                            "failed to capture screenshot",
                        ));
                    }
                }
            }
        } else if !screenshot_jobs.is_empty() {
            let render_disabled = self.renderer.device().is_none();
            for job in screenshot_jobs {
                match job.kind {
                    ScreenshotJobKind::Periodic => {
                        if render_disabled {
                            tracing::warn!("Skipping screenshot capture: render disabled");
                        } else {
                            tracing::warn!("Skipping screenshot capture: render unavailable");
                        }
                    }
                    ScreenshotJobKind::PeriodicEvent { .. } => {
                        if render_disabled {
                            tracing::warn!("Skipping screenshot capture: render disabled");
                        } else {
                            tracing::warn!("Skipping screenshot capture: render unavailable");
                        }
                    }
                    ScreenshotJobKind::Manual { id, respond_to } => {
                        let _ = respond_to.send(protocol::event_error(
                            id,
                            if render_disabled {
                                protocol::ErrorCode::Unsupported
                            } else {
                                protocol::ErrorCode::Internal
                            },
                            if render_disabled {
                                "render disabled"
                            } else {
                                "render unavailable"
                            },
                        ));
                    }
                }
            }
        }

        // Handle inventory close (after frame render to avoid borrow issues)
        if close_inventory_requested {
            self.toggle_inventory();
        }

        // Handle crafting close
        if close_crafting_requested {
            self.close_crafting();
        }

        // Handle overflow spills from UI actions (e.g., shift-crafting).
        for stack in spill_items {
            tracing::warn!(
                item = ?stack.item_type,
                count = stack.count,
                "Inventory full; spilling items"
            );
            self.spill_stack_to_world(stack);
        }

        // Handle furnace close
        if close_furnace_requested {
            self.close_furnace();
        }

        // Handle enchanting table close
        if close_enchanting_requested {
            self.close_enchanting_table();
        }

        // Handle brewing stand close
        if close_brewing_requested {
            self.close_brewing_stand();
        }

        // Handle chest close
        if close_chest_requested {
            self.close_chest();
        }

        // Handle hopper close
        if close_hopper_requested {
            self.close_hopper();
        }

        // Handle dispenser close
        if close_dispenser_requested {
            self.close_dispenser();
        }

        // Handle dropper close
        if close_dropper_requested {
            self.close_dropper();
        }

        if close_villager_trade_requested {
            self.close_villager_trade();
        }

        if command_close_requested {
            self.close_command_prompt();
        }
        if let Some(cmdline) = command_submit.take() {
            self.run_command_line(cmdline);
        }

        match pause_action {
            PauseMenuAction::None => {}
            PauseMenuAction::Resume => {
                self.close_pause_menu();
            }
            PauseMenuAction::ReturnToMenu => {
                self.pending_action = Some(GameAction::ReturnToMenu);
            }
            PauseMenuAction::Quit => {
                self.pending_action = Some(GameAction::Quit);
            }
        }

        if (fov_degrees - initial_fov_degrees).abs() > f32::EPSILON {
            self.renderer.camera_mut().fov = fov_degrees.to_radians();
        }
        if render_distance != initial_render_distance {
            self.render_distance = render_distance;
        }
        if input_bindings_changed {
            self.input_processor = InputProcessor::new(&self.controls);
        }
        if !Arc::ptr_eq(&initial_controls, &self.controls) {
            self.audio
                .update_settings(Self::audio_settings_from_controls(&self.controls));
        }

        // Handle enchanting result - apply enchantment to selected item
        if let Some(result) = enchanting_result {
            if let Some(enchantment) = result.enchantment_applied {
                // Apply enchantment to selected hotbar item
                if let Some(item) = self.hotbar.selected_item_mut() {
                    if item.add_enchantment(enchantment) {
                        // Consume XP levels
                        if self.player_xp.consume_levels(result.xp_to_consume) {
                            tracing::info!(
                                "Enchanted item with {:?} level {} (consumed {} XP levels)",
                                enchantment.enchantment_type,
                                enchantment.level,
                                result.xp_to_consume
                            );
                        }
                    } else {
                        tracing::warn!("Failed to apply enchantment to item");
                    }
                }
            }
        }

        self.audio.update();
        self.input.reset_frame();
    }

    /// Calculate and apply fall damage
    fn calculate_fall_damage(&mut self, fall_distance: f32) {
        // Minecraft formula: damage = fall_distance - 3.0
        // Player takes damage for falls > 3 blocks
        if fall_distance > 3.0 {
            let raw_damage = (fall_distance - 3.0) * 1.0; // 1 damage per block fallen
            let actual_damage = self.player_armor.take_damage(raw_damage, DamageKind::Fall);
            self.player_health.damage(actual_damage);
            tracing::info!(
                "Fell {:.1} blocks, took {:.1} fall damage",
                fall_distance,
                actual_damage
            );

            // Check if this killed the player
            if self.player_health.is_dead() && self.player_state != PlayerState::Dead {
                let msg = format!("You fell from a high place ({:.0} blocks)", fall_distance);
                self.handle_death(&msg);
            }
        }
    }

    /// Handle player death - enter death state and show death screen
    fn handle_death(&mut self, cause: &str) {
        if self.player_state == PlayerState::Dead {
            return; // Already dead
        }

        tracing::info!("Player died! Cause: {}", cause);

        self.player_state = PlayerState::Dead;
        self.death_message = cause.to_string();
        self.respawn_requested = false;
        self.menu_requested = false;

        // Release cursor so player can click UI buttons
        self.enter_menu();

        // Stop player movement
        self.player_physics.velocity = glam::Vec3::ZERO;
    }

    fn find_safe_spawn_near(&self, world_x: f32, world_z: f32) -> Option<glam::Vec3> {
        let base_x = world_x.floor() as i32;
        let base_z = world_z.floor() as i32;

        // Prefer near the requested coordinates, then expand outwards.
        for dz in -2i32..=2 {
            for dx in -2i32..=2 {
                let x = base_x + dx;
                let z = base_z + dz;
                let chunk_pos = ChunkPos::new(
                    x.div_euclid(CHUNK_SIZE_X as i32),
                    z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                let Some(chunk) = self.chunks.get(&chunk_pos) else {
                    continue;
                };

                let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                let start_local_y = match self.active_dimension {
                    DimensionId::Nether => world_y_to_local_y(140).unwrap_or(CHUNK_SIZE_Y - 2),
                    _ => CHUNK_SIZE_Y - 2,
                };
                for local_y in (1..=start_local_y).rev() {
                    if local_y + 1 >= CHUNK_SIZE_Y {
                        continue;
                    }

                    let below = chunk.voxel(local_x, local_y - 1, local_z).id;
                    let feet = chunk.voxel(local_x, local_y, local_z).id;
                    let head = chunk.voxel(local_x, local_y + 1, local_z).id;

                    if !self.block_properties.get(below).is_solid {
                        continue;
                    }

                    if self.block_properties.get(feet).is_solid || mdminecraft_world::is_fluid(feet)
                    {
                        continue;
                    }
                    if self.block_properties.get(head).is_solid || mdminecraft_world::is_fluid(head)
                    {
                        continue;
                    }

                    let world_y = local_y_to_world_y(local_y);
                    return Some(glam::Vec3::new(
                        x as f32 + 0.5,
                        world_y as f32 + PlayerPhysics::GROUND_EPS,
                        z as f32 + 0.5,
                    ));
                }
            }
        }

        None
    }

    fn find_safe_spawn_near_position(
        &self,
        world_x: f32,
        world_y: f32,
        world_z: f32,
    ) -> Option<glam::Vec3> {
        let base_x = world_x.floor() as i32;
        let base_z = world_z.floor() as i32;
        let base_y = world_y.floor() as i32;
        let start_world_y = base_y.clamp(WORLD_MIN_Y + 1, WORLD_MAX_Y - 2);
        let start_local_y = world_y_to_local_y(start_world_y).unwrap_or(CHUNK_SIZE_Y - 2) as i32;

        let min_local_y = (start_local_y - 16).max(1);
        let max_local_y = (start_local_y + 8).min((CHUNK_SIZE_Y.saturating_sub(2)) as i32);

        for dz in -2i32..=2 {
            for dx in -2i32..=2 {
                let x = base_x + dx;
                let z = base_z + dz;
                let chunk_pos = ChunkPos::new(
                    x.div_euclid(CHUNK_SIZE_X as i32),
                    z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                let Some(chunk) = self.chunks.get(&chunk_pos) else {
                    continue;
                };

                let local_x = x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                let local_z = z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                let check_candidate = |local_y: i32| -> Option<glam::Vec3> {
                    if local_y <= 0 {
                        return None;
                    }
                    let y_usize = local_y as usize;
                    if y_usize + 1 >= CHUNK_SIZE_Y {
                        return None;
                    }

                    let below = chunk.voxel(local_x, (local_y - 1) as usize, local_z).id;
                    let feet = chunk.voxel(local_x, y_usize, local_z).id;
                    let head = chunk.voxel(local_x, y_usize + 1, local_z).id;

                    if !self.block_properties.get(below).is_solid {
                        return None;
                    }

                    if self.block_properties.get(feet).is_solid || mdminecraft_world::is_fluid(feet)
                    {
                        return None;
                    }
                    if self.block_properties.get(head).is_solid || mdminecraft_world::is_fluid(head)
                    {
                        return None;
                    }

                    let world_y = local_y_to_world_y(y_usize);
                    Some(glam::Vec3::new(
                        x as f32 + 0.5,
                        world_y as f32 + PlayerPhysics::GROUND_EPS,
                        z as f32 + 0.5,
                    ))
                };

                for local_y in (min_local_y..=start_local_y).rev() {
                    if let Some(pos) = check_candidate(local_y) {
                        return Some(pos);
                    }
                }
                for local_y in (start_local_y + 1)..=max_local_y {
                    if let Some(pos) = check_candidate(local_y) {
                        return Some(pos);
                    }
                }
            }
        }

        None
    }

    fn switch_dimension(&mut self, target: DimensionId) -> anyhow::Result<()> {
        let from = self.active_dimension;
        if target == from {
            return Ok(());
        }

        self.portal_charge_ticks = 0;

        // Ensure no UI state keeps references into the outgoing dimension.
        self.stash_ui_items_for_save();
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.brewing_open = false;
        self.chest_open = false;
        self.hopper_open = false;
        self.dispenser_open = false;
        self.dropper_open = false;
        self.villager_trade_open = false;
        self.open_villager_trade_id = None;
        self.open_furnace_pos = None;
        self.open_enchanting_pos = None;
        self.open_brewing_pos = None;
        self.open_chest_pos = None;
        self.open_hopper_pos = None;
        self.open_dispenser_pos = None;
        self.open_dropper_pos = None;
        self.ui_drag_state.reset();
        self.ui_cursor_stack = None;

        // Save and drop all currently loaded chunks in the outgoing dimension.
        self.persist_loaded_chunks();
        let loaded_positions: Vec<_> = self.chunks.keys().copied().collect();
        for pos in loaded_positions {
            self.crop_growth.unregister_chunk(pos);
            self.sugar_cane_growth.unregister_chunk(pos);
        }
        self.chunks.clear();
        self.chunk_manager = ChunkManager::new();
        self.redstone_sim = RedstoneSimulator::new();
        self.fluid_sim = FluidSimulator::new();
        self.selected_block = None;

        let camera = self.renderer.camera_mut();
        let mut new_x = camera.position.x;
        let mut new_z = camera.position.z;
        match (from, target) {
            (DimensionId::Overworld, DimensionId::Nether) => {
                new_x /= 8.0;
                new_z /= 8.0;
            }
            (DimensionId::Nether, DimensionId::Overworld) => {
                new_x *= 8.0;
                new_z *= 8.0;
            }
            _ => {}
        }

        let eye_height = self.player_physics.eye_height;
        let provisional_y = if target == DimensionId::Nether {
            80.0 + eye_height
        } else {
            camera.position.y
        };

        camera.position = glam::Vec3::new(new_x, provisional_y, new_z);
        self.player_physics.velocity = glam::Vec3::ZERO;
        self.player_physics.on_ground = false;

        self.active_dimension = target;

        // Load/generate destination chunks, then snap to a safe nearby location.
        // Keep headless automation responsive by bounding the initial load.
        let load_limit = if self.window.is_none() { 8 } else { usize::MAX };
        self.update_chunks(load_limit);
        let camera_pos = self.renderer.camera().position;
        if let Some(feet) = self.find_safe_spawn_near(camera_pos.x, camera_pos.z) {
            let camera = self.renderer.camera_mut();
            camera.position = feet + glam::Vec3::new(0.0, eye_height, 0.0);
            self.player_physics.last_ground_y = feet.y;
        }

        if target == DimensionId::End {
            if self.end_boss_defeated {
                self.ensure_end_exit_portal_present();
            } else {
                self.ensure_end_boss_spawned();
            }
        }

        Ok(())
    }

    fn ensure_end_boss_spawned(&mut self) {
        if self.active_dimension != DimensionId::End {
            return;
        }
        if self.end_boss_defeated {
            return;
        }

        let already_alive = self.mobs.iter().any(|mob| {
            mob.dimension == DimensionId::End && mob.mob_type == MobType::EnderDragon && !mob.dead
        });
        if already_alive {
            return;
        }

        let candidates = [
            (16.0_f32, 0.0_f32),
            (-16.0_f32, 0.0_f32),
            (0.0_f32, 16.0_f32),
            (0.0_f32, -16.0_f32),
            (0.0_f32, 0.0_f32),
        ];

        let mut spawn_feet = None;
        for (x, z) in candidates {
            if let Some(feet) = self.find_safe_spawn_near(x, z) {
                spawn_feet = Some(feet);
                break;
            }
        }
        let spawn_feet = spawn_feet.unwrap_or_else(|| glam::Vec3::new(0.5, 80.0, 0.5));

        let mut mob = Mob::new(
            spawn_feet.x as f64,
            spawn_feet.y as f64,
            spawn_feet.z as f64,
            MobType::EnderDragon,
        );
        mob.dimension = DimensionId::End;
        self.assign_mob_id(&mut mob);
        self.mobs.push(mob);
    }

    fn ensure_end_exit_portal_present(&mut self) {
        if self.active_dimension != DimensionId::End {
            return;
        }

        let portal_center = self
            .find_safe_spawn_near(0.0, 0.0)
            .unwrap_or_else(|| glam::Vec3::new(0.5, 65.0, 0.5));
        let center_x = portal_center.x.floor() as i32;
        let center_y = portal_center.y.floor() as i32;
        let center_z = portal_center.z.floor() as i32;

        if world_y_to_local_y(center_y).is_none() {
            return;
        }

        let has_portal = (-1..=1).all(|dx| {
            (-1..=1).all(|dz| {
                self.get_block_at(IVec3::new(center_x + dx, center_y, center_z + dz))
                    == Some(BLOCK_END_PORTAL)
            })
        });

        if has_portal {
            return;
        }

        let Some(changed) = mdminecraft_world::place_end_exit_portal(
            &mut self.chunks,
            center_x,
            center_y,
            center_z,
        ) else {
            tracing::warn!("Failed to ensure End exit portal");
            return;
        };

        let changed_positions: Vec<IVec3> = changed
            .into_iter()
            .map(|(x, y, z)| IVec3::new(x, y, z))
            .collect();
        self.refresh_after_voxel_changes(&changed_positions);
    }

    /// Respawn the player at spawn point
    fn respawn(&mut self) {
        tracing::info!("Respawning player at spawn point...");

        // Reset health
        self.player_health.reset();

        // Reset state
        self.player_state = PlayerState::Alive;
        self.death_message.clear();

        let desired_dimension = self.spawn_point_dimension;
        if self.active_dimension != desired_dimension {
            if let Err(err) = self.switch_dimension(desired_dimension) {
                tracing::warn!("Respawn dimension switch failed: {err:#}");
            }
        }

        // If we couldn't reach the desired respawn dimension, fall back to the Overworld.
        if desired_dimension != DimensionId::Overworld && self.active_dimension != desired_dimension
        {
            tracing::warn!(
                "Respawn could not enter {desired_dimension:?}; falling back to Overworld"
            );
            if let Err(err) = self.switch_dimension(DimensionId::Overworld) {
                tracing::warn!("Respawn fallback dimension switch failed: {err:#}");
            }

            let eye_height = self.player_physics.eye_height;
            let camera = self.renderer.camera_mut();
            camera.position = glam::Vec3::new(0.5, 100.0 + eye_height, 0.5);
            self.player_physics.velocity = glam::Vec3::ZERO;
            self.player_physics.on_ground = false;

            let load_limit = if self.window.is_none() { 8 } else { usize::MAX };
            self.update_chunks(load_limit);
            if let Some(feet) = self.find_safe_spawn_near(0.0, 0.0) {
                let camera = self.renderer.camera_mut();
                camera.position = feet + glam::Vec3::new(0.0, eye_height, 0.0);
                self.player_physics.last_ground_y = feet.y;
            } else {
                self.player_physics.last_ground_y = 100.0;
            }

            // Re-capture cursor for gameplay
            self.enter_gameplay();
            return;
        }

        // Respawn player at spawn point and force-load chunks so it isn't a black screen.
        let eye_height = self.player_physics.eye_height;
        let camera = self.renderer.camera_mut();
        camera.position = self.spawn_point + glam::Vec3::new(0.0, eye_height, 0.0);
        self.player_physics.velocity = glam::Vec3::ZERO;
        self.player_physics.on_ground = false;

        let load_limit = if self.window.is_none() { 8 } else { usize::MAX };
        self.update_chunks(load_limit);

        // Vanilla-ish: respawn anchors control respawn in the Nether/End.
        // If the anchor is missing or uncharged, respawn at the Overworld world spawn (near origin).
        let mut should_consume_anchor_charge = false;
        let mut anchor_pos_for_consume: Option<IVec3> = None;
        if desired_dimension != DimensionId::Overworld && self.active_dimension == desired_dimension
        {
            let anchor_pos = IVec3::new(
                self.spawn_point.x.floor() as i32,
                self.spawn_point.y.floor() as i32 - 1,
                self.spawn_point.z.floor() as i32,
            );
            let anchor_ok = self.get_voxel_at(anchor_pos).is_some_and(|voxel| {
                voxel.id == BLOCK_RESPAWN_ANCHOR
                    && mdminecraft_world::respawn_anchor_charges(voxel.state) > 0
            });

            if anchor_ok {
                should_consume_anchor_charge = true;
                anchor_pos_for_consume = Some(anchor_pos);
            } else {
                tracing::info!(
                    "Respawn anchor missing/uncharged for {:?}; falling back to Overworld spawn",
                    anchor_pos
                );
                if self.active_dimension != DimensionId::Overworld {
                    if let Err(err) = self.switch_dimension(DimensionId::Overworld) {
                        tracing::warn!("Respawn fallback dimension switch failed: {err:#}");
                    }
                }
                let camera = self.renderer.camera_mut();
                camera.position = glam::Vec3::new(0.5, 100.0 + eye_height, 0.5);
                self.player_physics.velocity = glam::Vec3::ZERO;
                self.player_physics.on_ground = false;

                let load_limit = if self.window.is_none() { 8 } else { usize::MAX };
                self.update_chunks(load_limit);
                if let Some(feet) = self.find_safe_spawn_near(0.0, 0.0) {
                    let camera = self.renderer.camera_mut();
                    camera.position = feet + glam::Vec3::new(0.0, eye_height, 0.0);
                    self.player_physics.last_ground_y = feet.y;
                } else {
                    self.player_physics.last_ground_y = 100.0;
                }

                // Re-capture cursor for gameplay
                self.enter_gameplay();
                return;
            }
        }

        if let Some(feet) = self
            .find_safe_spawn_near_position(
                self.spawn_point.x,
                self.spawn_point.y,
                self.spawn_point.z,
            )
            .or_else(|| self.find_safe_spawn_near(self.spawn_point.x, self.spawn_point.z))
        {
            let camera = self.renderer.camera_mut();
            camera.position = feet + glam::Vec3::new(0.0, eye_height, 0.0);
            self.player_physics.last_ground_y = feet.y;
        } else {
            self.player_physics.last_ground_y = self.spawn_point.y;
        }

        if should_consume_anchor_charge {
            let Some(anchor_pos) = anchor_pos_for_consume else {
                tracing::warn!("Respawn anchor charge consumption expected but missing");
                // Continue anyway; this is just a parity mechanic.
                self.enter_gameplay();
                return;
            };
            let chunk_pos = ChunkPos::new(anchor_pos.x.div_euclid(16), anchor_pos.z.div_euclid(16));
            let Some(local_y) = world_y_to_local_y(anchor_pos.y) else {
                // Continue anyway; the player was already respawned.
                self.enter_gameplay();
                return;
            };
            if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                let local_x = anchor_pos.x.rem_euclid(16) as usize;
                let local_z = anchor_pos.z.rem_euclid(16) as usize;
                let voxel = chunk.voxel(local_x, local_y, local_z);
                if voxel.id == BLOCK_RESPAWN_ANCHOR {
                    let charges = mdminecraft_world::respawn_anchor_charges(voxel.state);
                    if charges > 0 {
                        let next = charges - 1;
                        let new_state =
                            mdminecraft_world::set_respawn_anchor_charges(voxel.state, next);
                        chunk.set_voxel(
                            local_x,
                            local_y,
                            local_z,
                            Voxel {
                                state: new_state,
                                ..voxel
                            },
                        );
                        self.refresh_after_voxel_changes(&[anchor_pos]);
                    }
                }
            }
        }

        // Re-capture cursor for gameplay
        self.enter_gameplay();
    }

    /// Check if player requested respawn from death screen
    fn check_death_screen_actions(&mut self) -> Option<GameAction> {
        if self.player_state != PlayerState::Dead {
            return None;
        }

        if self.respawn_requested {
            self.respawn_requested = false;
            self.respawn();
            return None;
        }

        if self.menu_requested {
            self.menu_requested = false;
            self.player_state = PlayerState::Alive; // Reset state before returning
            self.player_health.reset();
            return Some(GameAction::ReturnToMenu);
        }

        None
    }

    /// Update dropped items and handle player pickup
    fn update_dropped_items(&mut self) {
        // Get player position (feet position)
        let camera_pos = self.renderer.camera().position;
        let player_x = camera_pos.x as f64;
        let player_y = (camera_pos.y - self.player_physics.eye_height) as f64;
        let player_z = camera_pos.z as f64;

        // Create closure to get ground height
        let chunks = &self.chunks;
        let block_properties = &self.block_properties;
        let get_ground_height = |x: f64, z: f64| -> f64 {
            Self::column_ground_height(chunks, block_properties, x as f32, z as f32) as f64
        };

        // Update item physics
        self.item_manager
            .update(self.active_dimension, get_ground_height);

        // Merge nearby items
        self.item_manager.merge_nearby_items(self.active_dimension);

        // Check for item pickup
        let picked_up =
            self.item_manager
                .pickup_items(self.active_dimension, player_x, player_y, player_z);
        let mut played_pickup_sound = false;

        // Add picked up items to player storage (hotbar  main inventory)
        for (drop_type, count, durability, enchantments) in picked_up {
            if let Some(core_item_type) = Self::convert_dropped_item_type(drop_type) {
                let mut stack = ItemStack::new(core_item_type, count);
                if let Some(durability) = durability {
                    stack.durability = Some(durability);
                }
                if let Some(enchantments) = enchantments {
                    stack.enchantments = Some(enchantments);
                }
                if let Some(remainder) = self.try_add_stack_to_storage(stack) {
                    let inserted = count.saturating_sub(remainder.count);
                    if inserted > 0 && !played_pickup_sound {
                        played_pickup_sound = true;
                        self.audio.play_sfx(SoundId::ItemPickup);
                    }
                    tracing::warn!(
                        item = ?remainder.item_type,
                        count = remainder.count,
                        "Inventory full; re-spawning picked up items"
                    );
                    // `pickup_items` already removed the drop from the world; re-spawn any remainder
                    // just outside the pickup radius to avoid immediate re-pickup loops.
                    self.item_manager.spawn_item_with_metadata(
                        self.active_dimension,
                        (player_x + 2.0, player_y + 0.5, player_z),
                        drop_type,
                        remainder.count,
                        remainder.durability,
                        remainder.enchantments.clone(),
                    );
                } else {
                    if !played_pickup_sound {
                        played_pickup_sound = true;
                        self.audio.play_sfx(SoundId::ItemPickup);
                    }
                    tracing::info!("Picked up {:?} x{}", drop_type, count);
                }
            }
        }
    }

    /// Update mob AI and movement
    fn update_mobs(&mut self, _dt: f32) {
        // Use frame count as tick for deterministic behavior
        // TODO: Use proper SimTick for multiplayer sync
        let tick = self.sim_tick.0;
        let active_dimension = self.active_dimension;
        let chunks = &self.chunks;
        let block_properties = &self.block_properties;
        let biome_assigner = self.terrain_generator.biome_assigner();
        let is_precipitating = self.weather.is_precipitating();

        // Get player position for hostile mob targeting
        let player_pos = self.renderer.camera().position;
        let player_x = player_pos.x as f64;
        let player_z = player_pos.z as f64;
        let player_eye_y = player_pos.y as f64;
        let player_feet_y = (player_pos.y - self.player_physics.eye_height) as f64;
        let player_center_y = player_feet_y + (self.player_physics.player_height * 0.5) as f64;
        let player_aabb = self.player_physics.get_aabb(player_pos);
        let player_block_x = player_x.floor() as i32;
        let player_block_z = player_z.floor() as i32;
        let visibility = if self.status_effects.has(StatusEffectType::Invisibility) {
            0.25
        } else {
            1.0
        };

        // Check if it's night time (hostile mobs spawn at night)
        // Time: 0.0-0.25 NightDawn, 0.75-1.0 DuskNight
        let time = self.sim_time.time_of_day() as f32;
        let is_night = !(0.25..=0.75).contains(&time);

        let mob_chunk_loaded = |mob: &Mob| -> bool {
            let block_x = mob.x.floor() as i32;
            let block_z = mob.z.floor() as i32;
            let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
            let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
            chunks.contains_key(&ChunkPos::new(chunk_x, chunk_z))
        };

        // Vanilla-ish: hostile mobs are not persisted outside the active chunk set.
        // Keep the Ender Dragon alive regardless of chunk streaming to preserve the boss loop.
        self.mobs.retain(|mob| {
            if mob.dimension != active_dimension {
                return true;
            }
            if mob.dead {
                return true;
            }
            if mob.is_hostile() && mob.mob_type != MobType::EnderDragon {
                return mob_chunk_loaded(mob);
            }
            true
        });

        let can_fire_hostile_projectiles =
            self.player_state == PlayerState::Alive && !self.player_health.is_dead();

        let mut dragon_fireballs_in_flight = 0usize;
        let mut blaze_fireballs_in_flight = 0usize;
        let mut ghast_fireballs_in_flight = 0usize;
        let mut arrows_in_flight = 0usize;
        for projectile in &self.projectiles.projectiles {
            if projectile.dimension != active_dimension || projectile.dead {
                continue;
            }
            match projectile.projectile_type {
                mdminecraft_world::ProjectileType::Arrow => arrows_in_flight += 1,
                mdminecraft_world::ProjectileType::DragonFireball => {
                    dragon_fireballs_in_flight += 1
                }
                mdminecraft_world::ProjectileType::BlazeFireball => blaze_fireballs_in_flight += 1,
                mdminecraft_world::ProjectileType::GhastFireball => ghast_fireballs_in_flight += 1,
                _ => {}
            }
        }
        let mut hostile_projectiles: Vec<Projectile> = Vec::new();

        // Update each mob and track damage to player
        let mut melee_damage = 0.0f32;
        let mut blast_damage = 0.0f32;
        let mut exploded_creeper = false;
        let mut explosion_positions: Vec<(f64, f64, f64, f32)> = Vec::new();
        let mut creeper_explosions: Vec<(glam::Vec3, f32, f32)> = Vec::new();
        let mut player_knockback = glam::Vec3::ZERO;
        for mob in &mut self.mobs {
            if mob.dimension != active_dimension {
                continue;
            }

            if mob.mob_type != MobType::EnderDragon && !mob_chunk_loaded(mob) {
                continue;
            }

            let before_pos = (mob.x, mob.y, mob.z);

            // Vanilla-ish: chickens lay eggs periodically.
            if mob.mob_type == MobType::Chicken && !mob.dead {
                let pos_x = mob.x.floor() as i32;
                let pos_z = mob.z.floor() as i32;
                if Self::chicken_should_lay_egg(self.world_seed, tick, mob.id, pos_x, pos_z) {
                    self.item_manager.spawn_item(
                        active_dimension,
                        mob.x,
                        mob.y + 0.2,
                        mob.z,
                        DroppedItemType::Egg,
                        1,
                    );
                }
            }

            // Vanilla-ish: water + rain/snow extinguish burning mobs when exposed.
            if mob.fire_ticks > 0 && mob.dimension == DimensionId::Overworld {
                let mob_block_x = mob.x.floor() as i32;
                let mob_block_y = mob.y.floor() as i32;
                let mob_block_z = mob.z.floor() as i32;
                let head_y = mob_block_y + 1;
                let chunk_pos = ChunkPos::new(
                    mob_block_x.div_euclid(CHUNK_SIZE_X as i32),
                    mob_block_z.div_euclid(CHUNK_SIZE_Z as i32),
                );

                if let (Some(chunk), Some(local_head_y)) =
                    (chunks.get(&chunk_pos), world_y_to_local_y(head_y))
                {
                    let local_x = mob_block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let local_z = mob_block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                    let head_voxel = chunk.voxel(local_x, local_head_y, local_z);

                    let is_wet = get_fluid_type(head_voxel.id) == Some(FluidType::Water)
                        || (mdminecraft_world::block_supports_waterlogging(head_voxel.id)
                            && mdminecraft_world::is_waterlogged(head_voxel.state));

                    if is_wet {
                        mob.extinguish();
                    } else if is_precipitating {
                        let biome = biome_assigner.get_blended_biome(mob_block_x, mob_block_z, 2);
                        if biome.id != BiomeId::Desert
                            && Self::column_is_clear_to_sky(chunk, local_x, local_head_y, local_z)
                        {
                            mob.extinguish();
                        }
                    }
                }
            }

            // Update fire damage (from Fire Aspect enchantment)
            mob.update_fire();

            // Fire contact + ignition (vanilla-ish; simplified).
            {
                let mob_block_x = mob.x.floor() as i32;
                let mob_block_y = mob.y.floor() as i32;
                let mob_block_z = mob.z.floor() as i32;
                let chunk_pos = ChunkPos::new(
                    mob_block_x.div_euclid(CHUNK_SIZE_X as i32),
                    mob_block_z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                if let (Some(chunk), Some(local_y)) =
                    (chunks.get(&chunk_pos), world_y_to_local_y(mob_block_y))
                {
                    let local_x = mob_block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let local_z = mob_block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                    let here = chunk.voxel(local_x, local_y, local_z);
                    if here.id == mdminecraft_world::BLOCK_FIRE {
                        mob.set_on_fire(u32::from(LIGHTNING_FIRE_TICKS));
                    }
                }
            }

            // Vanilla-ish: zombies/skeletons burn in daylight when exposed to the sky,
            // and they are extinguished by water (and rain/snow).
            if matches!(mob.mob_type, MobType::Zombie | MobType::Skeleton)
                && mob.dimension == DimensionId::Overworld
                && !is_night
            {
                let mob_block_x = mob.x.floor() as i32;
                let mob_block_y = mob.y.floor() as i32;
                let mob_block_z = mob.z.floor() as i32;

                let head_y = mob_block_y + 1;
                let chunk_pos = ChunkPos::new(
                    mob_block_x.div_euclid(CHUNK_SIZE_X as i32),
                    mob_block_z.div_euclid(CHUNK_SIZE_Z as i32),
                );

                if let (Some(chunk), Some(local_head_y)) =
                    (chunks.get(&chunk_pos), world_y_to_local_y(head_y))
                {
                    let local_x = mob_block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let local_z = mob_block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                    let head_voxel = chunk.voxel(local_x, local_head_y, local_z);

                    let is_wet = get_fluid_type(head_voxel.id) == Some(FluidType::Water)
                        || (mdminecraft_world::block_supports_waterlogging(head_voxel.id)
                            && mdminecraft_world::is_waterlogged(head_voxel.state));
                    if is_wet {
                        mob.extinguish();
                    } else {
                        let sky_exposed =
                            Self::column_is_clear_to_sky(chunk, local_x, local_head_y, local_z);
                        let is_precipitating_here = is_precipitating
                            && biome_assigner
                                .get_blended_biome(mob_block_x, mob_block_z, 2)
                                .id
                                != BiomeId::Desert;

                        if Self::undead_should_extinguish(
                            is_wet,
                            is_precipitating_here,
                            sky_exposed,
                        ) {
                            mob.extinguish();
                        } else if Self::undead_should_burn_in_sun(
                            is_night,
                            is_precipitating_here,
                            is_wet,
                            head_voxel.light_sky,
                            sky_exposed,
                        ) {
                            mob.set_on_fire(UNDEAD_SUNLIGHT_FIRE_TICKS);
                        }
                    }
                }
            }

            // Spiders are only hostile at night, other hostile mobs always attack
            if mob.mob_type.is_hostile_at_time(is_night) {
                let (target_x, target_z) =
                    if matches!(mob.mob_type, MobType::Zombie | MobType::Spider) {
                        let distance = mob.distance_to(player_x, player_center_y, player_z);
                        let detection_range = (mob.mob_type.detection_range() as f64) * visibility;
                        let attack_range = mob.mob_type.size() as f64 + 1.5;

                        if distance > attack_range && distance <= detection_range {
                            let start = mdminecraft_world::GridPos::new(
                                mob.x.floor() as i32,
                                mob.z.floor() as i32,
                            );
                            let goal = mdminecraft_world::GridPos::new(
                                player_x.floor() as i32,
                                player_z.floor() as i32,
                            );
                            let nav_y = mob.y.floor() as i32;
                            let radius = mob.mob_type.detection_range().ceil() as i32 + 4;

                            let path = mdminecraft_world::astar_path_4dir(
                                start,
                                goal,
                                |p| {
                                    if (p.x - start.x).abs() > radius
                                        || (p.z - start.z).abs() > radius
                                    {
                                        return false;
                                    }

                                    let chunk_x = p.x.div_euclid(CHUNK_SIZE_X as i32);
                                    let chunk_z = p.z.div_euclid(CHUNK_SIZE_Z as i32);
                                    let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
                                    let Some(chunk) = chunks.get(&chunk_pos) else {
                                        return false;
                                    };

                                    let local_x = p.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                                    let local_z = p.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                                    let Some(local_y) = world_y_to_local_y(nav_y) else {
                                        return false;
                                    };
                                    let Some(local_above_y) = world_y_to_local_y(nav_y + 1) else {
                                        return false;
                                    };
                                    let Some(local_floor_y) = world_y_to_local_y(nav_y - 1) else {
                                        return false;
                                    };

                                    let here = chunk.voxel(local_x, local_y, local_z);
                                    if block_properties.get(here.id).is_solid {
                                        return false;
                                    }
                                    let above = chunk.voxel(local_x, local_above_y, local_z);
                                    if block_properties.get(above.id).is_solid {
                                        return false;
                                    }

                                    let floor = chunk.voxel(local_x, local_floor_y, local_z);
                                    let Some(top_offset) =
                                        Self::voxel_collision_top_offset(block_properties, &floor)
                                    else {
                                        return false;
                                    };
                                    top_offset >= 1.0
                                },
                                4096,
                            );

                            if let Some(path) = path {
                                if let Some(next) = path.get(1).copied() {
                                    (next.x as f64 + 0.5, next.z as f64 + 0.5)
                                } else {
                                    (player_x, player_z)
                                }
                            } else {
                                (player_x, player_z)
                            }
                        } else {
                            (player_x, player_z)
                        }
                    } else {
                        (player_x, player_z)
                    };

                let dealt_damage = mob.update_with_target_visibility(
                    tick,
                    target_x,
                    player_center_y,
                    target_z,
                    visibility,
                );
                if dealt_damage {
                    // Check if this was a creeper explosion
                    if mob.mob_type.explodes() && mob.dead {
                        let mut explosion_damage = mob.mob_type.explosion_damage();
                        let mut explosion_radius = mob.mob_type.explosion_radius();
                        if mob.mob_type == MobType::Creeper && mob.charged {
                            // Vanilla-ish: charged creepers have roughly double explosion power.
                            explosion_damage *= 2.0;
                            explosion_radius *= 2.0;
                        }

                        // Record explosion position for block destruction
                        explosion_positions.push((mob.x, mob.y, mob.z, explosion_radius));

                        let explosion_center = glam::Vec3::new(
                            mob.x as f32,
                            (mob.y + mob.mob_type.size() as f64) as f32,
                            mob.z as f32,
                        );
                        creeper_explosions.push((
                            explosion_center,
                            explosion_radius,
                            explosion_damage,
                        ));
                        let player_center = glam::Vec3::new(
                            player_x as f32,
                            player_center_y as f32,
                            player_z as f32,
                        );
                        let dist = (player_center - explosion_center).length();
                        let falloff = (1.0 - dist / explosion_radius.max(0.1)).clamp(0.0, 1.0);
                        let exposure = Self::explosion_exposure(
                            chunks,
                            block_properties,
                            explosion_center,
                            &player_aabb,
                        );
                        let effect = falloff * exposure;

                        // Creeper explosion damage is distance + exposure based (simplified vanilla-ish).
                        let damage = explosion_damage * effect;
                        if damage > 0.0 {
                            blast_damage += damage;
                            exploded_creeper = true;
                        }

                        let dx = player_center.x - explosion_center.x;
                        let dz = player_center.z - explosion_center.z;
                        let dist_sq = dx * dx + dz * dz;
                        if dist_sq > 1.0e-6 {
                            let dist = dist_sq.sqrt();
                            let strength = 1.2 * effect;
                            player_knockback +=
                                glam::Vec3::new(dx / dist, 0.0, dz / dist) * strength;
                        }
                        tracing::info!("Creeper exploded!");
                    } else {
                        // Normal attack damage
                        let mob_radius = mob.mob_type.size() as f64;
                        let mob_height = mob_radius * 2.0;
                        let mob_center = glam::Vec3::new(
                            mob.x as f32,
                            (mob.y + mob_height * 0.5) as f32,
                            mob.z as f32,
                        );
                        let player_center = glam::Vec3::new(
                            player_x as f32,
                            player_center_y as f32,
                            player_z as f32,
                        );
                        if Self::line_of_sight_clear(
                            chunks,
                            block_properties,
                            mob_center,
                            player_center,
                        ) {
                            melee_damage += mob.mob_type.attack_damage();
                            let dx = player_x - mob.x;
                            let dz = player_z - mob.z;
                            let dist_sq = dx * dx + dz * dz;
                            if dist_sq > 1.0e-6 {
                                let dist = dist_sq.sqrt();
                                let strength = match mob.mob_type {
                                    MobType::Spider => 0.5,
                                    MobType::EnderDragon => 0.7,
                                    _ => 0.4,
                                };
                                player_knockback +=
                                    glam::Vec3::new((dx / dist) as f32, 0.0, (dz / dist) as f32)
                                        * strength;
                            }
                        }
                    }
                }

                if can_fire_hostile_projectiles && dragon_fireballs_in_flight < 4 {
                    if let Some(projectile) = mob.try_spawn_dragon_fireball(
                        tick,
                        player_x,
                        player_eye_y,
                        player_z,
                        visibility,
                    ) {
                        let origin = glam::Vec3::new(
                            mob.x as f32,
                            (mob.y + mob.mob_type.size() as f64) as f32,
                            mob.z as f32,
                        );
                        if Self::line_of_sight_clear(chunks, block_properties, origin, player_pos) {
                            hostile_projectiles.push(projectile);
                            dragon_fireballs_in_flight += 1;
                        }
                    }
                }

                if can_fire_hostile_projectiles && blaze_fireballs_in_flight < 8 {
                    if let Some(projectile) = mob.try_spawn_blaze_fireball(
                        tick,
                        player_x,
                        player_eye_y,
                        player_z,
                        visibility,
                    ) {
                        let origin = glam::Vec3::new(
                            mob.x as f32,
                            (mob.y + mob.mob_type.size() as f64 * 0.8) as f32,
                            mob.z as f32,
                        );
                        if Self::line_of_sight_clear(chunks, block_properties, origin, player_pos) {
                            hostile_projectiles.push(projectile);
                            blaze_fireballs_in_flight += 1;
                        }
                    }
                }

                if can_fire_hostile_projectiles && ghast_fireballs_in_flight < 2 {
                    if let Some(projectile) = mob.try_spawn_ghast_fireball(
                        tick,
                        player_x,
                        player_eye_y,
                        player_z,
                        visibility,
                    ) {
                        let origin = glam::Vec3::new(
                            mob.x as f32,
                            (mob.y + mob.mob_type.size() as f64 * 0.6) as f32,
                            mob.z as f32,
                        );
                        if Self::line_of_sight_clear(chunks, block_properties, origin, player_pos) {
                            hostile_projectiles.push(projectile);
                            ghast_fireballs_in_flight += 1;
                        }
                    }
                }

                if can_fire_hostile_projectiles
                    && arrows_in_flight < MAX_ARROW_PROJECTILES_IN_FLIGHT
                {
                    if let Some(projectile) = mob.try_spawn_skeleton_arrow(
                        tick,
                        player_x,
                        player_eye_y,
                        player_z,
                        visibility,
                    ) {
                        let origin =
                            glam::Vec3::new(mob.x as f32, (mob.y + 1.4) as f32, mob.z as f32);
                        if Self::line_of_sight_clear(chunks, block_properties, origin, player_pos) {
                            hostile_projectiles.push(projectile);
                            arrows_in_flight += 1;
                        }
                    }
                }
            } else {
                // Update passive mob (or spider in daylight)
                mob.update(tick);
            }

            Self::resolve_mob_world_collisions(chunks, block_properties, mob, before_pos);
        }

        for projectile in hostile_projectiles {
            self.projectiles.spawn(active_dimension, projectile);
        }

        // Creeper explosions also damage/knock back nearby mobs (simplified vanilla-ish).
        for (explosion_center, explosion_radius, explosion_damage) in creeper_explosions {
            for mob in &mut self.mobs {
                if mob.dimension != active_dimension || mob.dead {
                    continue;
                }

                let mob_radius = mob.mob_type.size();
                let mob_height = mob_radius * 2.0;
                let mob_center =
                    glam::Vec3::new(mob.x as f32, mob.y as f32 + mob_height * 0.5, mob.z as f32);
                let dist = (mob_center - explosion_center).length();
                if dist >= explosion_radius {
                    continue;
                }

                let mob_aabb = AABB::from_center_size(
                    mob_center,
                    glam::Vec3::new(mob_radius * 2.0, mob_height, mob_radius * 2.0),
                );
                let falloff = (1.0 - dist / explosion_radius.max(0.1)).clamp(0.0, 1.0);
                let exposure = Self::explosion_exposure(
                    &self.chunks,
                    &self.block_properties,
                    explosion_center,
                    &mob_aabb,
                );
                let effect = falloff * exposure;
                let damage = explosion_damage * effect;
                if damage <= 0.0 {
                    continue;
                }

                mob.damage(damage);

                let dx = mob_center.x - explosion_center.x;
                let dz = mob_center.z - explosion_center.z;
                let dist_sq = dx * dx + dz * dz;
                if dist_sq > 1.0e-6 {
                    let dist = dist_sq.sqrt();
                    let strength = 0.9 * effect;
                    mob.apply_knockback((dx / dist) as f64, (dz / dist) as f64, strength as f64);
                }
            }
        }

        // Handle creeper explosion block destruction
        for (ex, ey, ez, radius) in explosion_positions {
            self.destroy_blocks_in_radius(ex, ey, ez, radius);
        }

        self.apply_player_knockback_displacement(player_knockback, 1.2);

        // Apply accumulated damage to player (reduced by armor)
        let raw_damage = melee_damage + blast_damage;
        if raw_damage > 0.0 && self.player_state == PlayerState::Alive {
            // Armor reduces damage and takes durability hit (per damage kind).
            let mut actual_damage = 0.0f32;
            if melee_damage > 0.0 {
                actual_damage += self
                    .player_armor
                    .take_damage(melee_damage, DamageKind::Generic);
            }
            if blast_damage > 0.0 {
                actual_damage += self
                    .player_armor
                    .take_damage(blast_damage, DamageKind::Blast);
            }
            self.player_health.damage(actual_damage);

            // Log armor reduction
            if actual_damage < raw_damage {
                tracing::debug!(
                    "Armor reduced damage from {:.1} to {:.1}",
                    raw_damage,
                    actual_damage
                );
            }

            // Determine damage source for potential death message
            let source = if exploded_creeper {
                "Creeper"
            } else if self
                .mobs
                .iter()
                .any(|m| m.dimension == active_dimension && m.mob_type == MobType::EnderDragon)
            {
                "Ender Dragon"
            } else if self
                .mobs
                .iter()
                .any(|m| m.dimension == active_dimension && m.mob_type == MobType::Blaze)
            {
                "Blaze"
            } else if self
                .mobs
                .iter()
                .any(|m| m.dimension == active_dimension && m.mob_type == MobType::Ghast)
            {
                "Ghast"
            } else if self
                .mobs
                .iter()
                .any(|m| m.dimension == active_dimension && m.mob_type == MobType::Spider)
            {
                "Spider"
            } else if self
                .mobs
                .iter()
                .any(|m| m.dimension == active_dimension && m.mob_type == MobType::Zombie)
            {
                "Zombie"
            } else {
                "Skeleton"
            };

            // Check for death
            if self.player_health.is_dead() {
                if exploded_creeper {
                    self.handle_death("Blown up by Creeper");
                } else {
                    self.handle_death(&format!("Slain by {}", source));
                }
            }
        }

        // Remove dead mobs and drop loot (and XP)
        type LootDrop = (
            f64,
            f64,
            f64,
            DroppedItemType,
            u32,
            Option<u32>,
            Option<Vec<Enchantment>>,
        );

        let mut loot_drops: Vec<LootDrop> = Vec::new();
        let mut xp_orb_spawns: Vec<(f64, f64, f64, u32)> = Vec::new();
        let mut ender_dragon_defeated = false;
        let loot_tables = &self.loot_tables;
        let world_seed = self.world_seed;
        let sim_tick = self.sim_tick;
        self.mobs.retain(|mob| {
            if mob.dimension != active_dimension {
                return true;
            }
            if mob.dead {
                // Spawn XP orb based on mob type
                let xp_value = match mob.mob_type {
                    MobType::Zombie | MobType::Skeleton | MobType::Spider => 5,
                    MobType::Creeper => 5,
                    MobType::Pig | MobType::Cow | MobType::Sheep | MobType::Chicken => 1,
                    MobType::Blaze | MobType::Ghast => 10,
                    MobType::EnderDragon => 500,
                    MobType::Villager => 0, // Villagers don't drop XP
                };
                xp_orb_spawns.push((mob.x, mob.y + 0.5, mob.z, xp_value));

                if mob.mob_type == MobType::EnderDragon {
                    ender_dragon_defeated = true;
                }

                if let Some(table) = loot_tables.mob.get(&mob.mob_type) {
                    let mut rng = {
                        let pos_x = mob.x.floor() as i32;
                        let pos_y = mob.y.floor() as i32;
                        let pos_z = mob.z.floor() as i32;
                        let pos_seed = (pos_x as u64)
                            ^ ((pos_y as u64).rotate_left(21))
                            ^ ((pos_z as u64).rotate_left(42));
                        let seed = world_seed
                            ^ sim_tick.0.wrapping_mul(0xA24B_AED4_963E_E407)
                            ^ (mob.mob_type as u64).wrapping_mul(0x9E37_79B9_7F4A_7C15)
                            ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
                            ^ 0xE0E7_7EAD_5EED_E0E7_u64;
                        StdRng::seed_from_u64(seed)
                    };

                    for (drop_type, count) in table.roll(&mut rng) {
                        loot_drops.push((mob.x, mob.y + 0.5, mob.z, drop_type, count, None, None));
                    }
                } else {
                    // Drop loot based on mob type
                    match mob.mob_type {
                        MobType::Zombie => {
                            // Zombies drop 0-2 rotten flesh
                            let count = (tick % 3) as u32;
                            if count > 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::RottenFlesh,
                                    count,
                                    None,
                                    None,
                                ));
                            }

                            // Vanilla-ish: zombies can drop carrots/potatoes/iron ingots (deterministic).
                            let pos_x = mob.x.floor() as i32;
                            let pos_z = mob.z.floor() as i32;
                            if let Some(extra_drop) = Self::zombie_rare_drop(tick, pos_x, pos_z) {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    extra_drop,
                                    1,
                                    None,
                                    None,
                                ));
                            }
                        }
                        MobType::Skeleton => {
                            // Skeletons drop 0-2 bones
                            let bone_count = (tick % 3) as u32;
                            if bone_count > 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::Bone,
                                    bone_count,
                                    None,
                                    None,
                                ));
                            }

                            // Vanilla-ish: skeletons also drop arrows (deterministic).
                            let arrow_count = (tick.wrapping_add(1) % 3) as u32;
                            if arrow_count > 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::Arrow,
                                    arrow_count,
                                    None,
                                    None,
                                ));
                            }

                            // Vanilla-ish: small chance to drop a bow (deterministic).
                            let pos_x = mob.x.floor() as i32;
                            let pos_z = mob.z.floor() as i32;
                            let roll = (tick as u32)
                                .wrapping_add((pos_x as u32).wrapping_mul(29))
                                .wrapping_add((pos_z as u32).wrapping_mul(53))
                                % 100;
                            if roll < 6 {
                                let (durability, enchantments) = Self::mob_bow_drop_metadata(
                                    world_seed,
                                    sim_tick,
                                    mob.id,
                                    (pos_x, mob.y.floor() as i32, pos_z),
                                );

                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::Bow,
                                    1,
                                    durability,
                                    enchantments,
                                ));
                            }
                        }
                        MobType::Pig => {
                            let drop_type =
                                Self::mob_meat_drop_type(mob.mob_type, mob.fire_ticks > 0)
                                    .unwrap_or(DroppedItemType::RawPork);
                            loot_drops.push((
                                mob.x,
                                mob.y + 0.5,
                                mob.z,
                                drop_type,
                                1 + (tick % 3) as u32,
                                None,
                                None,
                            ));
                        }
                        MobType::Cow => {
                            let drop_type =
                                Self::mob_meat_drop_type(mob.mob_type, mob.fire_ticks > 0)
                                    .unwrap_or(DroppedItemType::RawBeef);
                            loot_drops.push((
                                mob.x,
                                mob.y + 0.5,
                                mob.z,
                                drop_type,
                                1 + (tick % 3) as u32,
                                None,
                                None,
                            ));
                            loot_drops.push((
                                mob.x,
                                mob.y + 0.5,
                                mob.z,
                                DroppedItemType::Leather,
                                (tick % 2) as u32 + 1,
                                None,
                                None,
                            ));
                        }
                        MobType::Sheep => {
                            loot_drops.push((
                                mob.x,
                                mob.y + 0.5,
                                mob.z,
                                DroppedItemType::Wool,
                                1,
                                None,
                                None,
                            ));
                        }
                        MobType::Chicken => {
                            loot_drops.push((
                                mob.x,
                                mob.y + 0.5,
                                mob.z,
                                DroppedItemType::Feather,
                                1 + (tick % 2) as u32,
                                None,
                                None,
                            ));
                        }
                        MobType::Spider => {
                            // Spiders drop 0-2 string
                            let count = (tick % 3) as u32;
                            if count > 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::String,
                                    count,
                                    None,
                                    None,
                                ));
                            }

                            // Vanilla-ish: spiders also drop 0-1 spider eyes (deterministic).
                            let pos_x = mob.x.floor() as i32;
                            let pos_z = mob.z.floor() as i32;
                            let roll = (tick as u32)
                                .wrapping_add((pos_x as u32).wrapping_mul(37))
                                .wrapping_add((pos_z as u32).wrapping_mul(101))
                                % 3;
                            if roll == 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::SpiderEye,
                                    1,
                                    None,
                                    None,
                                ));
                            }
                        }
                        MobType::Creeper => {
                            // Creepers drop 0-2 gunpowder
                            let count = (tick % 3) as u32;
                            if count > 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::Gunpowder,
                                    count,
                                    None,
                                    None,
                                ));
                            }
                        }
                        MobType::Blaze => {
                            // Blazes drop 0-2 blaze powder (deterministic).
                            let count = (tick % 3) as u32;
                            if count > 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::BlazePowder,
                                    count,
                                    None,
                                    None,
                                ));
                            }
                        }
                        MobType::Ghast => {
                            // Ghasts drop 0-1 ghast tears (deterministic).
                            let roll = (tick as u32)
                                .wrapping_add((mob.x.floor() as u32).wrapping_mul(41))
                                .wrapping_add((mob.z.floor() as u32).wrapping_mul(71))
                                % 3;
                            if roll == 0 {
                                loot_drops.push((
                                    mob.x,
                                    mob.y + 0.5,
                                    mob.z,
                                    DroppedItemType::GhastTear,
                                    1,
                                    None,
                                    None,
                                ));
                            }
                        }
                        MobType::EnderDragon => {
                            // Boss-lite: no default item drops (XP + exit portal are handled elsewhere).
                        }
                        MobType::Villager => {
                            // Villagers don't drop items when killed
                        }
                    }
                }
                false // Remove dead mob
            } else {
                true // Keep alive mob
            }
        });

        if ender_dragon_defeated && active_dimension == DimensionId::End {
            self.end_boss_defeated = true;
            self.ensure_end_exit_portal_present();

            self.push_command_log_line("The Ender Dragon was defeated.".to_string());
            self.push_command_log_line("An exit portal has opened.".to_string());
        }

        // Spawn loot drops
        for (x, y, z, item_type, count, durability, enchantments) in loot_drops {
            if count > 0 {
                self.item_manager.spawn_item_with_metadata(
                    active_dimension,
                    (x, y, z),
                    item_type,
                    count,
                    durability,
                    enchantments,
                );
            }
        }

        // Spawn XP orbs from killed mobs
        for (spawn_index, (x, y, z, xp_value)) in xp_orb_spawns.into_iter().enumerate() {
            let pos = glam::Vec3::new(x as f32, y as f32, z as f32);
            let seed = self.world_seed
                ^ self.sim_tick.0.wrapping_mul(0xA24B_AED4_963E_E407)
                ^ (spawn_index as u64).wrapping_mul(0x9E37_79B9_7F4A_7C15)
                ^ (xp_value as u64).wrapping_mul(0xBF58_476D_1CE4_E5B9)
                ^ 0x5850_5F4F_5242_u64;
            self.xp_orbs.push(XPOrb::new(pos, xp_value, seed));
        }

        // Spawn hostile mobs at night (every ~100 ticks, max 10 hostile mobs).
        //
        // Use integer offsets to avoid platform-dependent trig differences; validity checks gate
        // spawns (solid ground, empty headroom, low light).
        if active_dimension == DimensionId::Overworld && is_night && tick.is_multiple_of(100) {
            let hostile_count = self
                .mobs
                .iter()
                .filter(|m| {
                    if m.dimension != active_dimension || m.dead || !m.is_hostile() {
                        return false;
                    }

                    let block_x = m.x.floor() as i32;
                    let block_z = m.z.floor() as i32;
                    let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
                    let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
                    self.chunks.contains_key(&ChunkPos::new(chunk_x, chunk_z))
                })
                .count();
            if hostile_count < 10 {
                const MIN_RADIUS: i32 = 16;
                const MAX_RADIUS: i32 = 32;
                const LIGHT_THRESHOLD: u8 = 7;

                let seed = self.world_seed
                    ^ tick.wrapping_mul(0x9E37_79B9_7F4A_7C15)
                    ^ 0x484F_5354_494C_4553_u64; // "HOSTILES"
                let mut rng = StdRng::seed_from_u64(seed);

                let base_x = player_x.floor() as i32;
                let base_z = player_z.floor() as i32;
                let min_sq = MIN_RADIUS * MIN_RADIUS;
                let max_sq = MAX_RADIUS * MAX_RADIUS;

                let mut spawned = false;
                for _attempt in 0..32 {
                    let dx = rng.gen_range(-MAX_RADIUS..=MAX_RADIUS);
                    let dz = rng.gen_range(-MAX_RADIUS..=MAX_RADIUS);
                    let dist_sq = dx * dx + dz * dz;
                    if dist_sq < min_sq || dist_sq > max_sq {
                        continue;
                    }

                    let spawn_block_x = base_x + dx;
                    let spawn_block_z = base_z + dz;

                    let chunk_x = spawn_block_x.div_euclid(CHUNK_SIZE_X as i32);
                    let chunk_z = spawn_block_z.div_euclid(CHUNK_SIZE_Z as i32);
                    let local_x = spawn_block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let local_z = spawn_block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                    let Some(chunk) = self.chunks.get(&ChunkPos::new(chunk_x, chunk_z)) else {
                        continue;
                    };

                    let mut ground_y = None;
                    for y in (0..CHUNK_SIZE_Y).rev() {
                        let id = chunk.voxel(local_x, y, local_z).id;
                        if id == BLOCK_AIR {
                            continue;
                        }
                        if !self.block_properties.get(id).is_solid {
                            continue;
                        }
                        ground_y = Some(y as i32);
                        break;
                    }

                    let Some(ground_y) = ground_y else {
                        continue;
                    };
                    let spawn_y = ground_y + 1;
                    if spawn_y + 1 >= CHUNK_SIZE_Y as i32 {
                        continue;
                    }

                    let spawn_voxel = chunk.voxel(local_x, spawn_y as usize, local_z);
                    if spawn_voxel.id != BLOCK_AIR {
                        continue;
                    }
                    let head_voxel = chunk.voxel(local_x, (spawn_y + 1) as usize, local_z);
                    if head_voxel.id != BLOCK_AIR {
                        continue;
                    }

                    let light = Self::effective_spawn_light_level(spawn_voxel, &self.sim_time);
                    if light > LIGHT_THRESHOLD {
                        continue;
                    }

                    // Choose mob type (zombie, skeleton, spider, or creeper).
                    let mob_type = match tick % 4 {
                        0 => MobType::Zombie,
                        1 => MobType::Skeleton,
                        2 => MobType::Spider,
                        _ => MobType::Creeper,
                    };

                    let world_spawn_y = local_y_to_world_y(spawn_y as usize);

                    let mut mob = Mob::new(
                        spawn_block_x as f64 + 0.5,
                        world_spawn_y as f64,
                        spawn_block_z as f64 + 0.5,
                        mob_type,
                    );
                    mob.dimension = active_dimension;
                    self.assign_mob_id(&mut mob);
                    self.mobs.push(mob);
                    spawned = true;
                    tracing::debug!(
                        "Spawned {:?} at ({}, {}, {})",
                        mob_type,
                        spawn_block_x,
                        world_spawn_y,
                        spawn_block_z
                    );
                    break;
                }

                if !spawned {
                    tracing::debug!("Hostile spawn attempt failed to find a valid location");
                }
            }
        }

        // Nether: periodic ghast spawns (every ~200 ticks, low cap).
        //
        // Ghasts are flying mobs, so we look for a small clear volume rather than a ground spot.
        if active_dimension == DimensionId::Nether && tick.is_multiple_of(200) {
            let ghast_count = self
                .mobs
                .iter()
                .filter(|m| {
                    m.dimension == active_dimension && !m.dead && m.mob_type == MobType::Ghast
                })
                .count();
            if ghast_count < 2 {
                const MIN_RADIUS: i32 = 16;
                const MAX_RADIUS: i32 = 48;
                const LIGHT_THRESHOLD: u8 = 7;

                let seed = self.world_seed
                    ^ tick.wrapping_mul(0x9E37_79B9_7F4A_7C15)
                    ^ 0x4E45_5448_4748_5354_u64; // "NETHGHST"
                let mut rng = StdRng::seed_from_u64(seed);

                let base_x = player_x.floor() as i32;
                let base_z = player_z.floor() as i32;
                let min_sq = MIN_RADIUS * MIN_RADIUS;
                let max_sq = MAX_RADIUS * MAX_RADIUS;

                let mut spawned = false;
                for _attempt in 0..32 {
                    let dx = rng.gen_range(-MAX_RADIUS..=MAX_RADIUS);
                    let dz = rng.gen_range(-MAX_RADIUS..=MAX_RADIUS);
                    let dist_sq = dx * dx + dz * dz;
                    if dist_sq < min_sq || dist_sq > max_sq {
                        continue;
                    }

                    let spawn_block_x = base_x + dx;
                    let spawn_block_z = base_z + dz;

                    let chunk_x = spawn_block_x.div_euclid(CHUNK_SIZE_X as i32);
                    let chunk_z = spawn_block_z.div_euclid(CHUNK_SIZE_Z as i32);
                    let local_x = spawn_block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let local_z = spawn_block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                    // Keep the clearance probe within the chunk bounds.
                    if !(2..=13).contains(&local_x) || !(2..=13).contains(&local_z) {
                        continue;
                    }

                    let local_y = rng.gen_range(40..=200) as usize;
                    if local_y + 3 >= CHUNK_SIZE_Y {
                        continue;
                    }

                    let Some(chunk) = self.chunks.get(&ChunkPos::new(chunk_x, chunk_z)) else {
                        continue;
                    };

                    let mut clear = true;
                    for dy in 0..=3 {
                        for oz in -1..=1 {
                            for ox in -1..=1 {
                                let x = (local_x as i32 + ox) as usize;
                                let y = local_y + dy;
                                let z = (local_z as i32 + oz) as usize;
                                if chunk.voxel(x, y, z).id != BLOCK_AIR {
                                    clear = false;
                                    break;
                                }
                            }
                            if !clear {
                                break;
                            }
                        }
                        if !clear {
                            break;
                        }
                    }

                    if !clear {
                        continue;
                    }

                    let spawn_voxel = chunk.voxel(local_x, local_y, local_z);
                    let light = Self::effective_spawn_light_level(spawn_voxel, &self.sim_time);
                    if light > LIGHT_THRESHOLD {
                        continue;
                    }

                    let mut mob = Mob::new(
                        spawn_block_x as f64 + 0.5,
                        local_y_to_world_y(local_y) as f64,
                        spawn_block_z as f64 + 0.5,
                        MobType::Ghast,
                    );
                    mob.dimension = active_dimension;
                    self.assign_mob_id(&mut mob);
                    self.mobs.push(mob);
                    spawned = true;
                    break;
                }

                if !spawned {
                    tracing::debug!("Nether ghast spawn attempt failed to find a valid location");
                }
            }
        }

        // Despawn hostile mobs during the day (too far from player or day time)
        if active_dimension == DimensionId::Overworld && !is_night {
            self.mobs.retain(|mob| {
                if mob.dimension != active_dimension {
                    return true;
                }
                if mob.is_hostile() {
                    // Despawn hostile mobs during the day
                    let mob_block_x = mob.x.floor() as i32;
                    let mob_block_z = mob.z.floor() as i32;
                    let dx = mob_block_x - player_block_x;
                    let dz = mob_block_z - player_block_z;
                    let dist_sq = (dx as i64) * (dx as i64) + (dz as i64) * (dz as i64);
                    dist_sq < 48_i64 * 48_i64 // Keep if within 48 blocks during day transition
                } else {
                    true
                }
            });
        }
    }

    fn effective_spawn_light_level(voxel: Voxel, time: &SimTime) -> u8 {
        let effective_skylight = time.effective_skylight() as u16;
        let scaled_sky = ((voxel.light_sky as u16) * effective_skylight + 7) / 15;
        scaled_sky.max(voxel.light_block as u16) as u8
    }

    fn column_is_clear_to_sky(
        chunk: &Chunk,
        local_x: usize,
        local_y: usize,
        local_z: usize,
    ) -> bool {
        if local_y >= CHUNK_SIZE_Y - 1 {
            return true;
        }

        for y in (local_y + 1)..CHUNK_SIZE_Y {
            if chunk.voxel(local_x, y, local_z).id != BLOCK_AIR {
                return false;
            }
        }

        true
    }

    fn undead_should_extinguish(
        is_wet: bool,
        is_precipitating_here: bool,
        sky_exposed: bool,
    ) -> bool {
        is_wet || (is_precipitating_here && sky_exposed)
    }

    fn undead_should_burn_in_sun(
        is_night: bool,
        is_precipitating_here: bool,
        is_wet: bool,
        light_sky: u8,
        sky_exposed: bool,
    ) -> bool {
        !is_night
            && sky_exposed
            && !Self::undead_should_extinguish(is_wet, is_precipitating_here, sky_exposed)
            && light_sky >= UNDEAD_SUNLIGHT_MIN_SKY_LIGHT
    }

    /// Update all projectiles - physics, collisions, and damage
    fn update_projectiles(&mut self) {
        #[derive(Clone, Copy)]
        enum EntityHit {
            Mob(usize),
            Player,
        }

        let active_dimension = self.active_dimension;
        let player_pos = self.renderer.camera().position;
        let has_fire_resistance = self.status_effects.has(StatusEffectType::FireResistance);
        let mut arrow_pickups: Vec<(f64, f64, f64)> = Vec::new();
        let mut button_mesh_refresh: std::collections::BTreeSet<ChunkPos> =
            std::collections::BTreeSet::new();

        // Update projectile physics
        self.projectiles.update(active_dimension);

        let player_aabb = self.player_physics.get_aabb(player_pos);
        let mut projectile_damage_generic_to_player = 0.0f32;
        let mut projectile_damage_fire_to_player = 0.0f32;
        let mut projectile_damage_projectile_to_player = 0.0f32;
        let mut projectile_damage_source: Option<&'static str> = None;
        let mut player_knockback = glam::Vec3::ZERO;

        // Check for collisions (swept): entities before later block impacts.
        for projectile in &mut self.projectiles.projectiles {
            if projectile.dimension != active_dimension || projectile.stuck || projectile.dead {
                continue;
            }

            let from = (projectile.prev_x, projectile.prev_y, projectile.prev_z);
            let to = (projectile.x, projectile.y, projectile.z);
            let seg_dx = to.0 - from.0;
            let seg_dy = to.1 - from.1;
            let seg_dz = to.2 - from.2;
            let seg_len_sq = seg_dx * seg_dx + seg_dy * seg_dy + seg_dz * seg_dz;

            let block_hit = Self::projectile_first_block_hit_along_segment_with_block(
                &self.chunks,
                &self.block_properties,
                from,
                to,
            );

            let block_hit_t = block_hit.map(|(hit, _)| {
                if seg_len_sq <= 1.0e-18 {
                    0.0_f32
                } else {
                    let hx = hit.0 - from.0;
                    let hy = hit.1 - from.1;
                    let hz = hit.2 - from.2;
                    let t =
                        ((hx * seg_dx + hy * seg_dy + hz * seg_dz) / seg_len_sq).clamp(0.0, 1.0);
                    t as f32
                }
            });
            let max_t = block_hit_t.unwrap_or(1.0);
            let projectile_hit_radius = projectile.projectile_type.hitbox_radius() as f32;
            let segment_from = glam::Vec3::new(from.0 as f32, from.1 as f32, from.2 as f32);
            let segment_to = glam::Vec3::new(to.0 as f32, to.1 as f32, to.2 as f32);

            let mut best_mob_hit: Option<(usize, u64, f32)> = None;
            {
                for (mob_index, mob) in self.mobs.iter().enumerate() {
                    if mob.dimension != active_dimension || mob.dead {
                        continue;
                    }

                    let mob_radius = mob.mob_type.size();
                    let mob_height = mob_radius * 2.0;
                    let center = glam::Vec3::new(
                        mob.x as f32,
                        mob.y as f32 + mob_height * 0.5,
                        mob.z as f32,
                    );
                    let size = glam::Vec3::new(mob_radius * 2.0, mob_height, mob_radius * 2.0);
                    let mob_aabb =
                        AABB::from_center_size(center, size).expand(projectile_hit_radius);

                    let Some(t) = mob_aabb.segment_entry_fraction(segment_from, segment_to) else {
                        continue;
                    };

                    if t > max_t + 1.0e-4 {
                        continue;
                    }

                    match best_mob_hit {
                        None => best_mob_hit = Some((mob_index, mob.id, t)),
                        Some((_, best_id, best_t)) => {
                            if t < best_t - 1.0e-4
                                || ((t - best_t).abs() <= 1.0e-4
                                    && mob.id != 0
                                    && (best_id == 0 || mob.id < best_id))
                            {
                                best_mob_hit = Some((mob_index, mob.id, t));
                            }
                        }
                    }
                }
            }

            let player_hit_t = match projectile.projectile_type {
                mdminecraft_world::ProjectileType::Arrow
                | mdminecraft_world::ProjectileType::DragonFireball
                | mdminecraft_world::ProjectileType::BlazeFireball
                | mdminecraft_world::ProjectileType::GhastFireball => {
                    let player_hit_aabb = player_aabb.expand(projectile_hit_radius);
                    player_hit_aabb
                        .segment_entry_fraction(segment_from, segment_to)
                        .filter(|t| *t <= max_t + 1.0e-4)
                }
                _ => None,
            };

            let mut entity_hit: Option<(EntityHit, f32)> =
                best_mob_hit.map(|hit| (EntityHit::Mob(hit.0), hit.2));
            if let Some(t) = player_hit_t {
                let replace = match entity_hit {
                    None => true,
                    Some((EntityHit::Mob(_), best_t)) => t < best_t - 1.0e-4,
                    Some((EntityHit::Player, best_t)) => t < best_t - 1.0e-4,
                };
                if replace {
                    entity_hit = Some((EntityHit::Player, t));
                }
            }

            if let Some((hit, t)) = entity_hit {
                projectile.x = from.0 + seg_dx * t as f64;
                projectile.y = from.1 + seg_dy * t as f64;
                projectile.z = from.2 + seg_dz * t as f64;

                match hit {
                    EntityHit::Mob(mob_index) => {
                        let mob = &mut self.mobs[mob_index];
                        if mob.dimension != active_dimension || mob.dead {
                            continue;
                        }

                        match projectile.projectile_type {
                            mdminecraft_world::ProjectileType::Arrow => {
                                // Arrow deals damage
                                let damage = projectile.damage();
                                mob.damage(damage);
                                projectile.hit();

                                // Apply knockback from arrow direction
                                let knock_dir_x = projectile.vel_x;
                                let knock_dir_z = projectile.vel_z;
                                let knock_len =
                                    (knock_dir_x * knock_dir_x + knock_dir_z * knock_dir_z).sqrt();
                                if knock_len > 0.001 {
                                    let knockback_strength =
                                        0.3 + 0.25 * (projectile.punch_level as f64);
                                    mob.apply_knockback(
                                        knock_dir_x / knock_len,
                                        knock_dir_z / knock_len,
                                        knockback_strength,
                                    );
                                }

                                if projectile.flame {
                                    mob.set_on_fire(100);
                                }

                                tracing::debug!(
                                    "Arrow hit {:?} for {:.1} damage",
                                    mob.mob_type,
                                    damage
                                );
                            }
                            mdminecraft_world::ProjectileType::SplashPotion(_)
                            | mdminecraft_world::ProjectileType::EnderPearl
                            | mdminecraft_world::ProjectileType::Egg => {
                                projectile.hit();
                                tracing::debug!(
                                    "{:?} hit {:?}",
                                    projectile.projectile_type,
                                    mob.mob_type
                                );
                            }
                            mdminecraft_world::ProjectileType::DragonFireball => {
                                if mob.mob_type != MobType::EnderDragon {
                                    let damage = projectile.damage();
                                    mob.damage(damage);
                                }
                                projectile.hit();
                            }
                            mdminecraft_world::ProjectileType::BlazeFireball => {
                                if mob.mob_type != MobType::Blaze {
                                    let damage = projectile.damage();
                                    mob.damage(damage);
                                    mob.set_on_fire(60);
                                }
                                projectile.hit();
                            }
                            mdminecraft_world::ProjectileType::GhastFireball => {
                                projectile.hit();
                            }
                        }
                    }
                    EntityHit::Player => {
                        if projectile.projectile_type
                            == mdminecraft_world::ProjectileType::GhastFireball
                        {
                            // Ghast fireball damage/knockback is handled via the explosion AoE pass
                            // so entities don't take a direct-hit double dip.
                            projectile.hit();
                            continue;
                        }

                        let (source, ignite_ticks, damage_kind) = match projectile.projectile_type {
                            mdminecraft_world::ProjectileType::Arrow => {
                                ("Arrow", None, DamageKind::Projectile)
                            }
                            mdminecraft_world::ProjectileType::DragonFireball => {
                                ("Ender Dragon", None, DamageKind::Generic)
                            }
                            mdminecraft_world::ProjectileType::BlazeFireball => {
                                ("Blaze", Some(100), DamageKind::Fire)
                            }
                            _ => continue,
                        };

                        let ignite_ticks = if projectile.projectile_type
                            == mdminecraft_world::ProjectileType::Arrow
                            && projectile.flame
                        {
                            Some(100)
                        } else {
                            ignite_ticks
                        };

                        let damage = projectile.damage();
                        match damage_kind {
                            DamageKind::Generic => projectile_damage_generic_to_player += damage,
                            DamageKind::Fire => projectile_damage_fire_to_player += damage,
                            DamageKind::Blast => projectile_damage_generic_to_player += damage,
                            DamageKind::Projectile => {
                                projectile_damage_projectile_to_player += damage
                            }
                            DamageKind::Fall => projectile_damage_generic_to_player += damage,
                        }
                        projectile.hit();
                        projectile_damage_source.get_or_insert(source);

                        let knockback_strength = match projectile.projectile_type {
                            mdminecraft_world::ProjectileType::Arrow => {
                                0.3 + 0.25 * (projectile.punch_level as f32)
                            }
                            mdminecraft_world::ProjectileType::DragonFireball => 0.4,
                            mdminecraft_world::ProjectileType::BlazeFireball => 0.35,
                            _ => 0.0,
                        };
                        if knockback_strength > 0.0 {
                            let mut dir =
                                glam::Vec2::new(projectile.vel_x as f32, projectile.vel_z as f32);
                            if dir.length_squared() < 1.0e-8 {
                                dir = glam::Vec2::new(seg_dx as f32, seg_dz as f32);
                            }
                            if dir.length_squared() > 1.0e-8 {
                                let dir = dir.normalize();
                                player_knockback +=
                                    glam::Vec3::new(dir.x, 0.0, dir.y) * knockback_strength;
                            }
                        }

                        if let Some(ticks) = ignite_ticks {
                            if !has_fire_resistance {
                                self.player_health.ignite(ticks);
                            }
                        }
                    }
                }

                continue;
            }

            let Some(((hit_x, hit_y, hit_z), hit_block_pos)) = block_hit else {
                continue;
            };

            projectile.x = hit_x;
            projectile.y = hit_y;
            projectile.z = hit_z;

            // Hit a block
            match projectile.projectile_type {
                mdminecraft_world::ProjectileType::Arrow => {
                    if Self::try_activate_button_from_projectile_hit(
                        projectile.projectile_type,
                        hit_block_pos,
                        &mut self.chunks,
                        &mut self.redstone_sim,
                    ) {
                        let chunk_pos = ChunkPos::new(
                            hit_block_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                            hit_block_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                        );
                        button_mesh_refresh.insert(chunk_pos);
                    }

                    projectile.stick();
                    projectile.dead = true;
                    if projectile.can_pick_up {
                        arrow_pickups.push((projectile.x, projectile.y, projectile.z));
                    }
                }
                mdminecraft_world::ProjectileType::SplashPotion(_)
                | mdminecraft_world::ProjectileType::EnderPearl
                | mdminecraft_world::ProjectileType::DragonFireball
                | mdminecraft_world::ProjectileType::BlazeFireball
                | mdminecraft_world::ProjectileType::GhastFireball
                | mdminecraft_world::ProjectileType::Egg => projectile.hit(),
            }
        }

        for (x, y, z) in arrow_pickups {
            self.item_manager
                .spawn_item(active_dimension, x, y, z, DroppedItemType::Arrow, 1);
        }

        for chunk_pos in button_mesh_refresh {
            self.debug_hud.chunk_uploads_last_frame +=
                self.upload_chunk_mesh_and_neighbors(chunk_pos);
        }

        let raw_projectile_damage = projectile_damage_generic_to_player
            + projectile_damage_fire_to_player
            + projectile_damage_projectile_to_player;
        if raw_projectile_damage > 0.0
            && self.player_state == PlayerState::Alive
            && !self.player_health.is_dead()
        {
            let mut actual_damage = 0.0f32;
            if projectile_damage_generic_to_player > 0.0 {
                actual_damage += self
                    .player_armor
                    .take_damage(projectile_damage_generic_to_player, DamageKind::Generic);
            }
            if projectile_damage_fire_to_player > 0.0 {
                actual_damage += self
                    .player_armor
                    .take_damage(projectile_damage_fire_to_player, DamageKind::Fire);
            }
            if projectile_damage_projectile_to_player > 0.0 {
                actual_damage += self.player_armor.take_damage(
                    projectile_damage_projectile_to_player,
                    DamageKind::Projectile,
                );
            }
            self.player_health.damage(actual_damage);
            if self.player_health.is_dead() {
                let source = projectile_damage_source.unwrap_or("a projectile");
                self.handle_death(&format!("Slain by {}", source));
            }
        }

        self.apply_player_knockback_displacement(player_knockback, 1.0);

        // Handle ender pearl teleport for projectiles that just broke.
        let mut ender_pearl_impact: Option<(f64, f64, f64)> = None;
        for projectile in &self.projectiles.projectiles {
            if projectile.dimension != active_dimension {
                continue;
            }
            if projectile.dead
                && projectile.hit_entity
                && projectile.projectile_type == mdminecraft_world::ProjectileType::EnderPearl
                && projectile.owner == mdminecraft_world::ProjectileOwner::Player
            {
                ender_pearl_impact = Some((projectile.x, projectile.y, projectile.z));
            }
        }

        if let Some((x, _y, z)) = ender_pearl_impact {
            if self.player_state == PlayerState::Alive && !self.player_health.is_dead() {
                if let Some(feet) = self.find_safe_spawn_near(x as f32, z as f32) {
                    let eye_height = self.player_physics.eye_height;
                    let camera = self.renderer.camera_mut();
                    camera.position = feet + glam::Vec3::new(0.0, eye_height, 0.0);
                    self.player_physics.velocity = glam::Vec3::ZERO;
                    self.player_physics.on_ground = false;
                    self.player_physics.last_ground_y = feet.y;

                    // Vanilla-ish: ender pearls deal 5 damage (2.5 hearts).
                    let actual_damage = self.player_armor.take_damage(5.0, DamageKind::Fall);
                    self.player_health.damage(actual_damage);
                    if self.player_health.is_dead() {
                        self.handle_death("Killed by Ender Pearl");
                    }
                }
            }
        }

        // Handle egg hatching for projectiles that just broke.
        let mut egg_impacts: Vec<(f64, f64, f64, u8)> = Vec::new();
        for projectile in &self.projectiles.projectiles {
            if projectile.dimension != active_dimension {
                continue;
            }
            if projectile.dead
                && projectile.hit_entity
                && projectile.projectile_type == mdminecraft_world::ProjectileType::Egg
                && projectile.egg_hatch_count > 0
            {
                egg_impacts.push((
                    projectile.x,
                    projectile.y,
                    projectile.z,
                    projectile.egg_hatch_count,
                ));
            }
        }

        for (x, y, z, count) in egg_impacts {
            // Vanilla-ish: thrown eggs have a small chance to hatch 1 or 4 chickens.
            let offsets = [(0.0_f64, 0.0_f64), (0.2, 0.0), (-0.2, 0.0), (0.0, 0.2)];
            for i in 0..count.min(4) {
                let (dx, dz) = offsets[i as usize];
                let mut mob = Mob::new(x + dx, y + 0.1, z + dz, MobType::Chicken);
                mob.dimension = active_dimension;
                self.assign_mob_id(&mut mob);
                self.mobs.push(mob);
            }
        }

        // Handle splash potion AoE effects for projectiles that just broke
        // Collect splash potion impact data before applying (to avoid borrow conflicts)
        let mut splash_impacts: Vec<(f64, f64, f64, u16)> = Vec::new();
        for projectile in &self.projectiles.projectiles {
            if projectile.dimension != active_dimension {
                continue;
            }
            if projectile.dead && projectile.hit_entity {
                if let Some(potion_id) = projectile.projectile_type.potion_id() {
                    splash_impacts.push((projectile.x, projectile.y, projectile.z, potion_id));
                }
            }
        }

        // Apply splash potion AoE effects
        for (splash_x, splash_y, splash_z, potion_id) in splash_impacts {
            let effect_radius = 4.0; // 4 block radius for splash effect

            // Apply effect to player if in range
            let player_pos = self.renderer.camera().position;
            let player_dist = ((player_pos.x as f64 - splash_x).powi(2)
                + (player_pos.y as f64 - splash_y).powi(2)
                + (player_pos.z as f64 - splash_z).powi(2))
            .sqrt();

            if player_dist < effect_radius {
                // Apply potion effect to player (reduced by distance)
                let effectiveness = 1.0 - (player_dist / effect_radius);
                self.apply_splash_potion_to_player(potion_id, effectiveness);
            }

            // Apply effect to mobs in range
            for mob in &mut self.mobs {
                if mob.dimension != active_dimension || mob.dead {
                    continue;
                }

                let mob_dist = ((mob.x - splash_x).powi(2)
                    + (mob.y - splash_y).powi(2)
                    + (mob.z - splash_z).powi(2))
                .sqrt();

                if mob_dist < effect_radius {
                    let effectiveness = 1.0 - (mob_dist / effect_radius);
                    // Apply splash potion effect to mob (inlined to avoid borrow issues)
                    match potion_id {
                        id if id == potion_ids::HEALING => {
                            // Healing heals living mobs - add health directly
                            let heal_amount = (4.0 * effectiveness) as f32;
                            mob.health = (mob.health + heal_amount).min(mob.mob_type.max_health());
                            tracing::debug!(
                                "Splash healing on {:?}: +{:.1} HP",
                                mob.mob_type,
                                heal_amount
                            );
                        }
                        id if id == potion_ids::HARMING => {
                            // Harming damages living mobs
                            let damage = (6.0 * effectiveness) as f32;
                            mob.damage(damage);
                            tracing::debug!(
                                "Splash harming on {:?}: -{:.1} HP",
                                mob.mob_type,
                                damage
                            );
                        }
                        id if id == potion_ids::POISON => {
                            // Poison does damage over time - simplified to instant damage
                            let damage = (2.0 * effectiveness) as f32;
                            mob.damage(damage);
                            tracing::debug!(
                                "Splash poison on {:?}: -{:.1} HP",
                                mob.mob_type,
                                damage
                            );
                        }
                        _ => {
                            // Other effects don't affect mobs in this implementation
                        }
                    }
                }
            }

            tracing::info!(
                "Splash potion (ID: {}) exploded at ({:.1}, {:.1}, {:.1})",
                potion_id,
                splash_x,
                splash_y,
                splash_z
            );
        }

        // Ghast fireballs explode (AoE damage + knockback + blocks).
        let ghast_fireball_block_radius = 2.0_f32;
        let ghast_fireball_effect_radius =
            mdminecraft_world::ProjectileType::GhastFireball.effect_radius() as f32;
        let ghast_fireball_impacts: Vec<(glam::Vec3, glam::Vec3, f32)> = self
            .projectiles
            .projectiles
            .iter()
            .filter_map(|projectile| {
                if projectile.dimension != active_dimension {
                    return None;
                }
                if !projectile.dead || !projectile.hit_entity {
                    return None;
                }
                if projectile.projectile_type != mdminecraft_world::ProjectileType::GhastFireball {
                    return None;
                }
                Some((
                    glam::Vec3::new(
                        projectile.x as f32,
                        projectile.y as f32,
                        projectile.z as f32,
                    ),
                    glam::Vec3::new(
                        projectile.vel_x as f32,
                        projectile.vel_y as f32,
                        projectile.vel_z as f32,
                    ),
                    projectile.damage(),
                ))
            })
            .collect();
        for (impact_pos, impact_vel, base_damage) in ghast_fireball_impacts {
            let explosion_center = Self::nudge_explosion_origin_out_of_collision(
                &self.chunks,
                &self.block_properties,
                impact_pos,
                impact_vel,
            );

            self.destroy_blocks_in_radius(
                explosion_center.x as f64,
                explosion_center.y as f64,
                explosion_center.z as f64,
                ghast_fireball_block_radius,
            );

            let player_pos = self.renderer.camera().position;
            let player_aabb = self.player_physics.get_aabb(player_pos);
            let player_center = (player_aabb.min + player_aabb.max) * 0.5;
            let dist = (player_center - explosion_center).length();
            if dist < ghast_fireball_effect_radius {
                let falloff = (1.0 - dist / ghast_fireball_effect_radius.max(0.1)).clamp(0.0, 1.0);
                let exposure = Self::explosion_exposure(
                    &self.chunks,
                    &self.block_properties,
                    explosion_center,
                    &player_aabb,
                );
                let effect = falloff * exposure;

                let damage = base_damage * effect;
                if damage > 0.0
                    && self.player_state == PlayerState::Alive
                    && !self.player_health.is_dead()
                {
                    let actual_damage = self.player_armor.take_damage(damage, DamageKind::Blast);
                    self.player_health.damage(actual_damage);
                    if self.player_health.is_dead() {
                        self.handle_death("Blown up by Ghast");
                    } else if !self.status_effects.has(StatusEffectType::FireResistance) {
                        self.player_health.ignite(160);
                    }
                }

                if effect > 0.0 {
                    let dx = player_center.x - explosion_center.x;
                    let dz = player_center.z - explosion_center.z;
                    let dist_sq = dx * dx + dz * dz;
                    if dist_sq > 1.0e-6 {
                        let dist = dist_sq.sqrt();
                        let strength = 1.1 * effect;
                        self.apply_player_knockback_displacement(
                            glam::Vec3::new(dx / dist, 0.0, dz / dist) * strength,
                            1.4,
                        );
                    }
                }
            }

            let chunks = &self.chunks;
            let block_properties = &self.block_properties;
            for mob in &mut self.mobs {
                if mob.dimension != active_dimension || mob.dead || mob.mob_type == MobType::Ghast {
                    continue;
                }

                let mob_radius = mob.mob_type.size();
                let mob_height = mob_radius * 2.0;
                let mob_center = glam::Vec3::new(
                    mob.x as f32,
                    (mob.y + mob_height as f64 * 0.5) as f32,
                    mob.z as f32,
                );
                let dist = (mob_center - explosion_center).length();
                if dist >= ghast_fireball_effect_radius {
                    continue;
                }

                let mob_aabb = AABB::from_center_size(
                    mob_center,
                    glam::Vec3::new(mob_radius * 2.0, mob_height, mob_radius * 2.0),
                );
                let falloff = (1.0 - dist / ghast_fireball_effect_radius.max(0.1)).clamp(0.0, 1.0);
                let exposure =
                    Self::explosion_exposure(chunks, block_properties, explosion_center, &mob_aabb);
                let effect = falloff * exposure;
                let damage = base_damage * effect;
                if damage <= 0.0 {
                    continue;
                }

                mob.damage(damage);
                mob.set_on_fire(100);

                let dx = mob_center.x - explosion_center.x;
                let dz = mob_center.z - explosion_center.z;
                let dist_sq = dx * dx + dz * dz;
                if dist_sq > 1.0e-6 {
                    let dist = dist_sq.sqrt();
                    let strength = 0.9 * effect;
                    mob.apply_knockback(
                        dx as f64 / dist as f64,
                        dz as f64 / dist as f64,
                        strength as f64,
                    );
                }
            }
        }

        // Check for player picking up stuck arrows
        let pickup_radius = 1.5_f64;
        let mut arrows_to_pickup = 0u32;

        self.projectiles.projectiles.retain(|projectile| {
            if projectile.dimension != active_dimension {
                return true;
            }

            if projectile.stuck && !projectile.dead {
                // Check distance to player
                let dx = projectile.x - player_pos.x as f64;
                let dy = projectile.y - player_pos.y as f64;
                let dz = projectile.z - player_pos.z as f64;
                let dist = (dx * dx + dy * dy + dz * dz).sqrt();

                if dist < pickup_radius {
                    arrows_to_pickup += 1;
                    return false; // Remove from projectiles
                }
            }
            true
        });

        // Add picked up arrows to hotbar
        if arrows_to_pickup > 0 {
            let arrow_type = ItemType::Item(2); // Arrow
            let mut added = false;

            // Try to add to existing stack
            for existing in self.hotbar.slots.iter_mut().flatten() {
                if existing.item_type == arrow_type && existing.can_add(arrows_to_pickup) {
                    existing.count += arrows_to_pickup;
                    added = true;
                    break;
                }
            }

            // Try empty slot
            if !added {
                for slot in &mut self.hotbar.slots {
                    if slot.is_none() {
                        *slot = Some(ItemStack::new(arrow_type, arrows_to_pickup));
                        added = true;
                        break;
                    }
                }
            }

            if added {
                tracing::debug!("Picked up {} arrow(s)", arrows_to_pickup);
            }
        }
    }

    /// Destroy blocks in a radius (for creeper explosions)
    fn destroy_blocks_in_radius(&mut self, cx: f64, cy: f64, cz: f64, radius: f32) {
        let radius_i = radius.ceil() as i32;
        let mut affected_chunks = std::collections::BTreeSet::new();
        let mut removed_blocks: Vec<(IVec3, BlockId, bool)> = Vec::new();

        // Iterate over all blocks in the explosion radius
        for dx in -radius_i..=radius_i {
            for dy in -radius_i..=radius_i {
                for dz in -radius_i..=radius_i {
                    // Check if block is within spherical radius
                    let dist = ((dx * dx + dy * dy + dz * dz) as f32).sqrt();
                    if dist > radius {
                        continue;
                    }

                    let block_x = cx.floor() as i32 + dx;
                    let block_y = cy.floor() as i32 + dy;
                    let block_z = cz.floor() as i32 + dz;

                    // Skip if out of world bounds
                    if !((WORLD_MIN_Y + 1)..=(WORLD_MAX_Y - 1)).contains(&block_y) {
                        continue;
                    }

                    let chunk_x = block_x.div_euclid(CHUNK_SIZE_X as i32);
                    let chunk_z = block_z.div_euclid(CHUNK_SIZE_Z as i32);
                    let local_x = block_x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                    let Some(local_y) = world_y_to_local_y(block_y) else {
                        continue;
                    };
                    let local_z = block_z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

                    let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
                    if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                        let voxel = chunk.voxel(local_x, local_y, local_z);
                        // Don't destroy bedrock (block 10) or air
                        if voxel.id != BLOCK_AIR && voxel.id != mdminecraft_world::BLOCK_BEDROCK {
                            let removed_id = voxel.id;
                            let left_water = self.active_dimension != DimensionId::Nether
                                && mdminecraft_world::block_supports_waterlogging(voxel.id)
                                && mdminecraft_world::is_waterlogged(voxel.state);

                            if left_water {
                                chunk.set_voxel(
                                    local_x,
                                    local_y,
                                    local_z,
                                    Voxel {
                                        id: FluidType::Water.source_block_id(),
                                        state: 0,
                                        light_sky: 0,
                                        light_block: 0,
                                    },
                                );
                            } else {
                                chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
                            }

                            affected_chunks.insert(chunk_pos);
                            removed_blocks.push((
                                IVec3::new(block_x, block_y, block_z),
                                removed_id,
                                left_water,
                            ));
                        }
                    }
                }
            }
        }

        for (pos, removed_id, left_water) in &removed_blocks {
            self.on_block_entity_removed(*pos, *removed_id);
            if *left_water {
                self.fluid_sim
                    .on_fluid_placed(FluidPos::new(pos.x, pos.y, pos.z), FluidType::Water);
            } else {
                self.fluid_sim
                    .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
            }
            self.schedule_redstone_updates_around(*pos);
        }

        let support_changes = Self::remove_unsupported_blocks(
            &mut self.chunks,
            &self.block_properties,
            removed_blocks.iter().map(|(pos, _, _)| *pos),
        );
        for (pos, removed_block_id) in support_changes.removed {
            self.on_block_entity_removed(pos, removed_block_id);
            affected_chunks.insert(ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            ));
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
            self.schedule_redstone_updates_around(pos);
        }
        for pos in support_changes.moved {
            affected_chunks.insert(ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            ));
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(pos.x, pos.y, pos.z), &self.chunks);
            self.schedule_redstone_updates_around(pos);
        }

        // Update lighting and meshes for affected chunks
        let mut mesh_refresh = std::collections::BTreeSet::new();
        for chunk_pos in affected_chunks {
            mesh_refresh.extend(self.recompute_skylight_local(chunk_pos));
            mesh_refresh.insert(chunk_pos);
            for neighbor in Self::neighbor_chunk_positions(chunk_pos) {
                mesh_refresh.insert(neighbor);
            }

            let affected = mdminecraft_world::recompute_block_light_local(
                &mut self.chunks,
                &self.registry,
                chunk_pos,
            );
            mesh_refresh.extend(affected);
        }
        for chunk_pos in mesh_refresh {
            let _ = self.upload_chunk_mesh(chunk_pos);
        }
    }

    /// Try to attack a mob that the player is looking at.
    /// Returns true if a mob was attacked.
    fn try_attack_mob(&mut self) -> bool {
        let active_dimension = self.active_dimension;

        // Get camera position and direction
        let camera = self.renderer.camera();
        let origin = camera.position;
        let dir = camera.forward();

        // Attack reach (slightly more than block reach for mobs)
        const ATTACK_REACH: f32 = 4.0;

        // Prevent attacking mobs through blocks: find the first solid collision along the attack ray.
        let attack_end = origin + dir * ATTACK_REACH;
        let blocking_distance = Self::projectile_first_block_hit_along_segment(
            &self.chunks,
            &self.block_properties,
            (origin.x as f64, origin.y as f64, origin.z as f64),
            (
                attack_end.x as f64,
                attack_end.y as f64,
                attack_end.z as f64,
            ),
        )
        .map(|hit| {
            let dx = hit.0 as f32 - origin.x;
            let dy = hit.1 as f32 - origin.y;
            let dz = hit.2 as f32 - origin.z;
            (dx * dx + dy * dy + dz * dz).sqrt()
        })
        .unwrap_or(f32::INFINITY);

        // Check each mob to see if the ray hits it
        let mut closest_hit: Option<(usize, f32)> = None;

        for (idx, mob) in self.mobs.iter().enumerate() {
            if mob.dimension != active_dimension || mob.dead {
                continue;
            }
            // Simple AABB collision for mob
            let mob_size = mob.mob_type.size();
            let mob_height = mob_size * 2.0; // Approximate height

            let mob_min = glam::Vec3::new(
                mob.x as f32 - mob_size,
                mob.y as f32,
                mob.z as f32 - mob_size,
            );
            let mob_max = glam::Vec3::new(
                mob.x as f32 + mob_size,
                mob.y as f32 + mob_height,
                mob.z as f32 + mob_size,
            );

            // Simple ray-AABB intersection
            if let Some(t) = ray_aabb_intersect(origin, dir, mob_min, mob_max) {
                if t > 0.0
                    && t < ATTACK_REACH
                    && t < blocking_distance - 1.0e-4
                    && (closest_hit.is_none() || t < closest_hit.unwrap().1)
                {
                    closest_hit = Some((idx, t));
                }
            }
        }

        // Attack the closest mob
        if let Some((idx, _distance)) = closest_hit {
            let tool = self.hotbar.selected_tool();
            let mut damage = calculate_attack_damage(tool);

            // Get enchantment levels from selected item
            let (sharpness_level, knockback_level, fire_aspect_level) =
                if let Some(item) = self.hotbar.selected_item() {
                    (
                        item.enchantment_level(EnchantmentType::Sharpness),
                        item.enchantment_level(EnchantmentType::Knockback),
                        item.enchantment_level(EnchantmentType::FireAspect),
                    )
                } else {
                    (0, 0, 0)
                };

            // Apply Sharpness enchantment bonus
            // Sharpness I: +1 damage, each additional level: +0.5 damage
            // (Minecraft Java: 0.5 + 0.5 * level extra damage)
            if sharpness_level > 0 {
                let bonus = 0.5 + 0.5 * sharpness_level as f32;
                damage += bonus;
                tracing::debug!("Sharpness {} adds {:.1} damage", sharpness_level, bonus);
            }

            damage += self.status_effects.attack_damage_modifier();
            damage = damage.max(0.0);

            // Critical hit detection: 1.5x damage if player is falling
            // Check if player has significant downward velocity
            let is_critical = self.player_physics.velocity.y < -0.1;
            if is_critical {
                damage *= 1.5;
            }

            // Calculate knockback direction
            let mob = &self.mobs[idx];
            let dx = mob.x - origin.x as f64;
            let dz = mob.z - origin.z as f64;

            // Calculate knockback strength with Knockback enchantment bonus
            // Base knockback: 0.5, each level adds 0.4
            let knockback_strength = 0.5 + 0.4 * knockback_level as f64;

            // Apply damage and knockback
            let mob = &mut self.mobs[idx];
            let _died = mob.damage(damage);
            mob.apply_knockback(dx, dz, knockback_strength);

            // Apply Fire Aspect: set target on fire
            // Fire Aspect I: 4 seconds (80 ticks), Fire Aspect II: 8 seconds (160 ticks)
            if fire_aspect_level > 0 {
                let fire_ticks = 80 * fire_aspect_level as u32;
                mob.set_on_fire(fire_ticks);
                tracing::debug!(
                    "Fire Aspect {} sets mob on fire for {} ticks",
                    fire_aspect_level,
                    fire_ticks
                );
            }

            if is_critical {
                tracing::info!(
                    "CRITICAL HIT! Attacked {:?} for {:.1} damage (health: {:.1})",
                    mob.mob_type,
                    damage,
                    mob.health
                );
            } else {
                tracing::info!(
                    "Attacked {:?} for {:.1} damage (health: {:.1})",
                    mob.mob_type,
                    damage,
                    mob.health
                );
            }

            // Sword sweep attack: if using a sword, nearby mobs take 1 + enchantment bonus damage
            // Sweep attacks hit mobs within 1 block of the primary target horizontally
            let is_sword = matches!(tool, Some((ToolType::Sword, _)));
            if is_sword {
                let target_x = mob.x;
                let target_z = mob.z;
                let sweep_damage = 1.0
                    + if sharpness_level > 0 {
                        0.5 + 0.5 * sharpness_level as f32
                    } else {
                        0.0
                    };
                let sweep_range = 1.0; // 1 block radius for sweep

                // Collect indices of mobs to sweep (excluding the primary target)
                let sweep_targets: Vec<usize> = self
                    .mobs
                    .iter()
                    .enumerate()
                    .filter_map(|(i, m)| {
                        if i == idx {
                            return None; // Skip primary target
                        }
                        if m.dimension != active_dimension || m.dead {
                            return None;
                        }
                        let dx = m.x - target_x;
                        let dz = m.z - target_z;
                        let dist_sq = dx * dx + dz * dz;
                        if dist_sq <= sweep_range * sweep_range {
                            Some(i)
                        } else {
                            None
                        }
                    })
                    .collect();

                // Apply sweep damage to nearby mobs
                let sweep_count = sweep_targets.len();
                for sweep_idx in sweep_targets {
                    let sweep_mob = &mut self.mobs[sweep_idx];
                    sweep_mob.damage(sweep_damage);
                    // Small knockback for sweep targets
                    let sdx = sweep_mob.x - origin.x as f64;
                    let sdz = sweep_mob.z - origin.z as f64;
                    sweep_mob.apply_knockback(sdx, sdz, 0.3);

                    // Fire Aspect also applies to sweep targets
                    if fire_aspect_level > 0 {
                        let fire_ticks = 80 * fire_aspect_level as u32;
                        sweep_mob.set_on_fire(fire_ticks);
                    }
                }

                if sweep_count > 0 {
                    tracing::info!(
                        "SWEEP ATTACK! Hit {} additional mobs for {:.1} damage each",
                        sweep_count,
                        sweep_damage
                    );
                }
            }

            // Use tool durability if we have a tool
            // (damage_durability handles Unbreaking enchantment internally)
            if let Some(item) = self.hotbar.selected_item_mut() {
                if matches!(item.item_type, ItemType::Tool(_, _)) {
                    item.damage_durability(1);
                    if item.is_broken() {
                        // Tool broke
                        self.hotbar.slots[self.hotbar.selected] = None;
                        tracing::info!("Tool broke!");
                    }
                }
            }

            return true;
        }

        false
    }

    fn try_open_villager_trade(&mut self) -> bool {
        if self.player_state != PlayerState::Alive {
            return false;
        }
        if self.villager_trade_open {
            return false;
        }

        let active_dimension = self.active_dimension;

        let camera = self.renderer.camera();
        let origin = camera.position;
        let dir = camera.forward();

        const INTERACT_REACH: f32 = 4.0;
        let blocking_distance = self
            .selected_block
            .map(|hit| hit.distance)
            .unwrap_or(f32::INFINITY);

        let mut closest: Option<(u64, f32)> = None;
        for mob in &self.mobs {
            if mob.dimension != active_dimension || mob.dead {
                continue;
            }
            if mob.mob_type != MobType::Villager {
                continue;
            }
            if mob.id == 0 {
                continue;
            }

            let mob_size = mob.mob_type.size();
            let mob_height = mob_size * 2.0;
            let mob_min = glam::Vec3::new(
                mob.x as f32 - mob_size,
                mob.y as f32,
                mob.z as f32 - mob_size,
            );
            let mob_max = glam::Vec3::new(
                mob.x as f32 + mob_size,
                mob.y as f32 + mob_height,
                mob.z as f32 + mob_size,
            );

            let Some(t) = ray_aabb_intersect(origin, dir, mob_min, mob_max) else {
                continue;
            };
            if !(0.0..INTERACT_REACH).contains(&t) {
                continue;
            }
            if t >= blocking_distance {
                continue;
            }

            if closest.is_none_or(|(_, prev_t)| t < prev_t) {
                closest = Some((mob.id, t));
            }
        }

        let Some((villager_id, _distance)) = closest else {
            return false;
        };

        self.open_villager_trade(villager_id);
        true
    }

    fn try_add_stack_to_storage(&mut self, stack: ItemStack) -> Option<ItemStack> {
        let remainder = self.hotbar.add_stack(stack)?;
        self.main_inventory.add_stack(remainder)
    }

    fn return_stack_to_storage_or_spill(&mut self, stack: ItemStack) {
        if let Some(remainder) = self.try_add_stack_to_storage(stack) {
            self.spill_stack_to_world(remainder);
        }
    }

    fn spill_stack_to_world(&mut self, stack: ItemStack) {
        let Some(dropped_type) = Self::convert_core_item_type_to_dropped(stack.item_type) else {
            tracing::warn!(
                item = ?stack.item_type,
                count = stack.count,
                "No dropped-item mapping; keeping in UI cursor"
            );
            let _ = try_add_stack_to_cursor(&mut self.ui_cursor_stack, stack);
            return;
        };

        let camera_pos = self.renderer.camera().position;
        let x = camera_pos.x as f64;
        let y = (camera_pos.y - self.player_physics.eye_height) as f64 + 0.5;
        let z = camera_pos.z as f64;

        self.item_manager.spawn_item_with_metadata(
            self.active_dimension,
            (x, y, z),
            dropped_type,
            stack.count,
            stack.durability,
            stack.enchantments.clone(),
        );
    }

    fn drop_selected_hotbar_item(&mut self, drop_stack: bool) {
        if self.player_state != PlayerState::Alive {
            return;
        }

        let Some(item) = self.hotbar.selected_item().cloned() else {
            return;
        };

        let Some(dropped_type) = Self::convert_core_item_type_to_dropped(item.item_type) else {
            tracing::warn!(
                item = ?item.item_type,
                "No dropped-item mapping; cannot drop from hotbar"
            );
            return;
        };

        let count_to_drop = if drop_stack || item.max_stack_size() == 1 {
            item.count
        } else {
            1.min(item.count)
        };
        if count_to_drop == 0 {
            return;
        }

        // Remove from hotbar.
        if drop_stack || item.count <= 1 || item.max_stack_size() == 1 {
            self.hotbar.slots[self.hotbar.selected] = None;
        } else if let Some(slot) = self.hotbar.selected_item_mut() {
            slot.count = slot.count.saturating_sub(count_to_drop);
            if slot.count == 0 {
                self.hotbar.slots[self.hotbar.selected] = None;
            }
        }

        let camera = self.renderer.camera();
        let (forward, _) = Self::flat_directions(camera);

        let base_x = camera.position.x as f64;
        let base_y = (camera.position.y - self.player_physics.eye_height) as f64 + 0.5;
        let base_z = camera.position.z as f64;

        // Spawn just outside pickup radius, in front of the player (vanilla-ish).
        let mut x = base_x + forward.x as f64 * 2.0;
        let y = base_y;
        let mut z = base_z + forward.z as f64 * 2.0;
        if forward.length_squared() <= f32::EPSILON {
            x = base_x + 2.0;
            z = base_z;
        }

        // Split into multiple dropped stacks if needed.
        let max = dropped_type.max_stack_size().max(1);
        let mut remaining = count_to_drop;
        while remaining > 0 {
            let batch = remaining.min(max);
            remaining -= batch;
            self.item_manager.spawn_item_with_metadata(
                self.active_dimension,
                (x, y, z),
                dropped_type,
                batch,
                item.durability,
                item.enchantments.clone(),
            );
        }
    }

    /// Toggle inventory UI open/closed
    fn toggle_inventory(&mut self) {
        self.inventory_open = !self.inventory_open;
        self.crafting_open = false; // Close crafting when toggling inventory
        self.ui_drag_state.reset();
        if self.inventory_open {
            // Release cursor when inventory is open
            self.enter_ui_overlay();
            self.audio.play_sfx(SoundId::InventoryOpen);
            tracing::info!("Inventory opened");
        } else {
            if let Some(stack) = self.ui_cursor_stack.take() {
                self.return_stack_to_storage_or_spill(stack);
            }

            // Capture cursor when inventory is closed
            self.enter_gameplay();
            self.audio.play_sfx(SoundId::InventoryClose);
            tracing::info!("Inventory closed");
        }
    }

    fn open_command_prompt(&mut self, initial_text: &str) {
        if self.command_open || self.player_state != PlayerState::Alive {
            return;
        }
        if self.inventory_open
            || self.crafting_open
            || self.furnace_open
            || self.enchanting_open
            || self.brewing_open
            || self.chest_open
            || self.hopper_open
            || self.dispenser_open
            || self.dropper_open
            || self.pause_menu_open
        {
            return;
        }

        self.command_open = true;
        self.command_focus_next_frame = true;
        self.command_input.clear();
        self.command_input.push_str(initial_text);
        self.enter_ui_overlay();
        tracing::info!("Command prompt opened");
    }

    fn close_command_prompt(&mut self) {
        if !self.command_open {
            return;
        }
        self.command_open = false;
        self.command_focus_next_frame = false;
        self.command_input.clear();
        self.enter_gameplay();
        tracing::info!("Command prompt closed");
    }

    fn push_command_log_line(&mut self, line: impl Into<String>) {
        const MAX_LINES: usize = 64;
        self.command_log.push_back(line.into());
        while self.command_log.len() > MAX_LINES {
            self.command_log.pop_front();
        }
    }

    fn run_command_line(&mut self, line: String) {
        let line = line.trim().to_string();
        if line.is_empty() {
            return;
        }

        self.push_command_log_line(format!("> {line}"));
        match commands::parse_command(&line, &self.registry) {
            Ok(cmd) => {
                let out = commands::execute_command(self, cmd);
                for line in out.lines {
                    self.push_command_log_line(line);
                }
            }
            Err(err) => {
                self.push_command_log_line(format!("Error: {err}"));
            }
        }
    }

    /// Open crafting table UI
    fn open_crafting(&mut self) {
        self.crafting_open = true;
        self.inventory_open = false; // Close inventory when opening crafting
        self.ui_drag_state.reset();
        // Release cursor for UI interaction
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Crafting table opened");
    }

    /// Close crafting UI
    fn close_crafting(&mut self) {
        self.crafting_open = false;
        self.ui_drag_state.reset();
        let mut returned: Vec<ItemStack> = Vec::new();
        if let Some(stack) = self.ui_cursor_stack.take() {
            returned.push(stack);
        }

        // Return any items still in the crafting grid.
        for row in &mut self.crafting_grid {
            for slot in row.iter_mut() {
                if let Some(stack) = slot.take() {
                    returned.push(stack);
                }
            }
        }

        for stack in returned {
            self.return_stack_to_storage_or_spill(stack);
        }
        // Capture cursor for gameplay
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Crafting closed");
    }

    /// Open furnace UI at the given position
    fn open_furnace(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.furnace_open = true;
        self.open_furnace_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.ui_drag_state.reset();
        // Create furnace state if it doesn't exist
        self.furnaces.entry(key).or_default();
        // Release cursor for UI interaction
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Furnace opened at {:?}", block_pos);
    }

    /// Close furnace UI
    fn close_furnace(&mut self) {
        self.furnace_open = false;
        self.open_furnace_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        // Capture cursor for gameplay
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Furnace closed");
    }

    /// Open enchanting table UI at the given position
    fn open_enchanting_table(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.enchanting_open = true;
        self.open_enchanting_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.ui_drag_state.reset();
        // Count nearby bookshelves first (before borrowing enchanting_tables)
        let bookshelf_count = self.count_nearby_bookshelves(block_pos);
        // Create enchanting table state if it doesn't exist and update bookshelf count
        let table = self.enchanting_tables.entry(key).or_default();
        table.set_bookshelf_count(bookshelf_count);
        // Release cursor for UI interaction
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!(
            "Enchanting table opened at {:?} with {} bookshelves",
            block_pos,
            bookshelf_count
        );
    }

    /// Close enchanting table UI
    fn close_enchanting_table(&mut self) {
        self.enchanting_open = false;
        self.open_enchanting_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        // Capture cursor for gameplay
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Enchanting table closed");
    }

    /// Open brewing stand UI at the given position
    fn open_brewing_stand(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.brewing_open = true;
        self.open_brewing_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.ui_drag_state.reset();
        // Create brewing stand state if it doesn't exist
        self.brewing_stands.entry(key).or_default();
        // Release cursor for UI interaction
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Brewing stand opened at {:?}", block_pos);
    }

    /// Close brewing stand UI
    fn close_brewing_stand(&mut self) {
        self.brewing_open = false;
        self.open_brewing_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        // Capture cursor for gameplay
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Brewing stand closed");
    }

    /// Open chest UI at the given position
    fn open_chest(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.chest_open = true;
        self.open_chest_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.brewing_open = false;
        self.ui_drag_state.reset();
        // Create chest state if it doesn't exist
        self.chests.entry(key).or_default();
        // Release cursor for UI interaction
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Chest opened at {:?}", block_pos);
    }

    /// Close chest UI
    fn close_chest(&mut self) {
        self.chest_open = false;
        self.open_chest_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        // Capture cursor for gameplay
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Chest closed");
    }

    fn open_villager_trade(&mut self, villager_id: u64) {
        self.villager_trade_open = true;
        self.open_villager_trade_id = Some(villager_id);
        self.selected_villager_trade_idx = 0;
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.brewing_open = false;
        self.chest_open = false;
        self.hopper_open = false;
        self.dispenser_open = false;
        self.dropper_open = false;
        self.ui_drag_state.reset();
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!(villager_id, "Villager trade opened");
    }

    fn close_villager_trade(&mut self) {
        self.villager_trade_open = false;
        self.open_villager_trade_id = None;
        self.selected_villager_trade_idx = 0;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Villager trade closed");
    }

    /// Open hopper UI at the given position
    fn open_hopper(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.hopper_open = true;
        self.open_hopper_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.brewing_open = false;
        self.chest_open = false;
        self.dispenser_open = false;
        self.dropper_open = false;
        self.ui_drag_state.reset();
        self.hoppers.entry(key).or_default();
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Hopper opened at {:?}", block_pos);
    }

    /// Close hopper UI
    fn close_hopper(&mut self) {
        self.hopper_open = false;
        self.open_hopper_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Hopper closed");
    }

    /// Open dispenser UI at the given position
    fn open_dispenser(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.dispenser_open = true;
        self.open_dispenser_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.brewing_open = false;
        self.chest_open = false;
        self.hopper_open = false;
        self.dropper_open = false;
        self.ui_drag_state.reset();
        self.dispensers.entry(key).or_default();
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Dispenser opened at {:?}", block_pos);
    }

    /// Close dispenser UI
    fn close_dispenser(&mut self) {
        self.dispenser_open = false;
        self.open_dispenser_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Dispenser closed");
    }

    /// Open dropper UI at the given position
    fn open_dropper(&mut self, block_pos: IVec3) {
        let key = self.block_entity_key(block_pos);
        self.dropper_open = true;
        self.open_dropper_pos = Some(key);
        self.inventory_open = false;
        self.crafting_open = false;
        self.furnace_open = false;
        self.enchanting_open = false;
        self.brewing_open = false;
        self.chest_open = false;
        self.hopper_open = false;
        self.dispenser_open = false;
        self.ui_drag_state.reset();
        self.droppers.entry(key).or_default();
        self.enter_ui_overlay();
        self.audio.play_sfx(SoundId::InventoryOpen);
        tracing::info!("Dropper opened at {:?}", block_pos);
    }

    /// Close dropper UI
    fn close_dropper(&mut self) {
        self.dropper_open = false;
        self.open_dropper_pos = None;
        self.ui_drag_state.reset();
        if let Some(stack) = self.ui_cursor_stack.take() {
            self.return_stack_to_storage_or_spill(stack);
        }
        self.enter_gameplay();
        self.audio.play_sfx(SoundId::InventoryClose);
        tracing::info!("Dropper closed");
    }

    fn purge_block_entity_state(&mut self, block_pos: IVec3, removed_block_id: BlockId) {
        let key = self.block_entity_key(block_pos);
        match removed_block_id {
            interactive_blocks::CHEST => {
                if self.chest_open && self.open_chest_pos == Some(key) {
                    self.close_chest();
                }
                let _ = self.chests.remove(&key);
            }
            mdminecraft_world::mechanical_blocks::HOPPER => {
                if self.hopper_open && self.open_hopper_pos == Some(key) {
                    self.close_hopper();
                }
                let _ = self.hoppers.remove(&key);
            }
            mdminecraft_world::mechanical_blocks::DISPENSER => {
                if self.dispenser_open && self.open_dispenser_pos == Some(key) {
                    self.close_dispenser();
                }
                let _ = self.dispensers.remove(&key);
            }
            mdminecraft_world::mechanical_blocks::DROPPER => {
                if self.dropper_open && self.open_dropper_pos == Some(key) {
                    self.close_dropper();
                }
                let _ = self.droppers.remove(&key);
            }
            BLOCK_FURNACE | BLOCK_FURNACE_LIT => {
                if self.furnace_open && self.open_furnace_pos == Some(key) {
                    self.close_furnace();
                }
                let _ = self.furnaces.remove(&key);
            }
            BLOCK_BREWING_STAND => {
                if self.brewing_open && self.open_brewing_pos == Some(key) {
                    self.close_brewing_stand();
                }
                let _ = self.brewing_stands.remove(&key);
            }
            BLOCK_ENCHANTING_TABLE => {
                if self.enchanting_open && self.open_enchanting_pos == Some(key) {
                    self.close_enchanting_table();
                }
                let _ = self.enchanting_tables.remove(&key);
            }
            _ => {}
        }
    }

    fn on_block_entity_removed(&mut self, block_pos: IVec3, removed_block_id: BlockId) {
        let key = self.block_entity_key(block_pos);

        let drop_pos = (
            block_pos.x as f64 + 0.5,
            block_pos.y as f64 + 0.5,
            block_pos.z as f64 + 0.5,
        );

        match removed_block_id {
            interactive_blocks::CHEST => {
                if self.chest_open && self.open_chest_pos == Some(key) {
                    self.close_chest();
                }

                let Some(chest) = self.chests.remove(&key) else {
                    return;
                };

                for (slot_idx, stack) in chest.slots.into_iter().enumerate() {
                    let Some(stack) = stack else {
                        continue;
                    };

                    if Self::spill_core_stack_to_world(
                        &mut self.item_manager,
                        key.dimension,
                        drop_pos,
                        &stack,
                    )
                    .is_none()
                    {
                        tracing::warn!(
                            slot = slot_idx,
                            item = ?stack.item_type,
                            "Chest contained an undroppable item type"
                        );
                        continue;
                    };
                }
            }
            mdminecraft_world::mechanical_blocks::HOPPER => {
                if self.hopper_open && self.open_hopper_pos == Some(key) {
                    self.close_hopper();
                }

                let Some(hopper) = self.hoppers.remove(&key) else {
                    return;
                };

                for (slot_idx, stack) in hopper.slots.into_iter().enumerate() {
                    let Some(stack) = stack else {
                        continue;
                    };

                    if Self::spill_core_stack_to_world(
                        &mut self.item_manager,
                        key.dimension,
                        drop_pos,
                        &stack,
                    )
                    .is_none()
                    {
                        tracing::warn!(
                            slot = slot_idx,
                            item = ?stack.item_type,
                            "Hopper contained an undroppable item type"
                        );
                        continue;
                    };
                }
            }
            mdminecraft_world::mechanical_blocks::DISPENSER => {
                if self.dispenser_open && self.open_dispenser_pos == Some(key) {
                    self.close_dispenser();
                }

                let Some(dispenser) = self.dispensers.remove(&key) else {
                    return;
                };

                for (slot_idx, stack) in dispenser.slots.into_iter().enumerate() {
                    let Some(stack) = stack else {
                        continue;
                    };

                    if Self::spill_core_stack_to_world(
                        &mut self.item_manager,
                        key.dimension,
                        drop_pos,
                        &stack,
                    )
                    .is_none()
                    {
                        tracing::warn!(
                            slot = slot_idx,
                            item = ?stack.item_type,
                            "Dispenser contained an undroppable item type"
                        );
                        continue;
                    };
                }
            }
            mdminecraft_world::mechanical_blocks::DROPPER => {
                if self.dropper_open && self.open_dropper_pos == Some(key) {
                    self.close_dropper();
                }

                let Some(dropper) = self.droppers.remove(&key) else {
                    return;
                };

                for (slot_idx, stack) in dropper.slots.into_iter().enumerate() {
                    let Some(stack) = stack else {
                        continue;
                    };

                    if Self::spill_core_stack_to_world(
                        &mut self.item_manager,
                        key.dimension,
                        drop_pos,
                        &stack,
                    )
                    .is_none()
                    {
                        tracing::warn!(
                            slot = slot_idx,
                            item = ?stack.item_type,
                            "Dropper contained an undroppable item type"
                        );
                        continue;
                    };
                }
            }
            BLOCK_FURNACE | BLOCK_FURNACE_LIT => {
                if self.furnace_open && self.open_furnace_pos == Some(key) {
                    self.close_furnace();
                }

                let Some(furnace) = self.furnaces.remove(&key) else {
                    return;
                };

                for (drop_type, count) in [furnace.input, furnace.fuel, furnace.output]
                    .into_iter()
                    .flatten()
                {
                    self.item_manager.spawn_item(
                        key.dimension,
                        drop_pos.0,
                        drop_pos.1,
                        drop_pos.2,
                        drop_type,
                        count,
                    );
                }
            }
            BLOCK_BREWING_STAND => {
                if self.brewing_open && self.open_brewing_pos == Some(key) {
                    self.close_brewing_stand();
                }

                let Some(stand) = self.brewing_stands.remove(&key) else {
                    return;
                };

                let BrewingStandState {
                    bottles,
                    bottle_is_splash,
                    bottle_is_extended,
                    bottle_amplifier,
                    ingredient,
                    fuel,
                    ..
                } = stand;

                if fuel > 0 {
                    self.item_manager.spawn_item(
                        key.dimension,
                        drop_pos.0,
                        drop_pos.1,
                        drop_pos.2,
                        DroppedItemType::BlazePowder,
                        fuel,
                    );
                }

                if let Some((ingredient_id, count)) = ingredient {
                    if let Some(core_item) = brew_ingredient_id_to_core_item_type(ingredient_id) {
                        if let Some(drop_type) = Self::convert_core_item_type_to_dropped(core_item)
                        {
                            self.item_manager.spawn_item(
                                key.dimension,
                                drop_pos.0,
                                drop_pos.1,
                                drop_pos.2,
                                drop_type,
                                count,
                            );
                        }
                    }
                }

                for (idx, bottle) in bottles.into_iter().enumerate() {
                    let Some(bottle) = bottle else {
                        continue;
                    };
                    let core_stack = bottle_to_core_item_stack(
                        bottle,
                        bottle_is_splash[idx],
                        bottle_is_extended[idx],
                        bottle_amplifier[idx],
                    );
                    if let Some(drop_type) =
                        Self::convert_core_item_type_to_dropped(core_stack.item_type)
                    {
                        self.item_manager.spawn_item(
                            key.dimension,
                            drop_pos.0,
                            drop_pos.1,
                            drop_pos.2,
                            drop_type,
                            1,
                        );
                    }
                }
            }
            BLOCK_ENCHANTING_TABLE => {
                if self.enchanting_open && self.open_enchanting_pos == Some(key) {
                    self.close_enchanting_table();
                }

                let Some(table) = self.enchanting_tables.remove(&key) else {
                    return;
                };

                if table.lapis_count > 0 {
                    self.item_manager.spawn_item(
                        key.dimension,
                        drop_pos.0,
                        drop_pos.1,
                        drop_pos.2,
                        DroppedItemType::LapisLazuli,
                        table.lapis_count,
                    );
                }
            }
            _ => {}
        }
    }

    fn should_drop_support_removed_block(
        removed_support: &[(IVec3, BlockId)],
        removed_pos: IVec3,
        removed_block_id: BlockId,
    ) -> bool {
        if mdminecraft_world::is_door_upper(removed_block_id) {
            let lower_pos = IVec3::new(removed_pos.x, removed_pos.y - 1, removed_pos.z);
            !removed_support.iter().any(|(other_pos, other_id)| {
                *other_pos == lower_pos && mdminecraft_world::is_door_lower(*other_id)
            })
        } else {
            removed_block_id != interactive_blocks::BED_HEAD
        }
    }

    fn spawn_support_removed_block_drop(
        &mut self,
        removed_support: &[(IVec3, BlockId)],
        removed_pos: IVec3,
        removed_block_id: BlockId,
    ) {
        if !Self::should_drop_support_removed_block(removed_support, removed_pos, removed_block_id)
        {
            return;
        }

        let drop_x = removed_pos.x as f64 + 0.5;
        let drop_y = removed_pos.y as f64 + 0.5;
        let drop_z = removed_pos.z as f64 + 0.5;

        if let Some(table) = self.loot_tables.block.get(&removed_block_id) {
            let mut rng = {
                let pos_seed = (removed_pos.x as u64)
                    ^ ((removed_pos.y as u64).rotate_left(21))
                    ^ ((removed_pos.z as u64).rotate_left(42));
                let seed = self.world_seed
                    ^ self.sim_tick.0.wrapping_mul(0x9E37_79B9_7F4A_7C15)
                    ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
                    ^ 0x10B1_0B15_EA4E_102E_u64;
                StdRng::seed_from_u64(seed)
            };

            for (drop_type, count) in table.roll(&mut rng) {
                self.item_manager.spawn_item(
                    self.active_dimension,
                    drop_x,
                    drop_y,
                    drop_z,
                    drop_type,
                    count,
                );
            }
            return;
        }

        if let Some((drop_type, count)) = DroppedItemType::from_block(removed_block_id) {
            self.item_manager.spawn_item(
                self.active_dimension,
                drop_x,
                drop_y,
                drop_z,
                drop_type,
                count,
            );
        }
    }

    fn open_pause_menu(&mut self) {
        self.pause_menu_open = true;
        self.pause_menu_view = PauseMenuView::Main;
        self.ui_drag_state.reset();
        self.enter_menu();
        tracing::info!("Pause menu opened");
    }

    fn close_pause_menu(&mut self) {
        self.pause_menu_open = false;
        self.pause_menu_view = PauseMenuView::Main;
        self.ui_drag_state.reset();
        self.enter_gameplay();
        tracing::info!("Pause menu closed");
    }

    fn handle_escape_pressed(&mut self) {
        if self.player_state != PlayerState::Alive {
            return;
        }

        if self.command_open {
            self.close_command_prompt();
            return;
        }

        if self.villager_trade_open {
            self.close_villager_trade();
            return;
        }
        if self.hopper_open {
            self.close_hopper();
            return;
        }
        if self.dispenser_open {
            self.close_dispenser();
            return;
        }
        if self.dropper_open {
            self.close_dropper();
            return;
        }
        if self.chest_open {
            self.close_chest();
            return;
        }
        if self.brewing_open {
            self.close_brewing_stand();
            return;
        }
        if self.enchanting_open {
            self.close_enchanting_table();
            return;
        }
        if self.furnace_open {
            self.close_furnace();
            return;
        }
        if self.crafting_open {
            self.close_crafting();
            return;
        }
        if self.inventory_open {
            self.toggle_inventory();
            return;
        }

        if self.pause_menu_open {
            if self.pause_menu_view == PauseMenuView::Options {
                self.pause_menu_view = PauseMenuView::Main;
            } else {
                self.close_pause_menu();
            }
            return;
        }

        self.open_pause_menu();
    }

    /// Drink a potion and apply its status effect
    /// Returns true if the potion was successfully drunk
    fn drink_potion(&mut self, potion_id: u16) -> bool {
        let Some((potion_type, is_extended, amplifier)) = potion_id_to_potion_state(potion_id)
        else {
            tracing::warn!("Unknown potion ID: {}", potion_id);
            return false;
        };

        // Get the status effect from the potion type
        if let Some(effect_type) = potion_type.effect() {
            if effect_type.is_instant() {
                apply_instant_status_effect_to_player_health(
                    &mut self.player_health,
                    effect_type,
                    amplifier,
                );
                tracing::info!(
                    "Drank {:?} potion - applied instant {:?} (amp={})",
                    potion_type,
                    effect_type,
                    amplifier
                );
                true
            } else {
                // Apply the effect
                if let Some(effect) = potion_type.create_effect(amplifier, is_extended) {
                    let duration = effect.duration_ticks;
                    self.status_effects.add(effect);
                    tracing::info!(
                        "Drank {:?} potion - applied {:?} for {} ticks (amp={})",
                        potion_type,
                        effect_type,
                        duration,
                        amplifier
                    );
                } else {
                    tracing::info!("Drank {:?} potion (no effect)", potion_type);
                }
                true
            }
        } else {
            // Awkward, Mundane, Thick potions have no effect
            tracing::info!("Drank {:?} potion (no effect)", potion_type);
            true
        }
    }

    /// Throw a splash potion
    fn throw_splash_potion(&mut self, potion_id: u16) {
        use mdminecraft_world::Projectile;

        // Get player position and look direction from camera
        let camera = self.renderer.camera();
        let player_pos = camera.position;
        let yaw = camera.yaw;
        let pitch = camera.pitch;
        let base_y = (player_pos.y - 1.5) as f64;

        // Create the splash potion projectile
        let projectile = Projectile::throw_splash_potion(
            player_pos.x as f64,
            base_y,
            player_pos.z as f64,
            yaw,
            pitch,
            potion_id,
        );

        // Add to projectile manager
        self.projectiles.spawn(self.active_dimension, projectile);

        tracing::info!("Threw splash potion (ID: {})", potion_id);
    }

    fn throw_ender_pearl(&mut self) {
        use mdminecraft_world::Projectile;

        let camera = self.renderer.camera();
        let player_pos = camera.position;

        let base_y = (player_pos.y - 1.5) as f64;
        let mut projectile = Projectile::throw_ender_pearl(
            player_pos.x as f64,
            base_y,
            player_pos.z as f64,
            camera.yaw,
            camera.pitch,
        );
        projectile.owner = mdminecraft_world::ProjectileOwner::Player;

        self.projectiles.spawn(self.active_dimension, projectile);
        tracing::info!("Threw ender pearl");
    }

    fn throw_egg(&mut self) {
        use mdminecraft_world::Projectile;

        let camera = self.renderer.camera();
        let player_pos = camera.position;

        let base_y = (player_pos.y - 1.5) as f64;
        let throw_index = self.projectiles.projectiles.len() as u64;
        let pos_x = player_pos.x.floor() as i32;
        let pos_z = player_pos.z.floor() as i32;
        let hatch_count =
            Self::egg_hatch_count(self.world_seed, self.sim_tick.0, throw_index, pos_x, pos_z);

        let mut projectile = Projectile::throw_egg(
            player_pos.x as f64,
            base_y,
            player_pos.z as f64,
            camera.yaw,
            camera.pitch,
        );
        projectile.egg_hatch_count = hatch_count;

        self.projectiles.spawn(self.active_dimension, projectile);
        tracing::info!("Threw egg");
    }

    /// Apply splash potion effect to the player
    fn apply_splash_potion_to_player(&mut self, potion_id: u16, effectiveness: f64) {
        let Some((potion_type, is_extended, amplifier)) = potion_id_to_potion_state(potion_id)
        else {
            return;
        };

        let Some(effect_type) = potion_type.effect() else {
            return;
        };

        if effect_type.is_instant() {
            match effect_type {
                StatusEffectType::InstantHealth => {
                    let base_amount = if amplifier > 0 { 8.0 } else { 4.0 };
                    let heal_amount = (base_amount * effectiveness) as f32;
                    self.player_health.heal(heal_amount);
                    tracing::info!("Splash healing: +{:.1} HP (amp={})", heal_amount, amplifier);
                }
                StatusEffectType::InstantDamage => {
                    let base_amount = if amplifier > 0 { 12.0 } else { 6.0 };
                    let damage = (base_amount * effectiveness) as f32;
                    self.player_health.damage(damage);
                    tracing::info!("Splash harming: -{:.1} HP (amp={})", damage, amplifier);
                }
                _ => {}
            }
            return;
        }

        let Some(mut effect) = potion_type.create_effect(amplifier, is_extended) else {
            return;
        };
        let duration = (effect.duration_ticks as f64 * effectiveness) as u32;
        if duration == 0 {
            return;
        }
        effect.duration_ticks = duration;
        self.status_effects.add(effect);
        tracing::info!(
            "Splash {:?} applied to player for {} ticks (amp={})",
            effect_type,
            duration,
            amplifier
        );
    }

    /// Count bookshelves within 2 blocks of the enchanting table (vanilla mechanics)
    fn count_nearby_bookshelves(&self, table_pos: IVec3) -> u32 {
        // Vanilla: bookshelves must be 2 blocks away, 1 block higher, with air in between
        // Simplified: check 5x5x2 area centered on table, 1 block up
        let bookshelf_id: BlockId = BLOCK_BOOKSHELF;

        let mut count = 0u32;
        for dy in 0..2 {
            for dx in -2i32..=2 {
                for dz in -2i32..=2 {
                    // Skip center 3x3 area (too close to table)
                    if dx.abs() <= 1 && dz.abs() <= 1 {
                        continue;
                    }

                    let check_pos =
                        IVec3::new(table_pos.x + dx, table_pos.y + dy, table_pos.z + dz);

                    if let Some(block_id) = self.get_block_at(check_pos) {
                        if block_id == bookshelf_id {
                            count += 1;
                        }
                    }
                }
            }
        }

        count.min(15) // Cap at 15 bookshelves (vanilla limit)
    }

    /// Get block ID at world position
    fn get_block_at(&self, pos: IVec3) -> Option<BlockId> {
        let chunk_pos = ChunkPos::new(
            pos.x.div_euclid(CHUNK_SIZE_X as i32),
            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let chunk = self.chunks.get(&chunk_pos)?;

        let local_y = world_y_to_local_y(pos.y)?;
        let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;

        Some(chunk.voxel(local_x, local_y, local_z).id)
    }

    fn get_voxel_at(&self, pos: IVec3) -> Option<Voxel> {
        let chunk_pos = ChunkPos::new(
            pos.x.div_euclid(CHUNK_SIZE_X as i32),
            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let chunk = self.chunks.get(&chunk_pos)?;

        let local_y = world_y_to_local_y(pos.y)?;
        let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        Some(chunk.voxel(local_x, local_y, local_z))
    }

    /// Update all furnaces in the world
    fn update_furnaces(&mut self, dt: f32) {
        let mut lit_changes: Vec<(IVec3, bool)> = Vec::new();

        for (key, furnace) in &mut self.furnaces {
            if key.dimension != self.active_dimension {
                continue;
            }
            let was_lit = furnace.is_lit;
            furnace.update(dt);
            if was_lit != furnace.is_lit {
                lit_changes.push((IVec3::new(key.x, key.y, key.z), furnace.is_lit));
            }
        }

        // Update furnace block states (lit/unlit)
        for (pos, is_lit) in lit_changes {
            let chunk_x = pos.x.div_euclid(16);
            let chunk_z = pos.z.div_euclid(16);
            let chunk_pos = ChunkPos::new(chunk_x, chunk_z);

            if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                let local_x = pos.x.rem_euclid(16) as usize;
                let Some(local_y) = world_y_to_local_y(pos.y) else {
                    continue;
                };
                let local_z = pos.z.rem_euclid(16) as usize;

                let new_id = if is_lit {
                    BLOCK_FURNACE_LIT
                } else {
                    BLOCK_FURNACE
                };
                let mut voxel = chunk.voxel(local_x, local_y, local_z);
                voxel.id = new_id;
                chunk.set_voxel(local_x, local_y, local_z, voxel);
            }
        }
    }

    /// Update all brewing stands in the world
    fn update_brewing_stands(&mut self, dt: f32) {
        for (key, stand) in &mut self.brewing_stands {
            if key.dimension != self.active_dimension {
                continue;
            }
            stand.update(dt);
        }
    }

    fn update_hoppers(&mut self) {
        mdminecraft_world::tick_hoppers(
            mdminecraft_world::HopperTickContext {
                chunks: &mut self.chunks,
                redstone_sim: &mut self.redstone_sim,
                item_manager: &mut self.item_manager,
                chests: &mut self.chests,
                hoppers: &mut self.hoppers,
                dispensers: &mut self.dispensers,
                droppers: &mut self.droppers,
            },
            |drop_type| {
                Self::convert_dropped_item_type(drop_type)
                    .map(|core_type| ItemStack::new(core_type, 1))
            },
        );
    }

    fn update_dispensers_and_droppers(&mut self) {
        const DISPENSER_COOLDOWN_TICKS: u8 = 4;

        let changed_positions = Self::tick_dispensers_and_droppers(
            DISPENSER_COOLDOWN_TICKS,
            self.active_dimension,
            self.world_seed,
            self.sim_tick,
            DispenserTickContext {
                chunks: &mut self.chunks,
                crop_growth: &mut self.crop_growth,
                block_properties: &self.block_properties,
                redstone_sim: &mut self.redstone_sim,
                item_manager: &mut self.item_manager,
                fluid_sim: &mut self.fluid_sim,
                projectiles: &mut self.projectiles,
                chests: &mut self.chests,
                hoppers: &mut self.hoppers,
                dispensers: &mut self.dispensers,
                droppers: &mut self.droppers,
            },
        );
        self.refresh_after_voxel_changes(&changed_positions);
    }

    fn tick_dispensers_and_droppers(
        cooldown_ticks: u8,
        active_dimension: DimensionId,
        world_seed: u64,
        sim_tick: SimTick,
        ctx: DispenserTickContext<'_>,
    ) -> Vec<IVec3> {
        let DispenserTickContext {
            chunks,
            crop_growth,
            block_properties,
            redstone_sim,
            item_manager,
            fluid_sim,
            projectiles,
            chests,
            hoppers,
            dispensers,
            droppers,
        } = ctx;
        let voxel_at = |chunks: &HashMap<ChunkPos, Chunk>, pos: IVec3| -> Option<Voxel> {
            let local_y = world_y_to_local_y(pos.y)?;

            let chunk_pos = ChunkPos::new(
                pos.x.div_euclid(CHUNK_SIZE_X as i32),
                pos.z.div_euclid(CHUNK_SIZE_Z as i32),
            );
            let chunk = chunks.get(&chunk_pos)?;
            let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
            let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
            Some(chunk.voxel(local_x, local_y, local_z))
        };

        let mut changed_positions: Vec<IVec3> = Vec::new();

        let mut chests_state = std::mem::take(chests);
        let mut hoppers_state = std::mem::take(hoppers);
        let mut dispensers_state = std::mem::take(dispensers);
        let mut droppers_state = std::mem::take(droppers);

        let dispenser_keys: Vec<_> = dispensers_state.keys().copied().collect();
        for key in dispenser_keys {
            let Some(mut dispenser) = dispensers_state.remove(&key) else {
                continue;
            };

            if key.dimension != active_dimension {
                dispensers_state.insert(key, dispenser);
                continue;
            }

            let pos = IVec3::new(key.x, key.y, key.z);
            let Some(voxel) = voxel_at(chunks, pos) else {
                dispensers_state.insert(key, dispenser);
                continue;
            };

            if voxel.id != mdminecraft_world::mechanical_blocks::DISPENSER {
                continue;
            }

            if dispenser.cooldown_ticks > 0 {
                dispenser.cooldown_ticks = dispenser.cooldown_ticks.saturating_sub(1);
            }

            let powered = mdminecraft_world::is_active(voxel.state);
            let rising_edge = powered && !dispenser.was_powered;
            dispenser.was_powered = powered;

            if rising_edge && dispenser.cooldown_ticks == 0 {
                let facing = mdminecraft_world::dispenser_facing(voxel.state);
                let (dx, dz) = facing.offset();
                let spawn_x = pos.x as f64 + 0.5 + dx as f64 * 0.7;
                let spawn_y = pos.y as f64 + 0.5;
                let spawn_z = pos.z as f64 + 0.5 + dz as f64 * 0.7;
                let target_pos = IVec3::new(pos.x + dx, pos.y, pos.z + dz);

                let Some((source_idx, one)) =
                    mdminecraft_world::take_one_from_core_slots(&mut dispenser.slots)
                else {
                    dispensers_state.insert(key, dispenser);
                    continue;
                };

                if let Some(target_voxel) = voxel_at(chunks, target_pos) {
                    let target_key = mdminecraft_world::BlockEntityKey {
                        dimension: key.dimension,
                        x: target_pos.x,
                        y: target_pos.y,
                        z: target_pos.z,
                    };
                    let target_pos = RedstonePos::new(target_pos.x, target_pos.y, target_pos.z);

                    let inserted = match target_voxel.id {
                        interactive_blocks::CHEST => {
                            let chest = chests_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut chest.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &chest.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        mdminecraft_world::mechanical_blocks::HOPPER => {
                            let hopper = hoppers_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut hopper.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &hopper.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        mdminecraft_world::mechanical_blocks::DISPENSER => {
                            let target = dispensers_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut target.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &target.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        mdminecraft_world::mechanical_blocks::DROPPER => {
                            let target = droppers_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut target.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &target.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        _ => false,
                    };

                    if inserted {
                        dispenser.cooldown_ticks = cooldown_ticks;
                        mdminecraft_world::update_container_signal(
                            chunks,
                            redstone_sim,
                            RedstonePos::new(pos.x, pos.y, pos.z),
                            &dispenser.slots,
                        );
                        dispensers_state.insert(key, dispenser);
                        continue;
                    }
                }

                // Vanilla-ish: dispensers can fill glass bottles when facing water.
                if let ItemType::Item(item_id) = one.item_type {
                    if item_id == CORE_ITEM_GLASS_BOTTLE {
                        if let Some(target_voxel) = voxel_at(chunks, target_pos) {
                            if target_voxel.id == BLOCK_WATER {
                                let filled =
                                    ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1);
                                if !mdminecraft_world::insert_one_into_core_slots(
                                    &mut dispenser.slots,
                                    filled.clone(),
                                ) {
                                    item_manager.spawn_item_with_metadata(
                                        key.dimension,
                                        (spawn_x, spawn_y, spawn_z),
                                        DroppedItemType::WaterBottle,
                                        1,
                                        filled.durability,
                                        filled.enchantments.clone(),
                                    );
                                }

                                dispenser.cooldown_ticks = cooldown_ticks;
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    RedstonePos::new(pos.x, pos.y, pos.z),
                                    &dispenser.slots,
                                );
                                dispensers_state.insert(key, dispenser);
                                continue;
                            }
                        }
                    }
                }

                // Vanilla-ish: dispensers interact with water/lava via buckets instead of dropping them.
                if let ItemType::Item(bucket_id) = one.item_type {
                    if matches!(
                        bucket_id,
                        CORE_ITEM_BUCKET | CORE_ITEM_WATER_BUCKET | CORE_ITEM_LAVA_BUCKET
                    ) {
                        let face_normal = IVec3::new(dx, 0, dz);
                        let target_pos = pos + face_normal;

                        let hit = if bucket_id == CORE_ITEM_BUCKET {
                            RaycastHit {
                                block_pos: target_pos,
                                face_normal: IVec3::ZERO,
                                distance: 0.0,
                                hit_pos: glam::Vec3::ZERO,
                            }
                        } else {
                            RaycastHit {
                                block_pos: pos,
                                face_normal,
                                distance: 0.0,
                                hit_pos: glam::Vec3::ZERO,
                            }
                        };

                        if let Some((new_bucket_id, mut changed)) =
                            try_bucket_interaction(key.dimension, bucket_id, hit, chunks, fluid_sim)
                        {
                            restore_one_into_core_slot(
                                &mut dispenser.slots,
                                source_idx,
                                ItemStack::new(ItemType::Item(new_bucket_id), 1),
                            );
                            dispenser.cooldown_ticks = cooldown_ticks;
                            mdminecraft_world::update_container_signal(
                                chunks,
                                redstone_sim,
                                RedstonePos::new(pos.x, pos.y, pos.z),
                                &dispenser.slots,
                            );
                            changed_positions.append(&mut changed);
                            dispensers_state.insert(key, dispenser);
                            continue;
                        }

                        // Failed bucket interaction: restore item, no dispense.
                        restore_one_into_core_slot(&mut dispenser.slots, source_idx, one);
                        dispensers_state.insert(key, dispenser);
                        continue;
                    }
                }

                match one.item_type {
                    // Item(18) = Bone Meal.
                    ItemType::Item(18) => {
                        if Self::apply_bone_meal_to_crop_at(
                            world_seed,
                            sim_tick.0,
                            target_pos,
                            chunks,
                            crop_growth,
                        ) {
                            changed_positions.push(target_pos);
                        } else {
                            item_manager.spawn_item_with_metadata(
                                key.dimension,
                                (spawn_x, spawn_y, spawn_z),
                                DroppedItemType::BoneMeal,
                                1,
                                one.durability,
                                one.enchantments.clone(),
                            );
                        }
                    }
                    ItemType::Item(2) => {
                        let speed = 1.1;
                        let arrow = mdminecraft_world::Projectile::new(
                            spawn_x,
                            spawn_y,
                            spawn_z,
                            dx as f64 * speed,
                            0.0,
                            dz as f64 * speed,
                            mdminecraft_world::ProjectileType::Arrow,
                            0.4,
                        );
                        projectiles.spawn(key.dimension, arrow);
                    }
                    ItemType::Item(CORE_ITEM_FLINT_AND_STEEL) => {
                        let ignite_pos = IVec3::new(pos.x + dx, pos.y, pos.z + dz);
                        let Some(local_y) = world_y_to_local_y(ignite_pos.y) else {
                            restore_one_into_core_slot(&mut dispenser.slots, source_idx, one);
                            dispensers_state.insert(key, dispenser);
                            continue;
                        };

                        let mut fire_changed: Vec<IVec3> = Vec::new();
                        let success = if let Some(mut portal_changed) =
                            try_activate_nether_portal(chunks, ignite_pos)
                        {
                            fire_changed.append(&mut portal_changed);
                            true
                        } else {
                            let support_pos =
                                IVec3::new(ignite_pos.x, ignite_pos.y - 1, ignite_pos.z);
                            if let Some(support_voxel) = voxel_at(chunks, support_pos) {
                                if !block_properties.get(support_voxel.id).is_solid {
                                    false
                                } else {
                                    let chunk_pos = ChunkPos::new(
                                        ignite_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                                        ignite_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                                    );
                                    if let Some(chunk) = chunks.get_mut(&chunk_pos) {
                                        let local_x =
                                            ignite_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                                        let local_z =
                                            ignite_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                                        let voxel = chunk.voxel(local_x, local_y, local_z);

                                        if voxel.id == mdminecraft_world::BLOCK_FIRE {
                                            true
                                        } else if voxel.id != BLOCK_AIR {
                                            false
                                        } else {
                                            chunk.set_voxel(
                                                local_x,
                                                local_y,
                                                local_z,
                                                Voxel {
                                                    id: mdminecraft_world::BLOCK_FIRE,
                                                    state: 0,
                                                    light_sky: 0,
                                                    light_block: 0,
                                                },
                                            );
                                            fire_changed.push(ignite_pos);
                                            true
                                        }
                                    } else {
                                        false
                                    }
                                }
                            } else {
                                false
                            }
                        };

                        if !success {
                            restore_one_into_core_slot(&mut dispenser.slots, source_idx, one);
                            dispensers_state.insert(key, dispenser);
                            continue;
                        }

                        let mut tool = one;
                        if !fire_changed.is_empty() {
                            if tool.durability.is_none() {
                                tool.durability = tool.max_durability();
                            }
                            tool.damage_durability(1);
                        }
                        if !tool.is_broken() {
                            restore_one_into_core_slot(&mut dispenser.slots, source_idx, tool);
                        }

                        changed_positions.append(&mut fire_changed);
                    }
                    ItemType::Item(104) => {
                        let speed = 0.9;
                        let throw_index = projectiles.projectiles.len() as u64;
                        let hatch_count = Self::egg_hatch_count(
                            world_seed,
                            sim_tick.0,
                            throw_index,
                            pos.x,
                            pos.z,
                        );

                        let mut projectile = mdminecraft_world::Projectile::new(
                            spawn_x,
                            spawn_y,
                            spawn_z,
                            dx as f64 * speed,
                            0.2,
                            dz as f64 * speed,
                            mdminecraft_world::ProjectileType::Egg,
                            1.0,
                        );
                        projectile.can_pick_up = false;
                        projectile.egg_hatch_count = hatch_count;
                        projectiles.spawn(key.dimension, projectile);
                    }
                    ItemType::SplashPotion(potion_id) => {
                        let speed = 0.8;
                        let projectile = mdminecraft_world::Projectile::new(
                            spawn_x,
                            spawn_y,
                            spawn_z,
                            dx as f64 * speed,
                            0.2,
                            dz as f64 * speed,
                            mdminecraft_world::ProjectileType::SplashPotion(potion_id),
                            1.0,
                        );
                        projectiles.spawn(key.dimension, projectile);
                    }
                    ItemType::Item(CORE_ITEM_ENDER_PEARL) => {
                        let speed = 0.9;
                        let mut projectile = mdminecraft_world::Projectile::new(
                            spawn_x,
                            spawn_y,
                            spawn_z,
                            dx as f64 * speed,
                            0.2,
                            dz as f64 * speed,
                            mdminecraft_world::ProjectileType::EnderPearl,
                            1.0,
                        );
                        projectile.can_pick_up = false;
                        projectiles.spawn(key.dimension, projectile);
                    }
                    ItemType::Item(CORE_ITEM_EYE_OF_ENDER) => {
                        let target_pos = IVec3::new(pos.x + dx, pos.y, pos.z + dz);
                        let mut inserted = false;

                        if key.dimension == DimensionId::Overworld {
                            if let Some(local_y) = world_y_to_local_y(target_pos.y) {
                                let chunk_pos = ChunkPos::new(
                                    target_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                                    target_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                                );
                                if let Some(chunk) = chunks.get_mut(&chunk_pos) {
                                    let local_x =
                                        target_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
                                    let local_z =
                                        target_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
                                    let frame_voxel = chunk.voxel(local_x, local_y, local_z);
                                    if frame_voxel.id == BLOCK_END_PORTAL_FRAME
                                        && (frame_voxel.state & 0x01) == 0
                                    {
                                        chunk.set_voxel(
                                            local_x,
                                            local_y,
                                            local_z,
                                            Voxel {
                                                state: frame_voxel.state | 0x01,
                                                ..frame_voxel
                                            },
                                        );
                                        changed_positions.push(target_pos);
                                        inserted = true;
                                    }
                                }
                            }
                        }

                        if inserted {
                            if let Some(mut portal_positions) =
                                try_activate_end_portal(chunks, target_pos)
                            {
                                changed_positions.append(&mut portal_positions);
                            }
                        } else {
                            item_manager.spawn_item_with_metadata(
                                key.dimension,
                                (spawn_x, spawn_y, spawn_z),
                                DroppedItemType::EyeOfEnder,
                                1,
                                one.durability,
                                one.enchantments.clone(),
                            );
                        }
                    }
                    other => {
                        let Some(drop_type) = Self::convert_core_item_type_to_dropped(other) else {
                            restore_one_into_core_slot(&mut dispenser.slots, source_idx, one);
                            dispensers_state.insert(key, dispenser);
                            continue;
                        };
                        item_manager.spawn_item_with_metadata(
                            key.dimension,
                            (spawn_x, spawn_y, spawn_z),
                            drop_type,
                            1,
                            one.durability,
                            one.enchantments.clone(),
                        );
                    }
                }

                dispenser.cooldown_ticks = cooldown_ticks;
                mdminecraft_world::update_container_signal(
                    chunks,
                    redstone_sim,
                    RedstonePos::new(pos.x, pos.y, pos.z),
                    &dispenser.slots,
                );
            }

            dispensers_state.insert(key, dispenser);
        }

        let dropper_keys: Vec<_> = droppers_state.keys().copied().collect();
        for key in dropper_keys {
            let Some(mut dropper) = droppers_state.remove(&key) else {
                continue;
            };

            if key.dimension != active_dimension {
                droppers_state.insert(key, dropper);
                continue;
            }

            let pos = IVec3::new(key.x, key.y, key.z);
            let Some(voxel) = voxel_at(chunks, pos) else {
                droppers_state.insert(key, dropper);
                continue;
            };

            if voxel.id != mdminecraft_world::mechanical_blocks::DROPPER {
                continue;
            }

            if dropper.cooldown_ticks > 0 {
                dropper.cooldown_ticks = dropper.cooldown_ticks.saturating_sub(1);
            }

            let powered = mdminecraft_world::is_active(voxel.state);
            let rising_edge = powered && !dropper.was_powered;
            dropper.was_powered = powered;

            if rising_edge && dropper.cooldown_ticks == 0 {
                let facing = mdminecraft_world::dropper_facing(voxel.state);
                let (dx, dz) = facing.offset();
                let spawn_x = pos.x as f64 + 0.5 + dx as f64 * 0.7;
                let spawn_y = pos.y as f64 + 0.5;
                let spawn_z = pos.z as f64 + 0.5 + dz as f64 * 0.7;
                let target_pos = IVec3::new(pos.x + dx, pos.y, pos.z + dz);

                let Some((source_idx, one)) =
                    mdminecraft_world::take_one_from_core_slots(&mut dropper.slots)
                else {
                    droppers_state.insert(key, dropper);
                    continue;
                };

                if let Some(target_voxel) = voxel_at(chunks, target_pos) {
                    let target_key = mdminecraft_world::BlockEntityKey {
                        dimension: key.dimension,
                        x: target_pos.x,
                        y: target_pos.y,
                        z: target_pos.z,
                    };
                    let target_pos = RedstonePos::new(target_pos.x, target_pos.y, target_pos.z);

                    let inserted = match target_voxel.id {
                        interactive_blocks::CHEST => {
                            let chest = chests_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut chest.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &chest.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        mdminecraft_world::mechanical_blocks::HOPPER => {
                            let hopper = hoppers_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut hopper.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &hopper.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        mdminecraft_world::mechanical_blocks::DISPENSER => {
                            let target = dispensers_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut target.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &target.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        mdminecraft_world::mechanical_blocks::DROPPER => {
                            let target = droppers_state.entry(target_key).or_default();
                            if mdminecraft_world::insert_one_into_core_slots(
                                &mut target.slots,
                                one.clone(),
                            ) {
                                mdminecraft_world::update_container_signal(
                                    chunks,
                                    redstone_sim,
                                    target_pos,
                                    &target.slots,
                                );
                                true
                            } else {
                                false
                            }
                        }
                        _ => false,
                    };

                    if inserted {
                        dropper.cooldown_ticks = cooldown_ticks;
                        mdminecraft_world::update_container_signal(
                            chunks,
                            redstone_sim,
                            RedstonePos::new(pos.x, pos.y, pos.z),
                            &dropper.slots,
                        );
                        droppers_state.insert(key, dropper);
                        continue;
                    }
                }

                let Some(drop_type) = Self::convert_core_item_type_to_dropped(one.item_type) else {
                    restore_one_into_core_slot(&mut dropper.slots, source_idx, one);
                    droppers_state.insert(key, dropper);
                    continue;
                };

                item_manager.spawn_item_with_metadata(
                    key.dimension,
                    (spawn_x, spawn_y, spawn_z),
                    drop_type,
                    1,
                    one.durability,
                    one.enchantments.clone(),
                );
                dropper.cooldown_ticks = cooldown_ticks;
                mdminecraft_world::update_container_signal(
                    chunks,
                    redstone_sim,
                    RedstonePos::new(pos.x, pos.y, pos.z),
                    &dropper.slots,
                );
            }

            droppers_state.insert(key, dropper);
        }

        *chests = chests_state;
        *hoppers = hoppers_state;
        *dispensers = dispensers_state;
        *droppers = droppers_state;
        changed_positions
    }

    /// Update player status effects (called every frame)
    fn update_status_effects(&mut self, _dt: f32) {
        // Tick all effects and remove expired ones
        // Note: StatusEffects.tick() handles one tick per call, independent of dt
        // In a real implementation, we'd track tick timing
        let expired = self.status_effects.tick();
        for effect_type in expired {
            tracing::info!("Status effect {:?} expired", effect_type);
        }
    }

    fn mob_bow_drop_metadata(
        world_seed: u64,
        sim_tick: SimTick,
        mob_id: u64,
        pos: (i32, i32, i32),
    ) -> (Option<u32>, Option<Vec<Enchantment>>) {
        let max_durability = ItemStack::new(ItemType::Item(1), 1).durability;
        let (pos_x, pos_y, pos_z) = pos;
        let pos_seed =
            (pos_x as u64) ^ ((pos_y as u64).rotate_left(21)) ^ ((pos_z as u64).rotate_left(42));
        let seed = world_seed
            ^ sim_tick.0.wrapping_mul(0xA24B_AED4_963E_E407)
            ^ mob_id.wrapping_mul(0x9E37_79B9_7F4A_7C15)
            ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
            ^ 0x004D_4F42_424F_5744_u64; // "MOBBOWD"
        let mut rng = StdRng::seed_from_u64(seed);

        let durability = max_durability.map(|max| {
            if max == 0 {
                return 0;
            }
            let damage = rng.gen_range(0..max);
            max - damage
        });

        // Vanilla-ish: rare enchanted equipment drops.
        let mut enchantments: Vec<Enchantment> = Vec::new();
        let enchant_roll: u32 = rng.gen_range(0..1000);
        if enchant_roll < 120 {
            // Baseline: small chance of Power I-II.
            let power_level: u8 = if rng.gen_range(0..100) < 25 { 2 } else { 1 };
            enchantments.push(Enchantment::new(EnchantmentType::Power, power_level));

            // Occasional supporting enchants.
            if rng.gen_range(0..100) < 18 {
                enchantments.push(Enchantment::new(EnchantmentType::Punch, 1));
            }
            if rng.gen_range(0..1000) < 25 {
                enchantments.push(Enchantment::new(EnchantmentType::Flame, 1));
            }
            if rng.gen_range(0..1000) < 10 {
                enchantments.push(Enchantment::new(EnchantmentType::Infinity, 1));
            }
            if rng.gen_range(0..100) < 30 {
                let level: u8 = if rng.gen_range(0..100) < 10 { 2 } else { 1 };
                enchantments.push(Enchantment::new(EnchantmentType::Unbreaking, level));
            }
        }

        let enchantments = if enchantments.is_empty() {
            None
        } else {
            Some(enchantments)
        };
        (durability, enchantments)
    }

    fn mob_meat_drop_type(mob_type: MobType, burning: bool) -> Option<DroppedItemType> {
        Some(match mob_type {
            MobType::Pig => {
                if burning {
                    DroppedItemType::CookedPork
                } else {
                    DroppedItemType::RawPork
                }
            }
            MobType::Cow => {
                if burning {
                    DroppedItemType::CookedBeef
                } else {
                    DroppedItemType::RawBeef
                }
            }
            _ => return None,
        })
    }

    fn zombie_rare_drop(tick: u64, pos_x: i32, pos_z: i32) -> Option<DroppedItemType> {
        let roll = (tick as u32)
            .wrapping_add((pos_x as u32).wrapping_mul(31))
            .wrapping_add((pos_z as u32).wrapping_mul(131))
            % 100;
        match roll {
            0..=1 => Some(DroppedItemType::Carrot),
            2..=3 => Some(DroppedItemType::Potato),
            4..=5 => Some(DroppedItemType::IronIngot),
            _ => None,
        }
    }

    fn chicken_should_lay_egg(
        world_seed: u64,
        tick: u64,
        mob_id: u64,
        pos_x: i32,
        pos_z: i32,
    ) -> bool {
        let identity_seed = if mob_id != 0 {
            mob_id
        } else {
            (pos_x as u64) ^ ((pos_z as u64).rotate_left(32))
        };

        let seed = world_seed
            ^ identity_seed.wrapping_mul(0x9E37_79B9_7F4A_7C15)
            ^ 0x0045_4747_4C41_5900_u64; // "EGGLAY\0"
        let interval = CHICKEN_EGG_MIN_INTERVAL_TICKS + (seed % CHICKEN_EGG_INTERVAL_RANGE_TICKS);
        let offset = (seed.rotate_left(23)) % interval.max(1);

        (tick.wrapping_add(offset)).is_multiple_of(interval)
    }

    fn egg_hatch_count(world_seed: u64, tick: u64, throw_index: u64, pos_x: i32, pos_z: i32) -> u8 {
        let pos_seed = (pos_x as u64) ^ ((pos_z as u64).rotate_left(32));
        let seed = world_seed
            ^ tick.wrapping_mul(0xA24B_AED4_963E_E407)
            ^ throw_index.wrapping_mul(0x9E37_79B9_7F4A_7C15)
            ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
            ^ 0x0045_4747_4854_4348_u64; // "EGGHTCH"

        match (seed & 31) as u8 {
            0 => 4,
            1..=3 => 1,
            _ => 0,
        }
    }

    fn bone_meal_crop_growth_delta(
        world_seed: u64,
        tick: u64,
        pos_x: i32,
        pos_y: i32,
        pos_z: i32,
        stage: u8,
    ) -> u8 {
        let pos_seed =
            (pos_x as u64) ^ ((pos_y as u64).rotate_left(21)) ^ ((pos_z as u64).rotate_left(42));
        let seed = world_seed
            ^ tick.wrapping_mul(0xA24B_AED4_963E_E407)
            ^ pos_seed.wrapping_mul(0xD6E8_FEB8_6659_FD93)
            ^ (stage as u64).wrapping_mul(0x9E37_79B9_7F4A_7C15)
            ^ 0x0042_4F4E_454D_4541_u64; // "BONEMEA"

        (seed % 4) as u8 + 2
    }

    fn spill_core_stack_to_world(
        item_manager: &mut ItemManager,
        dimension: DimensionId,
        drop_pos: (f64, f64, f64),
        stack: &ItemStack,
    ) -> Option<DroppedItemType> {
        let drop_type = Self::convert_core_item_type_to_dropped(stack.item_type)?;
        item_manager.spawn_item_with_metadata(
            dimension,
            drop_pos,
            drop_type,
            stack.count,
            stack.durability,
            stack.enchantments.clone(),
        );
        Some(drop_type)
    }

    /// Convert dropped item type to core item type
    fn convert_dropped_item_type(drop_type: DroppedItemType) -> Option<ItemType> {
        use mdminecraft_core::item::FoodType;

        // First check if it's a block item
        if let Some(block_id) = drop_type.to_block() {
            return Some(ItemType::Block(block_id));
        }

        // Handle non-block items
        match drop_type {
            DroppedItemType::RawPork | DroppedItemType::RawBeef => {
                Some(ItemType::Food(FoodType::RawMeat))
            }
            DroppedItemType::CookedPork | DroppedItemType::CookedBeef => {
                Some(ItemType::Food(FoodType::CookedMeat))
            }
            DroppedItemType::Apple => Some(ItemType::Food(FoodType::Apple)),
            DroppedItemType::Bow => Some(ItemType::Item(1)),
            DroppedItemType::Arrow => Some(ItemType::Item(2)),
            DroppedItemType::Stick => Some(ItemType::Item(3)),
            DroppedItemType::String => Some(ItemType::Item(4)),
            DroppedItemType::Flint => Some(ItemType::Item(5)),
            DroppedItemType::FlintAndSteel => Some(ItemType::Item(CORE_ITEM_FLINT_AND_STEEL)),
            DroppedItemType::EnderPearl => Some(ItemType::Item(CORE_ITEM_ENDER_PEARL)),
            DroppedItemType::EyeOfEnder => Some(ItemType::Item(CORE_ITEM_EYE_OF_ENDER)),
            DroppedItemType::Feather => Some(ItemType::Item(6)),
            DroppedItemType::IronIngot => Some(ItemType::Item(7)),
            DroppedItemType::Coal => Some(ItemType::Item(8)),
            DroppedItemType::GoldIngot => Some(ItemType::Item(9)),
            DroppedItemType::Diamond => Some(ItemType::Item(14)),
            DroppedItemType::LapisLazuli => Some(ItemType::Item(15)),
            DroppedItemType::Bone => Some(ItemType::Item(16)),
            DroppedItemType::Emerald => Some(ItemType::Item(17)),
            DroppedItemType::BoneMeal => Some(ItemType::Item(18)),
            DroppedItemType::Leather => Some(ItemType::Item(102)),
            DroppedItemType::Wool => Some(ItemType::Item(103)),
            DroppedItemType::Egg => Some(ItemType::Item(104)),
            DroppedItemType::Sapling => Some(ItemType::Item(105)),
            DroppedItemType::GlassBottle => Some(ItemType::Item(CORE_ITEM_GLASS_BOTTLE)),
            DroppedItemType::WaterBottle => Some(ItemType::Item(CORE_ITEM_WATER_BOTTLE)),
            DroppedItemType::NetherWart => Some(ItemType::Item(CORE_ITEM_NETHER_WART)),
            DroppedItemType::BlazePowder => Some(ItemType::Item(CORE_ITEM_BLAZE_POWDER)),
            DroppedItemType::Gunpowder => Some(ItemType::Item(CORE_ITEM_GUNPOWDER)),
            DroppedItemType::SpiderEye => Some(ItemType::Item(CORE_ITEM_SPIDER_EYE)),
            DroppedItemType::FermentedSpiderEye => {
                Some(ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE))
            }
            DroppedItemType::MagmaCream => Some(ItemType::Item(CORE_ITEM_MAGMA_CREAM)),
            DroppedItemType::GhastTear => Some(ItemType::Item(CORE_ITEM_GHAST_TEAR)),
            DroppedItemType::GlisteringMelon => Some(ItemType::Item(CORE_ITEM_GLISTERING_MELON)),
            DroppedItemType::RabbitFoot => Some(ItemType::Item(CORE_ITEM_RABBIT_FOOT)),
            DroppedItemType::PhantomMembrane => Some(ItemType::Item(CORE_ITEM_PHANTOM_MEMBRANE)),
            DroppedItemType::RedstoneDust => Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
            DroppedItemType::GlowstoneDust => Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
            DroppedItemType::Pufferfish => Some(ItemType::Item(CORE_ITEM_PUFFERFISH)),
            DroppedItemType::NetherQuartz => Some(ItemType::Item(CORE_ITEM_NETHER_QUARTZ)),
            DroppedItemType::Bucket => Some(ItemType::Item(CORE_ITEM_BUCKET)),
            DroppedItemType::WaterBucket => Some(ItemType::Item(CORE_ITEM_WATER_BUCKET)),
            DroppedItemType::LavaBucket => Some(ItemType::Item(CORE_ITEM_LAVA_BUCKET)),
            DroppedItemType::Sugar => Some(ItemType::Item(CORE_ITEM_SUGAR)),
            DroppedItemType::Paper => Some(ItemType::Item(CORE_ITEM_PAPER)),
            DroppedItemType::Book => Some(ItemType::Item(CORE_ITEM_BOOK)),
            DroppedItemType::WheatSeeds => Some(ItemType::Item(CORE_ITEM_WHEAT_SEEDS)),
            DroppedItemType::Wheat => Some(ItemType::Item(CORE_ITEM_WHEAT)),
            DroppedItemType::Bread => Some(ItemType::Food(FoodType::Bread)),
            DroppedItemType::Carrot => Some(ItemType::Food(FoodType::Carrot)),
            DroppedItemType::Potato => Some(ItemType::Food(FoodType::Potato)),
            DroppedItemType::BakedPotato => Some(ItemType::Food(FoodType::BakedPotato)),
            DroppedItemType::GoldenCarrot => Some(ItemType::Food(FoodType::GoldenCarrot)),
            DroppedItemType::PotionAwkward => Some(ItemType::Potion(potion_ids::AWKWARD)),
            DroppedItemType::PotionNightVision => Some(ItemType::Potion(potion_ids::NIGHT_VISION)),
            DroppedItemType::PotionInvisibility => Some(ItemType::Potion(potion_ids::INVISIBILITY)),
            DroppedItemType::PotionLeaping => Some(ItemType::Potion(potion_ids::LEAPING)),
            DroppedItemType::PotionFireResistance => {
                Some(ItemType::Potion(potion_ids::FIRE_RESISTANCE))
            }
            DroppedItemType::PotionSwiftness => Some(ItemType::Potion(potion_ids::SWIFTNESS)),
            DroppedItemType::PotionSlowness => Some(ItemType::Potion(potion_ids::SLOWNESS)),
            DroppedItemType::PotionWaterBreathing => {
                Some(ItemType::Potion(potion_ids::WATER_BREATHING))
            }
            DroppedItemType::PotionHealing => Some(ItemType::Potion(potion_ids::HEALING)),
            DroppedItemType::PotionHarming => Some(ItemType::Potion(potion_ids::HARMING)),
            DroppedItemType::PotionPoison => Some(ItemType::Potion(potion_ids::POISON)),
            DroppedItemType::PotionRegeneration => Some(ItemType::Potion(potion_ids::REGENERATION)),
            DroppedItemType::PotionStrength => Some(ItemType::Potion(potion_ids::STRENGTH)),
            DroppedItemType::PotionWeakness => Some(ItemType::Potion(potion_ids::WEAKNESS)),
            DroppedItemType::PotionSlowFalling => Some(ItemType::Potion(potion_ids::SLOW_FALLING)),
            DroppedItemType::PotionNightVisionLong => {
                Some(ItemType::Potion(potion_ids::NIGHT_VISION_LONG))
            }
            DroppedItemType::PotionInvisibilityLong => {
                Some(ItemType::Potion(potion_ids::INVISIBILITY_LONG))
            }
            DroppedItemType::PotionLeapingLong => Some(ItemType::Potion(potion_ids::LEAPING_LONG)),
            DroppedItemType::PotionLeapingStrong => {
                Some(ItemType::Potion(potion_ids::LEAPING_STRONG))
            }
            DroppedItemType::PotionFireResistanceLong => {
                Some(ItemType::Potion(potion_ids::FIRE_RESISTANCE_LONG))
            }
            DroppedItemType::PotionSwiftnessLong => {
                Some(ItemType::Potion(potion_ids::SWIFTNESS_LONG))
            }
            DroppedItemType::PotionSwiftnessStrong => {
                Some(ItemType::Potion(potion_ids::SWIFTNESS_STRONG))
            }
            DroppedItemType::PotionSlownessLong => {
                Some(ItemType::Potion(potion_ids::SLOWNESS_LONG))
            }
            DroppedItemType::PotionWaterBreathingLong => {
                Some(ItemType::Potion(potion_ids::WATER_BREATHING_LONG))
            }
            DroppedItemType::PotionHealingStrong => {
                Some(ItemType::Potion(potion_ids::HEALING_STRONG))
            }
            DroppedItemType::PotionHarmingStrong => {
                Some(ItemType::Potion(potion_ids::HARMING_STRONG))
            }
            DroppedItemType::PotionPoisonLong => Some(ItemType::Potion(potion_ids::POISON_LONG)),
            DroppedItemType::PotionPoisonStrong => {
                Some(ItemType::Potion(potion_ids::POISON_STRONG))
            }
            DroppedItemType::PotionRegenerationLong => {
                Some(ItemType::Potion(potion_ids::REGENERATION_LONG))
            }
            DroppedItemType::PotionRegenerationStrong => {
                Some(ItemType::Potion(potion_ids::REGENERATION_STRONG))
            }
            DroppedItemType::PotionStrengthLong => {
                Some(ItemType::Potion(potion_ids::STRENGTH_LONG))
            }
            DroppedItemType::PotionStrengthStrong => {
                Some(ItemType::Potion(potion_ids::STRENGTH_STRONG))
            }
            DroppedItemType::PotionWeaknessLong => {
                Some(ItemType::Potion(potion_ids::WEAKNESS_LONG))
            }
            DroppedItemType::PotionSlowFallingLong => {
                Some(ItemType::Potion(potion_ids::SLOW_FALLING_LONG))
            }
            DroppedItemType::SplashPotionAwkward => {
                Some(ItemType::SplashPotion(potion_ids::AWKWARD))
            }
            DroppedItemType::SplashPotionNightVision => {
                Some(ItemType::SplashPotion(potion_ids::NIGHT_VISION))
            }
            DroppedItemType::SplashPotionInvisibility => {
                Some(ItemType::SplashPotion(potion_ids::INVISIBILITY))
            }
            DroppedItemType::SplashPotionLeaping => {
                Some(ItemType::SplashPotion(potion_ids::LEAPING))
            }
            DroppedItemType::SplashPotionFireResistance => {
                Some(ItemType::SplashPotion(potion_ids::FIRE_RESISTANCE))
            }
            DroppedItemType::SplashPotionSwiftness => {
                Some(ItemType::SplashPotion(potion_ids::SWIFTNESS))
            }
            DroppedItemType::SplashPotionSlowness => {
                Some(ItemType::SplashPotion(potion_ids::SLOWNESS))
            }
            DroppedItemType::SplashPotionWaterBreathing => {
                Some(ItemType::SplashPotion(potion_ids::WATER_BREATHING))
            }
            DroppedItemType::SplashPotionHealing => {
                Some(ItemType::SplashPotion(potion_ids::HEALING))
            }
            DroppedItemType::SplashPotionHarming => {
                Some(ItemType::SplashPotion(potion_ids::HARMING))
            }
            DroppedItemType::SplashPotionPoison => Some(ItemType::SplashPotion(potion_ids::POISON)),
            DroppedItemType::SplashPotionRegeneration => {
                Some(ItemType::SplashPotion(potion_ids::REGENERATION))
            }
            DroppedItemType::SplashPotionStrength => {
                Some(ItemType::SplashPotion(potion_ids::STRENGTH))
            }
            DroppedItemType::SplashPotionWeakness => {
                Some(ItemType::SplashPotion(potion_ids::WEAKNESS))
            }
            DroppedItemType::SplashPotionSlowFalling => {
                Some(ItemType::SplashPotion(potion_ids::SLOW_FALLING))
            }
            DroppedItemType::SplashPotionNightVisionLong => {
                Some(ItemType::SplashPotion(potion_ids::NIGHT_VISION_LONG))
            }
            DroppedItemType::SplashPotionInvisibilityLong => {
                Some(ItemType::SplashPotion(potion_ids::INVISIBILITY_LONG))
            }
            DroppedItemType::SplashPotionLeapingLong => {
                Some(ItemType::SplashPotion(potion_ids::LEAPING_LONG))
            }
            DroppedItemType::SplashPotionLeapingStrong => {
                Some(ItemType::SplashPotion(potion_ids::LEAPING_STRONG))
            }
            DroppedItemType::SplashPotionFireResistanceLong => {
                Some(ItemType::SplashPotion(potion_ids::FIRE_RESISTANCE_LONG))
            }
            DroppedItemType::SplashPotionSwiftnessLong => {
                Some(ItemType::SplashPotion(potion_ids::SWIFTNESS_LONG))
            }
            DroppedItemType::SplashPotionSwiftnessStrong => {
                Some(ItemType::SplashPotion(potion_ids::SWIFTNESS_STRONG))
            }
            DroppedItemType::SplashPotionSlownessLong => {
                Some(ItemType::SplashPotion(potion_ids::SLOWNESS_LONG))
            }
            DroppedItemType::SplashPotionWaterBreathingLong => {
                Some(ItemType::SplashPotion(potion_ids::WATER_BREATHING_LONG))
            }
            DroppedItemType::SplashPotionHealingStrong => {
                Some(ItemType::SplashPotion(potion_ids::HEALING_STRONG))
            }
            DroppedItemType::SplashPotionHarmingStrong => {
                Some(ItemType::SplashPotion(potion_ids::HARMING_STRONG))
            }
            DroppedItemType::SplashPotionPoisonLong => {
                Some(ItemType::SplashPotion(potion_ids::POISON_LONG))
            }
            DroppedItemType::SplashPotionPoisonStrong => {
                Some(ItemType::SplashPotion(potion_ids::POISON_STRONG))
            }
            DroppedItemType::SplashPotionRegenerationLong => {
                Some(ItemType::SplashPotion(potion_ids::REGENERATION_LONG))
            }
            DroppedItemType::SplashPotionRegenerationStrong => {
                Some(ItemType::SplashPotion(potion_ids::REGENERATION_STRONG))
            }
            DroppedItemType::SplashPotionStrengthLong => {
                Some(ItemType::SplashPotion(potion_ids::STRENGTH_LONG))
            }
            DroppedItemType::SplashPotionStrengthStrong => {
                Some(ItemType::SplashPotion(potion_ids::STRENGTH_STRONG))
            }
            DroppedItemType::SplashPotionWeaknessLong => {
                Some(ItemType::SplashPotion(potion_ids::WEAKNESS_LONG))
            }
            DroppedItemType::SplashPotionSlowFallingLong => {
                Some(ItemType::SplashPotion(potion_ids::SLOW_FALLING_LONG))
            }
            DroppedItemType::WoodenPickaxe => {
                Some(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Wood))
            }
            DroppedItemType::StonePickaxe => {
                Some(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Stone))
            }
            DroppedItemType::IronPickaxe => {
                Some(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Iron))
            }
            DroppedItemType::DiamondPickaxe => {
                Some(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Diamond))
            }
            DroppedItemType::GoldPickaxe => {
                Some(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Gold))
            }
            DroppedItemType::WoodenAxe => Some(ItemType::Tool(ToolType::Axe, ToolMaterial::Wood)),
            DroppedItemType::StoneAxe => Some(ItemType::Tool(ToolType::Axe, ToolMaterial::Stone)),
            DroppedItemType::IronAxe => Some(ItemType::Tool(ToolType::Axe, ToolMaterial::Iron)),
            DroppedItemType::DiamondAxe => {
                Some(ItemType::Tool(ToolType::Axe, ToolMaterial::Diamond))
            }
            DroppedItemType::GoldAxe => Some(ItemType::Tool(ToolType::Axe, ToolMaterial::Gold)),
            DroppedItemType::WoodenShovel => {
                Some(ItemType::Tool(ToolType::Shovel, ToolMaterial::Wood))
            }
            DroppedItemType::StoneShovel => {
                Some(ItemType::Tool(ToolType::Shovel, ToolMaterial::Stone))
            }
            DroppedItemType::IronShovel => {
                Some(ItemType::Tool(ToolType::Shovel, ToolMaterial::Iron))
            }
            DroppedItemType::DiamondShovel => {
                Some(ItemType::Tool(ToolType::Shovel, ToolMaterial::Diamond))
            }
            DroppedItemType::GoldShovel => {
                Some(ItemType::Tool(ToolType::Shovel, ToolMaterial::Gold))
            }
            DroppedItemType::WoodenSword => {
                Some(ItemType::Tool(ToolType::Sword, ToolMaterial::Wood))
            }
            DroppedItemType::StoneSword => {
                Some(ItemType::Tool(ToolType::Sword, ToolMaterial::Stone))
            }
            DroppedItemType::IronSword => Some(ItemType::Tool(ToolType::Sword, ToolMaterial::Iron)),
            DroppedItemType::DiamondSword => {
                Some(ItemType::Tool(ToolType::Sword, ToolMaterial::Diamond))
            }
            DroppedItemType::GoldSword => Some(ItemType::Tool(ToolType::Sword, ToolMaterial::Gold)),
            DroppedItemType::WoodenHoe => Some(ItemType::Tool(ToolType::Hoe, ToolMaterial::Wood)),
            DroppedItemType::StoneHoe => Some(ItemType::Tool(ToolType::Hoe, ToolMaterial::Stone)),
            DroppedItemType::IronHoe => Some(ItemType::Tool(ToolType::Hoe, ToolMaterial::Iron)),
            DroppedItemType::DiamondHoe => {
                Some(ItemType::Tool(ToolType::Hoe, ToolMaterial::Diamond))
            }
            DroppedItemType::GoldHoe => Some(ItemType::Tool(ToolType::Hoe, ToolMaterial::Gold)),
            _ => None,
        }
    }

    pub(crate) fn convert_core_item_type_to_dropped(
        item_type: ItemType,
    ) -> Option<DroppedItemType> {
        use mdminecraft_core::item::FoodType;

        if let Some(armor) = item_type_to_armor_dropped(item_type) {
            return Some(armor);
        }

        match item_type {
            ItemType::Block(block_id) => DroppedItemType::from_placeable_block(block_id),
            ItemType::Food(food) => match food {
                FoodType::Apple => Some(DroppedItemType::Apple),
                FoodType::Bread => Some(DroppedItemType::Bread),
                FoodType::RawMeat => Some(DroppedItemType::RawPork),
                FoodType::CookedMeat => Some(DroppedItemType::CookedPork),
                FoodType::Carrot => Some(DroppedItemType::Carrot),
                FoodType::Potato => Some(DroppedItemType::Potato),
                FoodType::BakedPotato => Some(DroppedItemType::BakedPotato),
                FoodType::GoldenCarrot => Some(DroppedItemType::GoldenCarrot),
            },
            ItemType::Item(id) => match id {
                1 => Some(DroppedItemType::Bow),
                2 => Some(DroppedItemType::Arrow),
                3 => Some(DroppedItemType::Stick),
                4 => Some(DroppedItemType::String),
                5 => Some(DroppedItemType::Flint),
                6 => Some(DroppedItemType::Feather),
                7 => Some(DroppedItemType::IronIngot),
                8 => Some(DroppedItemType::Coal),
                9 => Some(DroppedItemType::GoldIngot),
                14 => Some(DroppedItemType::Diamond),
                15 => Some(DroppedItemType::LapisLazuli),
                16 => Some(DroppedItemType::Bone),
                17 => Some(DroppedItemType::Emerald),
                18 => Some(DroppedItemType::BoneMeal),
                102 => Some(DroppedItemType::Leather),
                103 => Some(DroppedItemType::Wool),
                104 => Some(DroppedItemType::Egg),
                105 => Some(DroppedItemType::Sapling),
                CORE_ITEM_GLASS_BOTTLE => Some(DroppedItemType::GlassBottle),
                CORE_ITEM_WATER_BOTTLE => Some(DroppedItemType::WaterBottle),
                CORE_ITEM_NETHER_WART => Some(DroppedItemType::NetherWart),
                CORE_ITEM_BLAZE_POWDER => Some(DroppedItemType::BlazePowder),
                CORE_ITEM_GUNPOWDER => Some(DroppedItemType::Gunpowder),
                CORE_ITEM_SPIDER_EYE => Some(DroppedItemType::SpiderEye),
                CORE_ITEM_FERMENTED_SPIDER_EYE => Some(DroppedItemType::FermentedSpiderEye),
                CORE_ITEM_SUGAR => Some(DroppedItemType::Sugar),
                CORE_ITEM_MAGMA_CREAM => Some(DroppedItemType::MagmaCream),
                CORE_ITEM_GHAST_TEAR => Some(DroppedItemType::GhastTear),
                CORE_ITEM_GLISTERING_MELON => Some(DroppedItemType::GlisteringMelon),
                CORE_ITEM_RABBIT_FOOT => Some(DroppedItemType::RabbitFoot),
                CORE_ITEM_PHANTOM_MEMBRANE => Some(DroppedItemType::PhantomMembrane),
                CORE_ITEM_REDSTONE_DUST => Some(DroppedItemType::RedstoneDust),
                CORE_ITEM_GLOWSTONE_DUST => Some(DroppedItemType::GlowstoneDust),
                CORE_ITEM_PUFFERFISH => Some(DroppedItemType::Pufferfish),
                CORE_ITEM_NETHER_QUARTZ => Some(DroppedItemType::NetherQuartz),
                CORE_ITEM_BUCKET => Some(DroppedItemType::Bucket),
                CORE_ITEM_WATER_BUCKET => Some(DroppedItemType::WaterBucket),
                CORE_ITEM_LAVA_BUCKET => Some(DroppedItemType::LavaBucket),
                CORE_ITEM_FLINT_AND_STEEL => Some(DroppedItemType::FlintAndSteel),
                CORE_ITEM_ENDER_PEARL => Some(DroppedItemType::EnderPearl),
                CORE_ITEM_EYE_OF_ENDER => Some(DroppedItemType::EyeOfEnder),
                CORE_ITEM_PAPER => Some(DroppedItemType::Paper),
                CORE_ITEM_BOOK => Some(DroppedItemType::Book),
                CORE_ITEM_WHEAT_SEEDS => Some(DroppedItemType::WheatSeeds),
                CORE_ITEM_WHEAT => Some(DroppedItemType::Wheat),
                _ => None,
            },
            ItemType::Tool(tool, material) => Some(match (tool, material) {
                (ToolType::Pickaxe, ToolMaterial::Wood) => DroppedItemType::WoodenPickaxe,
                (ToolType::Pickaxe, ToolMaterial::Stone) => DroppedItemType::StonePickaxe,
                (ToolType::Pickaxe, ToolMaterial::Iron) => DroppedItemType::IronPickaxe,
                (ToolType::Pickaxe, ToolMaterial::Diamond) => DroppedItemType::DiamondPickaxe,
                (ToolType::Pickaxe, ToolMaterial::Gold) => DroppedItemType::GoldPickaxe,
                (ToolType::Axe, ToolMaterial::Wood) => DroppedItemType::WoodenAxe,
                (ToolType::Axe, ToolMaterial::Stone) => DroppedItemType::StoneAxe,
                (ToolType::Axe, ToolMaterial::Iron) => DroppedItemType::IronAxe,
                (ToolType::Axe, ToolMaterial::Diamond) => DroppedItemType::DiamondAxe,
                (ToolType::Axe, ToolMaterial::Gold) => DroppedItemType::GoldAxe,
                (ToolType::Shovel, ToolMaterial::Wood) => DroppedItemType::WoodenShovel,
                (ToolType::Shovel, ToolMaterial::Stone) => DroppedItemType::StoneShovel,
                (ToolType::Shovel, ToolMaterial::Iron) => DroppedItemType::IronShovel,
                (ToolType::Shovel, ToolMaterial::Diamond) => DroppedItemType::DiamondShovel,
                (ToolType::Shovel, ToolMaterial::Gold) => DroppedItemType::GoldShovel,
                (ToolType::Sword, ToolMaterial::Wood) => DroppedItemType::WoodenSword,
                (ToolType::Sword, ToolMaterial::Stone) => DroppedItemType::StoneSword,
                (ToolType::Sword, ToolMaterial::Iron) => DroppedItemType::IronSword,
                (ToolType::Sword, ToolMaterial::Diamond) => DroppedItemType::DiamondSword,
                (ToolType::Sword, ToolMaterial::Gold) => DroppedItemType::GoldSword,
                (ToolType::Hoe, ToolMaterial::Wood) => DroppedItemType::WoodenHoe,
                (ToolType::Hoe, ToolMaterial::Stone) => DroppedItemType::StoneHoe,
                (ToolType::Hoe, ToolMaterial::Iron) => DroppedItemType::IronHoe,
                (ToolType::Hoe, ToolMaterial::Diamond) => DroppedItemType::DiamondHoe,
                (ToolType::Hoe, ToolMaterial::Gold) => DroppedItemType::GoldHoe,
            }),
            ItemType::Potion(id) => match id {
                potion_ids::AWKWARD => Some(DroppedItemType::PotionAwkward),
                potion_ids::NIGHT_VISION => Some(DroppedItemType::PotionNightVision),
                potion_ids::INVISIBILITY => Some(DroppedItemType::PotionInvisibility),
                potion_ids::LEAPING => Some(DroppedItemType::PotionLeaping),
                potion_ids::FIRE_RESISTANCE => Some(DroppedItemType::PotionFireResistance),
                potion_ids::SWIFTNESS => Some(DroppedItemType::PotionSwiftness),
                potion_ids::SLOWNESS => Some(DroppedItemType::PotionSlowness),
                potion_ids::WATER_BREATHING => Some(DroppedItemType::PotionWaterBreathing),
                potion_ids::HEALING => Some(DroppedItemType::PotionHealing),
                potion_ids::HARMING => Some(DroppedItemType::PotionHarming),
                potion_ids::POISON => Some(DroppedItemType::PotionPoison),
                potion_ids::REGENERATION => Some(DroppedItemType::PotionRegeneration),
                potion_ids::STRENGTH => Some(DroppedItemType::PotionStrength),
                potion_ids::WEAKNESS => Some(DroppedItemType::PotionWeakness),
                potion_ids::SLOW_FALLING => Some(DroppedItemType::PotionSlowFalling),
                potion_ids::NIGHT_VISION_LONG => Some(DroppedItemType::PotionNightVisionLong),
                potion_ids::INVISIBILITY_LONG => Some(DroppedItemType::PotionInvisibilityLong),
                potion_ids::LEAPING_LONG => Some(DroppedItemType::PotionLeapingLong),
                potion_ids::LEAPING_STRONG => Some(DroppedItemType::PotionLeapingStrong),
                potion_ids::FIRE_RESISTANCE_LONG => Some(DroppedItemType::PotionFireResistanceLong),
                potion_ids::SWIFTNESS_LONG => Some(DroppedItemType::PotionSwiftnessLong),
                potion_ids::SWIFTNESS_STRONG => Some(DroppedItemType::PotionSwiftnessStrong),
                potion_ids::SLOWNESS_LONG => Some(DroppedItemType::PotionSlownessLong),
                potion_ids::WATER_BREATHING_LONG => Some(DroppedItemType::PotionWaterBreathingLong),
                potion_ids::HEALING_STRONG => Some(DroppedItemType::PotionHealingStrong),
                potion_ids::HARMING_STRONG => Some(DroppedItemType::PotionHarmingStrong),
                potion_ids::POISON_LONG => Some(DroppedItemType::PotionPoisonLong),
                potion_ids::POISON_STRONG => Some(DroppedItemType::PotionPoisonStrong),
                potion_ids::REGENERATION_LONG => Some(DroppedItemType::PotionRegenerationLong),
                potion_ids::REGENERATION_STRONG => Some(DroppedItemType::PotionRegenerationStrong),
                potion_ids::STRENGTH_LONG => Some(DroppedItemType::PotionStrengthLong),
                potion_ids::STRENGTH_STRONG => Some(DroppedItemType::PotionStrengthStrong),
                potion_ids::WEAKNESS_LONG => Some(DroppedItemType::PotionWeaknessLong),
                potion_ids::SLOW_FALLING_LONG => Some(DroppedItemType::PotionSlowFallingLong),
                _ => None,
            },
            ItemType::SplashPotion(id) => match id {
                potion_ids::AWKWARD => Some(DroppedItemType::SplashPotionAwkward),
                potion_ids::NIGHT_VISION => Some(DroppedItemType::SplashPotionNightVision),
                potion_ids::INVISIBILITY => Some(DroppedItemType::SplashPotionInvisibility),
                potion_ids::LEAPING => Some(DroppedItemType::SplashPotionLeaping),
                potion_ids::FIRE_RESISTANCE => Some(DroppedItemType::SplashPotionFireResistance),
                potion_ids::SWIFTNESS => Some(DroppedItemType::SplashPotionSwiftness),
                potion_ids::SLOWNESS => Some(DroppedItemType::SplashPotionSlowness),
                potion_ids::WATER_BREATHING => Some(DroppedItemType::SplashPotionWaterBreathing),
                potion_ids::HEALING => Some(DroppedItemType::SplashPotionHealing),
                potion_ids::HARMING => Some(DroppedItemType::SplashPotionHarming),
                potion_ids::POISON => Some(DroppedItemType::SplashPotionPoison),
                potion_ids::REGENERATION => Some(DroppedItemType::SplashPotionRegeneration),
                potion_ids::STRENGTH => Some(DroppedItemType::SplashPotionStrength),
                potion_ids::WEAKNESS => Some(DroppedItemType::SplashPotionWeakness),
                potion_ids::SLOW_FALLING => Some(DroppedItemType::SplashPotionSlowFalling),
                potion_ids::NIGHT_VISION_LONG => Some(DroppedItemType::SplashPotionNightVisionLong),
                potion_ids::INVISIBILITY_LONG => {
                    Some(DroppedItemType::SplashPotionInvisibilityLong)
                }
                potion_ids::LEAPING_LONG => Some(DroppedItemType::SplashPotionLeapingLong),
                potion_ids::LEAPING_STRONG => Some(DroppedItemType::SplashPotionLeapingStrong),
                potion_ids::FIRE_RESISTANCE_LONG => {
                    Some(DroppedItemType::SplashPotionFireResistanceLong)
                }
                potion_ids::SWIFTNESS_LONG => Some(DroppedItemType::SplashPotionSwiftnessLong),
                potion_ids::SWIFTNESS_STRONG => Some(DroppedItemType::SplashPotionSwiftnessStrong),
                potion_ids::SLOWNESS_LONG => Some(DroppedItemType::SplashPotionSlownessLong),
                potion_ids::WATER_BREATHING_LONG => {
                    Some(DroppedItemType::SplashPotionWaterBreathingLong)
                }
                potion_ids::HEALING_STRONG => Some(DroppedItemType::SplashPotionHealingStrong),
                potion_ids::HARMING_STRONG => Some(DroppedItemType::SplashPotionHarmingStrong),
                potion_ids::POISON_LONG => Some(DroppedItemType::SplashPotionPoisonLong),
                potion_ids::POISON_STRONG => Some(DroppedItemType::SplashPotionPoisonStrong),
                potion_ids::REGENERATION_LONG => {
                    Some(DroppedItemType::SplashPotionRegenerationLong)
                }
                potion_ids::REGENERATION_STRONG => {
                    Some(DroppedItemType::SplashPotionRegenerationStrong)
                }
                potion_ids::STRENGTH_LONG => Some(DroppedItemType::SplashPotionStrengthLong),
                potion_ids::STRENGTH_STRONG => Some(DroppedItemType::SplashPotionStrengthStrong),
                potion_ids::WEAKNESS_LONG => Some(DroppedItemType::SplashPotionWeaknessLong),
                potion_ids::SLOW_FALLING_LONG => Some(DroppedItemType::SplashPotionSlowFallingLong),
                _ => None,
            },
        }
    }
}

fn try_bucket_interaction(
    dimension: DimensionId,
    held_bucket_id: u16,
    hit: RaycastHit,
    chunks: &mut HashMap<ChunkPos, Chunk>,
    fluid_sim: &mut FluidSimulator,
) -> Option<(u16, Vec<IVec3>)> {
    let chunk_and_local = |pos: IVec3| -> Option<(ChunkPos, usize, usize, usize)> {
        let local_y = world_y_to_local_y(pos.y)?;

        let chunk_pos = ChunkPos::new(
            pos.x.div_euclid(CHUNK_SIZE_X as i32),
            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        Some((chunk_pos, local_x, local_y, local_z))
    };

    match held_bucket_id {
        CORE_ITEM_BUCKET => {
            let target_pos = hit.block_pos;
            let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(target_pos)?;
            let voxel = chunks.get(&chunk_pos)?.voxel(local_x, local_y, local_z);

            let picking_up_waterlogged = mdminecraft_world::block_supports_waterlogging(voxel.id)
                && mdminecraft_world::is_waterlogged(voxel.state);

            let new_bucket_id =
                if voxel.id == FluidType::Water.source_block_id() || picking_up_waterlogged {
                    CORE_ITEM_WATER_BUCKET
                } else if voxel.id == FluidType::Lava.source_block_id() {
                    CORE_ITEM_LAVA_BUCKET
                } else {
                    return None;
                };

            {
                let chunk = chunks.get_mut(&chunk_pos)?;
                if picking_up_waterlogged {
                    let new_state = mdminecraft_world::set_waterlogged(voxel.state, false);
                    chunk.set_voxel(
                        local_x,
                        local_y,
                        local_z,
                        Voxel {
                            state: new_state,
                            ..voxel
                        },
                    );
                } else {
                    chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
                }
            }

            fluid_sim.on_fluid_removed(
                FluidPos::new(target_pos.x, target_pos.y, target_pos.z),
                chunks,
            );

            Some((new_bucket_id, vec![target_pos]))
        }
        CORE_ITEM_WATER_BUCKET | CORE_ITEM_LAVA_BUCKET => {
            let fluid_type = if held_bucket_id == CORE_ITEM_WATER_BUCKET {
                FluidType::Water
            } else {
                FluidType::Lava
            };

            if dimension == DimensionId::Nether && fluid_type == FluidType::Water {
                // Vanilla-ish: water evaporates immediately in the Nether.
                return Some((CORE_ITEM_BUCKET, Vec::new()));
            }

            let source_id = fluid_type.source_block_id();

            // Foundation support: allow waterlogging slabs.
            if fluid_type == FluidType::Water {
                let target_pos = hit.block_pos;
                let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(target_pos)?;
                let voxel = chunks.get(&chunk_pos)?.voxel(local_x, local_y, local_z);
                if mdminecraft_world::block_supports_waterlogging(voxel.id)
                    && !mdminecraft_world::is_waterlogged(voxel.state)
                {
                    {
                        let chunk = chunks.get_mut(&chunk_pos)?;
                        let new_state = mdminecraft_world::set_waterlogged(voxel.state, true);
                        chunk.set_voxel(
                            local_x,
                            local_y,
                            local_z,
                            Voxel {
                                state: new_state,
                                ..voxel
                            },
                        );
                    }

                    fluid_sim.on_fluid_placed(
                        FluidPos::new(target_pos.x, target_pos.y, target_pos.z),
                        FluidType::Water,
                    );

                    return Some((CORE_ITEM_BUCKET, vec![target_pos]));
                }
            }

            let place_pos = hit.block_pos + hit.face_normal;
            let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(place_pos)?;
            let voxel = chunks.get(&chunk_pos)?.voxel(local_x, local_y, local_z);

            if fluid_type == FluidType::Water
                && mdminecraft_world::block_supports_waterlogging(voxel.id)
                && !mdminecraft_world::is_waterlogged(voxel.state)
            {
                {
                    let chunk = chunks.get_mut(&chunk_pos)?;
                    let new_state = mdminecraft_world::set_waterlogged(voxel.state, true);
                    chunk.set_voxel(
                        local_x,
                        local_y,
                        local_z,
                        Voxel {
                            state: new_state,
                            ..voxel
                        },
                    );
                }

                fluid_sim.on_fluid_placed(
                    FluidPos::new(place_pos.x, place_pos.y, place_pos.z),
                    FluidType::Water,
                );

                return Some((CORE_ITEM_BUCKET, vec![place_pos]));
            }

            if voxel.id != BLOCK_AIR
                && voxel.id != mdminecraft_world::BLOCK_FIRE
                && get_fluid_type(voxel.id).is_none()
            {
                return None;
            }

            {
                let chunk = chunks.get_mut(&chunk_pos)?;
                chunk.set_voxel(
                    local_x,
                    local_y,
                    local_z,
                    Voxel {
                        id: source_id,
                        state: 0,
                        light_sky: 0,
                        light_block: 0,
                    },
                );
            }

            fluid_sim.on_fluid_placed(
                FluidPos::new(place_pos.x, place_pos.y, place_pos.z),
                fluid_type,
            );

            Some((CORE_ITEM_BUCKET, vec![place_pos]))
        }
        _ => None,
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PortalAxis {
    X,
    Z,
}

impl PortalAxis {
    fn to_state(self) -> BlockState {
        match self {
            PortalAxis::X => 0,
            PortalAxis::Z => 1,
        }
    }
}

fn portal_axis_from_state(state: BlockState) -> PortalAxis {
    if (state & 0x01) != 0 {
        PortalAxis::Z
    } else {
        PortalAxis::X
    }
}

fn try_activate_nether_portal(
    chunks: &mut HashMap<ChunkPos, Chunk>,
    ignition_pos: IVec3,
) -> Option<Vec<IVec3>> {
    let chunk_and_local = |pos: IVec3| -> Option<(ChunkPos, usize, usize, usize)> {
        let local_y = world_y_to_local_y(pos.y)?;

        let chunk_pos = ChunkPos::new(
            pos.x.div_euclid(CHUNK_SIZE_X as i32),
            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        Some((chunk_pos, local_x, local_y, local_z))
    };

    let voxel_id_at = |pos: IVec3| -> Option<BlockId> {
        let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(pos)?;
        Some(chunks.get(&chunk_pos)?.voxel(local_x, local_y, local_z).id)
    };

    let set_voxel = |chunks: &mut HashMap<ChunkPos, Chunk>,
                     pos: IVec3,
                     id: BlockId,
                     state: BlockState|
     -> Option<()> {
        let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(pos)?;
        let chunk = chunks.get_mut(&chunk_pos)?;
        chunk.set_voxel(
            local_x,
            local_y,
            local_z,
            Voxel {
                id,
                state,
                light_sky: 0,
                light_block: 0,
            },
        );
        Some(())
    };

    // Only allow igniting in empty space (or re-lighting existing portal blocks).
    match voxel_id_at(ignition_pos)? {
        BLOCK_AIR | BLOCK_NETHER_PORTAL => {}
        _ => return None,
    }

    let frame_matches = |origin: IVec3, axis: PortalAxis| -> bool {
        if origin.y < WORLD_MIN_Y || origin.y + 4 > WORLD_MAX_Y {
            return false;
        }

        for w in 0..4 {
            for h in 0..5 {
                let pos = match axis {
                    PortalAxis::X => IVec3::new(origin.x + w, origin.y + h, origin.z),
                    PortalAxis::Z => IVec3::new(origin.x, origin.y + h, origin.z + w),
                };

                let Some(id) = voxel_id_at(pos) else {
                    return false;
                };

                let is_border = w == 0 || w == 3 || h == 0 || h == 4;
                if is_border {
                    if id != BLOCK_OBSIDIAN {
                        return false;
                    }
                } else if id != BLOCK_AIR && id != BLOCK_NETHER_PORTAL {
                    return false;
                }
            }
        }

        true
    };

    for axis in [PortalAxis::X, PortalAxis::Z] {
        for offset_w in 0..=1 {
            for offset_h in 0..=2 {
                let origin = match axis {
                    PortalAxis::X => IVec3::new(
                        ignition_pos.x - 1 - offset_w,
                        ignition_pos.y - 1 - offset_h,
                        ignition_pos.z,
                    ),
                    PortalAxis::Z => IVec3::new(
                        ignition_pos.x,
                        ignition_pos.y - 1 - offset_h,
                        ignition_pos.z - 1 - offset_w,
                    ),
                };

                if !frame_matches(origin, axis) {
                    continue;
                }

                let state = axis.to_state();
                let mut changed = Vec::with_capacity(6);
                for w in 1..=2 {
                    for h in 1..=3 {
                        let pos = match axis {
                            PortalAxis::X => IVec3::new(origin.x + w, origin.y + h, origin.z),
                            PortalAxis::Z => IVec3::new(origin.x, origin.y + h, origin.z + w),
                        };

                        set_voxel(chunks, pos, BLOCK_NETHER_PORTAL, state)?;
                        changed.push(pos);
                    }
                }

                return Some(changed);
            }
        }
    }

    None
}

fn try_activate_end_portal(
    chunks: &mut HashMap<ChunkPos, Chunk>,
    frame_pos: IVec3,
) -> Option<Vec<IVec3>> {
    let chunk_and_local = |pos: IVec3| -> Option<(ChunkPos, usize, usize, usize)> {
        let local_y = world_y_to_local_y(pos.y)?;

        let chunk_pos = ChunkPos::new(
            pos.x.div_euclid(CHUNK_SIZE_X as i32),
            pos.z.div_euclid(CHUNK_SIZE_Z as i32),
        );
        let local_x = pos.x.rem_euclid(CHUNK_SIZE_X as i32) as usize;
        let local_z = pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as usize;
        Some((chunk_pos, local_x, local_y, local_z))
    };

    let voxel_at = |pos: IVec3| -> Option<Voxel> {
        let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(pos)?;
        Some(chunks.get(&chunk_pos)?.voxel(local_x, local_y, local_z))
    };

    let set_voxel =
        |chunks: &mut HashMap<ChunkPos, Chunk>, pos: IVec3, voxel: Voxel| -> Option<()> {
            let (chunk_pos, local_x, local_y, local_z) = chunk_and_local(pos)?;
            let chunk = chunks.get_mut(&chunk_pos)?;
            chunk.set_voxel(local_x, local_y, local_z, voxel);
            Some(())
        };

    let has_eye = |voxel: Voxel| -> bool { (voxel.state & 0x01) != 0 };

    // Look for a 5x5 ring of filled portal frames surrounding a 3x3 interior.
    for offset_x in 0..=4 {
        for offset_z in 0..=4 {
            let origin = IVec3::new(frame_pos.x - offset_x, frame_pos.y, frame_pos.z - offset_z);
            let mut ok = true;

            for dx in 0..=4 {
                for dz in 0..=4 {
                    let pos = IVec3::new(origin.x + dx, origin.y, origin.z + dz);
                    let Some(voxel) = voxel_at(pos) else {
                        ok = false;
                        break;
                    };

                    let is_border = dx == 0 || dx == 4 || dz == 0 || dz == 4;
                    if is_border {
                        if voxel.id != BLOCK_END_PORTAL_FRAME || !has_eye(voxel) {
                            ok = false;
                            break;
                        }
                    } else if voxel.id != BLOCK_AIR && voxel.id != BLOCK_END_PORTAL {
                        ok = false;
                        break;
                    }
                }
                if !ok {
                    break;
                }
            }

            if !ok {
                continue;
            }

            let mut changed = Vec::with_capacity(9);
            for dx in 1..=3 {
                for dz in 1..=3 {
                    let pos = IVec3::new(origin.x + dx, origin.y, origin.z + dz);
                    set_voxel(
                        chunks,
                        pos,
                        Voxel {
                            id: BLOCK_END_PORTAL,
                            state: 0,
                            light_sky: 0,
                            light_block: 0,
                        },
                    )?;
                    changed.push(pos);
                }
            }

            return Some(changed);
        }
    }

    None
}

fn render_hotbar(ctx: &egui::Context, hotbar: &Hotbar, registry: &BlockRegistry) {
    egui::Area::new(egui::Id::new("hotbar"))
        .anchor(egui::Align2::CENTER_BOTTOM, [0.0, -20.0])
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                for i in 0..9 {
                    let is_selected = i == hotbar.selected;
                    let item_stack = hotbar.slots[i].as_ref();
                    let item_name = hotbar.item_name(item_stack, registry);

                    let frame = if is_selected {
                        egui::Frame::none()
                            .fill(egui::Color32::from_rgba_unmultiplied(80, 80, 80, 200))
                            .stroke(egui::Stroke::new(3.0, egui::Color32::WHITE))
                            .inner_margin(8.0)
                    } else {
                        egui::Frame::none()
                            .fill(egui::Color32::from_rgba_unmultiplied(40, 40, 40, 180))
                            .stroke(egui::Stroke::new(1.0, egui::Color32::DARK_GRAY))
                            .inner_margin(8.0)
                    };

                    let inner = frame.show(ui, |ui| {
                        ui.set_min_size(egui::vec2(60.0, 60.0));
                        ui.vertical_centered(|ui| {
                            ui.label(egui::RichText::new(format!("{}", i + 1)).size(10.0).color(
                                if is_selected {
                                    egui::Color32::WHITE
                                } else {
                                    egui::Color32::GRAY
                                },
                            ));
                            ui.label(egui::RichText::new(&item_name).size(8.0).color(
                                if is_selected {
                                    egui::Color32::WHITE
                                } else {
                                    egui::Color32::LIGHT_GRAY
                                },
                            ));

                            // Show count.
                            if let Some(stack) = item_stack {
                                match stack.item_type {
                                    ItemType::Tool(_, _) => {}
                                    ItemType::Block(_)
                                    | ItemType::Item(_)
                                    | ItemType::Food(_)
                                    | ItemType::Potion(_)
                                    | ItemType::SplashPotion(_) => {
                                        if stack.count > 1 {
                                            ui.label(
                                                egui::RichText::new(format!("x{}", stack.count))
                                                    .size(9.0)
                                                    .color(egui::Color32::WHITE),
                                            );
                                        }
                                    }
                                }
                            }
                        });
                    });

                    if let Some(stack) = item_stack {
                        if let (Some(current), Some(max)) =
                            (stack.durability, stack.max_durability())
                        {
                            paint_durability_bar(ui, inner.response.rect, current, max);
                        }

                        let mut tooltip = item_name.clone();
                        tooltip.push_str(&format!("\nCount: {}", stack.count));
                        if let (Some(current), Some(max)) =
                            (stack.durability, stack.max_durability())
                        {
                            tooltip.push_str(&format!("\nDurability: {}/{}", current, max));
                        }
                        let enchants = stack.get_enchantments();
                        if !enchants.is_empty() {
                            tooltip.push_str("\nEnchantments:");
                            for enchant in enchants {
                                tooltip.push_str(&format!(
                                    "\n- {:?} {}",
                                    enchant.enchantment_type, enchant.level
                                ));
                            }
                        }
                        let _ = inner.response.on_hover_text(tooltip);
                    } else {
                        let _ = inner.response.on_hover_text("Empty");
                    }
                }
            });
        });
}

fn paint_durability_bar(ui: &egui::Ui, rect: egui::Rect, current: u32, max: u32) {
    if max == 0 {
        return;
    }

    let fraction = (current as f32 / max as f32).clamp(0.0, 1.0);
    let padding = 4.0;
    let height = 4.0;

    let max_width = (rect.width() - 2.0 * padding).max(0.0);
    let width = max_width * fraction;

    let bg_rect = egui::Rect::from_min_size(
        egui::pos2(rect.min.x + padding, rect.max.y - padding - height),
        egui::vec2(max_width, height),
    );
    let fg_rect = egui::Rect::from_min_size(
        egui::pos2(rect.min.x + padding, rect.max.y - padding - height),
        egui::vec2(width, height),
    );

    let color = if fraction < 0.2 {
        egui::Color32::from_rgb(220, 60, 60)
    } else if fraction < 0.5 {
        egui::Color32::from_rgb(230, 200, 70)
    } else {
        egui::Color32::from_rgb(80, 200, 80)
    };

    ui.painter().rect_filled(
        bg_rect,
        0.0,
        egui::Color32::from_rgba_unmultiplied(0, 0, 0, 120),
    );
    ui.painter().rect_filled(fg_rect, 0.0, color);
}

fn render_health_bar(ctx: &egui::Context, health: &PlayerHealth) {
    egui::Area::new(egui::Id::new("health_bar"))
        .anchor(egui::Align2::LEFT_BOTTOM, [10.0, -70.0])
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                // Draw hearts
                let max_hearts = (health.max / 2.0) as i32; // 20 health = 10 hearts
                let current_hearts = health.current / 2.0;

                for i in 0..max_hearts {
                    let heart_value = current_hearts - i as f32;
                    let (symbol, color) = if heart_value >= 1.0 {
                        ("", egui::Color32::from_rgb(255, 0, 0)) // Full heart - red
                    } else if heart_value >= 0.5 {
                        ("", egui::Color32::from_rgb(200, 0, 0)) // Half heart - darker red
                    } else {
                        ("", egui::Color32::from_rgb(100, 100, 100)) // Empty heart - gray
                    };

                    ui.label(egui::RichText::new(symbol).size(20.0).color(color));
                }

                // Show numerical health
                ui.add_space(10.0);
                let health_text = format!("{:.1}/{:.0}", health.current, health.max);
                let text_color = if health.current < 6.0 {
                    egui::Color32::RED
                } else if health.current < 10.0 {
                    egui::Color32::YELLOW
                } else {
                    egui::Color32::WHITE
                };
                ui.label(
                    egui::RichText::new(health_text)
                        .size(14.0)
                        .color(text_color),
                );
            });
        });
}

/// Render the hunger bar (10 shanks on the right side)
fn render_hunger_bar(ctx: &egui::Context, health: &PlayerHealth) {
    egui::Area::new(egui::Id::new("hunger_bar"))
        .anchor(egui::Align2::RIGHT_BOTTOM, [-10.0, -70.0])
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                // Show numerical hunger
                let hunger_text = format!("{:.1}/{:.0}", health.hunger, health.max_hunger);
                let text_color = if health.hunger < 6.0 {
                    egui::Color32::RED
                } else if health.hunger < 10.0 {
                    egui::Color32::YELLOW
                } else {
                    egui::Color32::WHITE
                };
                ui.label(
                    egui::RichText::new(hunger_text)
                        .size(14.0)
                        .color(text_color),
                );

                ui.add_space(10.0);

                // Draw shanks (drumsticks)
                let max_shanks = (health.max_hunger / 2.0) as i32; // 20 hunger = 10 shanks
                let current_shanks = health.hunger / 2.0;

                for i in 0..max_shanks {
                    let shank_value = current_shanks - i as f32;
                    let (symbol, color) = if shank_value >= 1.0 {
                        ("", egui::Color32::from_rgb(200, 150, 100)) // Full shank - brown
                    } else if shank_value >= 0.5 {
                        ("", egui::Color32::from_rgb(150, 100, 50)) // Half shank - darker
                    } else {
                        ("", egui::Color32::from_rgb(100, 100, 100)) // Empty - bone/gray
                    };

                    ui.label(egui::RichText::new(symbol).size(18.0).color(color));
                }
            });
        });
}

/// Render the armor bar (above health bar)
fn render_armor_bar(ctx: &egui::Context, armor: &PlayerArmor) {
    let defense = armor.total_defense();

    // Only show if player has armor equipped
    if defense > 0 {
        egui::Area::new(egui::Id::new("armor_bar"))
            .anchor(egui::Align2::LEFT_BOTTOM, [10.0, -100.0])
            .show(ctx, |ui| {
                ui.horizontal(|ui| {
                    // Draw armor icons (10 max, each represents 2 defense)
                    let max_icons = 10;
                    let filled_icons = (defense as f32 / 2.0).ceil() as u32;

                    for i in 0..max_icons {
                        let icon_value = defense.saturating_sub(i * 2);
                        let (symbol, color) = if icon_value >= 2 {
                            ("", egui::Color32::from_rgb(220, 220, 220)) // Full armor
                        } else if icon_value >= 1 {
                            ("", egui::Color32::from_rgb(150, 150, 150)) // Half armor
                        } else {
                            ("", egui::Color32::from_rgb(60, 60, 60)) // Empty
                        };

                        if i < filled_icons || icon_value > 0 {
                            ui.label(egui::RichText::new(symbol).size(16.0).color(color));
                        }
                    }

                    ui.add_space(5.0);

                    // Show defense value
                    ui.label(
                        egui::RichText::new(format!("{} defense", defense))
                            .size(12.0)
                            .color(egui::Color32::from_rgb(180, 180, 180)),
                    );
                });

                // Show individual armor pieces with durability
                ui.horizontal(|ui| {
                    if let Some(piece) = armor.get(ArmorSlot::Helmet) {
                        render_armor_piece_icon(ui, "H", piece.durability_ratio());
                    }
                    if let Some(piece) = armor.get(ArmorSlot::Chestplate) {
                        render_armor_piece_icon(ui, "C", piece.durability_ratio());
                    }
                    if let Some(piece) = armor.get(ArmorSlot::Leggings) {
                        render_armor_piece_icon(ui, "L", piece.durability_ratio());
                    }
                    if let Some(piece) = armor.get(ArmorSlot::Boots) {
                        render_armor_piece_icon(ui, "B", piece.durability_ratio());
                    }
                });
            });
    }
}

/// Render a small armor piece icon with durability indicator
fn render_armor_piece_icon(ui: &mut egui::Ui, label: &str, durability_ratio: f32) {
    let color = if durability_ratio > 0.5 {
        egui::Color32::from_rgb(100, 200, 100) // Green
    } else if durability_ratio > 0.25 {
        egui::Color32::from_rgb(200, 200, 100) // Yellow
    } else {
        egui::Color32::from_rgb(200, 100, 100) // Red
    };

    let frame = egui::Frame::none()
        .fill(egui::Color32::from_rgba_unmultiplied(40, 40, 40, 180))
        .stroke(egui::Stroke::new(1.0, color))
        .inner_margin(2.0);

    frame.show(ui, |ui| {
        ui.label(egui::RichText::new(label).size(10.0).color(color));
    });
}

/// Render tool durability bar (only shows when a tool is selected)
fn render_tool_durability(ctx: &egui::Context, hotbar: &Hotbar) {
    // Check if selected item is a tool with durability
    if let Some(item) = hotbar.selected_item() {
        if let ItemType::Tool(tool_type, material) = item.item_type {
            if let Some(durability) = item.durability {
                let max_durability = item.max_durability().unwrap_or(1);
                let percent = (durability as f32 / max_durability as f32 * 100.0) as u32;

                egui::Area::new(egui::Id::new("tool_durability"))
                    .anchor(egui::Align2::CENTER_BOTTOM, [0.0, -90.0])
                    .show(ctx, |ui| {
                        ui.horizontal(|ui| {
                            // Tool icon/name
                            let tool_name = match tool_type {
                                ToolType::Pickaxe => "",
                                ToolType::Axe => "",
                                ToolType::Shovel => "",
                                ToolType::Sword => "",
                                ToolType::Hoe => "",
                            };
                            let material_name = match material {
                                ToolMaterial::Wood => "Wood",
                                ToolMaterial::Stone => "Stone",
                                ToolMaterial::Iron => "Iron",
                                ToolMaterial::Gold => "Gold",
                                ToolMaterial::Diamond => "Diamond",
                            };

                            ui.label(
                                egui::RichText::new(format!("{} {} ", tool_name, material_name))
                                    .size(12.0)
                                    .color(egui::Color32::WHITE),
                            );

                            // Durability bar
                            let bar_width = 80.0;
                            let bar_height = 8.0;
                            let bar_color = if percent > 50 {
                                egui::Color32::GREEN
                            } else if percent > 20 {
                                egui::Color32::YELLOW
                            } else {
                                egui::Color32::RED
                            };

                            let (response, painter) = ui.allocate_painter(
                                egui::vec2(bar_width, bar_height),
                                egui::Sense::hover(),
                            );
                            let rect = response.rect;

                            // Background
                            painter.rect_filled(rect, 2.0, egui::Color32::from_rgb(40, 40, 40));

                            // Foreground (durability)
                            let fill_width = bar_width * (percent as f32 / 100.0);
                            painter.rect_filled(
                                egui::Rect::from_min_size(
                                    rect.min,
                                    egui::vec2(fill_width, bar_height),
                                ),
                                2.0,
                                bar_color,
                            );

                            // Border
                            painter.rect_stroke(
                                rect,
                                2.0,
                                egui::Stroke::new(1.0, egui::Color32::GRAY),
                            );

                            // Percentage text
                            ui.label(
                                egui::RichText::new(format!(" {}%", percent))
                                    .size(10.0)
                                    .color(bar_color),
                            );
                        });
                    });
            }
        }
    }
}

fn render_status_effects_overlay(ctx: &egui::Context, effects: &StatusEffects) {
    fn effect_name(effect_type: StatusEffectType) -> &'static str {
        match effect_type {
            StatusEffectType::Speed => "Speed",
            StatusEffectType::Haste => "Haste",
            StatusEffectType::Strength => "Strength",
            StatusEffectType::InstantHealth => "Instant Health",
            StatusEffectType::JumpBoost => "Jump Boost",
            StatusEffectType::Regeneration => "Regeneration",
            StatusEffectType::Resistance => "Resistance",
            StatusEffectType::FireResistance => "Fire Resistance",
            StatusEffectType::WaterBreathing => "Water Breathing",
            StatusEffectType::Invisibility => "Invisibility",
            StatusEffectType::NightVision => "Night Vision",
            StatusEffectType::Absorption => "Absorption",
            StatusEffectType::Saturation => "Saturation",
            StatusEffectType::SlowFalling => "Slow Falling",
            StatusEffectType::Luck => "Luck",
            StatusEffectType::Slowness => "Slowness",
            StatusEffectType::MiningFatigue => "Mining Fatigue",
            StatusEffectType::InstantDamage => "Instant Damage",
            StatusEffectType::Nausea => "Nausea",
            StatusEffectType::Blindness => "Blindness",
            StatusEffectType::Hunger => "Hunger",
            StatusEffectType::Weakness => "Weakness",
            StatusEffectType::Poison => "Poison",
            StatusEffectType::Wither => "Wither",
            StatusEffectType::BadLuck => "Bad Luck",
        }
    }

    fn roman(level: u8) -> &'static str {
        match level {
            1 => "I",
            2 => "II",
            3 => "III",
            4 => "IV",
            5 => "V",
            6 => "VI",
            7 => "VII",
            8 => "VIII",
            9 => "IX",
            10 => "X",
            _ => "",
        }
    }

    fn format_duration_ticks(ticks: u32) -> String {
        let seconds = ticks / 20;
        let minutes = seconds / 60;
        let seconds = seconds % 60;
        format!("{}:{:02}", minutes, seconds)
    }

    if effects.is_empty() {
        return;
    }

    let mut active: Vec<_> = effects.iter().copied().collect();
    active.sort_by_key(|effect| {
        (
            u8::from(!effect.effect_type.is_positive()),
            effect_name(effect.effect_type),
        )
    });

    egui::Area::new(egui::Id::new("status_effects"))
        .anchor(egui::Align2::RIGHT_TOP, [-10.0, 10.0])
        .show(ctx, |ui| {
            let frame = egui::Frame::none()
                .fill(egui::Color32::from_rgba_unmultiplied(15, 15, 15, 160))
                .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgb(60, 60, 60)))
                .inner_margin(egui::Margin::same(6.0));

            frame.show(ui, |ui| {
                ui.set_min_width(185.0);
                ui.vertical(|ui| {
                    for effect in active {
                        let name = effect_name(effect.effect_type);
                        let is_positive = effect.effect_type.is_positive();
                        let color = if is_positive {
                            egui::Color32::from_rgb(120, 220, 120)
                        } else {
                            egui::Color32::from_rgb(235, 120, 120)
                        };

                        let level = effect.level();
                        let level_suffix = if effect.effect_type.max_amplifier() == 0 {
                            String::new()
                        } else {
                            let roman = roman(level);
                            if roman.is_empty() {
                                format!(" {}", level)
                            } else {
                                format!(" {}", roman)
                            }
                        };

                        let duration = if effect.duration_ticks == 0 {
                            String::new()
                        } else {
                            format_duration_ticks(effect.duration_ticks)
                        };

                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            if !duration.is_empty() {
                                ui.label(
                                    egui::RichText::new(duration)
                                        .size(11.0)
                                        .color(egui::Color32::GRAY),
                                );
                                ui.add_space(8.0);
                            }

                            ui.label(
                                egui::RichText::new(format!("{}{}", name, level_suffix))
                                    .size(12.0)
                                    .color(color),
                            );
                        });
                    }
                });
            });
        });
}

/// Render the XP bar above the hotbar
fn render_xp_bar(ctx: &egui::Context, xp: &PlayerXP) {
    egui::Area::new(egui::Id::new("xp_bar"))
        .anchor(egui::Align2::CENTER_BOTTOM, [0.0, -85.0])
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                // XP bar background and foreground
                let bar_width = 182.0; // Match hotbar width roughly
                let bar_height = 5.0;

                let (response, painter) =
                    ui.allocate_painter(egui::vec2(bar_width, bar_height), egui::Sense::hover());
                let rect = response.rect;

                // Background (dark)
                painter.rect_filled(rect, 2.0, egui::Color32::from_rgb(20, 20, 20));

                // Foreground (green XP progress)
                let fill_width = bar_width * xp.progress();
                if fill_width > 0.0 {
                    painter.rect_filled(
                        egui::Rect::from_min_size(rect.min, egui::vec2(fill_width, bar_height)),
                        2.0,
                        egui::Color32::from_rgb(128, 255, 32), // Bright green
                    );
                }

                // Border
                painter.rect_stroke(
                    rect,
                    2.0,
                    egui::Stroke::new(1.0, egui::Color32::from_rgb(60, 60, 60)),
                );
            });

            // Level number centered above the bar
            if xp.level > 0 {
                ui.vertical_centered(|ui| {
                    ui.label(
                        egui::RichText::new(format!("{}", xp.level))
                            .size(12.0)
                            .color(egui::Color32::from_rgb(128, 255, 32))
                            .strong(),
                    );
                });
            }
        });
}

fn render_boss_bar(ctx: &egui::Context, name: &str, health: f32, max_health: f32) {
    let ratio = if max_health > 0.0 {
        (health / max_health).clamp(0.0, 1.0)
    } else {
        0.0
    };

    egui::Area::new(egui::Id::new("boss_bar"))
        .anchor(egui::Align2::CENTER_TOP, [0.0, 10.0])
        .show(ctx, |ui| {
            let bar_width = 360.0;
            let bar_height = 12.0;

            ui.vertical_centered(|ui| {
                ui.label(
                    egui::RichText::new(name)
                        .size(16.0)
                        .color(egui::Color32::from_rgb(220, 160, 255))
                        .strong(),
                );

                let (response, painter) =
                    ui.allocate_painter(egui::vec2(bar_width, bar_height), egui::Sense::hover());
                let rect = response.rect;

                painter.rect_filled(rect, 3.0, egui::Color32::from_rgb(40, 10, 50));

                let fill_width = bar_width * ratio;
                if fill_width > 0.0 {
                    painter.rect_filled(
                        egui::Rect::from_min_size(rect.min, egui::vec2(fill_width, bar_height)),
                        3.0,
                        egui::Color32::from_rgb(170, 60, 200),
                    );
                }

                painter.rect_stroke(
                    rect,
                    3.0,
                    egui::Stroke::new(1.0, egui::Color32::from_rgb(80, 80, 80)),
                );
            });
        });
}

fn render_pause_menu(
    ctx: &egui::Context,
    view: &mut PauseMenuView,
    controls: &mut Arc<ControlsConfig>,
    controls_dirty: &mut bool,
    fov_degrees: &mut f32,
    render_distance: &mut i32,
    bindings_changed: &mut bool,
) -> PauseMenuAction {
    let mut action = PauseMenuAction::None;

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("pause_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    egui::Window::new(match view {
        PauseMenuView::Main => "Game Menu",
        PauseMenuView::Options => "Options",
    })
    .collapsible(false)
    .resizable(false)
    .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
    .show(ctx, |ui| {
        ui.set_min_width(420.0);

        match view {
            PauseMenuView::Main => {
                ui.vertical_centered(|ui| {
                    ui.add_space(10.0);
                    ui.label(egui::RichText::new("Paused").size(22.0).strong());
                    ui.add_space(10.0);

                    let button = |text: &str| {
                        egui::Button::new(egui::RichText::new(text).size(16.0))
                            .min_size(egui::vec2(260.0, 38.0))
                    };

                    if ui.add(button("Resume Game")).clicked() {
                        action = PauseMenuAction::Resume;
                    }
                    if ui.add(button("Options...")).clicked() {
                        *view = PauseMenuView::Options;
                    }
                    if ui.add(button("Save & Quit to Title")).clicked() {
                        action = PauseMenuAction::ReturnToMenu;
                    }
                    if ui.add(button("Quit Game")).clicked() {
                        action = PauseMenuAction::Quit;
                    }

                    ui.add_space(8.0);
                    ui.label(
                        egui::RichText::new("Press Esc to resume")
                            .size(11.0)
                            .color(egui::Color32::GRAY),
                    );
                });
            }
            PauseMenuView::Options => {
                ui.label(
                    egui::RichText::new("Controls")
                        .size(18.0)
                        .color(egui::Color32::WHITE),
                );
                ui.add_space(6.0);

                let mut next_controls = (**controls).clone();
                let mut changed_controls = false;

                let mut sensitivity = next_controls.mouse_sensitivity;
                if ui
                    .add(
                        egui::Slider::new(&mut sensitivity, 0.001..=0.02)
                            .text("Mouse Sensitivity")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.mouse_sensitivity = sensitivity;
                    changed_controls = true;
                }

                let mut invert_y = next_controls.invert_y;
                if ui.checkbox(&mut invert_y, "Invert Y").changed() {
                    next_controls.invert_y = invert_y;
                    changed_controls = true;
                }

                ui.add_space(12.0);
                ui.separator();
                ui.add_space(10.0);

                ui.label(
                    egui::RichText::new("Keybinds")
                        .size(18.0)
                        .color(egui::Color32::WHITE),
                );
                ui.add_space(6.0);

                let key_options: &[(&str, &str)] = &[
                    ("KeyW", "W"),
                    ("KeyA", "A"),
                    ("KeyS", "S"),
                    ("KeyD", "D"),
                    ("KeyQ", "Q"),
                    ("KeyE", "E"),
                    ("KeyR", "R"),
                    ("KeyF", "F"),
                    ("KeyC", "C"),
                    ("KeyV", "V"),
                    ("Space", "Space"),
                    ("ShiftLeft", "Left Shift"),
                    ("ControlLeft", "Left Ctrl"),
                    ("Tab", "Tab"),
                    ("F3", "F3"),
                    ("F4", "F4"),
                    ("Digit1", "1"),
                    ("Digit2", "2"),
                    ("Digit3", "3"),
                    ("Digit4", "4"),
                    ("Digit5", "5"),
                    ("Digit6", "6"),
                    ("Digit7", "7"),
                    ("Digit8", "8"),
                    ("Digit9", "9"),
                ];

                let token_label = |token: &str| -> String {
                    key_options
                        .iter()
                        .find_map(|(key, label)| (*key == token).then_some(*label))
                        .map(|label| label.to_string())
                        .unwrap_or_else(|| token.to_string())
                };

                let rows: &[(&str, &str, &str)] = &[
                    ("Forward", "MoveForward", "KeyW"),
                    ("Back", "MoveBackward", "KeyS"),
                    ("Left", "MoveLeft", "KeyA"),
                    ("Right", "MoveRight", "KeyD"),
                    ("Jump", "Jump", "Space"),
                    ("Sprint", "Sprint", "ControlLeft"),
                    ("Crouch", "Crouch", "ShiftLeft"),
                    ("Drop Item", "DropItem", "KeyQ"),
                    ("Toggle Cursor", "ToggleCursor", "Tab"),
                    ("Toggle Fly", "ToggleFly", "F4"),
                ];

                for (label, action_name, default_token) in rows {
                    ui.horizontal(|ui| {
                        ui.label(
                            egui::RichText::new(*label)
                                .size(13.0)
                                .color(egui::Color32::LIGHT_GRAY),
                        );
                        ui.add_space(10.0);

                        let current_override = next_controls
                            .bindings
                            .base
                            .get(*action_name)
                            .and_then(|list| list.first())
                            .cloned();
                        let mut selection: Option<String> = current_override.clone();

                        let selected_text = if let Some(token) = current_override.as_deref() {
                            token_label(token)
                        } else {
                            format!("Default ({})", token_label(default_token))
                        };

                        egui::ComboBox::from_id_source(("bind", action_name))
                            .selected_text(selected_text)
                            .show_ui(ui, |ui| {
                                ui.selectable_value(
                                    &mut selection,
                                    None,
                                    format!("Default ({})", token_label(default_token)),
                                );
                                for (token, display) in key_options {
                                    ui.selectable_value(
                                        &mut selection,
                                        Some((*token).to_string()),
                                        (*display).to_string(),
                                    );
                                }
                            });

                        if selection != current_override {
                            match selection {
                                None => {
                                    next_controls.bindings.base.remove(*action_name);
                                }
                                Some(token) => {
                                    next_controls
                                        .bindings
                                        .base
                                        .insert((*action_name).to_string(), vec![token]);
                                }
                            }
                            changed_controls = true;
                            *bindings_changed = true;
                        }
                    });
                }

                ui.add_space(4.0);
                ui.label(
                    egui::RichText::new("Keybinds are limited to a fixed set for determinism.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );

                ui.add_space(12.0);
                ui.separator();
                ui.add_space(10.0);

                ui.label(
                    egui::RichText::new("Video")
                        .size(18.0)
                        .color(egui::Color32::WHITE),
                );
                ui.add_space(6.0);

                if ui
                    .add(
                        egui::Slider::new(fov_degrees, 60.0..=110.0)
                            .text("Field of View")
                            .suffix("")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.fov_degrees = *fov_degrees;
                    changed_controls = true;
                }

                if ui
                    .add(
                        egui::Slider::new(render_distance, 2..=16)
                            .text("Render Distance")
                            .suffix(" chunks")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.render_distance = *render_distance;
                    changed_controls = true;
                }

                ui.add_space(12.0);
                ui.separator();
                ui.add_space(10.0);

                ui.label(
                    egui::RichText::new("Audio")
                        .size(18.0)
                        .color(egui::Color32::WHITE),
                );
                ui.add_space(6.0);

                let mut audio_muted = next_controls.audio_muted;
                if ui.checkbox(&mut audio_muted, "Mute").changed() {
                    next_controls.audio_muted = audio_muted;
                    changed_controls = true;
                }

                let mut master_volume = next_controls.master_volume;
                if ui
                    .add(
                        egui::Slider::new(&mut master_volume, 0.0..=1.0)
                            .text("Master Volume")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.master_volume = master_volume;
                    changed_controls = true;
                }

                let mut music_volume = next_controls.music_volume;
                if ui
                    .add(
                        egui::Slider::new(&mut music_volume, 0.0..=1.0)
                            .text("Music Volume")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.music_volume = music_volume;
                    changed_controls = true;
                }

                let mut sfx_volume = next_controls.sfx_volume;
                if ui
                    .add(
                        egui::Slider::new(&mut sfx_volume, 0.0..=1.0)
                            .text("SFX Volume")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.sfx_volume = sfx_volume;
                    changed_controls = true;
                }

                let mut ambient_volume = next_controls.ambient_volume;
                if ui
                    .add(
                        egui::Slider::new(&mut ambient_volume, 0.0..=1.0)
                            .text("Ambient Volume")
                            .show_value(true),
                    )
                    .changed()
                {
                    next_controls.ambient_volume = ambient_volume;
                    changed_controls = true;
                }

                if changed_controls {
                    *controls = Arc::new(next_controls);
                    *controls_dirty = true;
                }

                ui.add_space(12.0);
                ui.separator();
                ui.add_space(10.0);

                ui.horizontal(|ui| {
                    if ui
                        .add_enabled(*controls_dirty, egui::Button::new("Save Settings"))
                        .clicked()
                    {
                        if let Err(err) = controls.as_ref().save() {
                            tracing::warn!(?err, "Failed to save settings");
                        } else {
                            *controls_dirty = false;
                        }
                    }

                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                        if ui.button("Done").clicked() {
                            *view = PauseMenuView::Main;
                        }
                    });
                });
            }
        }
    });

    action
}

/// Render the death screen overlay
/// Returns (respawn_clicked, menu_clicked)
fn render_death_screen(ctx: &egui::Context, death_message: &str) -> (bool, bool) {
    let mut respawn_clicked = false;
    let mut menu_clicked = false;

    // Semi-transparent red overlay
    egui::Area::new(egui::Id::new("death_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(139, 0, 0, 180), // Dark red
            );
        });

    // Death screen content
    egui::Area::new(egui::Id::new("death_screen"))
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.vertical_centered(|ui| {
                ui.add_space(20.0);

                // "You Died!" title
                ui.label(
                    egui::RichText::new("You Died!")
                        .size(64.0)
                        .color(egui::Color32::WHITE)
                        .strong(),
                );

                ui.add_space(20.0);

                // Death message
                ui.label(
                    egui::RichText::new(death_message)
                        .size(24.0)
                        .color(egui::Color32::from_rgb(255, 200, 200)),
                );

                ui.add_space(40.0);

                // Respawn button
                let respawn_button = egui::Button::new(
                    egui::RichText::new("Respawn")
                        .size(24.0)
                        .color(egui::Color32::WHITE),
                )
                .min_size(egui::vec2(200.0, 50.0))
                .fill(egui::Color32::from_rgb(60, 120, 60));

                if ui.add(respawn_button).clicked() {
                    respawn_clicked = true;
                }

                ui.add_space(15.0);

                // Return to menu button
                let menu_button = egui::Button::new(
                    egui::RichText::new("Title Screen")
                        .size(18.0)
                        .color(egui::Color32::LIGHT_GRAY),
                )
                .min_size(egui::vec2(180.0, 40.0))
                .fill(egui::Color32::from_rgb(80, 80, 80));

                if ui.add(menu_button).clicked() {
                    menu_clicked = true;
                }

                ui.add_space(20.0);
            });
        });

    (respawn_clicked, menu_clicked)
}

/// Render the inventory UI.
/// Returns `(close_clicked, spill_items)`.
#[allow(clippy::too_many_arguments)]
fn render_inventory(
    ctx: &egui::Context,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    player_armor: &mut PlayerArmor,
    personal_crafting_grid: &mut [[Option<ItemStack>; 2]; 2],
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
    blocks: &BlockRegistry,
) -> (bool, Vec<ItemStack>) {
    let mut close_clicked = false;
    let mut spill_items = Vec::new();
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                let mut dummy_crafting_grid: [[Option<ItemStack>; 3]; 3] = Default::default();
                apply_primary_drag_distribution(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    personal_crafting_grid,
                    &mut dummy_crafting_grid,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("inventory_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    // Inventory window
    egui::Window::new("Inventory")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(600.0);

            // Close button
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Inventory").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            // Main inventory (27 slots in 3 rows of 9)
            ui.label("Main Inventory");
            for row in 0..3 {
                ui.horizontal(|ui| {
                    for col in 0..9 {
                        let slot_idx = row * 9 + col;
                        render_core_slot_interactive_shift_moves_to_hotbar(
                            ui,
                            UiCoreSlotId::MainInventory(slot_idx),
                            &mut main_inventory.slots[slot_idx],
                            ui_cursor_stack,
                            hotbar,
                            ui_drag,
                            UiSlotVisual::new(36.0, false),
                        );
                    }
                });
            }

            ui.add_space(8.0);
            ui.separator();

            ui.label("Armor");
            ui.horizontal(|ui| {
                render_armor_slot_interactive(
                    ui,
                    ArmorSlot::Helmet,
                    player_armor,
                    ui_cursor_stack,
                    36.0,
                    ui_drag,
                );
                render_armor_slot_interactive(
                    ui,
                    ArmorSlot::Chestplate,
                    player_armor,
                    ui_cursor_stack,
                    36.0,
                    ui_drag,
                );
                render_armor_slot_interactive(
                    ui,
                    ArmorSlot::Leggings,
                    player_armor,
                    ui_cursor_stack,
                    36.0,
                    ui_drag,
                );
                render_armor_slot_interactive(
                    ui,
                    ArmorSlot::Boots,
                    player_armor,
                    ui_cursor_stack,
                    36.0,
                    ui_drag,
                );
            });

            ui.add_space(10.0);
            ui.separator();

            // Personal crafting (2x2).
            ui.label("Crafting (2x2)");
            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.label(
                    egui::RichText::new("Left click: pick/place. Right click: split/place one.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            let recipe_match = {
                let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
                #[allow(clippy::needless_range_loop)]
                for r in 0..2 {
                    #[allow(clippy::needless_range_loop)]
                    for c in 0..2 {
                        grid[r][c] = personal_crafting_grid[r][c].clone();
                    }
                }
                match_crafting_recipe(&grid, CraftingGridSize::TwoByTwo, blocks)
            };

            ui.horizontal(|ui| {
                let cursor_empty = ui_cursor_stack.is_none();
                let grid_empty = crafting_grid_is_empty(personal_crafting_grid);

                ui.vertical(|ui| {
                    ui.label(egui::RichText::new("Recipes").strong());
                    ui.add_space(4.0);
                    ui.label(
                        egui::RichText::new("Fill requires empty cursor + grid.")
                            .size(11.0)
                            .color(egui::Color32::GRAY),
                    );

                    let recipes = get_crafting_recipes();
                    let max_dim = CraftingGridSize::TwoByTwo.dimension();
                    egui::ScrollArea::vertical()
                        .max_height(120.0)
                        .auto_shrink([false, true])
                        .show(ui, |ui| {
                            for recipe in recipes
                                .iter()
                                .filter(|recipe| recipe.min_grid_size.dimension() <= max_dim)
                            {
                                let crafts = crafting_max_crafts_in_storage(
                                    hotbar,
                                    main_inventory,
                                    &recipe.inputs,
                                    blocks,
                                );
                                let craftable = crafts > 0;
                                ui.horizontal(|ui| {
                                    let label =
                                        format!("{:?} x{}", recipe.output, recipe.output_count);
                                    ui.label(egui::RichText::new(label).color(if craftable {
                                        egui::Color32::WHITE
                                    } else {
                                        egui::Color32::DARK_GRAY
                                    }));

                                    ui.with_layout(
                                        egui::Layout::right_to_left(egui::Align::Center),
                                        |ui| {
                                            let enabled = craftable && cursor_empty && grid_empty;
                                            if ui
                                                .add_enabled(enabled, egui::Button::new("Fill"))
                                                .clicked()
                                            {
                                                let _ = try_autofill_crafting_grid(
                                                    personal_crafting_grid,
                                                    hotbar,
                                                    main_inventory,
                                                    recipe,
                                                    blocks,
                                                );
                                            }
                                        },
                                    );
                                });
                            }
                        });
                });

                ui.add_space(16.0);
                ui.separator();
                ui.add_space(16.0);

                ui.horizontal(|ui| {
                    // 2x2 grid
                    ui.vertical(|ui| {
                        ui.horizontal(|ui| {
                            ui.label("Grid");
                            if ui
                                .add_enabled(cursor_empty, egui::Button::new("Clear"))
                                .clicked()
                            {
                                clear_crafting_grid_to_storage(
                                    personal_crafting_grid,
                                    hotbar,
                                    main_inventory,
                                    &mut spill_items,
                                );
                            }
                        });
                        #[allow(clippy::needless_range_loop)]
                        for r in 0..2 {
                            ui.horizontal(|ui| {
                                #[allow(clippy::needless_range_loop)]
                                for c in 0..2 {
                                    let slot_idx = r * 2 + c;
                                    render_core_slot_interactive_shift_moves_to_storage(
                                        ui,
                                        UiCoreSlotId::PersonalCrafting(slot_idx),
                                        &mut personal_crafting_grid[r][c],
                                        ui_cursor_stack,
                                        (&mut *hotbar, &mut *main_inventory),
                                        ui_drag,
                                        UiSlotVisual::new(40.0, false),
                                    );
                                }
                            });
                        }
                    });

                    ui.add_space(20.0);

                    // Output
                    ui.vertical(|ui| {
                        ui.label("Output");
                        if let Some(recipe) = recipe_match.as_ref() {
                            let result_stack = ItemStack::new(recipe.output, recipe.output_count);
                            let response = render_crafting_output_slot_interactive(
                                ui,
                                Some(&result_stack),
                                "Click to craft\nShift-click: craft all to inventory",
                            );
                            let clicked = response.clicked_by(egui::PointerButton::Primary)
                                || response.clicked_by(egui::PointerButton::Secondary);
                            if clicked {
                                let shift = ui.input(|i| i.modifiers.shift);
                                if shift {
                                    let crafts = crafting_max_crafts_2x2(
                                        personal_crafting_grid,
                                        recipe,
                                        blocks,
                                    );
                                    let mut crafted = 0_u32;
                                    for _ in 0..crafts {
                                        if consume_crafting_inputs_2x2(
                                            personal_crafting_grid,
                                            recipe,
                                            blocks,
                                        ) {
                                            crafted += 1;
                                        } else {
                                            break;
                                        }
                                    }

                                    if crafted > 0 {
                                        let total = recipe.output_count.saturating_mul(crafted);
                                        let output_stack = ItemStack::new(recipe.output, total);
                                        if let Some(remainder) = add_stack_to_storage(
                                            hotbar,
                                            main_inventory,
                                            output_stack,
                                        ) {
                                            spill_items.push(remainder);
                                        }
                                    }
                                } else if cursor_can_accept_full_stack(
                                    ui_cursor_stack,
                                    &result_stack,
                                ) && consume_crafting_inputs_2x2(
                                    personal_crafting_grid,
                                    recipe,
                                    blocks,
                                ) {
                                    cursor_add_full_stack(ui_cursor_stack, result_stack);
                                }
                            }
                        } else {
                            render_crafting_output_slot_interactive(ui, None, "No recipe");
                            ui.label(
                                egui::RichText::new("No recipe")
                                    .size(10.0)
                                    .color(egui::Color32::GRAY),
                            );
                        }
                    });
                });
            });

            ui.add_space(10.0);
            ui.separator();

            // Hotbar (9 slots)
            ui.label("Hotbar");
            ui.horizontal(|ui| {
                for i in 0..9 {
                    let is_selected = i == hotbar.selected;
                    render_core_slot_interactive_shift_moves_to_main_inventory(
                        ui,
                        UiCoreSlotId::Hotbar(i),
                        &mut hotbar.slots[i],
                        ui_cursor_stack,
                        main_inventory,
                        ui_drag,
                        UiSlotVisual::new(36.0, is_selected),
                    );
                }
            });

            ui.add_space(5.0);
            ui.label(
                egui::RichText::new("Press E to close")
                    .size(12.0)
                    .color(egui::Color32::GRAY),
            );
        });

    (close_clicked, spill_items)
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum UiSlotClick {
    Primary,
    Secondary,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum UiCoreSlotId {
    Hotbar(usize),
    MainInventory(usize),
    Chest(usize),
    Hopper(usize),
    Dispenser(usize),
    Dropper(usize),
    PersonalCrafting(usize),
    CraftingGrid(usize),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum UiDragButton {
    Primary,
    Secondary,
}

#[derive(Debug, Default)]
struct UiDragState {
    active_button: Option<UiDragButton>,
    visited: Vec<UiCoreSlotId>,
    suppress_clicks: bool,
}

#[derive(Debug, Clone, Copy)]
struct UiSlotVisual {
    size: f32,
    is_selected: bool,
}

impl UiSlotVisual {
    fn new(size: f32, is_selected: bool) -> Self {
        Self { size, is_selected }
    }
}

impl UiDragState {
    fn reset(&mut self) {
        self.active_button = None;
        self.visited.clear();
        self.suppress_clicks = false;
    }

    fn begin_frame(&mut self) {
        self.suppress_clicks = false;
    }

    fn finish_drag(&mut self) {
        self.active_button = None;
        self.visited.clear();
        self.suppress_clicks = true;
    }

    fn is_active(&self) -> bool {
        self.active_button.is_some()
    }

    fn start(&mut self, button: UiDragButton, slot_id: UiCoreSlotId) {
        self.active_button = Some(button);
        self.visited.clear();
        self.visited.push(slot_id);
    }

    fn push_slot(&mut self, slot_id: UiCoreSlotId) -> bool {
        if self.visited.contains(&slot_id) {
            return false;
        }

        self.visited.push(slot_id);
        true
    }
}

fn stacks_match_for_merge(a: &ItemStack, b: &ItemStack) -> bool {
    a.item_type == b.item_type && a.durability == b.durability && a.enchantments == b.enchantments
}

fn restore_one_into_core_slot(slots: &mut [Option<ItemStack>], idx: usize, stack: ItemStack) {
    debug_assert_eq!(stack.count, 1);

    if idx >= slots.len() {
        return;
    }

    match slots[idx].as_mut() {
        Some(existing) if stacks_match_for_merge(existing, &stack) => {
            existing.count = existing.count.saturating_add(1);
        }
        None => {
            slots[idx] = Some(stack);
        }
        Some(_) => {
            // Fallback: try to insert anywhere (should be extremely rare for deterministic
            // hopper transfers).
            let _ = mdminecraft_world::insert_one_into_core_slots(slots, stack);
        }
    }
}

const INVENTORY_STACK_METADATA_VERSION_V1: u8 = 1;
const INVENTORY_STACK_METADATA_FLAG_DURABILITY: u8 = 1 << 0;
const INVENTORY_STACK_METADATA_FLAG_ENCHANTMENTS: u8 = 1 << 1;

fn enchantment_type_to_id(enchantment_type: EnchantmentType) -> u8 {
    match enchantment_type {
        EnchantmentType::Efficiency => 1,
        EnchantmentType::SilkTouch => 2,
        EnchantmentType::Fortune => 3,
        EnchantmentType::Sharpness => 4,
        EnchantmentType::Knockback => 5,
        EnchantmentType::FireAspect => 6,
        EnchantmentType::Protection => 7,
        EnchantmentType::FireProtection => 8,
        EnchantmentType::BlastProtection => 9,
        EnchantmentType::ProjectileProtection => 10,
        EnchantmentType::Unbreaking => 11,
        EnchantmentType::Mending => 12,
        EnchantmentType::FeatherFalling => 13,
        EnchantmentType::Respiration => 14,
        EnchantmentType::Power => 15,
        EnchantmentType::Punch => 16,
        EnchantmentType::Flame => 17,
        EnchantmentType::Infinity => 18,
        EnchantmentType::AquaAffinity => 19,
        EnchantmentType::DepthStrider => 20,
    }
}

fn enchantment_type_from_id(id: u8) -> Option<EnchantmentType> {
    match id {
        1 => Some(EnchantmentType::Efficiency),
        2 => Some(EnchantmentType::SilkTouch),
        3 => Some(EnchantmentType::Fortune),
        4 => Some(EnchantmentType::Sharpness),
        5 => Some(EnchantmentType::Knockback),
        6 => Some(EnchantmentType::FireAspect),
        7 => Some(EnchantmentType::Protection),
        8 => Some(EnchantmentType::FireProtection),
        9 => Some(EnchantmentType::BlastProtection),
        10 => Some(EnchantmentType::ProjectileProtection),
        11 => Some(EnchantmentType::Unbreaking),
        12 => Some(EnchantmentType::Mending),
        13 => Some(EnchantmentType::FeatherFalling),
        14 => Some(EnchantmentType::Respiration),
        15 => Some(EnchantmentType::Power),
        16 => Some(EnchantmentType::Punch),
        17 => Some(EnchantmentType::Flame),
        18 => Some(EnchantmentType::Infinity),
        19 => Some(EnchantmentType::AquaAffinity),
        20 => Some(EnchantmentType::DepthStrider),
        _ => None,
    }
}

fn encode_inventory_stack_metadata(stack: &ItemStack) -> Option<Vec<u8>> {
    let durability = stack.durability.and_then(|current| {
        let max = stack.max_durability()?;
        if current < max {
            Some(current)
        } else {
            None
        }
    });
    let enchantments = stack
        .enchantments
        .as_ref()
        .filter(|enchants| !enchants.is_empty());

    if durability.is_none() && enchantments.is_none() {
        return None;
    }

    let mut bytes = Vec::with_capacity(2 + 4 + 1 + 2 * enchantments.map_or(0, |v| v.len()));
    bytes.push(INVENTORY_STACK_METADATA_VERSION_V1);

    let mut flags = 0u8;
    if durability.is_some() {
        flags |= INVENTORY_STACK_METADATA_FLAG_DURABILITY;
    }
    if enchantments.is_some() {
        flags |= INVENTORY_STACK_METADATA_FLAG_ENCHANTMENTS;
    }
    bytes.push(flags);

    if let Some(durability) = durability {
        bytes.extend_from_slice(&durability.to_le_bytes());
    }

    if let Some(enchantments) = enchantments {
        let count = u8::try_from(enchantments.len()).unwrap_or(u8::MAX);
        bytes.push(count);
        for enchantment in enchantments.iter().take(count as usize) {
            bytes.push(enchantment_type_to_id(enchantment.enchantment_type));
            bytes.push(enchantment.level);
        }
    }

    Some(bytes)
}

fn decode_inventory_stack_metadata(
    metadata: &[u8],
) -> Option<(Option<u32>, Option<Vec<Enchantment>>)> {
    if metadata.len() < 2 {
        return None;
    }

    let version = metadata[0];
    if version != INVENTORY_STACK_METADATA_VERSION_V1 {
        return None;
    }

    let flags = metadata[1];
    let mut offset = 2usize;

    let durability = if flags & INVENTORY_STACK_METADATA_FLAG_DURABILITY != 0 {
        let end = offset.checked_add(4)?;
        if end > metadata.len() {
            return None;
        }
        let durability = u32::from_le_bytes(metadata[offset..end].try_into().ok()?);
        offset = end;
        Some(durability)
    } else {
        None
    };

    let enchantments = if flags & INVENTORY_STACK_METADATA_FLAG_ENCHANTMENTS != 0 {
        let count = *metadata.get(offset)? as usize;
        offset = offset.checked_add(1)?;
        let end = offset.checked_add(count.checked_mul(2)?)?;
        if end > metadata.len() {
            return None;
        }

        let mut enchants = Vec::with_capacity(count);
        for _ in 0..count {
            let type_id = metadata.get(offset).copied()?;
            let level = metadata.get(offset + 1).copied()?;
            offset += 2;

            let enchantment_type = enchantment_type_from_id(type_id)?;
            enchants.push(Enchantment::new(enchantment_type, level));
        }

        Some(enchants)
    } else {
        None
    };

    Some((durability, enchantments))
}

fn apply_inventory_stack_metadata(stack: &mut ItemStack, metadata: &[u8]) {
    let Some((durability, enchantments)) = decode_inventory_stack_metadata(metadata) else {
        return;
    };

    if let Some(durability) = durability {
        if let Some(max) = stack.max_durability() {
            stack.durability = Some(durability.min(max));
        }
    }

    if let Some(enchantments) = enchantments {
        if !enchantments.is_empty() {
            stack.enchantments = Some(enchantments);
        }
    }
}

fn apply_slot_click(
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    click: UiSlotClick,
) {
    match click {
        UiSlotClick::Primary => apply_slot_primary_click(slot, cursor),
        UiSlotClick::Secondary => apply_slot_secondary_click(slot, cursor),
    }
}

fn apply_slot_primary_click(slot: &mut Option<ItemStack>, cursor: &mut Option<ItemStack>) {
    if cursor.is_none() {
        *cursor = slot.take();
        return;
    }

    if slot.is_none() {
        *slot = cursor.take();
        return;
    }

    let Some(slot_stack) = slot.as_mut() else {
        return;
    };
    let Some(cursor_stack) = cursor.as_mut() else {
        return;
    };

    if stacks_match_for_merge(slot_stack, cursor_stack) {
        let max = slot_stack.max_stack_size();
        if slot_stack.count < max {
            let space = max - slot_stack.count;
            let to_move = space.min(cursor_stack.count);
            slot_stack.count += to_move;
            cursor_stack.count -= to_move;
            if cursor_stack.count == 0 {
                *cursor = None;
            }
            return;
        }
    }

    std::mem::swap(slot, cursor);
}

fn apply_slot_secondary_click(slot: &mut Option<ItemStack>, cursor: &mut Option<ItemStack>) {
    if cursor.is_none() {
        let Some(slot_stack) = slot.as_mut() else {
            return;
        };

        let take = slot_stack.count.div_ceil(2);
        let mut taken = slot_stack.clone();
        taken.count = take;
        slot_stack.count -= take;
        if slot_stack.count == 0 {
            *slot = None;
        }
        *cursor = Some(taken);
        return;
    }

    let Some(cursor_stack) = cursor.as_mut() else {
        return;
    };

    if slot.is_none() {
        let mut placed = cursor_stack.clone();
        placed.count = 1.min(cursor_stack.count);
        cursor_stack.count -= placed.count;
        if cursor_stack.count == 0 {
            *cursor = None;
        }
        *slot = Some(placed);
        return;
    }

    let Some(slot_stack) = slot.as_mut() else {
        return;
    };

    if !stacks_match_for_merge(slot_stack, cursor_stack) {
        return;
    }

    let max = slot_stack.max_stack_size();
    if slot_stack.count >= max {
        return;
    }

    slot_stack.count += 1;
    cursor_stack.count -= 1;
    if cursor_stack.count == 0 {
        *cursor = None;
    }
}

fn try_drag_place_one_from_cursor(
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
) -> bool {
    let Some(cursor_stack) = cursor.as_mut() else {
        return false;
    };
    if cursor_stack.count == 0 {
        *cursor = None;
        return false;
    }

    if slot.is_none() {
        let mut placed = cursor_stack.clone();
        placed.count = 1;
        cursor_stack.count -= 1;
        if cursor_stack.count == 0 {
            *cursor = None;
        }
        *slot = Some(placed);
        return true;
    }

    let Some(slot_stack) = slot.as_mut() else {
        return false;
    };
    if !stacks_match_for_merge(slot_stack, cursor_stack) {
        return false;
    }

    let max = slot_stack.max_stack_size();
    if slot_stack.count >= max {
        return false;
    }

    slot_stack.count += 1;
    cursor_stack.count -= 1;
    if cursor_stack.count == 0 {
        *cursor = None;
    }
    true
}

fn apply_primary_drag_distribution(
    cursor: &mut Option<ItemStack>,
    visited: &[UiCoreSlotId],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    personal_crafting_grid: &mut [[Option<ItemStack>; 2]; 2],
    crafting_grid: &mut [[Option<ItemStack>; 3]; 3],
) {
    if visited.is_empty() {
        return;
    }

    while cursor.as_ref().is_some_and(|stack| stack.count > 0) {
        let mut progress = false;

        for slot_id in visited {
            let moved = match *slot_id {
                UiCoreSlotId::Hotbar(i) => {
                    if i < hotbar.slots.len() {
                        try_drag_place_one_from_cursor(&mut hotbar.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::MainInventory(i) => {
                    if i < main_inventory.slots.len() {
                        try_drag_place_one_from_cursor(&mut main_inventory.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Chest(_) => false,
                UiCoreSlotId::Hopper(_) => false,
                UiCoreSlotId::Dispenser(_) => false,
                UiCoreSlotId::Dropper(_) => false,
                UiCoreSlotId::PersonalCrafting(i) => {
                    let row = i / 2;
                    let col = i % 2;
                    if row < 2 && col < 2 {
                        try_drag_place_one_from_cursor(
                            &mut personal_crafting_grid[row][col],
                            cursor,
                        )
                    } else {
                        false
                    }
                }
                UiCoreSlotId::CraftingGrid(i) => {
                    let row = i / 3;
                    let col = i % 3;
                    if row < 3 && col < 3 {
                        try_drag_place_one_from_cursor(&mut crafting_grid[row][col], cursor)
                    } else {
                        false
                    }
                }
            };

            if moved {
                progress = true;
                if cursor.is_none() {
                    break;
                }
            }
        }

        if !progress {
            break;
        }
    }
}

fn apply_primary_drag_distribution_with_chest(
    cursor: &mut Option<ItemStack>,
    visited: &[UiCoreSlotId],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    chest: &mut ChestState,
) {
    if visited.is_empty() {
        return;
    }

    while cursor.as_ref().is_some_and(|stack| stack.count > 0) {
        let mut progress = false;

        for slot_id in visited {
            let moved = match *slot_id {
                UiCoreSlotId::Hotbar(i) => {
                    if i < hotbar.slots.len() {
                        try_drag_place_one_from_cursor(&mut hotbar.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::MainInventory(i) => {
                    if i < main_inventory.slots.len() {
                        try_drag_place_one_from_cursor(&mut main_inventory.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Chest(i) => {
                    if i < chest.slots.len() {
                        try_drag_place_one_from_cursor(&mut chest.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Hopper(_) | UiCoreSlotId::Dispenser(_) | UiCoreSlotId::Dropper(_) => {
                    false
                }
                UiCoreSlotId::PersonalCrafting(_) | UiCoreSlotId::CraftingGrid(_) => false,
            };

            if moved {
                progress = true;
                if cursor.is_none() {
                    break;
                }
            }
        }

        if !progress {
            break;
        }
    }
}

fn apply_primary_drag_distribution_with_hopper(
    cursor: &mut Option<ItemStack>,
    visited: &[UiCoreSlotId],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    hopper: &mut HopperState,
) {
    if visited.is_empty() {
        return;
    }

    while cursor.as_ref().is_some_and(|stack| stack.count > 0) {
        let mut progress = false;

        for slot_id in visited {
            let moved = match *slot_id {
                UiCoreSlotId::Hotbar(i) => {
                    if i < hotbar.slots.len() {
                        try_drag_place_one_from_cursor(&mut hotbar.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::MainInventory(i) => {
                    if i < main_inventory.slots.len() {
                        try_drag_place_one_from_cursor(&mut main_inventory.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Hopper(i) => {
                    if i < hopper.slots.len() {
                        try_drag_place_one_from_cursor(&mut hopper.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Chest(_)
                | UiCoreSlotId::Dispenser(_)
                | UiCoreSlotId::Dropper(_)
                | UiCoreSlotId::PersonalCrafting(_)
                | UiCoreSlotId::CraftingGrid(_) => false,
            };

            if moved {
                progress = true;
                if cursor.is_none() {
                    break;
                }
            }
        }

        if !progress {
            break;
        }
    }
}

fn apply_primary_drag_distribution_with_dispenser(
    cursor: &mut Option<ItemStack>,
    visited: &[UiCoreSlotId],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    dispenser: &mut DispenserState,
) {
    if visited.is_empty() {
        return;
    }

    while cursor.as_ref().is_some_and(|stack| stack.count > 0) {
        let mut progress = false;

        for slot_id in visited {
            let moved = match *slot_id {
                UiCoreSlotId::Hotbar(i) => {
                    if i < hotbar.slots.len() {
                        try_drag_place_one_from_cursor(&mut hotbar.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::MainInventory(i) => {
                    if i < main_inventory.slots.len() {
                        try_drag_place_one_from_cursor(&mut main_inventory.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Dispenser(i) => {
                    if i < dispenser.slots.len() {
                        try_drag_place_one_from_cursor(&mut dispenser.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Chest(_)
                | UiCoreSlotId::Hopper(_)
                | UiCoreSlotId::Dropper(_)
                | UiCoreSlotId::PersonalCrafting(_)
                | UiCoreSlotId::CraftingGrid(_) => false,
            };

            if moved {
                progress = true;
                if cursor.is_none() {
                    break;
                }
            }
        }

        if !progress {
            break;
        }
    }
}

fn apply_primary_drag_distribution_with_dropper(
    cursor: &mut Option<ItemStack>,
    visited: &[UiCoreSlotId],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    dropper: &mut DispenserState,
) {
    if visited.is_empty() {
        return;
    }

    while cursor.as_ref().is_some_and(|stack| stack.count > 0) {
        let mut progress = false;

        for slot_id in visited {
            let moved = match *slot_id {
                UiCoreSlotId::Hotbar(i) => {
                    if i < hotbar.slots.len() {
                        try_drag_place_one_from_cursor(&mut hotbar.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::MainInventory(i) => {
                    if i < main_inventory.slots.len() {
                        try_drag_place_one_from_cursor(&mut main_inventory.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Dropper(i) => {
                    if i < dropper.slots.len() {
                        try_drag_place_one_from_cursor(&mut dropper.slots[i], cursor)
                    } else {
                        false
                    }
                }
                UiCoreSlotId::Chest(_)
                | UiCoreSlotId::Hopper(_)
                | UiCoreSlotId::Dispenser(_)
                | UiCoreSlotId::PersonalCrafting(_)
                | UiCoreSlotId::CraftingGrid(_) => false,
            };

            if moved {
                progress = true;
                if cursor.is_none() {
                    break;
                }
            }
        }

        if !progress {
            break;
        }
    }
}

fn try_add_stack_to_cursor(
    cursor: &mut Option<ItemStack>,
    mut stack: ItemStack,
) -> Option<ItemStack> {
    if stack.count == 0 {
        return None;
    }

    let Some(cursor_stack) = cursor.as_mut() else {
        let max = stack.max_stack_size();
        if stack.count <= max {
            *cursor = Some(stack);
            return None;
        }

        let mut placed = stack.clone();
        placed.count = max;
        stack.count -= max;
        *cursor = Some(placed);
        return Some(stack);
    };

    if !stacks_match_for_merge(cursor_stack, &stack) {
        return Some(stack);
    }

    let max = cursor_stack.max_stack_size();
    if cursor_stack.count >= max {
        return Some(stack);
    }

    let space = max - cursor_stack.count;
    let to_add = space.min(stack.count);
    cursor_stack.count += to_add;
    stack.count -= to_add;

    if stack.count == 0 {
        None
    } else {
        Some(stack)
    }
}

fn render_core_slot_visual(
    ui: &mut egui::Ui,
    slot: &Option<ItemStack>,
    size: f32,
    is_selected: bool,
) -> egui::Response {
    let mut response = ui.allocate_response(egui::vec2(size, size), egui::Sense::click_and_drag());
    let rect = response.rect;

    let (fill, stroke) = if is_selected {
        (
            egui::Color32::from_rgba_unmultiplied(80, 80, 80, 200),
            egui::Stroke::new(2.0, egui::Color32::WHITE),
        )
    } else {
        (
            egui::Color32::from_rgba_unmultiplied(40, 40, 40, 180),
            egui::Stroke::new(1.0, egui::Color32::DARK_GRAY),
        )
    };

    ui.painter().rect_filled(rect, 0.0, fill);
    ui.painter().rect_stroke(rect, 0.0, stroke);

    ui.allocate_ui_at_rect(rect.shrink(4.0), |ui| {
        if let Some(stack) = slot.as_ref() {
            ui.vertical_centered(|ui| {
                let name = match stack.item_type {
                    mdminecraft_core::ItemType::Tool(tool, _) => format!("{:?}", tool),
                    mdminecraft_core::ItemType::Block(id) => format!("B{}", id),
                    mdminecraft_core::ItemType::Food(food) => format!("{:?}", food),
                    mdminecraft_core::ItemType::Potion(id) => format!("P{}", id),
                    mdminecraft_core::ItemType::SplashPotion(id) => format!("SP{}", id),
                    mdminecraft_core::ItemType::Item(id) => format!("I{}", id),
                };
                ui.label(
                    egui::RichText::new(&name[..name.len().min(4)])
                        .size(9.0)
                        .color(egui::Color32::WHITE),
                );
                if stack.count > 1 {
                    ui.label(
                        egui::RichText::new(format!("{}", stack.count))
                            .size(10.0)
                            .color(egui::Color32::YELLOW),
                    );
                }
            });
        }
    });

    response = if let Some(stack) = slot.as_ref() {
        let mut tooltip = format!("{:?}", stack.item_type);
        tooltip.push_str(&format!("\nCount: {}", stack.count));

        if let (Some(current), Some(max)) = (stack.durability, stack.max_durability()) {
            paint_durability_bar(ui, rect, current, max);
            tooltip.push_str(&format!("\nDurability: {}/{}", current, max));
        }

        let enchants = stack.get_enchantments();
        if !enchants.is_empty() {
            tooltip.push_str("\nEnchantments:");
            for enchant in enchants {
                tooltip.push_str(&format!(
                    "\n- {:?} {}",
                    enchant.enchantment_type, enchant.level
                ));
            }
        }
        response.on_hover_text(tooltip)
    } else {
        response.on_hover_text("Empty")
    };

    response
}

fn armor_slot_short_label(slot: ArmorSlot) -> &'static str {
    match slot {
        ArmorSlot::Helmet => "H",
        ArmorSlot::Chestplate => "C",
        ArmorSlot::Leggings => "L",
        ArmorSlot::Boots => "B",
    }
}

fn render_armor_slot_interactive(
    ui: &mut egui::Ui,
    armor_slot: ArmorSlot,
    player_armor: &mut PlayerArmor,
    cursor: &mut Option<ItemStack>,
    size: f32,
    drag: &UiDragState,
) {
    let stack = player_armor
        .get(armor_slot)
        .and_then(armor_piece_to_core_stack);
    let mut response = render_core_slot_visual(ui, &stack, size, false);

    if stack.is_none() {
        ui.painter().text(
            response.rect.center(),
            egui::Align2::CENTER_CENTER,
            armor_slot_short_label(armor_slot),
            egui::FontId::proportional(12.0),
            egui::Color32::GRAY,
        );
    }

    if let Some(piece) = player_armor.get(armor_slot) {
        paint_durability_bar(ui, response.rect, piece.durability, piece.max_durability);

        let mut tooltip = format!("{:?}", piece.item_type);
        tooltip.push_str(&format!("\nSlot: {:?}", piece.slot));
        tooltip.push_str(&format!(
            "\nDurability: {}/{}",
            piece.durability, piece.max_durability
        ));

        if !piece.enchantments.is_empty() {
            tooltip.push_str("\nEnchantments:");
            for enchant in &piece.enchantments {
                tooltip.push_str(&format!(
                    "\n- {:?} {}",
                    enchant.enchantment_type, enchant.level
                ));
            }
        }

        response = response.on_hover_text(tooltip);
    } else {
        response = response.on_hover_text(format!("Empty {:?} slot", armor_slot));
    }

    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(_click) = click else {
        return;
    };

    if cursor.is_none() {
        let Some(piece) = player_armor.unequip(armor_slot) else {
            return;
        };

        if let Some(stack) = armor_piece_to_core_stack(&piece) {
            *cursor = Some(stack);
        } else {
            tracing::warn!(
                slot = ?armor_slot,
                item = ?piece.item_type,
                "Unequipped armor could not be represented as a core stack"
            );
        }
        return;
    }

    let Some(cursor_stack) = cursor.take() else {
        return;
    };

    let Some(new_piece) = armor_piece_from_core_stack(&cursor_stack) else {
        *cursor = Some(cursor_stack);
        return;
    };

    if new_piece.slot != armor_slot {
        *cursor = Some(cursor_stack);
        return;
    }

    let old_piece = player_armor.equip(new_piece);
    *cursor = old_piece.and_then(|piece| armor_piece_to_core_stack(&piece));
}

fn ui_drag_handle_slot(
    ui: &egui::Ui,
    response: &egui::Response,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) -> bool {
    let cursor_present = cursor.is_some();

    if cursor_present && !drag.is_active() {
        if response.drag_started_by(egui::PointerButton::Primary) {
            drag.start(UiDragButton::Primary, slot_id);
            return true;
        }

        if response.drag_started_by(egui::PointerButton::Secondary) {
            drag.start(UiDragButton::Secondary, slot_id);
            let _ = try_drag_place_one_from_cursor(slot, cursor);
            return true;
        }
    }

    let Some(active) = drag.active_button else {
        return false;
    };

    let is_button_down = ui.input(|i| match active {
        UiDragButton::Primary => i.pointer.primary_down(),
        UiDragButton::Secondary => i.pointer.secondary_down(),
    });
    if !is_button_down {
        return false;
    }

    if response.hovered() && drag.push_slot(slot_id) && active == UiDragButton::Secondary {
        let _ = try_drag_place_one_from_cursor(slot, cursor);
    }

    true
}

fn render_core_slot_interactive_shift_moves_to_hotbar(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    hotbar: &mut Hotbar,
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(stack) = slot.take() {
            *slot = hotbar.add_stack(stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_storage(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (hotbar, main_inventory): (&mut Hotbar, &mut MainInventory),
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(stack) = slot.take() {
            *slot = add_stack_to_storage(hotbar, main_inventory, stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_main_inventory(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    main_inventory: &mut MainInventory,
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(stack) = slot.take() {
            *slot = main_inventory.add_stack(stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn add_stack_to_storage(
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    stack: ItemStack,
) -> Option<ItemStack> {
    let remainder = hotbar.add_stack(stack)?;
    main_inventory.add_stack(remainder)
}

fn render_player_storage(
    ui: &mut egui::Ui,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_hotbar(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    hotbar,
                    drag,
                    UiSlotVisual::new(36.0, false),
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_main_inventory(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                main_inventory,
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn furnace_try_insert(
    slot: &mut Option<(DroppedItemType, u32)>,
    item_type: DroppedItemType,
    count: u32,
) -> u32 {
    if count == 0 {
        return 0;
    }

    let max = item_type.max_stack_size().max(1);

    match slot {
        None => {
            let moved = count.min(max);
            *slot = Some((item_type, moved));
            moved
        }
        Some((existing_type, existing_count)) => {
            if *existing_type != item_type {
                return 0;
            }

            let space = max.saturating_sub(*existing_count);
            let moved = space.min(count);
            *existing_count += moved;
            moved
        }
    }
}

fn try_shift_move_core_stack_into_furnace(
    stack: &mut ItemStack,
    furnace: &mut FurnaceState,
) -> bool {
    let Some(dropped_type) = GameWorld::convert_core_item_type_to_dropped(stack.item_type) else {
        return false;
    };

    if furnace_slot_accepts_item(FurnaceSlotKind::Input, dropped_type) {
        let moved = furnace_try_insert(&mut furnace.input, dropped_type, stack.count);
        if moved > 0 {
            stack.count = stack.count.saturating_sub(moved);
            return true;
        }
    }

    if furnace_slot_accepts_item(FurnaceSlotKind::Fuel, dropped_type) {
        let moved = furnace_try_insert(&mut furnace.fuel, dropped_type, stack.count);
        if moved > 0 {
            stack.count = stack.count.saturating_sub(moved);
            return true;
        }
    }

    false
}

fn try_shift_move_core_stack_into_brewing_stand(
    stack: &mut ItemStack,
    stand: &mut BrewingStandState,
) -> bool {
    if stack.count == 0 {
        return false;
    }

    // Blaze powder prefers the fuel slot, but can also be a brewing ingredient.
    if stack.item_type == ItemType::Item(CORE_ITEM_BLAZE_POWDER) {
        let remainder = stand.add_fuel(stack.count);
        let moved = stack.count.saturating_sub(remainder);
        if moved > 0 {
            stack.count = remainder;
            return true;
        }
    }

    if let Some((potion_type, is_splash, is_extended, amplifier)) = core_item_stack_to_bottle(stack)
    {
        let mut remaining = stack.count;
        let mut moved_any = false;
        let (bottles, bottle_is_splash, bottle_is_extended, bottle_amplifier) = (
            &mut stand.bottles,
            &mut stand.bottle_is_splash,
            &mut stand.bottle_is_extended,
            &mut stand.bottle_amplifier,
        );
        for (idx, slot) in bottles.iter_mut().enumerate() {
            if remaining == 0 {
                break;
            }
            if slot.is_none() {
                *slot = Some(potion_type);
                bottle_is_splash[idx] = is_splash && potion_type != PotionType::Water;
                bottle_is_extended[idx] = is_extended && potion_type != PotionType::Water;
                bottle_amplifier[idx] = if potion_type != PotionType::Water {
                    amplifier
                } else {
                    0
                };
                remaining = remaining.saturating_sub(1);
                moved_any = true;
            }
        }

        if moved_any {
            stack.count = remaining;
            return true;
        }

        return false;
    }

    let Some(ingredient_id) = core_item_type_to_brew_ingredient_id(stack.item_type) else {
        return false;
    };

    let remainder = stand.add_ingredient(ingredient_id, stack.count);
    let moved = stack.count.saturating_sub(remainder);
    stack.count = remainder;
    moved > 0
}

fn try_shift_move_core_stack_into_enchanting_table(
    stack: &mut ItemStack,
    table: &mut EnchantingTableState,
) -> bool {
    if stack.count == 0 {
        return false;
    }

    // Lapis lazuli only.
    if stack.item_type != ItemType::Item(15) {
        return false;
    }

    let remainder = table.add_lapis(stack.count);
    let moved = stack.count.saturating_sub(remainder);
    stack.count = remainder;
    moved > 0
}

fn try_shift_move_core_stack_into_slots(
    stack: &mut ItemStack,
    slots: &mut [Option<ItemStack>],
) -> bool {
    if stack.count == 0 {
        return false;
    }

    let before = stack.count;

    // Merge into existing stacks first.
    for existing in slots.iter_mut().flatten() {
        if stack.count == 0 {
            break;
        }
        if !stacks_match_for_merge(existing, stack) {
            continue;
        }

        let max = existing.max_stack_size();
        if existing.count >= max {
            continue;
        }

        let space = max - existing.count;
        let to_add = space.min(stack.count);
        existing.count += to_add;
        stack.count -= to_add;
    }

    // Then fill empty slots, splitting if needed.
    for slot in slots {
        if stack.count == 0 {
            break;
        }
        if slot.is_some() {
            continue;
        }

        let max = stack.max_stack_size();
        if stack.count <= max {
            *slot = Some(stack.clone());
            stack.count = 0;
            break;
        }

        let mut placed = stack.clone();
        placed.count = max;
        *slot = Some(placed);
        stack.count -= max;
    }

    stack.count != before
}

fn try_shift_move_core_stack_into_chest(stack: &mut ItemStack, chest: &mut ChestState) -> bool {
    try_shift_move_core_stack_into_slots(stack, &mut chest.slots)
}

fn try_shift_move_core_stack_into_hopper(stack: &mut ItemStack, hopper: &mut HopperState) -> bool {
    try_shift_move_core_stack_into_slots(stack, &mut hopper.slots)
}

fn try_shift_move_core_stack_into_dispenser(
    stack: &mut ItemStack,
    dispenser: &mut DispenserState,
) -> bool {
    try_shift_move_core_stack_into_slots(stack, &mut dispenser.slots)
}

fn try_shift_move_core_stack_into_dropper(
    stack: &mut ItemStack,
    dropper: &mut DispenserState,
) -> bool {
    try_shift_move_core_stack_into_slots(stack, &mut dropper.slots)
}

fn render_core_slot_interactive_shift_moves_to_furnace_or_hotbar(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (furnace, hotbar): (&mut FurnaceState, &mut Hotbar),
    drag: &mut UiDragState,
    size: f32,
) {
    let response = render_core_slot_visual(ui, slot, size, false);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(mut stack) = slot.take() {
            let moved_any = try_shift_move_core_stack_into_furnace(&mut stack, furnace);
            if moved_any {
                if stack.count > 0 {
                    *slot = Some(stack);
                }
            } else {
                *slot = hotbar.add_stack(stack);
            }
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_brewing_or_hotbar(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (stand, hotbar): (&mut BrewingStandState, &mut Hotbar),
    drag: &mut UiDragState,
    size: f32,
) {
    let response = render_core_slot_visual(ui, slot, size, false);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(mut stack) = slot.take() {
            let moved_any = try_shift_move_core_stack_into_brewing_stand(&mut stack, stand);
            if moved_any {
                if stack.count > 0 {
                    *slot = Some(stack);
                }
            } else {
                *slot = hotbar.add_stack(stack);
            }
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_enchanting_or_hotbar(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (table, hotbar): (&mut EnchantingTableState, &mut Hotbar),
    drag: &mut UiDragState,
    size: f32,
) {
    let response = render_core_slot_visual(ui, slot, size, false);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(mut stack) = slot.take() {
            let moved_any = try_shift_move_core_stack_into_enchanting_table(&mut stack, table);
            if moved_any {
                if stack.count > 0 {
                    *slot = Some(stack);
                }
            } else {
                *slot = hotbar.add_stack(stack);
            }
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_furnace_or_main_inventory(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (furnace, main_inventory): (&mut FurnaceState, &mut MainInventory),
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(mut stack) = slot.take() {
            let moved_any = try_shift_move_core_stack_into_furnace(&mut stack, furnace);
            if moved_any {
                if stack.count > 0 {
                    *slot = Some(stack);
                }
            } else {
                *slot = main_inventory.add_stack(stack);
            }
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_brewing_or_main_inventory(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (stand, main_inventory): (&mut BrewingStandState, &mut MainInventory),
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(mut stack) = slot.take() {
            let moved_any = try_shift_move_core_stack_into_brewing_stand(&mut stack, stand);
            if moved_any {
                if stack.count > 0 {
                    *slot = Some(stack);
                }
            } else {
                *slot = main_inventory.add_stack(stack);
            }
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_enchanting_or_main_inventory(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    (table, main_inventory): (&mut EnchantingTableState, &mut MainInventory),
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        if let Some(mut stack) = slot.take() {
            let moved_any = try_shift_move_core_stack_into_enchanting_table(&mut stack, table);
            if moved_any {
                if stack.count > 0 {
                    *slot = Some(stack);
                }
            } else {
                *slot = main_inventory.add_stack(stack);
            }
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_core_slot_interactive_shift_moves_to_chest(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    chest: &mut ChestState,
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        let Some(mut stack) = slot.take() else {
            return;
        };

        let moved_any = try_shift_move_core_stack_into_chest(&mut stack, chest);
        if !moved_any || stack.count > 0 {
            *slot = Some(stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_player_storage_for_chest(
    ui: &mut egui::Ui,
    chest: &mut ChestState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_chest(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    &mut *chest,
                    drag,
                    UiSlotVisual::new(36.0, false),
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_chest(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                &mut *chest,
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn render_core_slot_interactive_shift_moves_to_hopper(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    hopper: &mut HopperState,
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        let Some(mut stack) = slot.take() else {
            return;
        };

        let moved_any = try_shift_move_core_stack_into_hopper(&mut stack, hopper);
        if !moved_any || stack.count > 0 {
            *slot = Some(stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_player_storage_for_hopper(
    ui: &mut egui::Ui,
    hopper: &mut HopperState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_hopper(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    &mut *hopper,
                    drag,
                    UiSlotVisual::new(36.0, false),
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_hopper(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                &mut *hopper,
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn render_core_slot_interactive_shift_moves_to_dispenser(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    dispenser: &mut DispenserState,
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        let Some(mut stack) = slot.take() else {
            return;
        };

        let moved_any = try_shift_move_core_stack_into_dispenser(&mut stack, dispenser);
        if !moved_any || stack.count > 0 {
            *slot = Some(stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_player_storage_for_dispenser(
    ui: &mut egui::Ui,
    dispenser: &mut DispenserState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_dispenser(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    &mut *dispenser,
                    drag,
                    UiSlotVisual::new(36.0, false),
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_dispenser(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                &mut *dispenser,
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn render_core_slot_interactive_shift_moves_to_dropper(
    ui: &mut egui::Ui,
    slot_id: UiCoreSlotId,
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    dropper: &mut DispenserState,
    drag: &mut UiDragState,
    visual: UiSlotVisual,
) {
    let response = render_core_slot_visual(ui, slot, visual.size, visual.is_selected);
    if ui_drag_handle_slot(ui, &response, slot_id, slot, cursor, drag) {
        return;
    }
    if drag.suppress_clicks {
        return;
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    let Some(click) = click else {
        return;
    };

    let shift = ui.input(|i| i.modifiers.shift);
    if shift {
        let Some(mut stack) = slot.take() else {
            return;
        };

        let moved_any = try_shift_move_core_stack_into_dropper(&mut stack, dropper);
        if !moved_any || stack.count > 0 {
            *slot = Some(stack);
        }
        return;
    }

    apply_slot_click(slot, cursor, click);
}

fn render_player_storage_for_dropper(
    ui: &mut egui::Ui,
    dropper: &mut DispenserState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_dropper(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    &mut *dropper,
                    drag,
                    UiSlotVisual::new(36.0, false),
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_dropper(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                &mut *dropper,
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn render_player_storage_for_furnace(
    ui: &mut egui::Ui,
    furnace: &mut FurnaceState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_furnace_or_hotbar(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    (&mut *furnace, &mut *hotbar),
                    drag,
                    36.0,
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_furnace_or_main_inventory(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                (&mut *furnace, &mut *main_inventory),
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn render_player_storage_for_brewing_stand(
    ui: &mut egui::Ui,
    stand: &mut BrewingStandState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_brewing_or_hotbar(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    (&mut *stand, &mut *hotbar),
                    drag,
                    36.0,
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_brewing_or_main_inventory(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                (&mut *stand, &mut *main_inventory),
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

fn render_player_storage_for_enchanting_table(
    ui: &mut egui::Ui,
    table: &mut EnchantingTableState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    cursor: &mut Option<ItemStack>,
    drag: &mut UiDragState,
) {
    ui.label(
        egui::RichText::new("Inventory")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    for row in 0..3 {
        ui.horizontal(|ui| {
            for col in 0..9 {
                let slot_idx = row * 9 + col;
                render_core_slot_interactive_shift_moves_to_enchanting_or_hotbar(
                    ui,
                    UiCoreSlotId::MainInventory(slot_idx),
                    &mut main_inventory.slots[slot_idx],
                    cursor,
                    (&mut *table, &mut *hotbar),
                    drag,
                    36.0,
                );
            }
        });
    }

    ui.add_space(6.0);

    ui.label(
        egui::RichText::new("Hotbar")
            .size(12.0)
            .color(egui::Color32::GRAY),
    );
    ui.horizontal(|ui| {
        for i in 0..9 {
            let is_selected = i == hotbar.selected;
            render_core_slot_interactive_shift_moves_to_enchanting_or_main_inventory(
                ui,
                UiCoreSlotId::Hotbar(i),
                &mut hotbar.slots[i],
                cursor,
                (&mut *table, &mut *main_inventory),
                drag,
                UiSlotVisual::new(36.0, is_selected),
            );
        }
    });
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum CraftingIngredient {
    Exact(ItemType),
    BlockTag(RegistryKey),
}

impl From<ItemType> for CraftingIngredient {
    fn from(value: ItemType) -> Self {
        CraftingIngredient::Exact(value)
    }
}

impl CraftingIngredient {
    fn matches_item(&self, item_type: ItemType, blocks: &BlockRegistry) -> bool {
        match self {
            CraftingIngredient::Exact(expected) => *expected == item_type,
            CraftingIngredient::BlockTag(tag) => match item_type {
                ItemType::Block(block_id) => blocks.has_tag(block_id, tag),
                _ => false,
            },
        }
    }
}

fn item_type_sort_key(item_type: ItemType) -> (u8, u16, u16) {
    let variant = match item_type {
        ItemType::Tool(_, _) => 0,
        ItemType::Block(_) => 1,
        ItemType::Food(_) => 2,
        ItemType::Potion(_) => 3,
        ItemType::SplashPotion(_) => 4,
        ItemType::Item(_) => 5,
    };

    let (a, b) = match item_type {
        ItemType::Tool(tool, material) => (tool_sort_key(tool) as u16, material_sort_key(material)),
        ItemType::Block(id) => (id, 0),
        ItemType::Food(food) => (food_sort_key(food) as u16, 0),
        ItemType::Potion(id) => (id, 0),
        ItemType::SplashPotion(id) => (id, 0),
        ItemType::Item(id) => (id, 0),
    };

    (variant, a, b)
}

fn tool_sort_key(tool: ToolType) -> u8 {
    match tool {
        ToolType::Pickaxe => 0,
        ToolType::Axe => 1,
        ToolType::Shovel => 2,
        ToolType::Sword => 3,
        ToolType::Hoe => 4,
    }
}

fn material_sort_key(material: ToolMaterial) -> u16 {
    match material {
        ToolMaterial::Wood => 0,
        ToolMaterial::Stone => 1,
        ToolMaterial::Iron => 2,
        ToolMaterial::Diamond => 3,
        ToolMaterial::Gold => 4,
    }
}

fn food_sort_key(food: mdminecraft_core::item::FoodType) -> u8 {
    use mdminecraft_core::item::FoodType;

    match food {
        FoodType::Apple => 0,
        FoodType::Bread => 1,
        FoodType::RawMeat => 2,
        FoodType::CookedMeat => 3,
        FoodType::Carrot => 4,
        FoodType::Potato => 5,
        FoodType::BakedPotato => 6,
        FoodType::GoldenCarrot => 7,
    }
}

#[derive(Debug, Clone)]
struct CraftingPattern {
    width: usize,
    height: usize,
    cells: [[Option<CraftingIngredient>; 3]; 3],
}

impl CraftingPattern {
    fn from_exact_cells(width: usize, height: usize, exact: [[Option<ItemType>; 3]; 3]) -> Self {
        let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
        for (r, row) in exact.into_iter().enumerate() {
            for (c, cell) in row.into_iter().enumerate() {
                cells[r][c] = cell.map(CraftingIngredient::Exact);
            }
        }

        Self {
            width,
            height,
            cells,
        }
    }

    fn mirrored_horizontal(&self) -> Self {
        if self.width == 0 || self.height == 0 {
            return self.clone();
        }

        let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
        for (r, row) in cells.iter_mut().enumerate().take(self.height) {
            let source_row = &self.cells[r];
            for (c, source) in source_row.iter().cloned().enumerate().take(self.width) {
                row[self.width - 1 - c] = source;
            }
        }

        Self {
            width: self.width,
            height: self.height,
            cells,
        }
    }
}

#[derive(Debug, Clone)]
struct CraftingRecipe {
    inputs: Vec<(CraftingIngredient, u32)>,
    output: ItemType,
    output_count: u32,
    pattern: Option<CraftingPattern>,
    /// If true, shaped recipes also match a horizontally mirrored pattern.
    ///
    /// Used for recipes like stairs/bows where vanilla accepts both orientations.
    allow_horizontal_mirror: bool,
    min_grid_size: CraftingGridSize,
    /// If true, allow extra counts of the required item types (no extra item types).
    ///
    /// This is used sparingly to avoid ambiguous matches with subset/superset recipes.
    allow_extra_counts_of_required_types: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum CraftingGridSize {
    TwoByTwo,
    ThreeByThree,
}

impl CraftingGridSize {
    fn dimension(self) -> usize {
        match self {
            CraftingGridSize::TwoByTwo => 2,
            CraftingGridSize::ThreeByThree => 3,
        }
    }
}

static PACK_CRAFTING_RECIPES: OnceLock<Vec<CraftingRecipe>> = OnceLock::new();

#[derive(Debug, Deserialize)]
struct PackShapedRecipeDefinition {
    name: String,
    pattern: Vec<String>,
    key: std::collections::BTreeMap<String, String>,
    output: mdminecraft_assets::RecipeOutput,
    #[serde(default)]
    allow_horizontal_mirror: bool,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum PackCraftingRecipeDefinition {
    Shapeless(mdminecraft_assets::RecipeDefinition),
    Shaped(PackShapedRecipeDefinition),
}

fn pack_crafting_recipes() -> &'static Vec<CraftingRecipe> {
    PACK_CRAFTING_RECIPES.get_or_init(|| {
        let blocks = load_block_registry();
        load_pack_crafting_recipes_lenient(&blocks)
    })
}

fn load_pack_crafting_recipes_lenient(blocks: &BlockRegistry) -> Vec<CraftingRecipe> {
    let packs_root = Path::new(content_packs::CONTENT_PACKS_DIR);
    load_pack_crafting_recipes_lenient_from_root(blocks, packs_root)
}

fn load_pack_crafting_recipes_lenient_from_root(
    blocks: &BlockRegistry,
    packs_root: &Path,
) -> Vec<CraftingRecipe> {
    let mut recipes = Vec::new();
    for pack in content_packs::discover_packs_lenient(packs_root) {
        let recipes_path = pack.dir.join("recipes.json");
        if !recipes_path.exists() {
            continue;
        }

        let contents = match fs::read_to_string(&recipes_path) {
            Ok(contents) => contents,
            Err(err) => {
                tracing::warn!(
                    "Failed to read content pack recipes {}: {err:#}",
                    recipes_path.display()
                );
                continue;
            }
        };

        let defs: Vec<PackCraftingRecipeDefinition> = match serde_json::from_str(&contents) {
            Ok(defs) => defs,
            Err(err) => {
                tracing::warn!(
                    "Failed to parse content pack recipes {}: {err:#}",
                    recipes_path.display()
                );
                continue;
            }
        };

        for def in defs {
            let recipe = match &def {
                PackCraftingRecipeDefinition::Shapeless(def) => {
                    recipe_definition_to_crafting_recipe(def, blocks)
                }
                PackCraftingRecipeDefinition::Shaped(def) => {
                    shaped_recipe_definition_to_crafting_recipe(def, blocks)
                }
            };

            match recipe {
                Ok(recipe) => recipes.push(recipe),
                Err(err) => tracing::warn!(
                    "Ignoring invalid recipe from {}: {err:#}",
                    recipes_path.display()
                ),
            }
        }
    }

    recipes
}

#[cfg(test)]
fn load_pack_crafting_recipes_strict(blocks: &BlockRegistry) -> Result<Vec<CraftingRecipe>> {
    let packs_root = Path::new(content_packs::CONTENT_PACKS_DIR);
    load_pack_crafting_recipes_strict_from_root(blocks, packs_root)
}

#[cfg(test)]
fn load_pack_crafting_recipes_strict_from_root(
    blocks: &BlockRegistry,
    packs_root: &Path,
) -> Result<Vec<CraftingRecipe>> {
    let mut recipe_names = std::collections::BTreeSet::<String>::new();

    let mut recipes = Vec::new();
    for pack in content_packs::discover_packs_strict(packs_root)? {
        let recipes_path = pack.dir.join("recipes.json");
        if !recipes_path.exists() {
            continue;
        }

        let contents = fs::read_to_string(&recipes_path)?;
        let defs: Vec<PackCraftingRecipeDefinition> = serde_json::from_str(&contents)?;
        for def in defs {
            let name = match &def {
                PackCraftingRecipeDefinition::Shapeless(def) => def.name.clone(),
                PackCraftingRecipeDefinition::Shaped(def) => def.name.clone(),
            };
            if !recipe_names.insert(name.clone()) {
                anyhow::bail!(
                    "Duplicate recipe name '{}' while loading {}",
                    name,
                    recipes_path.display()
                );
            }

            let recipe = match def {
                PackCraftingRecipeDefinition::Shapeless(def) => {
                    recipe_definition_to_crafting_recipe(&def, blocks)?
                }
                PackCraftingRecipeDefinition::Shaped(def) => {
                    shaped_recipe_definition_to_crafting_recipe(&def, blocks)?
                }
            };
            recipes.push(recipe);
        }
    }

    Ok(recipes)
}

fn recipe_definition_to_crafting_recipe(
    def: &mdminecraft_assets::RecipeDefinition,
    blocks: &BlockRegistry,
) -> Result<CraftingRecipe> {
    if def.output.count == 0 {
        anyhow::bail!("Recipe '{}' output count must be > 0", def.name);
    }

    let mut inputs = Vec::with_capacity(def.inputs.len());
    let mut total_required: u32 = 0;
    for input in &def.inputs {
        if input.count == 0 {
            anyhow::bail!("Recipe '{}' has a zero-count input", def.name);
        }
        let ingredient = parse_pack_crafting_ingredient(&input.item, blocks).ok_or_else(|| {
            anyhow::anyhow!(
                "Recipe '{}' has unknown input item '{}'",
                def.name,
                input.item
            )
        })?;
        inputs.push((ingredient, input.count));
        total_required = total_required.saturating_add(input.count);
    }

    if inputs.is_empty() {
        anyhow::bail!("Recipe '{}' has no inputs", def.name);
    }

    let output = parse_pack_item_type(&def.output.item, blocks).ok_or_else(|| {
        anyhow::anyhow!(
            "Recipe '{}' has unknown output item '{}'",
            def.name,
            def.output.item
        )
    })?;

    let min_grid_size = if total_required <= 4 {
        CraftingGridSize::TwoByTwo
    } else {
        CraftingGridSize::ThreeByThree
    };

    Ok(CraftingRecipe {
        inputs,
        output,
        output_count: def.output.count,
        pattern: None,
        allow_horizontal_mirror: false,
        min_grid_size,
        allow_extra_counts_of_required_types: false,
    })
}

fn parse_pack_item_type(token: &str, blocks: &BlockRegistry) -> Option<ItemType> {
    let token = token.trim();
    if token.is_empty() {
        return None;
    }

    if !token.contains(':') {
        if let Some(block_id) = blocks.id_by_name(token) {
            return Some(ItemType::Block(block_id));
        }
    }

    mdminecraft_assets::parse_item_type_with_blocks(token, Some(blocks))
}

fn parse_pack_block_tag(token: &str, blocks: &BlockRegistry) -> Option<RegistryKey> {
    let tag = RegistryKey::parse(token).ok()?;
    if !blocks.blocks_with_tag(&tag).is_empty() {
        return Some(tag);
    }

    if tag.namespace() == "minecraft" {
        let alias = RegistryKey::parse(tag.path()).ok()?;
        if !blocks.blocks_with_tag(&alias).is_empty() {
            return Some(alias);
        }
    }

    None
}

fn parse_pack_crafting_ingredient(
    token: &str,
    blocks: &BlockRegistry,
) -> Option<CraftingIngredient> {
    let token = token.trim();
    if token.is_empty() {
        return None;
    }

    if let Some(rest) = token.strip_prefix('#') {
        let tag = parse_pack_block_tag(rest, blocks)?;
        return Some(CraftingIngredient::BlockTag(tag));
    }

    if let Some(rest) = token.strip_prefix("tag:") {
        let tag = parse_pack_block_tag(rest, blocks)?;
        return Some(CraftingIngredient::BlockTag(tag));
    }

    if let Some(rest) = token.strip_prefix("block_tag:") {
        let tag = parse_pack_block_tag(rest, blocks)?;
        return Some(CraftingIngredient::BlockTag(tag));
    }

    parse_pack_item_type(token, blocks).map(CraftingIngredient::Exact)
}

fn shaped_recipe_definition_to_crafting_recipe(
    def: &PackShapedRecipeDefinition,
    blocks: &BlockRegistry,
) -> Result<CraftingRecipe> {
    if def.output.count == 0 {
        anyhow::bail!("Recipe '{}' output count must be > 0", def.name);
    }

    if def.pattern.is_empty() {
        anyhow::bail!("Recipe '{}' has an empty pattern", def.name);
    }

    let height = def.pattern.len();
    if height > 3 {
        anyhow::bail!("Recipe '{}' pattern height must be <= 3", def.name);
    }

    let mut width = 0_usize;
    for (row_idx, row) in def.pattern.iter().enumerate() {
        let row_width = row.chars().count();
        if row_width == 0 {
            anyhow::bail!("Recipe '{}' has an empty pattern row", def.name);
        }
        if row_idx == 0 {
            width = row_width;
        } else if row_width != width {
            anyhow::bail!("Recipe '{}' pattern rows must be the same width", def.name);
        }
    }
    if width > 3 {
        anyhow::bail!("Recipe '{}' pattern width must be <= 3", def.name);
    }

    let min_grid_size = if width <= 2 && height <= 2 {
        CraftingGridSize::TwoByTwo
    } else {
        CraftingGridSize::ThreeByThree
    };

    let output = parse_pack_item_type(&def.output.item, blocks).ok_or_else(|| {
        anyhow::anyhow!(
            "Recipe '{}' has unknown output item '{}'",
            def.name,
            def.output.item
        )
    })?;

    let mut key = std::collections::HashMap::<char, CraftingIngredient>::new();
    for (symbol, item) in &def.key {
        let mut chars = symbol.chars();
        let Some(ch) = chars.next() else {
            anyhow::bail!("Recipe '{}' has an empty key symbol", def.name);
        };
        if chars.next().is_some() {
            anyhow::bail!("Recipe '{}' key symbols must be one character", def.name);
        }
        if matches!(ch, ' ' | '.') {
            anyhow::bail!(
                "Recipe '{}' key symbol '{}' is reserved for empty cells",
                def.name,
                symbol
            );
        }
        let ingredient = parse_pack_crafting_ingredient(item, blocks).ok_or_else(|| {
            anyhow::anyhow!("Recipe '{}' has unknown key item '{}'", def.name, item)
        })?;
        key.insert(ch, ingredient);
    }

    let mut inputs_in_order = Vec::<CraftingIngredient>::new();
    let mut counts = std::collections::HashMap::<CraftingIngredient, u32>::new();
    let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
    let mut required_cells = 0_usize;

    for (r, row) in def.pattern.iter().enumerate() {
        for (c, token) in row.chars().enumerate() {
            let ingredient = match token {
                ' ' | '.' => None,
                symbol => {
                    let ingredient = key.get(&symbol).cloned().ok_or_else(|| {
                        anyhow::anyhow!(
                            "Recipe '{}' pattern uses symbol '{}' without a key entry",
                            def.name,
                            symbol
                        )
                    })?;
                    Some(ingredient)
                }
            };

            cells[r][c] = ingredient.clone();
            if let Some(ingredient) = ingredient {
                required_cells += 1;
                let entry = counts.entry(ingredient.clone()).or_insert(0);
                if *entry == 0 {
                    inputs_in_order.push(ingredient);
                }
                *entry = entry.saturating_add(1);
            }
        }
    }

    if required_cells == 0 {
        anyhow::bail!("Recipe '{}' pattern has no required cells", def.name);
    }

    let mut inputs = Vec::with_capacity(inputs_in_order.len());
    for ingredient in inputs_in_order {
        let count = counts.get(&ingredient).copied().unwrap_or(0);
        if count > 0 {
            inputs.push((ingredient, count));
        }
    }

    Ok(CraftingRecipe {
        inputs,
        output,
        output_count: def.output.count,
        pattern: Some(CraftingPattern {
            width,
            height,
            cells,
        }),
        allow_horizontal_mirror: def.allow_horizontal_mirror,
        min_grid_size,
        allow_extra_counts_of_required_types: false,
    })
}

/// Get available crafting recipes as (inputs, output, output_count)
/// Inputs are a list of (CraftingIngredient, count) required
fn get_crafting_recipes() -> Vec<CraftingRecipe> {
    let planks = CraftingIngredient::BlockTag(
        RegistryKey::parse("planks").expect("planks tag key should be valid"),
    );

    let mut recipes = vec![
        // Furnace: 8 cobblestone  furnace
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_COBBLESTONE).into(), 8)],
            output: ItemType::Block(BLOCK_FURNACE),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        None,
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Chest: 8 planks  chest
        CraftingRecipe {
            inputs: vec![(planks.clone(), 8)],
            output: ItemType::Block(interactive_blocks::CHEST),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                for (r, row) in cells.iter_mut().enumerate() {
                    for (c, cell) in row.iter_mut().enumerate() {
                        if r == 1 && c == 1 {
                            continue;
                        }
                        *cell = Some(planks.clone());
                    }
                }
                CraftingPattern {
                    width: 3,
                    height: 3,
                    cells,
                }
            }),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Planks: 1 log  4 planks
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_LOG).into(), 1)],
            output: ItemType::Block(BLOCK_OAK_PLANKS),
            output_count: 4,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: true,
        },
        // Crafting Table: 4 planks  crafting table
        CraftingRecipe {
            inputs: vec![(planks.clone(), 4)],
            output: ItemType::Block(BLOCK_CRAFTING_TABLE),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(planks.clone());
                cells[0][1] = Some(planks.clone());
                cells[1][0] = Some(planks.clone());
                cells[1][1] = Some(planks.clone());
                CraftingPattern {
                    width: 2,
                    height: 2,
                    cells,
                }
            }),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Sticks: 2 planks  4 sticks
        CraftingRecipe {
            inputs: vec![(planks.clone(), 2)],
            output: ItemType::Item(3),
            output_count: 4,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(planks.clone());
                cells[1][0] = Some(planks.clone());
                CraftingPattern {
                    width: 1,
                    height: 2,
                    cells,
                }
            }),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        }, // Item(3) = Stick
        // Bone Meal: 1 bone  3 bone meal
        CraftingRecipe {
            inputs: vec![(ItemType::Item(16).into(), 1)], // Item(16) = Bone
            output: ItemType::Item(18),                   // Item(18) = Bone Meal
            output_count: 3,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: true,
        },
        // Torches: 1 coal + 1 stick  4 torches
        CraftingRecipe {
            inputs: vec![(ItemType::Item(8).into(), 1), (ItemType::Item(3).into(), 1)], // Item(8) = Coal
            output: ItemType::Block(interactive_blocks::TORCH),
            output_count: 4,
            pattern: Some(CraftingPattern::from_exact_cells(
                1,
                2,
                [
                    [Some(ItemType::Item(8)), None, None],
                    [Some(ItemType::Item(3)), None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Bread: 3 wheat  bread
        CraftingRecipe {
            inputs: vec![(ItemType::Item(CORE_ITEM_WHEAT).into(), 3)],
            output: ItemType::Food(mdminecraft_core::item::FoodType::Bread),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                1,
                [
                    [
                        Some(ItemType::Item(CORE_ITEM_WHEAT)),
                        Some(ItemType::Item(CORE_ITEM_WHEAT)),
                        Some(ItemType::Item(CORE_ITEM_WHEAT)),
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Sugar: 1 sugar cane  sugar
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_SUGAR_CANE).into(), 1)],
            output: ItemType::Item(CORE_ITEM_SUGAR),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: true,
        },
        // Paper: 3 sugar cane  3 paper
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_SUGAR_CANE).into(), 3)],
            output: ItemType::Item(CORE_ITEM_PAPER),
            output_count: 3,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                1,
                [
                    [
                        Some(ItemType::Block(BLOCK_SUGAR_CANE)),
                        Some(ItemType::Block(BLOCK_SUGAR_CANE)),
                        Some(ItemType::Block(BLOCK_SUGAR_CANE)),
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Book: 3 paper + 1 leather  1 book
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(CORE_ITEM_PAPER).into(), 3),
                (ItemType::Item(102).into(), 1), // Item(102) = Leather
            ],
            output: ItemType::Item(CORE_ITEM_BOOK),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: true,
        },
        // Fermented Spider Eye (vanilla-ish): 1 brown mushroom + 1 sugar + 1 spider eye  1 fermented spider eye
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_BROWN_MUSHROOM).into(), 1),
                (ItemType::Item(CORE_ITEM_SUGAR).into(), 1),
                (ItemType::Item(CORE_ITEM_SPIDER_EYE).into(), 1),
            ],
            output: ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: true,
        },
        // Golden Carrot (vanilla-ish): 1 carrot + 1 gold ingot  golden carrot
        CraftingRecipe {
            inputs: vec![
                (
                    ItemType::Food(mdminecraft_core::item::FoodType::Carrot).into(),
                    1,
                ),
                (ItemType::Item(9).into(), 1), // Item(9) = Gold ingot
            ],
            output: ItemType::Food(mdminecraft_core::item::FoodType::GoldenCarrot),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Glass Bottles: 3 glass  3 bottles
        CraftingRecipe {
            inputs: vec![(ItemType::Block(interactive_blocks::GLASS).into(), 3)],
            output: ItemType::Item(CORE_ITEM_GLASS_BOTTLE),
            output_count: 3,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                        None,
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                    ],
                    [None, Some(ItemType::Block(interactive_blocks::GLASS)), None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Glass Panes: 6 glass  16 glass panes
        CraftingRecipe {
            inputs: vec![(ItemType::Block(interactive_blocks::GLASS).into(), 6)],
            output: ItemType::Block(interactive_blocks::GLASS_PANE),
            output_count: 16,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                    ],
                    [
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                        Some(ItemType::Block(interactive_blocks::GLASS)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Iron Bars (vanilla-ish): 6 iron ingots  16 bars
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 6)], // Item(7) = Iron Ingot
            output: ItemType::Block(interactive_blocks::IRON_BARS),
            output_count: 16,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Nether Wart Block: 1 block  9 nether wart items
        CraftingRecipe {
            inputs: vec![(
                ItemType::Block(mdminecraft_world::BLOCK_NETHER_WART_BLOCK).into(),
                1,
            )],
            output: ItemType::Item(CORE_ITEM_NETHER_WART),
            output_count: 9,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Bed: 3 wool + 3 planks  1 bed
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(103).into(), 3),
                (ItemType::Block(BLOCK_OAK_PLANKS).into(), 3),
            ], // Item(103) = Wool
            output: ItemType::Block(interactive_blocks::BED_FOOT),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Item(103)),
                        Some(ItemType::Item(103)),
                        Some(ItemType::Item(103)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Brewing Stand: 1 blaze powder + 3 cobblestone  1 brewing stand
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(CORE_ITEM_BLAZE_POWDER).into(), 1),
                (ItemType::Block(BLOCK_COBBLESTONE).into(), 3),
            ],
            output: ItemType::Block(BLOCK_BREWING_STAND),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [None, Some(ItemType::Item(CORE_ITEM_BLAZE_POWDER)), None],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Enchanting Table (vanilla-ish): 4 obsidian + 2 diamonds + 1 lapis  table
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OBSIDIAN).into(), 4),
                (ItemType::Item(14).into(), 2), // Item(14) = Diamond
                (ItemType::Item(15).into(), 1), // Item(15) = Lapis Lazuli
            ],
            output: ItemType::Block(BLOCK_ENCHANTING_TABLE),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [None, Some(ItemType::Item(15)), None],
                    [
                        Some(ItemType::Item(14)),
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                        Some(ItemType::Item(14)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Bookshelf (vanilla-ish): 6 planks + 3 books  bookshelf
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OAK_PLANKS).into(), 6),
                (ItemType::Item(CORE_ITEM_BOOK).into(), 3),
            ],
            output: ItemType::Block(BLOCK_BOOKSHELF),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [
                        Some(ItemType::Item(CORE_ITEM_BOOK)),
                        Some(ItemType::Item(CORE_ITEM_BOOK)),
                        Some(ItemType::Item(CORE_ITEM_BOOK)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Ladder: 7 sticks  3 ladders
        CraftingRecipe {
            inputs: vec![(ItemType::Item(3).into(), 7)],
            output: ItemType::Block(interactive_blocks::LADDER),
            output_count: 3,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [Some(ItemType::Item(3)), None, Some(ItemType::Item(3))],
                    [
                        Some(ItemType::Item(3)),
                        Some(ItemType::Item(3)),
                        Some(ItemType::Item(3)),
                    ],
                    [Some(ItemType::Item(3)), None, Some(ItemType::Item(3))],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Door: 6 planks  3 doors
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_PLANKS).into(), 6)],
            output: ItemType::Block(interactive_blocks::OAK_DOOR_LOWER),
            output_count: 3,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        None,
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        None,
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        None,
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Iron Door: 6 iron ingots  3 doors
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 6)], // Item(7) = Iron Ingot
            output: ItemType::Block(interactive_blocks::IRON_DOOR_LOWER),
            output_count: 3,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                3,
                [
                    [Some(ItemType::Item(7)), Some(ItemType::Item(7)), None],
                    [Some(ItemType::Item(7)), Some(ItemType::Item(7)), None],
                    [Some(ItemType::Item(7)), Some(ItemType::Item(7)), None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Bucket (vanilla-ish): 3 iron ingots  1 bucket
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 3)], // Item(7) = Iron Ingot
            output: ItemType::Item(CORE_ITEM_BUCKET),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                    [None, Some(ItemType::Item(7)), None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Flint and Steel (vanilla-ish): 1 iron ingot + 1 flint  flint and steel
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 1), (ItemType::Item(5).into(), 1)],
            output: ItemType::Item(CORE_ITEM_FLINT_AND_STEEL),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                2,
                [
                    [Some(ItemType::Item(7)), None, None],
                    [None, Some(ItemType::Item(5)), None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Glowstone (vanilla-ish): 4 glowstone dust  1 glowstone
        CraftingRecipe {
            inputs: vec![(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST).into(), 4)],
            output: ItemType::Block(BLOCK_GLOWSTONE),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                2,
                [
                    [
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        None,
                    ],
                    [
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        None,
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Crying obsidian (mdminecraft proxy): 1 obsidian + 1 ghast tear  1 crying obsidian
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OBSIDIAN).into(), 1),
                (ItemType::Item(CORE_ITEM_GHAST_TEAR).into(), 1),
            ],
            output: ItemType::Block(BLOCK_CRYING_OBSIDIAN),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Respawn anchor (vanilla-ish): 6 crying obsidian + 3 glowstone  1 respawn anchor
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_CRYING_OBSIDIAN).into(), 6),
                (ItemType::Block(BLOCK_GLOWSTONE).into(), 3),
            ],
            output: ItemType::Block(BLOCK_RESPAWN_ANCHOR),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_CRYING_OBSIDIAN)),
                        Some(ItemType::Block(BLOCK_GLOWSTONE)),
                        Some(ItemType::Block(BLOCK_CRYING_OBSIDIAN)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_CRYING_OBSIDIAN)),
                        Some(ItemType::Block(BLOCK_GLOWSTONE)),
                        Some(ItemType::Block(BLOCK_CRYING_OBSIDIAN)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_CRYING_OBSIDIAN)),
                        Some(ItemType::Block(BLOCK_GLOWSTONE)),
                        Some(ItemType::Block(BLOCK_CRYING_OBSIDIAN)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Eye of Ender (vanilla-ish): 1 ender pearl + 1 blaze powder  1 eye of ender
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(CORE_ITEM_ENDER_PEARL).into(), 1),
                (ItemType::Item(CORE_ITEM_BLAZE_POWDER).into(), 1),
            ],
            output: ItemType::Item(CORE_ITEM_EYE_OF_ENDER),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // End Portal Frame (mdminecraft alternative): 4 obsidian + 4 stone bricks + 1 nether quartz  1 frame
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OBSIDIAN).into(), 4),
                (
                    ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS).into(),
                    4,
                ),
                (ItemType::Item(CORE_ITEM_NETHER_QUARTZ).into(), 1),
            ],
            output: ItemType::Block(BLOCK_END_PORTAL_FRAME),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Item(CORE_ITEM_NETHER_QUARTZ)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(BLOCK_OBSIDIAN)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Trapdoor: 6 planks  2 trapdoors
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_PLANKS).into(), 6)],
            output: ItemType::Block(interactive_blocks::TRAPDOOR),
            output_count: 2,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Fence: 4 planks + 2 sticks  3 fences
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OAK_PLANKS).into(), 4),
                (ItemType::Item(3).into(), 2),
            ],
            output: ItemType::Block(interactive_blocks::OAK_FENCE),
            output_count: 3,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Item(3)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Item(3)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Fence Gate: 2 planks + 4 sticks  1 fence gate
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OAK_PLANKS).into(), 2),
                (ItemType::Item(3).into(), 4),
            ],
            output: ItemType::Block(interactive_blocks::OAK_FENCE_GATE),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Item(3)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Item(3)),
                    ],
                    [
                        Some(ItemType::Item(3)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Item(3)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Cobblestone Wall (vanilla-ish): 6 cobblestone  6 walls
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_COBBLESTONE).into(), 6)],
            output: ItemType::Block(interactive_blocks::COBBLESTONE_WALL),
            output_count: 6,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Pressure Plate: 2 planks  1 plate
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_PLANKS).into(), 2)],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                1,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        None,
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Button: 1 plank  1 button
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_PLANKS).into(), 1)],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::OAK_BUTTON),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Button: 1 stone  1 button
        CraftingRecipe {
            inputs: vec![(ItemType::Block(mdminecraft_world::BLOCK_STONE).into(), 1)],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::STONE_BUTTON),
            output_count: 1,
            pattern: None,
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Redstone Torch: 1 redstone dust + 1 stick  1 redstone torch
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 1),
                (ItemType::Item(3).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                1,
                2,
                [
                    [Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)), None, None],
                    [Some(ItemType::Item(3)), None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Redstone Lamp (vanilla-inspired): alternating redstone/glowstone dust in a 3x3 grid
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 4),
                (ItemType::Item(CORE_ITEM_GLOWSTONE_DUST).into(), 5),
            ],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_LAMP),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                    ],
                    [
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                    ],
                    [
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Redstone Repeater (vanilla-ish): torches + redstone dust over stone
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(mdminecraft_world::BLOCK_STONE).into(), 3),
                (
                    ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH).into(),
                    2,
                ),
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_REPEATER),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(
                            mdminecraft_world::redstone_blocks::REDSTONE_TORCH,
                        )),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Block(
                            mdminecraft_world::redstone_blocks::REDSTONE_TORCH,
                        )),
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Redstone Comparator (vanilla): torches around nether quartz over stone
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(mdminecraft_world::BLOCK_STONE).into(), 3),
                (
                    ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH).into(),
                    3,
                ),
                (ItemType::Item(CORE_ITEM_NETHER_QUARTZ).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        None,
                        Some(ItemType::Block(
                            mdminecraft_world::redstone_blocks::REDSTONE_TORCH,
                        )),
                        None,
                    ],
                    [
                        Some(ItemType::Block(
                            mdminecraft_world::redstone_blocks::REDSTONE_TORCH,
                        )),
                        Some(ItemType::Item(CORE_ITEM_NETHER_QUARTZ)),
                        Some(ItemType::Block(
                            mdminecraft_world::redstone_blocks::REDSTONE_TORCH,
                        )),
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Observer (vanilla): cobblestone, redstone dust, nether quartz
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_COBBLESTONE).into(), 6),
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 2),
                (ItemType::Item(CORE_ITEM_NETHER_QUARTZ).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_OBSERVER),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Item(CORE_ITEM_NETHER_QUARTZ)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Piston (vanilla-ish): planks, cobblestone, iron ingot, redstone dust
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_OAK_PLANKS).into(), 3),
                (ItemType::Block(BLOCK_COBBLESTONE).into(), 4),
                (ItemType::Item(7).into(), 1), // Item(7) = Iron Ingot
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::mechanical_blocks::PISTON),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Hopper (vanilla-ish): 5 iron ingots + 1 chest
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(7).into(), 5), // Item(7) = Iron Ingot
                (ItemType::Block(interactive_blocks::CHEST).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::mechanical_blocks::HOPPER),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Block(interactive_blocks::CHEST)),
                        Some(ItemType::Item(7)),
                    ],
                    [None, Some(ItemType::Item(7)), None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Dropper (vanilla): cobblestone ring + redstone dust
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_COBBLESTONE).into(), 7),
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::mechanical_blocks::DROPPER),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Dispenser (vanilla): cobblestone ring + bow + redstone dust
        CraftingRecipe {
            inputs: vec![
                (ItemType::Block(BLOCK_COBBLESTONE).into(), 7),
                (ItemType::Item(1).into(), 1), // Item(1) = Bow
                (ItemType::Item(CORE_ITEM_REDSTONE_DUST).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::mechanical_blocks::DISPENSER),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Item(1)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Lever: 1 stick + 1 cobblestone  1 lever
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(3).into(), 1),
                (ItemType::Block(BLOCK_COBBLESTONE).into(), 1),
            ],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::LEVER),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                1,
                2,
                [
                    [Some(ItemType::Item(3)), None, None],
                    [Some(ItemType::Block(BLOCK_COBBLESTONE)), None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Pressure Plate: 2 stone  1 plate
        CraftingRecipe {
            inputs: vec![(ItemType::Block(mdminecraft_world::BLOCK_STONE).into(), 2)],
            output: ItemType::Block(mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                1,
                [
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        None,
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Slab: 3 cobblestone  6 slabs
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_COBBLESTONE).into(), 3)],
            output: ItemType::Block(interactive_blocks::STONE_SLAB),
            output_count: 6,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                1,
                [
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Slab: 3 planks  6 slabs
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_PLANKS).into(), 3)],
            output: ItemType::Block(interactive_blocks::OAK_SLAB),
            output_count: 6,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                1,
                [
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Stairs: 6 cobblestone  4 stairs
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_COBBLESTONE).into(), 6)],
            output: ItemType::Block(interactive_blocks::STONE_STAIRS),
            output_count: 4,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [Some(ItemType::Block(BLOCK_COBBLESTONE)), None, None],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        None,
                    ],
                    [
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                        Some(ItemType::Block(BLOCK_COBBLESTONE)),
                    ],
                ],
            )),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Bricks (vanilla-ish): 4 stone  4 stone bricks
        CraftingRecipe {
            inputs: vec![(ItemType::Block(mdminecraft_world::BLOCK_STONE).into(), 4)],
            output: ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            output_count: 4,
            pattern: Some(CraftingPattern::from_exact_cells(
                2,
                2,
                [
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        None,
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE)),
                        None,
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::TwoByTwo,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Brick Slab: 3 stone bricks  6 slabs
        CraftingRecipe {
            inputs: vec![(
                ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS).into(),
                3,
            )],
            output: ItemType::Block(interactive_blocks::STONE_BRICK_SLAB),
            output_count: 6,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                1,
                [
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                    ],
                    [None, None, None],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Brick Stairs: 6 stone bricks  4 stairs
        CraftingRecipe {
            inputs: vec![(
                ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS).into(),
                6,
            )],
            output: ItemType::Block(interactive_blocks::STONE_BRICK_STAIRS),
            output_count: 4,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        None,
                        None,
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        None,
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                    ],
                ],
            )),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Stone Brick Wall (vanilla-ish): 6 stone bricks  6 walls
        CraftingRecipe {
            inputs: vec![(
                ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS).into(),
                6,
            )],
            output: ItemType::Block(interactive_blocks::STONE_BRICK_WALL),
            output_count: 6,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                    ],
                    [
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                        Some(ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS)),
                    ],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Oak Stairs: 6 planks  4 stairs
        CraftingRecipe {
            inputs: vec![(ItemType::Block(BLOCK_OAK_PLANKS).into(), 6)],
            output: ItemType::Block(interactive_blocks::OAK_STAIRS),
            output_count: 4,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [Some(ItemType::Block(BLOCK_OAK_PLANKS)), None, None],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        None,
                    ],
                    [
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                        Some(ItemType::Block(BLOCK_OAK_PLANKS)),
                    ],
                ],
            )),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        },
        // Bow: 3 sticks + 3 string
        CraftingRecipe {
            inputs: vec![(ItemType::Item(3).into(), 3), (ItemType::Item(4).into(), 3)],
            output: ItemType::Item(1),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [Some(ItemType::Item(3)), Some(ItemType::Item(4)), None],
                    [Some(ItemType::Item(3)), None, Some(ItemType::Item(4))],
                    [Some(ItemType::Item(3)), Some(ItemType::Item(4)), None],
                ],
            )),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(4) = String
        // Arrow: 1 flint + 1 stick + 1 feather
        CraftingRecipe {
            inputs: vec![
                (ItemType::Item(5).into(), 1),
                (ItemType::Item(3).into(), 1),
                (ItemType::Item(6).into(), 1),
            ],
            output: ItemType::Item(2),
            output_count: 4,
            pattern: Some(CraftingPattern::from_exact_cells(
                1,
                3,
                [
                    [Some(ItemType::Item(5)), None, None],
                    [Some(ItemType::Item(3)), None, None],
                    [Some(ItemType::Item(6)), None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(5) = Flint, Item(6) = Feather
        // Leather armor (Item(102) = Leather)
        // Leather Helmet: 5 leather
        CraftingRecipe {
            inputs: vec![(ItemType::Item(102).into(), 5)],
            output: ItemType::Item(20),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                    ],
                    [Some(ItemType::Item(102)), None, Some(ItemType::Item(102))],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(20) = LeatherHelmet
        // Leather Chestplate: 8 leather
        CraftingRecipe {
            inputs: vec![(ItemType::Item(102).into(), 8)],
            output: ItemType::Item(21),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                    ],
                    [Some(ItemType::Item(102)), None, Some(ItemType::Item(102))],
                    [
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(21) = LeatherChestplate
        // Leather Leggings: 7 leather
        CraftingRecipe {
            inputs: vec![(ItemType::Item(102).into(), 7)],
            output: ItemType::Item(22),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                        Some(ItemType::Item(102)),
                    ],
                    [Some(ItemType::Item(102)), None, Some(ItemType::Item(102))],
                    [Some(ItemType::Item(102)), None, Some(ItemType::Item(102))],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(22) = LeatherLeggings
        // Leather Boots: 4 leather
        CraftingRecipe {
            inputs: vec![(ItemType::Item(102).into(), 4)],
            output: ItemType::Item(23),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [Some(ItemType::Item(102)), None, Some(ItemType::Item(102))],
                    [Some(ItemType::Item(102)), None, Some(ItemType::Item(102))],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(23) = LeatherBoots
        // Iron armor (Item(7) = IronIngot)
        // Iron Helmet: 5 iron ingots
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 5)],
            output: ItemType::Item(10),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(10) = IronHelmet
        // Iron Chestplate: 8 iron ingots
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 8)],
            output: ItemType::Item(11),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(11) = IronChestplate
        // Iron Leggings: 7 iron ingots
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 7)],
            output: ItemType::Item(12),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                        Some(ItemType::Item(7)),
                    ],
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(12) = IronLeggings
        // Iron Boots: 4 iron ingots
        CraftingRecipe {
            inputs: vec![(ItemType::Item(7).into(), 4)],
            output: ItemType::Item(13),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                    [Some(ItemType::Item(7)), None, Some(ItemType::Item(7))],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(13) = IronBoots
        // Diamond armor (Item(14) = Diamond)
        // Diamond Helmet: 5 diamonds
        CraftingRecipe {
            inputs: vec![(ItemType::Item(14).into(), 5)],
            output: ItemType::Item(30),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                    ],
                    [Some(ItemType::Item(14)), None, Some(ItemType::Item(14))],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(30) = DiamondHelmet
        // Diamond Chestplate: 8 diamonds
        CraftingRecipe {
            inputs: vec![(ItemType::Item(14).into(), 8)],
            output: ItemType::Item(31),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                    ],
                    [Some(ItemType::Item(14)), None, Some(ItemType::Item(14))],
                    [
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                    ],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(31) = DiamondChestplate
        // Diamond Leggings: 7 diamonds
        CraftingRecipe {
            inputs: vec![(ItemType::Item(14).into(), 7)],
            output: ItemType::Item(32),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                3,
                [
                    [
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                        Some(ItemType::Item(14)),
                    ],
                    [Some(ItemType::Item(14)), None, Some(ItemType::Item(14))],
                    [Some(ItemType::Item(14)), None, Some(ItemType::Item(14))],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(32) = DiamondLeggings
        // Diamond Boots: 4 diamonds
        CraftingRecipe {
            inputs: vec![(ItemType::Item(14).into(), 4)],
            output: ItemType::Item(33),
            output_count: 1,
            pattern: Some(CraftingPattern::from_exact_cells(
                3,
                2,
                [
                    [Some(ItemType::Item(14)), None, Some(ItemType::Item(14))],
                    [Some(ItemType::Item(14)), None, Some(ItemType::Item(14))],
                    [None, None, None],
                ],
            )),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        }, // Item(33) = DiamondBoots
    ];

    recipes.extend(get_tool_crafting_recipes());
    recipes
}

fn get_tool_crafting_recipes() -> Vec<CraftingRecipe> {
    let stick = CraftingIngredient::Exact(ItemType::Item(3));
    let planks = CraftingIngredient::BlockTag(
        RegistryKey::parse("planks").expect("planks tag key should be valid"),
    );
    let tool_materials: [(ToolMaterial, CraftingIngredient); 5] = [
        (ToolMaterial::Wood, planks.clone()),
        (
            ToolMaterial::Stone,
            ItemType::Block(BLOCK_COBBLESTONE).into(),
        ),
        (ToolMaterial::Iron, ItemType::Item(7).into()),
        (ToolMaterial::Diamond, ItemType::Item(14).into()),
        (ToolMaterial::Gold, ItemType::Item(9).into()),
    ];

    let mut recipes = Vec::new();
    for (tool_material, material) in tool_materials {
        // Pickaxe: 3 materials + 2 sticks.
        recipes.push(CraftingRecipe {
            inputs: vec![(material.clone(), 3), (stick.clone(), 2)],
            output: ItemType::Tool(ToolType::Pickaxe, tool_material),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(material.clone());
                cells[0][1] = Some(material.clone());
                cells[0][2] = Some(material.clone());
                cells[1][1] = Some(stick.clone());
                cells[2][1] = Some(stick.clone());
                CraftingPattern {
                    width: 3,
                    height: 3,
                    cells,
                }
            }),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        });

        // Axe: 3 materials + 2 sticks (mirrorable).
        recipes.push(CraftingRecipe {
            inputs: vec![(material.clone(), 3), (stick.clone(), 2)],
            output: ItemType::Tool(ToolType::Axe, tool_material),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(material.clone());
                cells[0][1] = Some(material.clone());
                cells[1][0] = Some(material.clone());
                cells[1][1] = Some(stick.clone());
                cells[2][1] = Some(stick.clone());
                CraftingPattern {
                    width: 2,
                    height: 3,
                    cells,
                }
            }),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        });

        // Shovel: 1 material + 2 sticks.
        recipes.push(CraftingRecipe {
            inputs: vec![(material.clone(), 1), (stick.clone(), 2)],
            output: ItemType::Tool(ToolType::Shovel, tool_material),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(material.clone());
                cells[1][0] = Some(stick.clone());
                cells[2][0] = Some(stick.clone());
                CraftingPattern {
                    width: 1,
                    height: 3,
                    cells,
                }
            }),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        });

        // Sword: 2 materials + 1 stick.
        recipes.push(CraftingRecipe {
            inputs: vec![(material.clone(), 2), (stick.clone(), 1)],
            output: ItemType::Tool(ToolType::Sword, tool_material),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(material.clone());
                cells[1][0] = Some(material.clone());
                cells[2][0] = Some(stick.clone());
                CraftingPattern {
                    width: 1,
                    height: 3,
                    cells,
                }
            }),
            allow_horizontal_mirror: false,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        });

        // Hoe: 2 materials + 2 sticks (mirrorable).
        recipes.push(CraftingRecipe {
            inputs: vec![(material.clone(), 2), (stick.clone(), 2)],
            output: ItemType::Tool(ToolType::Hoe, tool_material),
            output_count: 1,
            pattern: Some({
                let mut cells: [[Option<CraftingIngredient>; 3]; 3] = Default::default();
                cells[0][0] = Some(material.clone());
                cells[0][1] = Some(material.clone());
                cells[1][1] = Some(stick.clone());
                cells[2][1] = Some(stick.clone());
                CraftingPattern {
                    width: 2,
                    height: 3,
                    cells,
                }
            }),
            allow_horizontal_mirror: true,
            min_grid_size: CraftingGridSize::ThreeByThree,
            allow_extra_counts_of_required_types: false,
        });
    }

    recipes.extend(pack_crafting_recipes().iter().cloned());
    recipes
}

fn sorted_item_counts(items: &std::collections::HashMap<ItemType, u32>) -> Vec<(ItemType, u32)> {
    let mut counts: Vec<(ItemType, u32)> = items.iter().map(|(t, c)| (*t, *c)).collect();
    counts.sort_by_key(|(t, _)| item_type_sort_key(*t));
    counts
}

#[derive(Debug, Clone)]
struct CraftingAllocation {
    used_by_item: Vec<u32>,
    used_by_requirement: Vec<Vec<(usize, u32)>>,
}

fn allocate_crafting_requirements(
    available: &[(ItemType, u32)],
    requirements: &[(CraftingIngredient, u32)],
    blocks: &BlockRegistry,
) -> Option<CraftingAllocation> {
    #[derive(Clone)]
    struct Edge {
        to: usize,
        rev: usize,
        cap: u32,
    }

    fn add_edge(graph: &mut [Vec<Edge>], from: usize, to: usize, cap: u32) -> usize {
        let from_rev = graph[from].len();
        let to_rev = graph[to].len();
        graph[from].push(Edge {
            to,
            rev: to_rev,
            cap,
        });
        graph[to].push(Edge {
            to: from,
            rev: from_rev,
            cap: 0,
        });
        from_rev
    }

    fn max_flow(graph: &mut [Vec<Edge>], source: usize, sink: usize) -> u32 {
        use std::collections::VecDeque;

        let mut flow = 0_u32;
        loop {
            let mut parent: Vec<Option<(usize, usize)>> = vec![None; graph.len()];
            let mut queue = VecDeque::new();
            queue.push_back(source);
            parent[source] = Some((source, usize::MAX));

            while let Some(v) = queue.pop_front() {
                if v == sink {
                    break;
                }
                for (edge_idx, edge) in graph[v].iter().enumerate() {
                    if edge.cap == 0 {
                        continue;
                    }
                    if parent[edge.to].is_some() {
                        continue;
                    }
                    parent[edge.to] = Some((v, edge_idx));
                    queue.push_back(edge.to);
                }
            }

            if parent[sink].is_none() {
                break;
            }

            let mut path_flow = u32::MAX;
            let mut v = sink;
            while v != source {
                let (p, edge_idx) = parent[v].expect("path must exist");
                path_flow = path_flow.min(graph[p][edge_idx].cap);
                v = p;
            }

            let mut v = sink;
            while v != source {
                let (p, edge_idx) = parent[v].expect("path must exist");
                let rev = graph[p][edge_idx].rev;
                graph[p][edge_idx].cap -= path_flow;
                graph[v][rev].cap += path_flow;
                v = p;
            }

            flow += path_flow;
        }
        flow
    }

    let requirements: Vec<(CraftingIngredient, u32)> = requirements
        .iter()
        .filter_map(|(ingredient, count)| (*count > 0).then_some((ingredient.clone(), *count)))
        .collect();
    if requirements.is_empty() {
        return None;
    }

    let total_required: u32 = requirements.iter().map(|(_, count)| *count).sum();
    if total_required == 0 {
        return None;
    }

    let item_count = available.len();
    let req_count = requirements.len();
    let source = 0;
    let items_offset = 1;
    let reqs_offset = items_offset + item_count;
    let sink = reqs_offset + req_count;

    let mut graph: Vec<Vec<Edge>> = vec![Vec::new(); sink + 1];
    let mut source_edges = Vec::with_capacity(item_count);
    let mut source_caps = Vec::with_capacity(item_count);

    for (idx, (_, count)) in available.iter().enumerate() {
        source_caps.push(*count);
        let edge_idx = add_edge(&mut graph, source, items_offset + idx, *count);
        source_edges.push(edge_idx);
    }

    let mut requirement_item_edges: Vec<Vec<(usize, usize)>> = vec![Vec::new(); req_count];

    for (req_idx, (ingredient, count)) in requirements.iter().enumerate() {
        add_edge(&mut graph, reqs_offset + req_idx, sink, *count);

        for (item_idx, (item_type, avail_count)) in available.iter().enumerate() {
            if *avail_count == 0 {
                continue;
            }
            if ingredient.matches_item(*item_type, blocks) {
                let edge_idx = add_edge(
                    &mut graph,
                    items_offset + item_idx,
                    reqs_offset + req_idx,
                    *avail_count,
                );
                requirement_item_edges[req_idx].push((item_idx, edge_idx));
            }
        }
    }

    let flow = max_flow(&mut graph, source, sink);
    if flow != total_required {
        return None;
    }

    let mut used_by_item = Vec::with_capacity(item_count);
    for (idx, cap) in source_caps.into_iter().enumerate() {
        let edge_idx = source_edges[idx];
        let remaining = graph[source][edge_idx].cap;
        used_by_item.push(cap.saturating_sub(remaining));
    }

    let mut used_by_requirement = Vec::with_capacity(req_count);
    for (req_idx, item_edges) in requirement_item_edges.into_iter().enumerate() {
        let mut allocations = Vec::new();
        for (item_idx, edge_idx) in item_edges {
            let item_node = items_offset + item_idx;
            let req_node = reqs_offset + req_idx;
            let rev = graph[item_node][edge_idx].rev;
            let flow = graph[req_node][rev].cap;
            if flow > 0 {
                allocations.push((item_idx, flow));
            }
        }
        used_by_requirement.push(allocations);
    }

    Some(CraftingAllocation {
        used_by_item,
        used_by_requirement,
    })
}

fn match_crafting_recipe(
    crafting_grid: &[[Option<ItemStack>; 3]; 3],
    grid_size: CraftingGridSize,
    blocks: &BlockRegistry,
) -> Option<CraftingRecipe> {
    let grid_dim = grid_size.dimension();
    // Treat any items outside the active grid size as an automatic mismatch.
    for (r, row) in crafting_grid.iter().enumerate() {
        for (c, slot) in row.iter().enumerate() {
            if (r >= grid_dim || c >= grid_dim) && slot.is_some() {
                return None;
            }
        }
    }

    // Gather items from grid
    let mut grid_items: std::collections::HashMap<ItemType, u32> = std::collections::HashMap::new();
    let mut total_grid_items: u32 = 0;
    for row in crafting_grid {
        for stack in row.iter().flatten() {
            *grid_items.entry(stack.item_type).or_insert(0) += stack.count;
            total_grid_items = total_grid_items.saturating_add(stack.count);
        }
    }

    let pattern_matches = |pattern: &CraftingPattern| -> bool {
        if pattern.width > grid_dim || pattern.height > grid_dim {
            return false;
        }

        for row_offset in 0..=grid_dim.saturating_sub(pattern.height) {
            for col_offset in 0..=grid_dim.saturating_sub(pattern.width) {
                let mut ok = true;
                for (r, row) in crafting_grid.iter().enumerate().take(grid_dim) {
                    for (c, slot) in row.iter().enumerate().take(grid_dim) {
                        let expected = if (row_offset..row_offset + pattern.height).contains(&r)
                            && (col_offset..col_offset + pattern.width).contains(&c)
                        {
                            pattern.cells[r - row_offset][c - col_offset].as_ref()
                        } else {
                            None
                        };

                        let actual = slot.as_ref().map(|stack| stack.item_type);
                        let matches = match (expected, actual) {
                            (None, None) => true,
                            (Some(expected), Some(actual)) => expected.matches_item(actual, blocks),
                            _ => false,
                        };
                        if !matches {
                            ok = false;
                            break;
                        }
                    }
                    if !ok {
                        break;
                    }
                }

                if ok {
                    return true;
                }
            }
        }

        false
    };

    // Prefer shaped recipes when they match the grid exactly (vanilla behavior).
    let recipes = get_crafting_recipes();
    for recipe in recipes.iter() {
        if recipe.min_grid_size.dimension() > grid_size.dimension() {
            continue;
        }

        let Some(pattern) = recipe.pattern.as_ref() else {
            continue;
        };
        if pattern_matches(pattern) {
            return Some(recipe.clone());
        }
        if recipe.allow_horizontal_mirror {
            let mirrored = pattern.mirrored_horizontal();
            if pattern_matches(&mirrored) {
                return Some(recipe.clone());
            }
        }
    }

    // Check shapeless recipes.
    for recipe in recipes {
        if recipe.min_grid_size.dimension() > grid_size.dimension() {
            continue;
        }

        if recipe.pattern.is_some() {
            continue;
        }

        let has_tags = recipe
            .inputs
            .iter()
            .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
        if !has_tags {
            let mut matches = true;
            let mut required: std::collections::HashMap<ItemType, u32> =
                std::collections::HashMap::new();
            for (ingredient, needed) in &recipe.inputs {
                let CraftingIngredient::Exact(item_type) = ingredient else {
                    matches = false;
                    break;
                };
                *required.entry(*item_type).or_insert(0) += needed;
            }

            if matches {
                // Check required items are present (optionally allowing extra counts).
                for (item_type, needed) in &required {
                    match grid_items.get(item_type) {
                        Some(have) if *have >= *needed => {
                            if !recipe.allow_extra_counts_of_required_types && *have != *needed {
                                matches = false;
                                break;
                            }
                        }
                        _ => {
                            matches = false;
                            break;
                        }
                    }
                }
            }

            // Also check no extra item types.
            if matches {
                for item_type in grid_items.keys() {
                    if !required.contains_key(item_type) {
                        matches = false;
                        break;
                    }
                }
            }

            if matches {
                return Some(recipe);
            }

            continue;
        }

        let total_required: u32 = recipe.inputs.iter().map(|(_, count)| *count).sum();
        if total_required == 0 {
            continue;
        }
        if !recipe.allow_extra_counts_of_required_types && total_grid_items != total_required {
            continue;
        }

        // Ensure there are no extra item types that don't match any ingredient.
        let has_unexpected = grid_items.keys().any(|item_type| {
            !recipe
                .inputs
                .iter()
                .any(|(ingredient, _)| ingredient.matches_item(*item_type, blocks))
        });
        if has_unexpected {
            continue;
        }

        let available = sorted_item_counts(&grid_items);
        if allocate_crafting_requirements(&available, &recipe.inputs, blocks).is_some() {
            return Some(recipe);
        }
    }

    None
}

fn storage_count_item_type(
    hotbar: &Hotbar,
    main_inventory: &MainInventory,
    item_type: ItemType,
) -> u32 {
    let mut total: u32 = 0;
    for stack in main_inventory
        .slots
        .iter()
        .chain(hotbar.slots.iter())
        .flatten()
    {
        if stack.item_type == item_type {
            total = total.saturating_add(stack.count);
        }
    }
    total
}

fn crafting_max_crafts_in_storage(
    hotbar: &Hotbar,
    main_inventory: &MainInventory,
    inputs: &[(CraftingIngredient, u32)],
    blocks: &BlockRegistry,
) -> u32 {
    let has_tags = inputs
        .iter()
        .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
    if !has_tags {
        let mut required: std::collections::HashMap<ItemType, u32> =
            std::collections::HashMap::new();
        for (ingredient, count) in inputs.iter().cloned() {
            let CraftingIngredient::Exact(item_type) = ingredient else {
                return 0;
            };
            if count == 0 {
                continue;
            }
            *required.entry(item_type).or_insert(0) += count;
        }

        let mut crafts = u32::MAX;
        for (item_type, needed) in required {
            if needed == 0 {
                continue;
            }
            let have = storage_count_item_type(hotbar, main_inventory, item_type);
            crafts = crafts.min(have / needed);
        }

        return if crafts == u32::MAX { 0 } else { crafts };
    }

    let mut available_map: std::collections::HashMap<ItemType, u32> =
        std::collections::HashMap::new();
    for stack in main_inventory
        .slots
        .iter()
        .chain(hotbar.slots.iter())
        .flatten()
    {
        if stack.count == 0 {
            continue;
        }
        *available_map.entry(stack.item_type).or_insert(0) += stack.count;
    }

    let available = sorted_item_counts(&available_map);
    if available.is_empty() {
        return 0;
    }

    let mut upper = u32::MAX;
    for (ingredient, needed) in inputs.iter() {
        if *needed == 0 {
            continue;
        }

        let have = match ingredient {
            CraftingIngredient::Exact(item_type) => {
                storage_count_item_type(hotbar, main_inventory, *item_type)
            }
            CraftingIngredient::BlockTag(tag) => main_inventory
                .slots
                .iter()
                .chain(hotbar.slots.iter())
                .flatten()
                .filter(|stack| match stack.item_type {
                    ItemType::Block(block_id) => blocks.has_tag(block_id, tag),
                    _ => false,
                })
                .map(|stack| stack.count)
                .sum(),
        };

        upper = upper.min(have / *needed);
    }
    if upper == u32::MAX {
        return 0;
    }

    let mut lo = 0_u32;
    let mut hi = upper;
    while lo < hi {
        let mid = lo.saturating_add(hi).saturating_add(1) / 2;
        let scaled: Vec<(CraftingIngredient, u32)> = inputs
            .iter()
            .filter_map(|(ingredient, count)| {
                let scaled = count.saturating_mul(mid);
                (scaled > 0).then_some((ingredient.clone(), scaled))
            })
            .collect();

        if allocate_crafting_requirements(&available, &scaled, blocks).is_some() {
            lo = mid;
        } else {
            hi = mid.saturating_sub(1);
        }
    }

    lo
}

fn take_items_from_storage(
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    item_type: ItemType,
    mut remaining: u32,
) -> bool {
    if remaining == 0 {
        return true;
    }

    for slot in main_inventory
        .slots
        .iter_mut()
        .chain(hotbar.slots.iter_mut())
    {
        if remaining == 0 {
            break;
        }

        let Some(stack) = slot.as_mut() else {
            continue;
        };
        if stack.item_type != item_type || stack.count == 0 {
            continue;
        }

        let take = remaining.min(stack.count);
        stack.count -= take;
        remaining -= take;
        if stack.count == 0 {
            *slot = None;
        }
    }

    remaining == 0
}

fn crafting_grid_is_empty<const N: usize>(grid: &[[Option<ItemStack>; N]; N]) -> bool {
    grid.iter().all(|row| row.iter().all(Option::is_none))
}

fn try_autofill_crafting_grid<const N: usize>(
    grid: &mut [[Option<ItemStack>; N]; N],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    recipe: &CraftingRecipe,
    blocks: &BlockRegistry,
) -> bool {
    if !crafting_grid_is_empty(grid) {
        return false;
    }

    if let Some(pattern) = recipe.pattern.as_ref() {
        if pattern.width > N || pattern.height > N {
            return false;
        }

        let mut ingredients_in_order: Vec<CraftingIngredient> = Vec::new();
        let mut counts: std::collections::HashMap<CraftingIngredient, u32> =
            std::collections::HashMap::new();
        for r in 0..pattern.height {
            for c in 0..pattern.width {
                let Some(ingredient) = pattern.cells[r][c].as_ref() else {
                    continue;
                };
                if !counts.contains_key(ingredient) {
                    ingredients_in_order.push(ingredient.clone());
                }
                *counts.entry(ingredient.clone()).or_insert(0) += 1;
            }
        }

        let requirements: Vec<(CraftingIngredient, u32)> = ingredients_in_order
            .iter()
            .filter_map(|ingredient| {
                let count = counts.get(ingredient).copied().unwrap_or(0);
                (count > 0).then_some((ingredient.clone(), count))
            })
            .collect();

        let has_tags = requirements
            .iter()
            .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
        if !has_tags {
            for (ingredient, needed) in requirements.iter() {
                let CraftingIngredient::Exact(item_type) = ingredient else {
                    return false;
                };
                let have = storage_count_item_type(hotbar, main_inventory, *item_type);
                if have < *needed {
                    return false;
                }
            }

            for (ingredient, needed) in requirements.into_iter() {
                let CraftingIngredient::Exact(item_type) = ingredient else {
                    return false;
                };
                let ok = take_items_from_storage(hotbar, main_inventory, item_type, needed);
                debug_assert!(ok, "pre-checked storage but take_items_from_storage failed");
                if !ok {
                    return false;
                }
            }

            for (r, row) in grid.iter_mut().enumerate().take(pattern.height) {
                for (c, slot) in row.iter_mut().enumerate().take(pattern.width) {
                    let Some(ingredient) = pattern.cells[r][c].as_ref() else {
                        continue;
                    };
                    let CraftingIngredient::Exact(item_type) = ingredient else {
                        return false;
                    };
                    *slot = Some(ItemStack::new(*item_type, 1));
                }
            }

            return true;
        }

        let mut available_map: std::collections::HashMap<ItemType, u32> =
            std::collections::HashMap::new();
        for stack in main_inventory
            .slots
            .iter()
            .chain(hotbar.slots.iter())
            .flatten()
        {
            if stack.count == 0 {
                continue;
            }
            *available_map.entry(stack.item_type).or_insert(0) += stack.count;
        }

        let available = sorted_item_counts(&available_map);
        let Some(allocation) = allocate_crafting_requirements(&available, &requirements, blocks)
        else {
            return false;
        };

        for (item_idx, used) in allocation.used_by_item.iter().copied().enumerate() {
            if used == 0 {
                continue;
            }
            let item_type = available[item_idx].0;
            let ok = take_items_from_storage(hotbar, main_inventory, item_type, used);
            debug_assert!(
                ok,
                "allocation derived from storage but take_items_from_storage failed"
            );
            if !ok {
                return false;
            }
        }

        let mut ingredient_index: std::collections::HashMap<CraftingIngredient, usize> =
            std::collections::HashMap::new();
        for (idx, ingredient) in ingredients_in_order.iter().enumerate() {
            ingredient_index.insert(ingredient.clone(), idx);
        }

        let mut expanded_for_requirement: Vec<Vec<ItemType>> = Vec::new();
        for allocations in allocation.used_by_requirement.iter() {
            let mut expanded = Vec::new();
            for (item_idx, count) in allocations.iter().copied() {
                let item_type = available[item_idx].0;
                expanded.extend(std::iter::repeat_n(item_type, count as usize));
            }
            expanded_for_requirement.push(expanded);
        }
        let mut next_for_requirement = vec![0usize; expanded_for_requirement.len()];

        for (r, row) in grid.iter_mut().enumerate().take(pattern.height) {
            for (c, slot) in row.iter_mut().enumerate().take(pattern.width) {
                let Some(ingredient) = pattern.cells[r][c].as_ref() else {
                    continue;
                };
                let Some(&req_idx) = ingredient_index.get(ingredient) else {
                    return false;
                };
                let idx = next_for_requirement[req_idx];
                let Some(item_type) = expanded_for_requirement
                    .get(req_idx)
                    .and_then(|v| v.get(idx))
                    .copied()
                else {
                    return false;
                };
                next_for_requirement[req_idx] += 1;
                *slot = Some(ItemStack::new(item_type, 1));
            }
        }

        return true;
    }

    let inputs = &recipe.inputs;
    let has_tags = inputs
        .iter()
        .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
    if !has_tags {
        let mut required: std::collections::HashMap<ItemType, u32> =
            std::collections::HashMap::new();
        for (ingredient, count) in inputs.iter().cloned() {
            let CraftingIngredient::Exact(item_type) = ingredient else {
                return false;
            };
            if count == 0 {
                continue;
            }
            *required.entry(item_type).or_insert(0) += count;
        }

        let mut needed_slots = 0_usize;
        for (item_type, count) in required.iter() {
            let max = ItemStack::new(*item_type, 1).max_stack_size().max(1);
            needed_slots += count.div_ceil(max) as usize;
        }
        if needed_slots > N * N {
            return false;
        }

        for (item_type, needed) in required.iter() {
            let have = storage_count_item_type(hotbar, main_inventory, *item_type);
            if have < *needed {
                return false;
            }
        }

        for (item_type, needed) in required.iter() {
            if !take_items_from_storage(hotbar, main_inventory, *item_type, *needed) {
                return false;
            }
        }

        for (ingredient, count) in inputs.iter().cloned() {
            let CraftingIngredient::Exact(item_type) = ingredient else {
                return false;
            };
            let max = ItemStack::new(item_type, 1).max_stack_size().max(1);
            let mut remaining = count;
            while remaining > 0 {
                let placed = remaining.min(max);
                remaining -= placed;
                let placed_stack = ItemStack::new(item_type, placed);

                let mut target = None;
                #[allow(clippy::needless_range_loop)]
                for row in 0..N {
                    #[allow(clippy::needless_range_loop)]
                    for col in 0..N {
                        if grid[row][col].is_none() {
                            target = Some((row, col));
                            break;
                        }
                    }
                    if target.is_some() {
                        break;
                    }
                }

                let Some((row, col)) = target else {
                    return false;
                };

                grid[row][col] = Some(placed_stack);
            }
        }

        return true;
    }

    let mut available_map: std::collections::HashMap<ItemType, u32> =
        std::collections::HashMap::new();
    for stack in main_inventory
        .slots
        .iter()
        .chain(hotbar.slots.iter())
        .flatten()
    {
        if stack.count == 0 {
            continue;
        }
        *available_map.entry(stack.item_type).or_insert(0) += stack.count;
    }

    let available = sorted_item_counts(&available_map);
    let requirements: Vec<(CraftingIngredient, u32)> = inputs
        .iter()
        .filter_map(|(ingredient, count)| (*count > 0).then_some((ingredient.clone(), *count)))
        .collect();
    let Some(allocation) = allocate_crafting_requirements(&available, &requirements, blocks) else {
        return false;
    };

    let mut needed_slots = 0_usize;
    for (item_idx, used) in allocation.used_by_item.iter().copied().enumerate() {
        if used == 0 {
            continue;
        }
        let item_type = available[item_idx].0;
        let max = ItemStack::new(item_type, 1).max_stack_size().max(1);
        needed_slots += used.div_ceil(max) as usize;
    }
    if needed_slots > N * N {
        return false;
    }

    for (item_idx, used) in allocation.used_by_item.iter().copied().enumerate() {
        if used == 0 {
            continue;
        }
        let item_type = available[item_idx].0;
        if !take_items_from_storage(hotbar, main_inventory, item_type, used) {
            return false;
        }
    }

    for (item_idx, used) in allocation.used_by_item.iter().copied().enumerate() {
        if used == 0 {
            continue;
        }

        let item_type = available[item_idx].0;
        let max = ItemStack::new(item_type, 1).max_stack_size().max(1);
        let mut remaining = used;
        while remaining > 0 {
            let placed = remaining.min(max);
            remaining -= placed;
            let placed_stack = ItemStack::new(item_type, placed);

            let mut target = None;
            #[allow(clippy::needless_range_loop)]
            for row in 0..N {
                #[allow(clippy::needless_range_loop)]
                for col in 0..N {
                    if grid[row][col].is_none() {
                        target = Some((row, col));
                        break;
                    }
                }
                if target.is_some() {
                    break;
                }
            }

            let Some((row, col)) = target else {
                return false;
            };

            grid[row][col] = Some(placed_stack);
        }
    }

    true
}

fn clear_crafting_grid_to_storage<const N: usize>(
    grid: &mut [[Option<ItemStack>; N]; N],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    spill_items: &mut Vec<ItemStack>,
) {
    for row in grid.iter_mut() {
        for slot in row.iter_mut() {
            let Some(stack) = slot.take() else {
                continue;
            };

            if let Some(remainder) = add_stack_to_storage(hotbar, main_inventory, stack) {
                spill_items.push(remainder);
            }
        }
    }
}

fn consume_crafting_inputs_3x3(
    crafting_grid: &mut [[Option<ItemStack>; 3]; 3],
    recipe: &CraftingRecipe,
    blocks: &BlockRegistry,
) -> bool {
    if let Some(pattern) = recipe.pattern.as_ref() {
        let required_cells: usize = (0..pattern.height)
            .flat_map(|r| (0..pattern.width).filter_map(move |c| pattern.cells[r][c].as_ref()))
            .count();
        if required_cells == 0 {
            return false;
        }

        let non_empty_cells = crafting_grid
            .iter()
            .flatten()
            .filter(|slot| slot.is_some())
            .count();
        if non_empty_cells != required_cells {
            return false;
        }

        for row in crafting_grid.iter_mut() {
            for slot in row.iter_mut() {
                let Some(stack) = slot.as_mut() else {
                    continue;
                };
                stack.count = stack.count.saturating_sub(1);
                if stack.count == 0 {
                    *slot = None;
                }
            }
        }

        return true;
    }

    let has_tags = recipe
        .inputs
        .iter()
        .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
    if !has_tags {
        for (ingredient, mut remaining) in recipe.inputs.iter().cloned() {
            let CraftingIngredient::Exact(item_type) = ingredient else {
                return false;
            };
            if remaining == 0 {
                continue;
            }

            for row in crafting_grid.iter_mut() {
                for slot in row.iter_mut() {
                    if remaining == 0 {
                        break;
                    }

                    let Some(stack) = slot.as_mut() else {
                        continue;
                    };
                    if stack.item_type != item_type || stack.count == 0 {
                        continue;
                    }

                    let take = remaining.min(stack.count);
                    stack.count -= take;
                    remaining -= take;

                    if stack.count == 0 {
                        *slot = None;
                    }
                }
            }

            if remaining != 0 {
                return false;
            }
        }

        return true;
    }

    let mut grid_items: std::collections::HashMap<ItemType, u32> = std::collections::HashMap::new();
    for stack in crafting_grid.iter().flatten().flatten() {
        if stack.count == 0 {
            continue;
        }
        *grid_items.entry(stack.item_type).or_insert(0) += stack.count;
    }
    let available = sorted_item_counts(&grid_items);
    let requirements: Vec<(CraftingIngredient, u32)> = recipe
        .inputs
        .iter()
        .filter_map(|(ingredient, count)| (*count > 0).then_some((ingredient.clone(), *count)))
        .collect();
    let Some(allocation) = allocate_crafting_requirements(&available, &requirements, blocks) else {
        return false;
    };

    for (item_idx, mut remaining) in allocation.used_by_item.into_iter().enumerate() {
        if remaining == 0 {
            continue;
        }

        let Some((item_type, _)) = available.get(item_idx) else {
            return false;
        };
        for row in crafting_grid.iter_mut() {
            for slot in row.iter_mut() {
                if remaining == 0 {
                    break;
                }

                let Some(stack) = slot.as_mut() else {
                    continue;
                };
                if stack.item_type != *item_type || stack.count == 0 {
                    continue;
                }

                let take = remaining.min(stack.count);
                stack.count -= take;
                remaining -= take;

                if stack.count == 0 {
                    *slot = None;
                }
            }
        }

        if remaining != 0 {
            return false;
        }
    }

    true
}

fn consume_crafting_inputs_2x2(
    crafting_grid: &mut [[Option<ItemStack>; 2]; 2],
    recipe: &CraftingRecipe,
    blocks: &BlockRegistry,
) -> bool {
    if let Some(pattern) = recipe.pattern.as_ref() {
        let required_cells: usize = (0..pattern.height)
            .flat_map(|r| (0..pattern.width).filter_map(move |c| pattern.cells[r][c].as_ref()))
            .count();
        if required_cells == 0 {
            return false;
        }

        let non_empty_cells = crafting_grid
            .iter()
            .flatten()
            .filter(|slot| slot.is_some())
            .count();
        if non_empty_cells != required_cells {
            return false;
        }

        for row in crafting_grid.iter_mut() {
            for slot in row.iter_mut() {
                let Some(stack) = slot.as_mut() else {
                    continue;
                };
                stack.count = stack.count.saturating_sub(1);
                if stack.count == 0 {
                    *slot = None;
                }
            }
        }

        return true;
    }

    let has_tags = recipe
        .inputs
        .iter()
        .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
    if !has_tags {
        for (ingredient, mut remaining) in recipe.inputs.iter().cloned() {
            let CraftingIngredient::Exact(item_type) = ingredient else {
                return false;
            };
            if remaining == 0 {
                continue;
            }

            for row in crafting_grid.iter_mut() {
                for slot in row.iter_mut() {
                    if remaining == 0 {
                        break;
                    }

                    let Some(stack) = slot.as_mut() else {
                        continue;
                    };
                    if stack.item_type != item_type || stack.count == 0 {
                        continue;
                    }

                    let take = remaining.min(stack.count);
                    stack.count -= take;
                    remaining -= take;

                    if stack.count == 0 {
                        *slot = None;
                    }
                }
            }

            if remaining != 0 {
                return false;
            }
        }

        return true;
    }

    let mut grid_items: std::collections::HashMap<ItemType, u32> = std::collections::HashMap::new();
    for stack in crafting_grid.iter().flatten().flatten() {
        if stack.count == 0 {
            continue;
        }
        *grid_items.entry(stack.item_type).or_insert(0) += stack.count;
    }
    let available = sorted_item_counts(&grid_items);
    let requirements: Vec<(CraftingIngredient, u32)> = recipe
        .inputs
        .iter()
        .filter_map(|(ingredient, count)| (*count > 0).then_some((ingredient.clone(), *count)))
        .collect();
    let Some(allocation) = allocate_crafting_requirements(&available, &requirements, blocks) else {
        return false;
    };

    for (item_idx, mut remaining) in allocation.used_by_item.into_iter().enumerate() {
        if remaining == 0 {
            continue;
        }

        let Some((item_type, _)) = available.get(item_idx) else {
            return false;
        };
        for row in crafting_grid.iter_mut() {
            for slot in row.iter_mut() {
                if remaining == 0 {
                    break;
                }

                let Some(stack) = slot.as_mut() else {
                    continue;
                };
                if stack.item_type != *item_type || stack.count == 0 {
                    continue;
                }

                let take = remaining.min(stack.count);
                stack.count -= take;
                remaining -= take;

                if stack.count == 0 {
                    *slot = None;
                }
            }
        }

        if remaining != 0 {
            return false;
        }
    }

    true
}

fn cursor_can_accept_full_stack(cursor: &Option<ItemStack>, stack: &ItemStack) -> bool {
    if stack.count == 0 {
        return false;
    }

    match cursor {
        None => stack.count <= stack.max_stack_size(),
        Some(cursor_stack) => {
            stacks_match_for_merge(cursor_stack, stack)
                && cursor_stack.count + stack.count <= cursor_stack.max_stack_size()
        }
    }
}

fn cursor_add_full_stack(cursor: &mut Option<ItemStack>, stack: ItemStack) {
    if stack.count == 0 {
        return;
    }

    match cursor {
        None => {
            *cursor = Some(stack);
        }
        Some(cursor_stack) => {
            debug_assert!(stacks_match_for_merge(cursor_stack, &stack));
            cursor_stack.count += stack.count;
        }
    }
}

fn crafting_max_crafts_3x3(
    crafting_grid: &[[Option<ItemStack>; 3]; 3],
    recipe: &CraftingRecipe,
    blocks: &BlockRegistry,
) -> u32 {
    if let Some(pattern) = recipe.pattern.as_ref() {
        let required_cells: usize = (0..pattern.height)
            .flat_map(|r| (0..pattern.width).filter_map(move |c| pattern.cells[r][c].as_ref()))
            .count();
        if required_cells == 0 {
            return 0;
        }

        let mut min_count = u32::MAX;
        let mut non_empty_cells = 0_usize;
        for stack in crafting_grid.iter().flatten().flatten() {
            non_empty_cells += 1;
            min_count = min_count.min(stack.count);
        }
        if non_empty_cells != required_cells {
            return 0;
        }

        if min_count == u32::MAX {
            0
        } else {
            min_count
        }
    } else {
        let has_tags = recipe
            .inputs
            .iter()
            .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
        if !has_tags {
            let mut crafts = u32::MAX;
            for (ingredient, needed) in recipe.inputs.iter() {
                if *needed == 0 {
                    continue;
                }
                let CraftingIngredient::Exact(item_type) = ingredient else {
                    return 0;
                };

                let have: u32 = crafting_grid
                    .iter()
                    .flatten()
                    .flatten()
                    .filter(|stack| stack.item_type == *item_type)
                    .map(|stack| stack.count)
                    .sum();
                crafts = crafts.min(have / *needed);
            }

            return if crafts == u32::MAX { 0 } else { crafts };
        }

        let mut available_map: std::collections::HashMap<ItemType, u32> =
            std::collections::HashMap::new();
        for stack in crafting_grid.iter().flatten().flatten() {
            if stack.count == 0 {
                continue;
            }
            *available_map.entry(stack.item_type).or_insert(0) += stack.count;
        }
        let available = sorted_item_counts(&available_map);
        if available.is_empty() {
            return 0;
        }

        let mut upper = u32::MAX;
        for (ingredient, needed) in recipe.inputs.iter() {
            if *needed == 0 {
                continue;
            }

            let have = match ingredient {
                CraftingIngredient::Exact(item_type) => {
                    available_map.get(item_type).copied().unwrap_or(0)
                }
                CraftingIngredient::BlockTag(tag) => available
                    .iter()
                    .filter(|(item_type, _)| match item_type {
                        ItemType::Block(block_id) => blocks.has_tag(*block_id, tag),
                        _ => false,
                    })
                    .map(|(_, count)| *count)
                    .sum(),
            };

            upper = upper.min(have / *needed);
        }
        if upper == u32::MAX {
            return 0;
        }

        let mut lo = 0_u32;
        let mut hi = upper;
        while lo < hi {
            let mid = lo.saturating_add(hi).saturating_add(1) / 2;
            let scaled: Vec<(CraftingIngredient, u32)> = recipe
                .inputs
                .iter()
                .filter_map(|(ingredient, count)| {
                    let scaled = count.saturating_mul(mid);
                    (scaled > 0).then_some((ingredient.clone(), scaled))
                })
                .collect();

            if allocate_crafting_requirements(&available, &scaled, blocks).is_some() {
                lo = mid;
            } else {
                hi = mid.saturating_sub(1);
            }
        }

        lo
    }
}

fn crafting_max_crafts_2x2(
    crafting_grid: &[[Option<ItemStack>; 2]; 2],
    recipe: &CraftingRecipe,
    blocks: &BlockRegistry,
) -> u32 {
    if let Some(pattern) = recipe.pattern.as_ref() {
        let required_cells: usize = (0..pattern.height)
            .flat_map(|r| (0..pattern.width).filter_map(move |c| pattern.cells[r][c].as_ref()))
            .count();
        if required_cells == 0 {
            return 0;
        }

        let mut min_count = u32::MAX;
        let mut non_empty_cells = 0_usize;
        for stack in crafting_grid.iter().flatten().flatten() {
            non_empty_cells += 1;
            min_count = min_count.min(stack.count);
        }
        if non_empty_cells != required_cells {
            return 0;
        }

        if min_count == u32::MAX {
            0
        } else {
            min_count
        }
    } else {
        let has_tags = recipe
            .inputs
            .iter()
            .any(|(ingredient, _)| matches!(ingredient, CraftingIngredient::BlockTag(_)));
        if !has_tags {
            let mut crafts = u32::MAX;
            for (ingredient, needed) in recipe.inputs.iter() {
                if *needed == 0 {
                    continue;
                }
                let CraftingIngredient::Exact(item_type) = ingredient else {
                    return 0;
                };

                let have: u32 = crafting_grid
                    .iter()
                    .flatten()
                    .flatten()
                    .filter(|stack| stack.item_type == *item_type)
                    .map(|stack| stack.count)
                    .sum();
                crafts = crafts.min(have / *needed);
            }

            return if crafts == u32::MAX { 0 } else { crafts };
        }

        let mut available_map: std::collections::HashMap<ItemType, u32> =
            std::collections::HashMap::new();
        for stack in crafting_grid.iter().flatten().flatten() {
            if stack.count == 0 {
                continue;
            }
            *available_map.entry(stack.item_type).or_insert(0) += stack.count;
        }
        let available = sorted_item_counts(&available_map);
        if available.is_empty() {
            return 0;
        }

        let mut upper = u32::MAX;
        for (ingredient, needed) in recipe.inputs.iter() {
            if *needed == 0 {
                continue;
            }

            let have = match ingredient {
                CraftingIngredient::Exact(item_type) => {
                    available_map.get(item_type).copied().unwrap_or(0)
                }
                CraftingIngredient::BlockTag(tag) => available
                    .iter()
                    .filter(|(item_type, _)| match item_type {
                        ItemType::Block(block_id) => blocks.has_tag(*block_id, tag),
                        _ => false,
                    })
                    .map(|(_, count)| *count)
                    .sum(),
            };

            upper = upper.min(have / *needed);
        }
        if upper == u32::MAX {
            return 0;
        }

        let mut lo = 0_u32;
        let mut hi = upper;
        while lo < hi {
            let mid = lo.saturating_add(hi).saturating_add(1) / 2;
            let scaled: Vec<(CraftingIngredient, u32)> = recipe
                .inputs
                .iter()
                .filter_map(|(ingredient, count)| {
                    let scaled = count.saturating_mul(mid);
                    (scaled > 0).then_some((ingredient.clone(), scaled))
                })
                .collect();

            if allocate_crafting_requirements(&available, &scaled, blocks).is_some() {
                lo = mid;
            } else {
                hi = mid.saturating_sub(1);
            }
        }

        lo
    }
}

/// Check if the crafting grid matches a recipe.
///
/// This only reports the output; see [`match_crafting_recipe`] for the full match.
#[cfg(test)]
fn test_blocks() -> &'static BlockRegistry {
    static BLOCKS: OnceLock<BlockRegistry> = OnceLock::new();
    BLOCKS.get_or_init(|| {
        crate::config::load_block_registry_strict().expect("block registry should load for tests")
    })
}

#[cfg(test)]
fn check_crafting_recipe(crafting_grid: &[[Option<ItemStack>; 3]; 3]) -> Option<(ItemType, u32)> {
    match_crafting_recipe(crafting_grid, CraftingGridSize::ThreeByThree, test_blocks())
        .map(|recipe| (recipe.output, recipe.output_count))
}

/// Render the crafting table UI
/// Returns (close_clicked, spill_items)
fn render_crafting(
    ctx: &egui::Context,
    crafting_grid: &mut [[Option<ItemStack>; 3]; 3],
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
    blocks: &BlockRegistry,
) -> (bool, Vec<ItemStack>) {
    let mut close_clicked = false;
    let mut spill_items = Vec::new();
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                let mut dummy_personal_grid: [[Option<ItemStack>; 2]; 2] = Default::default();
                apply_primary_drag_distribution(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    &mut dummy_personal_grid,
                    crafting_grid,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    // Check for matching recipe
    let recipe_match = match_crafting_recipe(crafting_grid, CraftingGridSize::ThreeByThree, blocks);

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("crafting_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    // Crafting window
    egui::Window::new("Crafting Table")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(640.0);

            // Close button
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Crafting").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.label(
                    egui::RichText::new("Left click: pick/place. Right click: split/place one.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            ui.separator();

            ui.horizontal(|ui| {
                let cursor_empty = ui_cursor_stack.is_none();
                let grid_empty = crafting_grid_is_empty(crafting_grid);

                ui.vertical(|ui| {
                    ui.label(egui::RichText::new("Recipe Book").strong());
                    ui.add_space(4.0);
                    ui.label(
                        egui::RichText::new("Fill requires empty cursor + grid.")
                            .size(11.0)
                            .color(egui::Color32::GRAY),
                    );

                    ui.add_space(6.0);

                    let recipes = get_crafting_recipes();
                    egui::ScrollArea::vertical()
                        .max_height(210.0)
                        .auto_shrink([false, true])
                        .show(ui, |ui| {
                            for recipe in recipes.iter() {
                                let crafts = crafting_max_crafts_in_storage(
                                    hotbar,
                                    main_inventory,
                                    &recipe.inputs,
                                    blocks,
                                );
                                let craftable = crafts > 0;
                                ui.horizontal(|ui| {
                                    let label =
                                        format!("{:?} x{}", recipe.output, recipe.output_count);
                                    ui.label(egui::RichText::new(label).color(if craftable {
                                        egui::Color32::WHITE
                                    } else {
                                        egui::Color32::DARK_GRAY
                                    }));

                                    ui.with_layout(
                                        egui::Layout::right_to_left(egui::Align::Center),
                                        |ui| {
                                            let enabled = craftable && cursor_empty && grid_empty;
                                            if ui
                                                .add_enabled(enabled, egui::Button::new("Fill"))
                                                .clicked()
                                            {
                                                let _ = try_autofill_crafting_grid(
                                                    crafting_grid,
                                                    hotbar,
                                                    main_inventory,
                                                    recipe,
                                                    blocks,
                                                );
                                            }
                                        },
                                    );
                                });
                                ui.add_space(2.0);
                            }
                        });
                });

                ui.add_space(18.0);
                ui.separator();
                ui.add_space(18.0);

                ui.vertical(|ui| {
                    ui.horizontal(|ui| {
                        // 3x3 Crafting grid with clickable slots
                        ui.vertical(|ui| {
                            ui.horizontal(|ui| {
                                ui.label("Crafting Grid");
                                if ui
                                    .add_enabled(cursor_empty, egui::Button::new("Clear"))
                                    .clicked()
                                {
                                    clear_crafting_grid_to_storage(
                                        crafting_grid,
                                        hotbar,
                                        main_inventory,
                                        &mut spill_items,
                                    );
                                }
                            });
                            #[allow(clippy::needless_range_loop)]
                            for row_idx in 0..3 {
                                ui.horizontal(|ui| {
                                    #[allow(clippy::needless_range_loop)]
                                    for col_idx in 0..3 {
                                        render_core_slot_interactive_shift_moves_to_storage(
                                            ui,
                                            UiCoreSlotId::CraftingGrid(row_idx * 3 + col_idx),
                                            &mut crafting_grid[row_idx][col_idx],
                                            ui_cursor_stack,
                                            (&mut *hotbar, &mut *main_inventory),
                                            ui_drag,
                                            UiSlotVisual::new(40.0, false),
                                        );
                                    }
                                });
                            }
                        });

                        ui.add_space(20.0);

                        // Arrow and result
                        ui.vertical(|ui| {
                            ui.add_space(40.0);
                            ui.label(
                                egui::RichText::new("")
                                    .size(24.0)
                                    .color(egui::Color32::WHITE),
                            );
                        });

                        ui.add_space(20.0);

                        // Result slot with craft button
                        ui.vertical(|ui| {
                            ui.label("Result");
                            ui.add_space(10.0);
                            if let Some(recipe) = recipe_match.as_ref() {
                                let result_stack =
                                    ItemStack::new(recipe.output, recipe.output_count);
                                let response = render_crafting_output_slot_interactive(
                                    ui,
                                    Some(&result_stack),
                                    "Click to craft\nShift-click: craft all to inventory",
                                );
                                let clicked = response.clicked_by(egui::PointerButton::Primary)
                                    || response.clicked_by(egui::PointerButton::Secondary);
                                if clicked {
                                    let shift = ui.input(|i| i.modifiers.shift);
                                    if shift {
                                        let crafts =
                                            crafting_max_crafts_3x3(crafting_grid, recipe, blocks);
                                        let mut crafted = 0_u32;
                                        for _ in 0..crafts {
                                            if consume_crafting_inputs_3x3(
                                                crafting_grid,
                                                recipe,
                                                blocks,
                                            ) {
                                                crafted += 1;
                                            } else {
                                                break;
                                            }
                                        }

                                        if crafted > 0 {
                                            let total = recipe.output_count.saturating_mul(crafted);
                                            let output_stack = ItemStack::new(recipe.output, total);
                                            if let Some(remainder) = add_stack_to_storage(
                                                hotbar,
                                                main_inventory,
                                                output_stack,
                                            ) {
                                                spill_items.push(remainder);
                                            }
                                        }
                                    } else if cursor_can_accept_full_stack(
                                        ui_cursor_stack,
                                        &result_stack,
                                    ) && consume_crafting_inputs_3x3(
                                        crafting_grid,
                                        recipe,
                                        blocks,
                                    ) {
                                        cursor_add_full_stack(ui_cursor_stack, result_stack);
                                    }
                                }
                            } else {
                                render_crafting_output_slot_interactive(ui, None, "No recipe");
                                ui.label(
                                    egui::RichText::new("No recipe")
                                        .size(10.0)
                                        .color(egui::Color32::GRAY),
                                );
                            }
                        });
                    });
                });
            });

            ui.add_space(10.0);
            ui.separator();
            render_player_storage(ui, hotbar, main_inventory, ui_cursor_stack, ui_drag);
        });

    (close_clicked, spill_items)
}

/// Render a single crafting slot
fn render_crafting_slot(ui: &mut egui::Ui, item: Option<&ItemStack>) {
    let frame = egui::Frame::none()
        .fill(egui::Color32::from_rgba_unmultiplied(60, 60, 60, 200))
        .stroke(egui::Stroke::new(1.0, egui::Color32::GRAY))
        .inner_margin(4.0);

    frame.show(ui, |ui| {
        ui.set_min_size(egui::vec2(40.0, 40.0));
        ui.set_max_size(egui::vec2(40.0, 40.0));

        if let Some(stack) = item {
            ui.vertical_centered(|ui| {
                let name = match stack.item_type {
                    mdminecraft_core::ItemType::Tool(tool, _) => format!("{:?}", tool),
                    mdminecraft_core::ItemType::Block(id) => format!("B{}", id),
                    mdminecraft_core::ItemType::Food(food) => format!("{:?}", food),
                    mdminecraft_core::ItemType::Potion(id) => format!("P{}", id),
                    mdminecraft_core::ItemType::SplashPotion(id) => format!("SP{}", id),
                    mdminecraft_core::ItemType::Item(id) => format!("I{}", id),
                };
                ui.label(
                    egui::RichText::new(&name[..name.len().min(4)])
                        .size(10.0)
                        .color(egui::Color32::WHITE),
                );

                if stack.count > 1 {
                    ui.label(
                        egui::RichText::new(format!("{}", stack.count))
                            .size(10.0)
                            .color(egui::Color32::YELLOW),
                    );
                }
            });
        }
    });
}

fn render_crafting_output_slot_interactive(
    ui: &mut egui::Ui,
    item: Option<&ItemStack>,
    hover_text: &str,
) -> egui::Response {
    let mut response = ui.allocate_response(egui::vec2(40.0, 40.0), egui::Sense::click());
    let rect = response.rect;

    let fill = egui::Color32::from_rgba_unmultiplied(60, 60, 60, 200);
    ui.painter().rect_filled(rect, 0.0, fill);
    ui.painter()
        .rect_stroke(rect, 0.0, egui::Stroke::new(1.0, egui::Color32::GRAY));

    ui.allocate_ui_at_rect(rect.shrink(4.0), |ui| {
        if let Some(stack) = item {
            ui.vertical_centered(|ui| {
                let name = match stack.item_type {
                    mdminecraft_core::ItemType::Tool(tool, _) => format!("{:?}", tool),
                    mdminecraft_core::ItemType::Block(id) => format!("B{}", id),
                    mdminecraft_core::ItemType::Food(food) => format!("{:?}", food),
                    mdminecraft_core::ItemType::Potion(id) => format!("P{}", id),
                    mdminecraft_core::ItemType::SplashPotion(id) => format!("SP{}", id),
                    mdminecraft_core::ItemType::Item(id) => format!("I{}", id),
                };
                ui.label(
                    egui::RichText::new(&name[..name.len().min(4)])
                        .size(10.0)
                        .color(egui::Color32::WHITE),
                );
                if stack.count > 1 {
                    ui.label(
                        egui::RichText::new(format!("{}", stack.count))
                            .size(10.0)
                            .color(egui::Color32::YELLOW),
                    );
                }
            });
        }
    });

    if let Some(stack) = item {
        let mut tooltip = format!("{:?}\nCount: {}", stack.item_type, stack.count);
        if let (Some(current), Some(max)) = (stack.durability, stack.max_durability()) {
            paint_durability_bar(ui, rect, current, max);
            tooltip.push_str(&format!("\nDurability: {}/{}", current, max));
        }
        let enchants = stack.get_enchantments();
        if !enchants.is_empty() {
            tooltip.push_str("\nEnchantments:");
            for enchant in enchants {
                tooltip.push_str(&format!(
                    "\n- {:?} {}",
                    enchant.enchantment_type, enchant.level
                ));
            }
        }
        tooltip.push_str(&format!("\n\n{}", hover_text));
        response = response.on_hover_text(tooltip);
    } else {
        response = response.on_hover_text(hover_text);
    }

    response
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct VillagerTradeOffer {
    buy_a: (ItemType, u32),
    buy_b: Option<(ItemType, u32)>,
    sell: (ItemType, u32),
}

fn villager_trade_offers(
    world_seed: u64,
    villager_id: u64,
) -> (&'static str, Vec<VillagerTradeOffer>) {
    let hash =
        world_seed ^ villager_id.wrapping_mul(0x9E37_79B9_7F4A_7C15) ^ 0x5649_4C4C_4147_4552_u64; // "VILLAGER"

    let emerald = ItemType::Item(17);
    match hash % 3 {
        0 => (
            "Farmer",
            vec![
                VillagerTradeOffer {
                    buy_a: (ItemType::Item(CORE_ITEM_WHEAT), 20),
                    buy_b: None,
                    sell: (emerald, 1),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 1),
                    buy_b: None,
                    sell: (ItemType::Food(mdminecraft_core::item::FoodType::Bread), 3),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 1),
                    buy_b: None,
                    sell: (ItemType::Food(mdminecraft_core::item::FoodType::Apple), 3),
                },
            ],
        ),
        1 => (
            "Fletcher",
            vec![
                VillagerTradeOffer {
                    buy_a: (ItemType::Item(3), 32),
                    buy_b: None,
                    sell: (emerald, 1),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 1),
                    buy_b: None,
                    sell: (ItemType::Item(2), 16),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 1),
                    buy_b: None,
                    sell: (ItemType::Block(interactive_blocks::TORCH), 16),
                },
            ],
        ),
        _ => (
            "Librarian",
            vec![
                VillagerTradeOffer {
                    buy_a: (ItemType::Item(CORE_ITEM_PAPER), 24),
                    buy_b: None,
                    sell: (emerald, 1),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 1),
                    buy_b: None,
                    sell: (ItemType::Item(CORE_ITEM_BOOK), 1),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 5),
                    buy_b: None,
                    sell: (ItemType::Item(CORE_ITEM_ENDER_PEARL), 1),
                },
                VillagerTradeOffer {
                    buy_a: (emerald, 3),
                    buy_b: None,
                    sell: (ItemType::Block(BLOCK_BOOKSHELF), 1),
                },
            ],
        ),
    }
}

fn render_villager_trade(
    ctx: &egui::Context,
    profession: &str,
    offers: &[VillagerTradeOffer],
    selected_trade: &mut usize,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    registry: &BlockRegistry,
) -> (bool, Option<ItemStack>) {
    let mut close_clicked = false;
    let mut spill: Option<ItemStack> = None;

    egui::Area::new(egui::Id::new("villager_trade_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    egui::Window::new("Trading")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(520.0);

            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Trading").size(18.0).strong());
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new(format!("({})", profession))
                        .size(12.0)
                        .color(egui::Color32::GRAY),
                );
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            if offers.is_empty() {
                ui.label(
                    egui::RichText::new("No trades available.")
                        .size(12.0)
                        .color(egui::Color32::GRAY),
                );
                return;
            }

            if *selected_trade >= offers.len() {
                *selected_trade = 0;
            }

            ui.label(
                egui::RichText::new("Select an offer, then click Trade.")
                    .size(11.0)
                    .color(egui::Color32::GRAY),
            );
            ui.add_space(8.0);

            egui::ScrollArea::vertical()
                .max_height(220.0)
                .show(ui, |ui| {
                    for (idx, offer) in offers.iter().enumerate() {
                        let buy_a_name = hotbar.item_name(
                            Some(&ItemStack::new(offer.buy_a.0, offer.buy_a.1)),
                            registry,
                        );
                        let sell_name = hotbar
                            .item_name(Some(&ItemStack::new(offer.sell.0, offer.sell.1)), registry);
                        let buy_b_name = offer.buy_b.as_ref().map(|(ty, count)| {
                            hotbar.item_name(Some(&ItemStack::new(*ty, *count)), registry)
                        });

                        let have_a = storage_count_item_type(hotbar, main_inventory, offer.buy_a.0);
                        let can_trade = have_a >= offer.buy_a.1
                            && offer
                                .buy_b
                                .as_ref()
                                .map(|(ty, needed)| {
                                    storage_count_item_type(hotbar, main_inventory, *ty) >= *needed
                                })
                                .unwrap_or(true);

                        ui.horizontal(|ui| {
                            let selected = *selected_trade == idx;
                            let label = if let Some(buy_b_name) = buy_b_name.as_ref() {
                                format!("{buy_a_name} + {buy_b_name}  {sell_name}")
                            } else {
                                format!("{buy_a_name}  {sell_name}")
                            };
                            let mut response = ui.selectable_label(selected, label);
                            if !can_trade {
                                response = response.on_hover_text("Not enough items to trade");
                            }
                            if response.clicked() {
                                *selected_trade = idx;
                            }

                            ui.with_layout(
                                egui::Layout::right_to_left(egui::Align::Center),
                                |ui| {
                                    let trade_enabled = can_trade && idx == *selected_trade;
                                    if ui
                                        .add_enabled(trade_enabled, egui::Button::new("Trade"))
                                        .clicked()
                                    {
                                        let ok = take_items_from_storage(
                                            hotbar,
                                            main_inventory,
                                            offer.buy_a.0,
                                            offer.buy_a.1,
                                        );
                                        debug_assert!(ok, "can_trade gate should ensure buy_a");

                                        if let Some((ty, needed)) = offer.buy_b {
                                            let ok = take_items_from_storage(
                                                hotbar,
                                                main_inventory,
                                                ty,
                                                needed,
                                            );
                                            debug_assert!(ok, "can_trade gate should ensure buy_b");
                                        }

                                        let remainder = add_stack_to_storage(
                                            hotbar,
                                            main_inventory,
                                            ItemStack::new(offer.sell.0, offer.sell.1),
                                        );
                                        spill = remainder;
                                    }
                                },
                            );
                        });
                    }
                });

            ui.add_space(6.0);
            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    (close_clicked, spill)
}

/// Render the chest UI
/// Returns true if the close button was clicked
fn render_chest(
    ctx: &egui::Context,
    chest: &mut ChestState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> bool {
    let mut close_clicked = false;
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                apply_primary_drag_distribution_with_chest(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    chest,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("chest_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    // Chest window
    egui::Window::new("Chest")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(420.0);

            // Close button
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Chest").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new("Shift: quick-move. Drag: distribute.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            ui.add_space(10.0);

            ui.label(
                egui::RichText::new("Chest")
                    .size(12.0)
                    .color(egui::Color32::GRAY),
            );
            for row in 0..3 {
                ui.horizontal(|ui| {
                    for col in 0..9 {
                        let slot_idx = row * 9 + col;
                        render_core_slot_interactive_shift_moves_to_storage(
                            ui,
                            UiCoreSlotId::Chest(slot_idx),
                            &mut chest.slots[slot_idx],
                            ui_cursor_stack,
                            (hotbar, main_inventory),
                            ui_drag,
                            UiSlotVisual::new(36.0, false),
                        );
                    }
                });
            }

            ui.add_space(10.0);
            ui.separator();
            render_player_storage_for_chest(
                ui,
                chest,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            ui.add_space(5.0);
            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    close_clicked
}

fn render_hopper(
    ctx: &egui::Context,
    hopper: &mut HopperState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> bool {
    let mut close_clicked = false;
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                apply_primary_drag_distribution_with_hopper(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    hopper,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    egui::Area::new(egui::Id::new("hopper_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    egui::Window::new("Hopper")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(360.0);

            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Hopper").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new("Shift: quick-move. Drag: distribute.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            ui.add_space(10.0);

            ui.label(
                egui::RichText::new("Hopper")
                    .size(12.0)
                    .color(egui::Color32::GRAY),
            );
            ui.horizontal(|ui| {
                for slot_idx in 0..hopper.slots.len() {
                    render_core_slot_interactive_shift_moves_to_storage(
                        ui,
                        UiCoreSlotId::Hopper(slot_idx),
                        &mut hopper.slots[slot_idx],
                        ui_cursor_stack,
                        (hotbar, main_inventory),
                        ui_drag,
                        UiSlotVisual::new(36.0, false),
                    );
                }
            });

            ui.add_space(10.0);
            ui.separator();
            render_player_storage_for_hopper(
                ui,
                hopper,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            ui.add_space(5.0);
            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    close_clicked
}

fn render_dispenser(
    ctx: &egui::Context,
    dispenser: &mut DispenserState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> bool {
    let mut close_clicked = false;
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                apply_primary_drag_distribution_with_dispenser(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    dispenser,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    egui::Area::new(egui::Id::new("dispenser_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    egui::Window::new("Dispenser")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(420.0);

            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Dispenser").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new("Shift: quick-move. Drag: distribute.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            ui.add_space(10.0);

            ui.label(
                egui::RichText::new("Dispenser")
                    .size(12.0)
                    .color(egui::Color32::GRAY),
            );
            for row in 0..3 {
                ui.horizontal(|ui| {
                    for col in 0..3 {
                        let slot_idx = row * 3 + col;
                        render_core_slot_interactive_shift_moves_to_storage(
                            ui,
                            UiCoreSlotId::Dispenser(slot_idx),
                            &mut dispenser.slots[slot_idx],
                            ui_cursor_stack,
                            (hotbar, main_inventory),
                            ui_drag,
                            UiSlotVisual::new(36.0, false),
                        );
                    }
                });
            }

            ui.add_space(10.0);
            ui.separator();
            render_player_storage_for_dispenser(
                ui,
                dispenser,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            ui.add_space(5.0);
            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    close_clicked
}

fn render_dropper(
    ctx: &egui::Context,
    dropper: &mut DispenserState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> bool {
    let mut close_clicked = false;
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                apply_primary_drag_distribution_with_dropper(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    dropper,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    egui::Area::new(egui::Id::new("dropper_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    egui::Window::new("Dropper")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(420.0);

            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Dropper").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new("Shift: quick-move. Drag: distribute.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            ui.add_space(10.0);

            ui.label(
                egui::RichText::new("Dropper")
                    .size(12.0)
                    .color(egui::Color32::GRAY),
            );
            for row in 0..3 {
                ui.horizontal(|ui| {
                    for col in 0..3 {
                        let slot_idx = row * 3 + col;
                        render_core_slot_interactive_shift_moves_to_storage(
                            ui,
                            UiCoreSlotId::Dropper(slot_idx),
                            &mut dropper.slots[slot_idx],
                            ui_cursor_stack,
                            (hotbar, main_inventory),
                            ui_drag,
                            UiSlotVisual::new(36.0, false),
                        );
                    }
                });
            }

            ui.add_space(10.0);
            ui.separator();
            render_player_storage_for_dropper(
                ui,
                dropper,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            ui.add_space(5.0);
            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    close_clicked
}

/// Render the furnace UI
/// Returns true if the close button was clicked
fn render_furnace(
    ctx: &egui::Context,
    furnace: &mut FurnaceState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> bool {
    let mut close_clicked = false;
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                let mut dummy_personal_grid: [[Option<ItemStack>; 2]; 2] = Default::default();
                let mut dummy_crafting_grid: [[Option<ItemStack>; 3]; 3] = Default::default();
                apply_primary_drag_distribution(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    &mut dummy_personal_grid,
                    &mut dummy_crafting_grid,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("furnace_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    // Furnace window
    egui::Window::new("Furnace")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(360.0);

            // Close button
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Furnace").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
            });
            ui.add_space(6.0);

            ui.horizontal(|ui| {
                // Input and Fuel slots column
                ui.vertical(|ui| {
                    ui.label("Input (smeltable)");
                    render_furnace_slot_interactive(
                        ui,
                        &mut furnace.input,
                        ui_cursor_stack,
                        hotbar,
                        main_inventory,
                        FurnaceSlotKind::Input,
                    );

                    ui.add_space(10.0);

                    ui.label("Fuel");
                    render_furnace_slot_interactive(
                        ui,
                        &mut furnace.fuel,
                        ui_cursor_stack,
                        hotbar,
                        main_inventory,
                        FurnaceSlotKind::Fuel,
                    );
                });

                ui.add_space(20.0);

                // Arrow and progress
                ui.vertical(|ui| {
                    ui.add_space(20.0);

                    // Progress bar
                    let progress = furnace.smelt_progress;
                    let progress_bar = egui::ProgressBar::new(progress)
                        .desired_width(60.0)
                        .text(format!("{:.0}%", progress * 100.0));
                    ui.add(progress_bar);

                    ui.add_space(5.0);

                    // Fire indicator
                    let fire_color = if furnace.is_lit {
                        egui::Color32::from_rgb(255, 128, 0)
                    } else {
                        egui::Color32::DARK_GRAY
                    };
                    ui.label(egui::RichText::new("").size(24.0).color(fire_color));

                    // Fuel remaining indicator
                    if furnace.fuel_remaining > 0.0 {
                        ui.label(
                            egui::RichText::new(format!("{:.1}", furnace.fuel_remaining))
                                .size(10.0)
                                .color(egui::Color32::YELLOW),
                        );
                    }
                });

                ui.add_space(20.0);

                // Output slot
                ui.vertical(|ui| {
                    ui.label("Output");
                    render_furnace_slot_interactive(
                        ui,
                        &mut furnace.output,
                        ui_cursor_stack,
                        hotbar,
                        main_inventory,
                        FurnaceSlotKind::Output,
                    );
                });
            });

            ui.add_space(10.0);
            ui.separator();

            // Status text
            let status = if furnace.is_lit {
                "Smelting..."
            } else if furnace.input.is_some() && furnace.fuel.is_none() {
                "Need fuel"
            } else if furnace.input.is_none() {
                "Add smeltable item"
            } else {
                "Ready"
            };
            ui.label(
                egui::RichText::new(status)
                    .size(12.0)
                    .color(if furnace.is_lit {
                        egui::Color32::from_rgb(255, 200, 100)
                    } else {
                        egui::Color32::GRAY
                    }),
            );

            ui.add_space(5.0);
            ui.separator();
            render_player_storage_for_furnace(
                ui,
                furnace,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    close_clicked
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FurnaceSlotKind {
    Input,
    Fuel,
    Output,
}

fn furnace_slot_accepts_item(kind: FurnaceSlotKind, item: DroppedItemType) -> bool {
    match kind {
        FurnaceSlotKind::Input => mdminecraft_world::get_smelt_output(item).is_some(),
        FurnaceSlotKind::Fuel => mdminecraft_world::is_fuel(item),
        FurnaceSlotKind::Output => false,
    }
}

fn apply_furnace_slot_click(
    slot: &mut Option<(DroppedItemType, u32)>,
    cursor: &mut Option<ItemStack>,
    kind: FurnaceSlotKind,
    click: UiSlotClick,
) {
    let Some((slot_drop_type, slot_count)) = slot.take() else {
        if kind == FurnaceSlotKind::Output {
            return;
        }

        let Some(mut cursor_stack) = cursor.take() else {
            return;
        };

        let Some(cursor_drop_type) =
            GameWorld::convert_core_item_type_to_dropped(cursor_stack.item_type)
        else {
            *cursor = Some(cursor_stack);
            return;
        };

        if !furnace_slot_accepts_item(kind, cursor_drop_type) {
            *cursor = Some(cursor_stack);
            return;
        }

        let max = cursor_drop_type.max_stack_size();
        let to_place = match click {
            UiSlotClick::Primary => cursor_stack.count.min(max),
            UiSlotClick::Secondary => 1.min(cursor_stack.count).min(max),
        };
        if to_place == 0 {
            *cursor = Some(cursor_stack);
            return;
        }

        *slot = Some((cursor_drop_type, to_place));
        cursor_stack.count -= to_place;
        if cursor_stack.count > 0 {
            *cursor = Some(cursor_stack);
        }
        return;
    };

    // Slot contains an item.
    let Some(core_item_type) = GameWorld::convert_dropped_item_type(slot_drop_type) else {
        *slot = Some((slot_drop_type, slot_count));
        return;
    };

    let Some(mut cursor_stack) = cursor.take() else {
        let take = match click {
            UiSlotClick::Primary => slot_count,
            UiSlotClick::Secondary => slot_count.div_ceil(2),
        };
        if take == 0 {
            *slot = Some((slot_drop_type, slot_count));
            return;
        }

        *cursor = Some(ItemStack::new(core_item_type, take));
        let remaining = slot_count - take;
        if remaining > 0 {
            *slot = Some((slot_drop_type, remaining));
        }
        return;
    };

    if kind == FurnaceSlotKind::Output {
        if cursor_stack.item_type != core_item_type {
            *cursor = Some(cursor_stack);
            *slot = Some((slot_drop_type, slot_count));
            return;
        }

        let max = cursor_stack.max_stack_size();
        if cursor_stack.count >= max {
            *cursor = Some(cursor_stack);
            *slot = Some((slot_drop_type, slot_count));
            return;
        }

        let space = max - cursor_stack.count;
        let to_take = match click {
            UiSlotClick::Primary => space.min(slot_count),
            UiSlotClick::Secondary => 1.min(space).min(slot_count),
        };
        if to_take == 0 {
            *cursor = Some(cursor_stack);
            *slot = Some((slot_drop_type, slot_count));
            return;
        }

        cursor_stack.count += to_take;
        *cursor = Some(cursor_stack);

        let remaining = slot_count - to_take;
        if remaining > 0 {
            *slot = Some((slot_drop_type, remaining));
        }
        return;
    }

    let Some(cursor_drop_type) =
        GameWorld::convert_core_item_type_to_dropped(cursor_stack.item_type)
    else {
        *cursor = Some(cursor_stack);
        *slot = Some((slot_drop_type, slot_count));
        return;
    };

    if !furnace_slot_accepts_item(kind, cursor_drop_type) {
        *cursor = Some(cursor_stack);
        *slot = Some((slot_drop_type, slot_count));
        return;
    }

    if cursor_drop_type == slot_drop_type {
        let max = slot_drop_type.max_stack_size();
        if slot_count >= max {
            *cursor = Some(cursor_stack);
            *slot = Some((slot_drop_type, slot_count));
            return;
        }

        let space = max - slot_count;
        let to_move = match click {
            UiSlotClick::Primary => space.min(cursor_stack.count),
            UiSlotClick::Secondary => 1.min(space).min(cursor_stack.count),
        };
        if to_move == 0 {
            *cursor = Some(cursor_stack);
            *slot = Some((slot_drop_type, slot_count));
            return;
        }

        *slot = Some((slot_drop_type, slot_count + to_move));
        cursor_stack.count -= to_move;
        if cursor_stack.count > 0 {
            *cursor = Some(cursor_stack);
        }
        return;
    }

    // Different item types: left-click swaps if the cursor stack fits entirely.
    if click == UiSlotClick::Secondary {
        *cursor = Some(cursor_stack);
        *slot = Some((slot_drop_type, slot_count));
        return;
    }

    if cursor_stack.count > cursor_drop_type.max_stack_size() {
        *cursor = Some(cursor_stack);
        *slot = Some((slot_drop_type, slot_count));
        return;
    }

    *slot = Some((cursor_drop_type, cursor_stack.count));
    *cursor = Some(ItemStack::new(core_item_type, slot_count));
}

fn render_furnace_slot_interactive(
    ui: &mut egui::Ui,
    slot: &mut Option<(DroppedItemType, u32)>,
    cursor: &mut Option<ItemStack>,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    kind: FurnaceSlotKind,
) {
    let mut response = ui.allocate_response(egui::vec2(48.0, 48.0), egui::Sense::click());
    let rect = response.rect;
    let fill = if slot.is_some() {
        egui::Color32::from_rgba_unmultiplied(80, 80, 80, 200)
    } else {
        egui::Color32::from_rgba_unmultiplied(40, 40, 40, 180)
    };
    ui.painter()
        .rect(rect, 2.0, fill, egui::Stroke::new(1.0, egui::Color32::GRAY));

    if let Some((item_type, count)) = slot.as_ref() {
        let name = format!("{:?}", item_type);
        let display_name = if name.len() > 6 { &name[..6] } else { &name };
        ui.painter().text(
            rect.center(),
            egui::Align2::CENTER_CENTER,
            display_name,
            egui::FontId::proportional(10.0),
            egui::Color32::WHITE,
        );
        if *count > 1 {
            ui.painter().text(
                rect.right_bottom() - egui::vec2(4.0, 4.0),
                egui::Align2::RIGHT_BOTTOM,
                format!("{}", count),
                egui::FontId::proportional(9.0),
                egui::Color32::YELLOW,
            );
        }

        let mut tooltip = format!("{:?}\nCount: {}", item_type, count);
        if kind == FurnaceSlotKind::Input {
            tooltip.push_str("\nSmeltable");
        } else if kind == FurnaceSlotKind::Fuel {
            tooltip.push_str("\nFuel");
        } else {
            tooltip.push_str("\nOutput");
        }
        response = response.on_hover_text(tooltip);
    } else {
        response = response.on_hover_text(match kind {
            FurnaceSlotKind::Input => "Input (smeltable)",
            FurnaceSlotKind::Fuel => "Fuel",
            FurnaceSlotKind::Output => "Output",
        });
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };

    if let Some(click) = click {
        let shift = ui.input(|i| i.modifiers.shift);
        if shift {
            let Some((item_type, count)) = slot.take() else {
                return;
            };

            let Some(core_item_type) = GameWorld::convert_dropped_item_type(item_type) else {
                *slot = Some((item_type, count));
                return;
            };

            let stack = ItemStack::new(core_item_type, count);
            if let Some(remainder) = add_stack_to_storage(hotbar, main_inventory, stack) {
                *slot = Some((item_type, remainder.count));
            }
            return;
        }

        apply_furnace_slot_click(slot, cursor, kind, click);
    }
}

/// Result of enchanting table interaction
struct EnchantingResult {
    /// Whether close was requested
    close_requested: bool,
    /// Enchantment to apply (if any)
    enchantment_applied: Option<mdminecraft_core::Enchantment>,
    /// XP levels to consume (if enchantment applied)
    xp_to_consume: u32,
}

/// Render the enchanting table UI
/// Returns close state and any enchantment result
fn render_enchanting_table(
    ctx: &egui::Context,
    table: &mut EnchantingTableState,
    player_xp: &PlayerXP,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> EnchantingResult {
    use mdminecraft_world::LAPIS_COSTS;

    let mut result = EnchantingResult {
        close_requested: false,
        enchantment_applied: None,
        xp_to_consume: 0,
    };
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                let mut dummy_personal_grid: [[Option<ItemStack>; 2]; 2] = Default::default();
                let mut dummy_crafting_grid: [[Option<ItemStack>; 3]; 3] = Default::default();
                apply_primary_drag_distribution(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    &mut dummy_personal_grid,
                    &mut dummy_crafting_grid,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("enchanting_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    // Enchanting table window
    egui::Window::new("Enchanting Table")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(350.0);

            let selected_item = hotbar.selected_item();
            let selected_item_enchantable = selected_item
                .map(|item| item.is_enchantable())
                .unwrap_or(false);
            let selected_item_id = selected_item
                .and_then(core_item_to_enchanting_id)
                .filter(|_| selected_item_enchantable);

            // Keep the table's internal "preview item" in sync with the selected hotbar tool.
            let current_item_id = table.item.map(|(id, _)| id);
            if selected_item_id != current_item_id {
                let _ = table.take_item();
                if let Some(id) = selected_item_id {
                    let _ = table.add_item(id, 1);
                }
            }

            // Close button
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Enchanting Table").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        result.close_requested = true;
                    }
                });
            });

            ui.separator();

            // Status info
            ui.horizontal(|ui| {
                ui.label(format!("Bookshelves: {}", table.bookshelf_count));
                ui.add_space(20.0);
                ui.label("Lapis:");
                render_enchanting_lapis_slot(ui, &mut table.lapis_count, ui_cursor_stack);
                ui.add_space(20.0);
                ui.label(format!("Your Level: {}", player_xp.level));
            });

            ui.add_space(6.0);
            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
            });

            ui.add_space(10.0);

            // Item status
            ui.horizontal(|ui| {
                if selected_item_enchantable {
                    ui.label(
                        egui::RichText::new("Selected hotbar item can be enchanted")
                            .color(egui::Color32::GREEN),
                    );
                } else {
                    ui.label(
                        egui::RichText::new("Select an enchantable item in your hotbar")
                            .color(egui::Color32::YELLOW),
                    );
                }
            });

            ui.add_space(10.0);
            ui.separator();
            ui.add_space(5.0);

            // Enchantment options
            ui.label(
                egui::RichText::new("Enchantment Options:")
                    .size(14.0)
                    .strong(),
            );
            ui.add_space(5.0);

            // Track which slot was clicked (to apply after iteration)
            let mut apply_slot: Option<usize> = None;

            // Copy data we need to display (avoids borrow issues)
            let options_copy: [(Option<_>, u32); 3] = [
                (table.enchant_options[0], LAPIS_COSTS[0]),
                (table.enchant_options[1], LAPIS_COSTS[1]),
                (table.enchant_options[2], LAPIS_COSTS[2]),
            ];
            let lapis_count = table.lapis_count;

            for (slot_idx, (option, lapis_cost)) in options_copy.iter().enumerate() {
                if let Some(offer) = option {
                    // Can only enchant if player has enough XP, lapis, AND has an enchantable item
                    let can_afford = player_xp.level >= offer.level_cost
                        && lapis_count >= *lapis_cost
                        && selected_item_enchantable;

                    let text_color = if can_afford {
                        egui::Color32::WHITE
                    } else {
                        egui::Color32::DARK_GRAY
                    };

                    ui.horizontal(|ui| {
                        // Slot number
                        ui.label(
                            egui::RichText::new(format!("{}.", slot_idx + 1))
                                .size(14.0)
                                .color(text_color),
                        );

                        // Enchantment name and level
                        let enchant_name = format!(
                            "{:?} {}",
                            offer.enchantment.enchantment_type, offer.enchantment.level
                        );
                        ui.label(
                            egui::RichText::new(enchant_name)
                                .size(13.0)
                                .color(text_color),
                        );

                        ui.add_space(10.0);

                        // Cost info
                        ui.label(
                            egui::RichText::new(format!(
                                "Cost: {} levels, {} lapis",
                                offer.level_cost, lapis_cost
                            ))
                            .size(11.0)
                            .color(if can_afford {
                                egui::Color32::GREEN
                            } else {
                                egui::Color32::RED
                            }),
                        );

                        // Enchant button (disabled if can't afford or no enchantable item)
                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            let button = egui::Button::new("Enchant").sense(if can_afford {
                                egui::Sense::click()
                            } else {
                                egui::Sense::hover()
                            });
                            if ui.add(button).clicked() && can_afford {
                                apply_slot = Some(slot_idx);
                            }
                        });
                    });
                } else {
                    ui.label(
                        egui::RichText::new(format!("{}. ---", slot_idx + 1))
                            .size(14.0)
                            .color(egui::Color32::DARK_GRAY),
                    );
                }

                ui.add_space(3.0);
            }

            // Apply enchantment after the loop (now we can mutably borrow table)
            if let Some(slot_idx) = apply_slot {
                if let Some((enchantment, levels_consumed)) = table.apply_enchantment(slot_idx) {
                    result.enchantment_applied = Some(enchantment);
                    result.xp_to_consume = levels_consumed;
                    let bookshelf_count = table.bookshelf_count;
                    table.set_bookshelf_count(bookshelf_count);
                    tracing::info!(
                        "Enchanting: {:?} level {} (costs {} XP levels)",
                        enchantment.enchantment_type,
                        enchantment.level,
                        levels_consumed
                    );
                }
            }

            ui.add_space(10.0);
            ui.separator();

            render_player_storage_for_enchanting_table(
                ui,
                table,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    result
}

fn core_item_to_enchanting_id(stack: &ItemStack) -> Option<u16> {
    match stack.item_type {
        ItemType::Tool(tool, material) => {
            let tool_index: u16 = match tool {
                ToolType::Pickaxe => 0,
                ToolType::Axe => 1,
                ToolType::Shovel => 2,
                ToolType::Hoe => 3,
                ToolType::Sword => 4,
            };
            let material_index = material as u16;
            Some(
                mdminecraft_world::TOOL_ID_START
                    .saturating_add(tool_index.saturating_mul(5))
                    .saturating_add(material_index),
            )
        }
        ItemType::Item(id) => match id {
            1 => Some(mdminecraft_world::BOW_ID),
            // Armor core item IDs (see `armor_piece_from_core_stack` for the core id mapping).
            10 => Some(mdminecraft_world::ARMOR_ID_START + 1), // iron_helmet
            11 => Some(mdminecraft_world::ARMOR_ID_START + 5), // iron_chestplate
            12 => Some(mdminecraft_world::ARMOR_ID_START + 9), // iron_leggings
            13 => Some(mdminecraft_world::ARMOR_ID_START + 13), // iron_boots
            20 => Some(mdminecraft_world::ARMOR_ID_START),     // leather_helmet
            21 => Some(mdminecraft_world::ARMOR_ID_START + 4), // leather_chestplate
            22 => Some(mdminecraft_world::ARMOR_ID_START + 8), // leather_leggings
            23 => Some(mdminecraft_world::ARMOR_ID_START + 12), // leather_boots
            30 => Some(mdminecraft_world::ARMOR_ID_START + 3), // diamond_helmet
            31 => Some(mdminecraft_world::ARMOR_ID_START + 7), // diamond_chestplate
            32 => Some(mdminecraft_world::ARMOR_ID_START + 11), // diamond_leggings
            33 => Some(mdminecraft_world::ARMOR_ID_START + 15), // diamond_boots
            _ => None,
        },
        _ => None,
    }
}

fn render_enchanting_lapis_slot(
    ui: &mut egui::Ui,
    lapis_count: &mut u32,
    cursor: &mut Option<ItemStack>,
) {
    let mut response = ui.allocate_response(egui::vec2(48.0, 48.0), egui::Sense::click());
    let rect = response.rect;
    let fill = if *lapis_count > 0 {
        egui::Color32::from_rgba_unmultiplied(80, 80, 80, 200)
    } else {
        egui::Color32::from_rgba_unmultiplied(40, 40, 40, 180)
    };
    ui.painter()
        .rect(rect, 2.0, fill, egui::Stroke::new(1.0, egui::Color32::GRAY));

    if *lapis_count > 0 {
        ui.painter().text(
            rect.center(),
            egui::Align2::CENTER_CENTER,
            "Lapis",
            egui::FontId::proportional(10.0),
            egui::Color32::WHITE,
        );
        if *lapis_count > 1 {
            ui.painter().text(
                rect.right_bottom() - egui::vec2(4.0, 4.0),
                egui::Align2::RIGHT_BOTTOM,
                format!("{}", lapis_count),
                egui::FontId::proportional(9.0),
                egui::Color32::YELLOW,
            );
        }
        response = response.on_hover_text(format!("Lapis Lazuli\nCount: {}", lapis_count));
    } else {
        response = response.on_hover_text("Lapis Lazuli");
    }

    let click = if response.clicked_by(egui::PointerButton::Primary) {
        Some(UiSlotClick::Primary)
    } else if response.clicked_by(egui::PointerButton::Secondary) {
        Some(UiSlotClick::Secondary)
    } else {
        None
    };
    let Some(click) = click else {
        return;
    };

    let Some(mut cursor_stack) = cursor.take() else {
        if *lapis_count == 0 {
            return;
        }
        let take = match click {
            UiSlotClick::Primary => *lapis_count,
            UiSlotClick::Secondary => lapis_count.div_ceil(2),
        };
        if take == 0 {
            return;
        }
        *lapis_count -= take;
        *cursor = Some(ItemStack::new(ItemType::Item(15), take));
        return;
    };

    if cursor_stack.item_type != ItemType::Item(15) {
        *cursor = Some(cursor_stack);
        return;
    }

    let to_add = match click {
        UiSlotClick::Primary => cursor_stack.count,
        UiSlotClick::Secondary => 1.min(cursor_stack.count),
    };
    if to_add == 0 {
        *cursor = Some(cursor_stack);
        return;
    }

    let max = 64_u32;
    let space = max.saturating_sub(*lapis_count);
    let added = to_add.min(space);
    if added == 0 {
        *cursor = Some(cursor_stack);
        return;
    }

    *lapis_count += added;
    cursor_stack.count -= added;
    if cursor_stack.count > 0 {
        *cursor = Some(cursor_stack);
    }
}

/// Render the brewing stand UI
/// Returns true if close was requested
fn render_brewing_stand(
    ctx: &egui::Context,
    stand: &mut BrewingStandState,
    hotbar: &mut Hotbar,
    main_inventory: &mut MainInventory,
    ui_cursor_stack: &mut Option<ItemStack>,
    ui_drag: &mut UiDragState,
) -> bool {
    let mut close_clicked = false;
    ui_drag.begin_frame();

    if ui_cursor_stack.is_none() {
        ui_drag.reset();
    } else if let Some(button) = ui_drag.active_button {
        let primary_down = ctx.input(|i| i.pointer.primary_down());
        let secondary_down = ctx.input(|i| i.pointer.secondary_down());
        match button {
            UiDragButton::Primary if !primary_down => {
                let visited = std::mem::take(&mut ui_drag.visited);
                let mut dummy_personal_grid: [[Option<ItemStack>; 2]; 2] = Default::default();
                let mut dummy_crafting_grid: [[Option<ItemStack>; 3]; 3] = Default::default();
                apply_primary_drag_distribution(
                    ui_cursor_stack,
                    &visited,
                    hotbar,
                    main_inventory,
                    &mut dummy_personal_grid,
                    &mut dummy_crafting_grid,
                );
                ui_drag.finish_drag();
            }
            UiDragButton::Secondary if !secondary_down => {
                ui_drag.finish_drag();
            }
            _ => {}
        }
    }

    // Semi-transparent dark overlay
    egui::Area::new(egui::Id::new("brewing_overlay"))
        .anchor(egui::Align2::LEFT_TOP, [0.0, 0.0])
        .show(ctx, |ui| {
            let screen_rect = ctx.screen_rect();
            ui.painter().rect_filled(
                screen_rect,
                0.0,
                egui::Color32::from_rgba_unmultiplied(0, 0, 0, 160),
            );
        });

    // Brewing stand window
    egui::Window::new("Brewing Stand")
        .collapsible(false)
        .resizable(false)
        .anchor(egui::Align2::CENTER_CENTER, [0.0, 0.0])
        .show(ctx, |ui| {
            ui.set_min_width(420.0);

            // Close button
            ui.horizontal(|ui| {
                ui.label(egui::RichText::new("Brewing Stand").size(18.0).strong());
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if ui.button("X").clicked() {
                        close_clicked = true;
                    }
                });
            });

            ui.separator();

            ui.horizontal(|ui| {
                ui.label("Cursor:");
                render_crafting_slot(ui, ui_cursor_stack.as_ref());
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new("Left: pick/place/swap, Right: split/place one.")
                        .size(11.0)
                        .color(egui::Color32::GRAY),
                );
            });

            ui.add_space(10.0);

            // Main brewing layout
            ui.horizontal(|ui| {
                // Left side: Fuel + Ingredient
                ui.vertical(|ui| {
                    ui.label("Fuel (Blaze Powder)");
                    let mut fuel_stack = if stand.fuel > 0 {
                        Some(ItemStack::new(
                            ItemType::Item(CORE_ITEM_BLAZE_POWDER),
                            stand.fuel,
                        ))
                    } else {
                        None
                    };
                    let response = render_core_slot_visual(ui, &fuel_stack, 48.0, false)
                        .on_hover_text("Fuel: Blaze Powder");
                    let click = if response.clicked_by(egui::PointerButton::Primary) {
                        Some(UiSlotClick::Primary)
                    } else if response.clicked_by(egui::PointerButton::Secondary) {
                        Some(UiSlotClick::Secondary)
                    } else {
                        None
                    };
                    if let Some(click) = click {
                        let shift = ui.input(|i| i.modifiers.shift);
                        if shift {
                            if let Some(stack) = fuel_stack.take() {
                                if let Some(remainder) =
                                    add_stack_to_storage(hotbar, main_inventory, stack)
                                {
                                    fuel_stack = Some(remainder);
                                }
                            }
                        } else if ui_cursor_stack.as_ref().is_some_and(|stack| {
                            stack.item_type != ItemType::Item(CORE_ITEM_BLAZE_POWDER)
                        }) {
                            // Fuel slot only accepts blaze powder.
                        } else {
                            apply_slot_click(&mut fuel_stack, ui_cursor_stack, click);
                        }
                    }
                    stand.fuel = fuel_stack.as_ref().map(|s| s.count).unwrap_or(0);

                    ui.add_space(10.0);

                    ui.label("Ingredient");
                    let mut ingredient_stack =
                        stand.ingredient.and_then(|(ingredient_id, count)| {
                            brew_ingredient_id_to_core_item_type(ingredient_id)
                                .map(|item_type| ItemStack::new(item_type, count))
                        });
                    let ingredient_hover = stand
                        .ingredient
                        .map(|(id, count)| format!("{} x{}", brew_ingredient_label(id), count))
                        .unwrap_or_else(|| "Empty".to_string());
                    let response = render_core_slot_visual(ui, &ingredient_stack, 48.0, false)
                        .on_hover_text(ingredient_hover);
                    let click = if response.clicked_by(egui::PointerButton::Primary) {
                        Some(UiSlotClick::Primary)
                    } else if response.clicked_by(egui::PointerButton::Secondary) {
                        Some(UiSlotClick::Secondary)
                    } else {
                        None
                    };
                    if let Some(click) = click {
                        let shift = ui.input(|i| i.modifiers.shift);
                        if shift {
                            if let Some(stack) = ingredient_stack.take() {
                                if let Some(remainder) =
                                    add_stack_to_storage(hotbar, main_inventory, stack)
                                {
                                    ingredient_stack = Some(remainder);
                                }
                            }
                        } else if ui_cursor_stack.as_ref().is_some_and(|stack| {
                            core_item_type_to_brew_ingredient_id(stack.item_type).is_none()
                        }) {
                            // Ingredient slot only accepts valid brewing ingredients.
                        } else {
                            apply_slot_click(&mut ingredient_stack, ui_cursor_stack, click);
                        }
                    }
                    stand.ingredient = ingredient_stack.and_then(|stack| {
                        core_item_type_to_brew_ingredient_id(stack.item_type)
                            .map(|ingredient_id| (ingredient_id, stack.count))
                    });
                });

                ui.add_space(20.0);

                // Middle: Progress arrow
                ui.vertical(|ui| {
                    ui.add_space(15.0);

                    // Progress bar
                    let progress_bar = egui::ProgressBar::new(stand.brew_progress)
                        .desired_width(60.0)
                        .text(format!("{:.0}%", stand.brew_progress * 100.0));
                    ui.add(progress_bar);

                    ui.add_space(5.0);

                    // Brewing icon
                    let brew_color = if stand.is_brewing {
                        egui::Color32::from_rgb(100, 200, 255)
                    } else {
                        egui::Color32::DARK_GRAY
                    };
                    ui.label(egui::RichText::new("").size(24.0).color(brew_color));
                });

                ui.add_space(20.0);

                // Right side: Bottle slots (3 bottles in a row)
                ui.vertical(|ui| {
                    ui.label("Bottles");
                    ui.horizontal(|ui| {
                        let (bottles, bottle_is_splash, bottle_is_extended, bottle_amplifier) = (
                            &mut stand.bottles,
                            &mut stand.bottle_is_splash,
                            &mut stand.bottle_is_extended,
                            &mut stand.bottle_amplifier,
                        );
                        for (i, bottle) in bottles.iter_mut().enumerate() {
                            let before = *bottle;
                            let before_splash = bottle_is_splash[i];
                            let before_extended = bottle_is_extended[i];
                            let before_amplifier = bottle_amplifier[i];
                            let mut bottle_stack = (*bottle).map(|potion| {
                                bottle_to_core_item_stack(
                                    potion,
                                    before_splash,
                                    before_extended,
                                    before_amplifier,
                                )
                            });
                            let response = render_core_slot_visual(ui, &bottle_stack, 52.0, false);
                            let click = if response.clicked_by(egui::PointerButton::Primary) {
                                Some(UiSlotClick::Primary)
                            } else if response.clicked_by(egui::PointerButton::Secondary) {
                                Some(UiSlotClick::Secondary)
                            } else {
                                None
                            };
                            if let Some(click) = click {
                                let shift = ui.input(|i| i.modifiers.shift);
                                if shift {
                                    if let Some(stack) = bottle_stack.take() {
                                        if let Some(remainder) =
                                            add_stack_to_storage(hotbar, main_inventory, stack)
                                        {
                                            bottle_stack = Some(remainder);
                                        }
                                    }
                                } else {
                                    apply_brewing_bottle_slot_click(
                                        &mut bottle_stack,
                                        ui_cursor_stack,
                                        click,
                                    );
                                }
                            }

                            let mapped = bottle_stack.as_ref().and_then(core_item_stack_to_bottle);
                            match mapped {
                                Some((potion, is_splash, is_extended, amplifier)) => {
                                    *bottle = Some(potion);
                                    bottle_is_splash[i] = is_splash && potion != PotionType::Water;
                                    bottle_is_extended[i] =
                                        is_extended && potion != PotionType::Water;
                                    bottle_amplifier[i] = if potion != PotionType::Water {
                                        amplifier
                                    } else {
                                        0
                                    };
                                }
                                None if bottle_stack.is_none() => {
                                    *bottle = None;
                                    bottle_is_splash[i] = false;
                                    bottle_is_extended[i] = false;
                                    bottle_amplifier[i] = 0;
                                }
                                _ => {
                                    *bottle = before;
                                    bottle_is_splash[i] = before_splash;
                                    bottle_is_extended[i] = before_extended;
                                    bottle_amplifier[i] = before_amplifier;
                                }
                            }
                            if i < 2 {
                                ui.add_space(4.0);
                            }
                        }
                    });
                });
            });

            ui.add_space(10.0);
            ui.separator();

            // Status text
            let status = if stand.is_brewing {
                "Brewing in progress..."
            } else if stand.fuel == 0 {
                "Need blaze powder for fuel"
            } else if !stand.bottles.iter().any(|b| b.is_some()) {
                "Add potions to brew"
            } else if stand.ingredient.is_none() {
                "Add ingredient to brew"
            } else {
                "Ready to brew"
            };
            ui.label(
                egui::RichText::new(status)
                    .size(12.0)
                    .color(if stand.is_brewing {
                        egui::Color32::from_rgb(100, 200, 255)
                    } else {
                        egui::Color32::GRAY
                    }),
            );

            ui.add_space(10.0);
            ui.separator();
            render_player_storage_for_brewing_stand(
                ui,
                stand,
                hotbar,
                main_inventory,
                ui_cursor_stack,
                ui_drag,
            );

            if std::env::var("MDM_DEBUG_BREWING_QUICK_ADD").as_deref() == Ok("1") {
                ui.add_space(8.0);
                ui.separator();
                ui.label(
                    egui::RichText::new("Debug: quick add")
                        .size(12.0)
                        .color(egui::Color32::DARK_GRAY),
                );
                ui.horizontal(|ui| {
                    if ui.button("+ Water Bottle").clicked() {
                        for bottle in &mut stand.bottles {
                            if bottle.is_none() {
                                *bottle = Some(PotionType::Water);
                                break;
                            }
                        }
                    }
                    if ui.button("+ Nether Wart").clicked() {
                        stand.add_ingredient(item_ids::NETHER_WART, 1);
                    }
                    if ui.button("+ Fuel").clicked() {
                        stand.add_fuel(1);
                    }
                });
            }

            ui.label(
                egui::RichText::new("Escape or X to close")
                    .size(11.0)
                    .color(egui::Color32::DARK_GRAY),
            );
        });

    close_clicked
}

fn apply_brewing_bottle_slot_click(
    slot: &mut Option<ItemStack>,
    cursor: &mut Option<ItemStack>,
    _click: UiSlotClick,
) {
    let is_bottle = |stack: &ItemStack| -> bool { core_item_stack_to_bottle(stack).is_some() };

    if cursor.is_none() {
        *cursor = slot.take();
        return;
    }

    let Some(cursor_stack) = cursor.as_mut() else {
        return;
    };

    if !is_bottle(cursor_stack) {
        return;
    }

    if slot.is_none() {
        // Place one water bottle out of a stack; potions already have max stack size 1.
        if cursor_stack.item_type == ItemType::Item(CORE_ITEM_WATER_BOTTLE)
            && cursor_stack.count > 1
        {
            let mut placed = cursor_stack.clone();
            placed.count = 1;
            cursor_stack.count -= 1;
            if cursor_stack.count == 0 {
                *cursor = None;
            }
            *slot = Some(placed);
            return;
        }

        *slot = cursor.take();
        return;
    }

    // Merge extra water bottles into the cursor stack when possible.
    if let Some(slot_stack) = slot.as_ref() {
        if slot_stack.item_type == ItemType::Item(CORE_ITEM_WATER_BOTTLE)
            && cursor_stack.item_type == ItemType::Item(CORE_ITEM_WATER_BOTTLE)
        {
            let max = cursor_stack.max_stack_size();
            if cursor_stack.count < max {
                cursor_stack.count += 1;
                *slot = None;
            }
            return;
        }
    }

    // Only allow swapping if the cursor holds a single bottle.
    if cursor_stack.count != 1 {
        return;
    }

    std::mem::swap(slot, cursor);
}

fn armor_dropped_to_core_item_id(item_type: DroppedItemType) -> Option<u16> {
    match item_type {
        DroppedItemType::LeatherHelmet => Some(20),
        DroppedItemType::LeatherChestplate => Some(21),
        DroppedItemType::LeatherLeggings => Some(22),
        DroppedItemType::LeatherBoots => Some(23),
        DroppedItemType::IronHelmet => Some(10),
        DroppedItemType::IronChestplate => Some(11),
        DroppedItemType::IronLeggings => Some(12),
        DroppedItemType::IronBoots => Some(13),
        DroppedItemType::DiamondHelmet => Some(30),
        DroppedItemType::DiamondChestplate => Some(31),
        DroppedItemType::DiamondLeggings => Some(32),
        DroppedItemType::DiamondBoots => Some(33),
        _ => None,
    }
}

fn armor_piece_to_core_stack(piece: &ArmorPiece) -> Option<ItemStack> {
    let core_id = armor_dropped_to_core_item_id(piece.item_type)?;
    let mut stack = ItemStack::new(ItemType::Item(core_id), 1);
    stack.durability = Some(piece.durability);
    if !piece.enchantments.is_empty() {
        stack.enchantments = Some(piece.enchantments.clone());
    }
    Some(stack)
}

fn armor_piece_from_core_stack(stack: &ItemStack) -> Option<ArmorPiece> {
    if stack.count != 1 {
        return None;
    }

    let dropped_type = item_type_to_armor_dropped(stack.item_type)?;
    let enchantments = stack.enchantments.clone().unwrap_or_default();
    let mut piece = ArmorPiece::from_item_with_enchantments(dropped_type, enchantments)?;

    if let Some(durability) = stack.durability {
        piece.durability = durability.min(piece.max_durability);
    }

    Some(piece)
}

/// Convert an ItemType to DroppedItemType for armor pieces
/// Returns the DroppedItemType if the item is armor, None otherwise
fn item_type_to_armor_dropped(item_type: ItemType) -> Option<DroppedItemType> {
    if let ItemType::Item(id) = item_type {
        match id {
            // Leather armor
            20 => Some(DroppedItemType::LeatherHelmet),
            21 => Some(DroppedItemType::LeatherChestplate),
            22 => Some(DroppedItemType::LeatherLeggings),
            23 => Some(DroppedItemType::LeatherBoots),
            // Iron armor
            10 => Some(DroppedItemType::IronHelmet),
            11 => Some(DroppedItemType::IronChestplate),
            12 => Some(DroppedItemType::IronLeggings),
            13 => Some(DroppedItemType::IronBoots),
            // Diamond armor
            30 => Some(DroppedItemType::DiamondHelmet),
            31 => Some(DroppedItemType::DiamondChestplate),
            32 => Some(DroppedItemType::DiamondLeggings),
            33 => Some(DroppedItemType::DiamondBoots),
            _ => None,
        }
    } else {
        None
    }
}

impl commands::CommandContext for GameWorld {
    fn player_position(&self) -> (f64, f64, f64) {
        let pos = self.renderer.camera().position;
        (pos.x as f64, pos.y as f64, pos.z as f64)
    }

    fn teleport_player(&mut self, x: f64, y: f64, z: f64) -> anyhow::Result<()> {
        let camera = self.renderer.camera_mut();
        camera.position = glam::Vec3::new(x as f32, y as f32, z as f32);
        self.player_physics.velocity = glam::Vec3::ZERO;
        self.player_physics.on_ground = false;

        // Preload a bounded number of chunks around the new position so teleporting isn't a black
        // screen, without stalling on slower GPUs or defeating headless step control.
        self.update_chunks(1);
        Ok(())
    }

    fn set_dimension(&mut self, dimension: DimensionId) -> anyhow::Result<()> {
        self.switch_dimension(dimension)
    }

    fn world_seed(&self) -> u64 {
        self.world_seed
    }

    fn give_item(&mut self, item: ItemType, count: u32) -> u32 {
        let remainder = add_stack_to_storage(
            &mut self.hotbar,
            &mut self.main_inventory,
            ItemStack::new(item, count),
        );
        remainder.map(|stack| stack.count).unwrap_or(0)
    }

    fn clear_items(&mut self, item: Option<ItemType>, max_count: Option<u32>) -> u32 {
        let matches = |stack: &ItemStack| item.is_none_or(|value| stack.item_type == value);

        if max_count == Some(0) {
            let mut total = 0u32;
            for stack in self
                .hotbar
                .slots
                .iter()
                .chain(self.main_inventory.slots.iter())
                .flatten()
            {
                if matches(stack) {
                    total = total.saturating_add(stack.count);
                }
            }
            return total;
        }

        let mut remaining = max_count.unwrap_or(u32::MAX);
        let mut cleared = 0u32;
        for slot in self
            .hotbar
            .slots
            .iter_mut()
            .chain(self.main_inventory.slots.iter_mut())
        {
            if remaining == 0 {
                break;
            }
            let Some(stack) = slot.as_mut() else {
                continue;
            };
            if !matches(stack) || stack.count == 0 {
                continue;
            }

            let to_remove = stack.count.min(remaining);
            stack.count -= to_remove;
            remaining -= to_remove;
            cleared += to_remove;
            if stack.count == 0 {
                *slot = None;
            }
        }

        cleared
    }

    fn kill_player(&mut self) -> anyhow::Result<()> {
        if self.player_state != PlayerState::Alive {
            return Ok(());
        }

        self.player_health.current = 0.0;
        self.handle_death("Killed by command");
        Ok(())
    }

    fn respawn_player(&mut self) -> anyhow::Result<()> {
        if self.player_state != PlayerState::Dead {
            anyhow::bail!("Player is not dead");
        }

        self.respawn();
        Ok(())
    }

    fn destroy_blocks(&mut self, blocks: &[(i32, i32, i32)]) -> anyhow::Result<()> {
        if blocks.is_empty() {
            return Ok(());
        }

        for &(_, y, _) in blocks {
            if world_y_to_local_y(y).is_none() {
                anyhow::bail!("Y out of bounds: {y}");
            }
        }

        let mut changed_positions: Vec<IVec3> = Vec::with_capacity(blocks.len());

        for &(x, y, z) in blocks {
            let pos = IVec3::new(x, y, z);
            let chunk_pos = ChunkPos::new(x.div_euclid(16), z.div_euclid(16));
            self.ensure_chunk_loaded_for_command(chunk_pos);

            let local_x = x.rem_euclid(16) as usize;
            let local_y =
                world_y_to_local_y(y).ok_or_else(|| anyhow::anyhow!("Y out of bounds: {y}"))?;
            let local_z = z.rem_euclid(16) as usize;

            let (old_id, old_state) = {
                let chunk = self
                    .chunks
                    .get(&chunk_pos)
                    .ok_or_else(|| anyhow::anyhow!("Chunk missing at {chunk_pos:?}"))?;
                let voxel = chunk.voxel(local_x, local_y, local_z);
                (voxel.id, voxel.state)
            };
            if old_id == BLOCK_AIR {
                continue;
            }

            self.on_block_entity_removed(pos, old_id);
            if mdminecraft_world::CropType::is_crop(old_id) {
                self.crop_growth.unregister_crop(CropPosition {
                    chunk: chunk_pos,
                    x: local_x as u8,
                    y: local_y as u8,
                    z: local_z as u8,
                });
            }

            let left_water = self.active_dimension != DimensionId::Nether
                && mdminecraft_world::block_supports_waterlogging(old_id)
                && mdminecraft_world::is_waterlogged(old_state);

            if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                if left_water {
                    chunk.set_voxel(
                        local_x,
                        local_y,
                        local_z,
                        Voxel {
                            id: FluidType::Water.source_block_id(),
                            state: 0,
                            light_sky: 0,
                            light_block: 0,
                        },
                    );
                } else {
                    chunk.set_voxel(local_x, local_y, local_z, Voxel::default());
                }
            }

            let mut removed_extra: Option<IVec3> = None;
            if mdminecraft_world::is_door(old_id) {
                if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                    if let Some(other_local_y) =
                        Self::try_remove_other_door_half(chunk, local_x, local_y, local_z, old_id)
                    {
                        removed_extra = Some(IVec3::new(x, local_y_to_world_y(other_local_y), z));
                    }
                }
            }
            if removed_extra.is_none() && mdminecraft_world::is_bed(old_id) {
                if let Some((other_pos, _)) = Self::bed_other_half_pos(pos, old_id, old_state) {
                    let other_chunk_pos = ChunkPos::new(
                        other_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                        other_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                    );
                    self.ensure_chunk_loaded_for_command(other_chunk_pos);
                }
                removed_extra =
                    Self::try_remove_other_bed_half(&mut self.chunks, pos, old_id, old_state);
            }
            if removed_extra.is_none()
                && matches!(
                    old_id,
                    mdminecraft_world::mechanical_blocks::PISTON
                        | mdminecraft_world::mechanical_blocks::PISTON_HEAD
                )
            {
                let facing = mdminecraft_world::piston_facing(old_state);
                let (dx, dz) = facing.offset();
                let other_pos = if old_id == mdminecraft_world::mechanical_blocks::PISTON {
                    IVec3::new(pos.x + dx, pos.y, pos.z + dz)
                } else {
                    IVec3::new(pos.x - dx, pos.y, pos.z - dz)
                };
                let other_chunk_pos = ChunkPos::new(
                    other_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    other_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                self.ensure_chunk_loaded_for_command(other_chunk_pos);
                removed_extra =
                    Self::try_remove_other_piston_part(&mut self.chunks, pos, old_id, old_state);
            }

            if left_water {
                self.fluid_sim
                    .on_fluid_placed(FluidPos::new(x, y, z), FluidType::Water);
            } else {
                self.fluid_sim
                    .on_fluid_removed(FluidPos::new(x, y, z), &self.chunks);
            }
            self.schedule_redstone_updates_around(pos);
            changed_positions.push(pos);

            if let Some(extra) = removed_extra {
                self.fluid_sim
                    .on_fluid_removed(FluidPos::new(extra.x, extra.y, extra.z), &self.chunks);
                self.schedule_redstone_updates_around(extra);
                changed_positions.push(extra);
            }

            if let Some((drop_type, count)) = DroppedItemType::from_block(old_id) {
                let drop_x = x as f64 + 0.5;
                let drop_y = y as f64 + 0.5;
                let drop_z = z as f64 + 0.5;
                self.item_manager.spawn_item(
                    self.active_dimension,
                    drop_x,
                    drop_y,
                    drop_z,
                    drop_type,
                    count,
                );
            }
        }

        if changed_positions.is_empty() {
            return Ok(());
        }

        let support_changes = Self::remove_unsupported_blocks(
            &mut self.chunks,
            &self.block_properties,
            changed_positions.iter().copied(),
        );
        for &(removed_pos, removed_block_id) in &support_changes.removed {
            if mdminecraft_world::CropType::is_crop(removed_block_id) {
                let removed_chunk = ChunkPos::new(
                    removed_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    removed_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                if let Some(local_y) = world_y_to_local_y(removed_pos.y) {
                    self.crop_growth.unregister_crop(CropPosition {
                        chunk: removed_chunk,
                        x: removed_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as u8,
                        y: local_y as u8,
                        z: removed_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as u8,
                    });
                }
            }

            self.on_block_entity_removed(removed_pos, removed_block_id);
            self.fluid_sim.on_fluid_removed(
                FluidPos::new(removed_pos.x, removed_pos.y, removed_pos.z),
                &self.chunks,
            );
            self.schedule_redstone_updates_around(removed_pos);
            self.spawn_support_removed_block_drop(
                &support_changes.removed,
                removed_pos,
                removed_block_id,
            );
            changed_positions.push(removed_pos);
        }
        for &moved_pos in &support_changes.moved {
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(moved_pos.x, moved_pos.y, moved_pos.z), &self.chunks);
            self.schedule_redstone_updates_around(moved_pos);
            changed_positions.push(moved_pos);
        }

        self.refresh_after_voxel_changes(&changed_positions);
        Ok(())
    }

    fn destroy_block(&mut self, x: i32, y: i32, z: i32) -> anyhow::Result<()> {
        self.destroy_blocks(&[(x, y, z)])
    }

    fn time_tick(&self) -> u64 {
        self.sim_time.tick.0
    }

    fn set_time_tick(&mut self, tick: u64) {
        self.sim_time.tick = SimTick(tick);
        self.time_of_day
            .set_time(self.sim_time.time_of_day() as f32);
    }

    fn set_weather(&mut self, state: WeatherState) {
        self.weather.set_state(state);
        // Deterministic reschedule.
        let delay_ticks = Self::weather_delay_ticks(
            self.world_seed,
            self.sim_tick,
            900..2400, // 45..120 seconds at 20 TPS
            0x0057_4541_5448_4552_u64,
        );
        self.weather_next_change_tick = self.sim_tick.advance(delay_ticks);
    }

    fn set_gamemode(&mut self, mode: commands::Gamemode) {
        let wants_physics = matches!(mode, commands::Gamemode::Survival);
        if self.player_physics.physics_enabled != wants_physics {
            self.player_physics.toggle_physics();
        }
    }

    fn apply_status_effect(
        &mut self,
        effect: StatusEffectType,
        seconds: u32,
        amplifier: u8,
    ) -> anyhow::Result<()> {
        if effect.is_instant() {
            apply_instant_status_effect_to_player_health(
                &mut self.player_health,
                effect,
                amplifier,
            );
            return Ok(());
        }

        let ticks = seconds.saturating_mul(20);
        self.status_effects
            .add(mdminecraft_world::StatusEffect::new(
                effect, amplifier, ticks,
            ));
        Ok(())
    }

    fn clear_status_effects(&mut self) {
        self.status_effects.clear();
    }

    fn remove_status_effect(&mut self, effect: StatusEffectType) {
        self.status_effects.remove(effect);
    }

    fn get_block(&mut self, x: i32, y: i32, z: i32) -> anyhow::Result<(u16, u16)> {
        let local_y =
            world_y_to_local_y(y).ok_or_else(|| anyhow::anyhow!("Y out of bounds: {y}"))?;

        let chunk_pos = ChunkPos::new(x.div_euclid(16), z.div_euclid(16));
        self.ensure_chunk_loaded_for_command(chunk_pos);
        let Some(chunk) = self.chunks.get(&chunk_pos) else {
            anyhow::bail!("Chunk missing at {chunk_pos:?}");
        };

        let local_x = x.rem_euclid(16) as usize;
        let local_z = z.rem_euclid(16) as usize;
        let voxel = chunk.voxel(local_x, local_y, local_z);
        Ok((voxel.id, voxel.state))
    }

    fn get_block_entity(
        &mut self,
        x: i32,
        y: i32,
        z: i32,
        block_id: u16,
    ) -> anyhow::Result<Option<commands::BlockEntityData>> {
        if world_y_to_local_y(y).is_none() {
            anyhow::bail!("Y out of bounds: {y}");
        }

        let key = self.block_entity_key(IVec3::new(x, y, z));
        let data = match block_id {
            interactive_blocks::CHEST => Some(commands::BlockEntityData::Chest(Box::new(
                self.chests.entry(key).or_default().clone(),
            ))),
            mdminecraft_world::mechanical_blocks::HOPPER => {
                Some(commands::BlockEntityData::Hopper(Box::new(
                    self.hoppers.entry(key).or_default().clone(),
                )))
            }
            mdminecraft_world::mechanical_blocks::DISPENSER => {
                Some(commands::BlockEntityData::Dispenser(Box::new(
                    self.dispensers.entry(key).or_default().clone(),
                )))
            }
            mdminecraft_world::mechanical_blocks::DROPPER => {
                Some(commands::BlockEntityData::Dropper(Box::new(
                    self.droppers.entry(key).or_default().clone(),
                )))
            }
            BLOCK_FURNACE | BLOCK_FURNACE_LIT => Some(commands::BlockEntityData::Furnace(
                Box::new(self.furnaces.entry(key).or_default().clone()),
            )),
            BLOCK_BREWING_STAND => Some(commands::BlockEntityData::BrewingStand(Box::new(
                self.brewing_stands.entry(key).or_default().clone(),
            ))),
            BLOCK_ENCHANTING_TABLE => Some(commands::BlockEntityData::EnchantingTable(Box::new(
                self.enchanting_tables.entry(key).or_default().clone(),
            ))),
            _ => None,
        };
        Ok(data)
    }

    fn set_block_entity(
        &mut self,
        x: i32,
        y: i32,
        z: i32,
        data: commands::BlockEntityData,
    ) -> anyhow::Result<()> {
        if world_y_to_local_y(y).is_none() {
            anyhow::bail!("Y out of bounds: {y}");
        }

        let chunk_pos = ChunkPos::new(x.div_euclid(16), z.div_euclid(16));
        self.ensure_chunk_loaded_for_command(chunk_pos);
        let key = self.block_entity_key(IVec3::new(x, y, z));

        match data {
            commands::BlockEntityData::Chest(state) => {
                mdminecraft_world::update_container_signal(
                    &mut self.chunks,
                    &mut self.redstone_sim,
                    RedstonePos::new(x, y, z),
                    &state.slots,
                );
                self.chests.insert(key, *state);
            }
            commands::BlockEntityData::Hopper(state) => {
                mdminecraft_world::update_container_signal(
                    &mut self.chunks,
                    &mut self.redstone_sim,
                    RedstonePos::new(x, y, z),
                    &state.slots,
                );
                self.hoppers.insert(key, *state);
            }
            commands::BlockEntityData::Dispenser(state) => {
                mdminecraft_world::update_container_signal(
                    &mut self.chunks,
                    &mut self.redstone_sim,
                    RedstonePos::new(x, y, z),
                    &state.slots,
                );
                self.dispensers.insert(key, *state);
            }
            commands::BlockEntityData::Dropper(state) => {
                mdminecraft_world::update_container_signal(
                    &mut self.chunks,
                    &mut self.redstone_sim,
                    RedstonePos::new(x, y, z),
                    &state.slots,
                );
                self.droppers.insert(key, *state);
            }
            commands::BlockEntityData::Furnace(state) => {
                self.furnaces.insert(key, *state);
            }
            commands::BlockEntityData::BrewingStand(state) => {
                self.brewing_stands.insert(key, *state);
            }
            commands::BlockEntityData::EnchantingTable(state) => {
                self.enchanting_tables.insert(key, *state);
            }
        }

        Ok(())
    }

    fn set_block(
        &mut self,
        x: i32,
        y: i32,
        z: i32,
        block_id: u16,
        state: u16,
    ) -> anyhow::Result<()> {
        let local_y =
            world_y_to_local_y(y).ok_or_else(|| anyhow::anyhow!("Y out of bounds: {y}"))?;

        let pos = IVec3::new(x, y, z);
        let chunk_pos = ChunkPos::new(x.div_euclid(16), z.div_euclid(16));
        self.ensure_chunk_loaded_for_command(chunk_pos);
        let Some(chunk) = self.chunks.get(&chunk_pos) else {
            anyhow::bail!("Chunk missing at {chunk_pos:?}");
        };
        let local_x = x.rem_euclid(16) as usize;
        let local_z = z.rem_euclid(16) as usize;

        let old_id = chunk.voxel(local_x, local_y, local_z).id;
        if old_id != block_id {
            self.purge_block_entity_state(pos, old_id);
        }

        let voxel = Voxel {
            id: block_id,
            state,
            light_sky: 0,
            light_block: 0,
        };
        if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
            chunk.set_voxel(local_x, local_y, local_z, voxel);
        }

        if mdminecraft_world::CropType::is_crop(old_id)
            && !mdminecraft_world::CropType::is_crop(block_id)
        {
            self.crop_growth.unregister_crop(CropPosition {
                chunk: chunk_pos,
                x: local_x as u8,
                y: local_y as u8,
                z: local_z as u8,
            });
        }
        if mdminecraft_world::CropType::is_crop(block_id) {
            self.crop_growth.register_crop(CropPosition {
                chunk: chunk_pos,
                x: local_x as u8,
                y: local_y as u8,
                z: local_z as u8,
            });
        }
        if block_id == mdminecraft_world::BLOCK_SUGAR_CANE {
            let below_is_cane = local_y > 0
                && self
                    .chunks
                    .get(&chunk_pos)
                    .is_some_and(|chunk| chunk.voxel(local_x, local_y - 1, local_z).id == block_id);
            if !below_is_cane {
                self.sugar_cane_growth.register_base(SugarCanePosition {
                    chunk: chunk_pos,
                    x: local_x as u8,
                    y: local_y as u8,
                    z: local_z as u8,
                });
            }
        }

        // Initialize block-entity state when needed.
        let key = self.block_entity_key(pos);
        match block_id {
            interactive_blocks::CHEST => {
                self.chests.entry(key).or_default();
            }
            mdminecraft_world::mechanical_blocks::HOPPER => {
                self.hoppers.entry(key).or_default();
            }
            mdminecraft_world::mechanical_blocks::DISPENSER => {
                self.dispensers.entry(key).or_default();
            }
            mdminecraft_world::mechanical_blocks::DROPPER => {
                self.droppers.entry(key).or_default();
            }
            BLOCK_FURNACE | BLOCK_FURNACE_LIT => {
                self.furnaces.entry(key).or_default();
            }
            BLOCK_BREWING_STAND => {
                self.brewing_stands.entry(key).or_default();
            }
            BLOCK_ENCHANTING_TABLE => {
                self.enchanting_tables.entry(key).or_default();
            }
            _ => {}
        }

        // Wake sims.
        self.fluid_sim
            .on_fluid_removed(FluidPos::new(x, y, z), &self.chunks);
        if let Some(fluid_type) = get_fluid_type(block_id) {
            self.fluid_sim
                .on_fluid_placed(FluidPos::new(x, y, z), fluid_type);
        } else if mdminecraft_world::block_supports_waterlogging(block_id)
            && mdminecraft_world::is_waterlogged(state)
        {
            self.fluid_sim
                .on_fluid_placed(FluidPos::new(x, y, z), FluidType::Water);
        }
        self.schedule_redstone_updates_around(pos);

        let mut changed_positions = vec![pos];
        let support_changes =
            Self::remove_unsupported_blocks(&mut self.chunks, &self.block_properties, [pos]);
        for &(removed_pos, removed_block_id) in &support_changes.removed {
            if mdminecraft_world::CropType::is_crop(removed_block_id) {
                let removed_chunk = ChunkPos::new(
                    removed_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    removed_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                if let Some(local_y) = world_y_to_local_y(removed_pos.y) {
                    self.crop_growth.unregister_crop(CropPosition {
                        chunk: removed_chunk,
                        x: removed_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as u8,
                        y: local_y as u8,
                        z: removed_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as u8,
                    });
                }
            }

            self.on_block_entity_removed(removed_pos, removed_block_id);
            self.fluid_sim.on_fluid_removed(
                FluidPos::new(removed_pos.x, removed_pos.y, removed_pos.z),
                &self.chunks,
            );
            self.schedule_redstone_updates_around(removed_pos);
            self.spawn_support_removed_block_drop(
                &support_changes.removed,
                removed_pos,
                removed_block_id,
            );
            changed_positions.push(removed_pos);
        }
        for &moved_pos in &support_changes.moved {
            self.fluid_sim.on_fluid_removed(
                FluidPos::new(moved_pos.x, moved_pos.y, moved_pos.z),
                &self.chunks,
            );
            self.schedule_redstone_updates_around(moved_pos);
            changed_positions.push(moved_pos);
        }

        self.refresh_after_voxel_changes(&changed_positions);
        Ok(())
    }

    fn set_blocks(&mut self, blocks: &[(i32, i32, i32, u16, u16)]) -> anyhow::Result<()> {
        if blocks.is_empty() {
            return Ok(());
        }

        for &(_, y, _, _, _) in blocks {
            if world_y_to_local_y(y).is_none() {
                anyhow::bail!("Y out of bounds: {y}");
            }
        }

        let mut changed_positions: Vec<IVec3> = Vec::with_capacity(blocks.len());

        for &(x, y, z, block_id, state) in blocks {
            let pos = IVec3::new(x, y, z);
            let chunk_pos = ChunkPos::new(x.div_euclid(16), z.div_euclid(16));
            self.ensure_chunk_loaded_for_command(chunk_pos);

            let local_x = x.rem_euclid(16) as usize;
            let local_y =
                world_y_to_local_y(y).ok_or_else(|| anyhow::anyhow!("Y out of bounds: {y}"))?;
            let local_z = z.rem_euclid(16) as usize;

            let old_id = self
                .chunks
                .get(&chunk_pos)
                .ok_or_else(|| anyhow::anyhow!("Chunk missing at {chunk_pos:?}"))?
                .voxel(local_x, local_y, local_z)
                .id;
            if old_id != block_id {
                self.purge_block_entity_state(pos, old_id);
            }

            let voxel = Voxel {
                id: block_id,
                state,
                light_sky: 0,
                light_block: 0,
            };
            if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
                chunk.set_voxel(local_x, local_y, local_z, voxel);
            }

            if mdminecraft_world::CropType::is_crop(old_id)
                && !mdminecraft_world::CropType::is_crop(block_id)
            {
                self.crop_growth.unregister_crop(CropPosition {
                    chunk: chunk_pos,
                    x: local_x as u8,
                    y: local_y as u8,
                    z: local_z as u8,
                });
            }
            if mdminecraft_world::CropType::is_crop(block_id) {
                self.crop_growth.register_crop(CropPosition {
                    chunk: chunk_pos,
                    x: local_x as u8,
                    y: local_y as u8,
                    z: local_z as u8,
                });
            }
            if block_id == mdminecraft_world::BLOCK_SUGAR_CANE {
                let below_is_cane = local_y > 0
                    && self.chunks.get(&chunk_pos).is_some_and(|chunk| {
                        chunk.voxel(local_x, local_y - 1, local_z).id == block_id
                    });
                if !below_is_cane {
                    self.sugar_cane_growth.register_base(SugarCanePosition {
                        chunk: chunk_pos,
                        x: local_x as u8,
                        y: local_y as u8,
                        z: local_z as u8,
                    });
                }
            }

            // Initialize block-entity state when needed.
            let key = self.block_entity_key(pos);
            match block_id {
                interactive_blocks::CHEST => {
                    self.chests.entry(key).or_default();
                }
                mdminecraft_world::mechanical_blocks::HOPPER => {
                    self.hoppers.entry(key).or_default();
                }
                mdminecraft_world::mechanical_blocks::DISPENSER => {
                    self.dispensers.entry(key).or_default();
                }
                mdminecraft_world::mechanical_blocks::DROPPER => {
                    self.droppers.entry(key).or_default();
                }
                BLOCK_FURNACE | BLOCK_FURNACE_LIT => {
                    self.furnaces.entry(key).or_default();
                }
                BLOCK_BREWING_STAND => {
                    self.brewing_stands.entry(key).or_default();
                }
                BLOCK_ENCHANTING_TABLE => {
                    self.enchanting_tables.entry(key).or_default();
                }
                _ => {}
            }

            // Wake sims.
            self.fluid_sim
                .on_fluid_removed(FluidPos::new(x, y, z), &self.chunks);
            if let Some(fluid_type) = get_fluid_type(block_id) {
                self.fluid_sim
                    .on_fluid_placed(FluidPos::new(x, y, z), fluid_type);
            } else if mdminecraft_world::block_supports_waterlogging(block_id)
                && mdminecraft_world::is_waterlogged(state)
            {
                self.fluid_sim
                    .on_fluid_placed(FluidPos::new(x, y, z), FluidType::Water);
            }
            self.schedule_redstone_updates_around(pos);

            changed_positions.push(pos);
        }

        let support_changes = Self::remove_unsupported_blocks(
            &mut self.chunks,
            &self.block_properties,
            changed_positions.iter().copied(),
        );
        for &(removed_pos, removed_block_id) in &support_changes.removed {
            if mdminecraft_world::CropType::is_crop(removed_block_id) {
                let removed_chunk = ChunkPos::new(
                    removed_pos.x.div_euclid(CHUNK_SIZE_X as i32),
                    removed_pos.z.div_euclid(CHUNK_SIZE_Z as i32),
                );
                if let Some(local_y) = world_y_to_local_y(removed_pos.y) {
                    self.crop_growth.unregister_crop(CropPosition {
                        chunk: removed_chunk,
                        x: removed_pos.x.rem_euclid(CHUNK_SIZE_X as i32) as u8,
                        y: local_y as u8,
                        z: removed_pos.z.rem_euclid(CHUNK_SIZE_Z as i32) as u8,
                    });
                }
            }

            self.on_block_entity_removed(removed_pos, removed_block_id);
            self.fluid_sim.on_fluid_removed(
                FluidPos::new(removed_pos.x, removed_pos.y, removed_pos.z),
                &self.chunks,
            );
            self.schedule_redstone_updates_around(removed_pos);
            self.spawn_support_removed_block_drop(
                &support_changes.removed,
                removed_pos,
                removed_block_id,
            );
            changed_positions.push(removed_pos);
        }
        for &moved_pos in &support_changes.moved {
            self.fluid_sim.on_fluid_removed(
                FluidPos::new(moved_pos.x, moved_pos.y, moved_pos.z),
                &self.chunks,
            );
            self.schedule_redstone_updates_around(moved_pos);
            changed_positions.push(moved_pos);
        }

        self.refresh_after_voxel_changes(&changed_positions);
        Ok(())
    }

    fn summon_mob(&mut self, mob: MobType, x: f64, y: f64, z: f64) -> anyhow::Result<()> {
        let mut mob = Mob::new(x, y, z, mob);
        mob.dimension = self.active_dimension;
        self.assign_mob_id(&mut mob);
        self.mobs.push(mob);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::{
        add_stack_to_storage, apply_brewing_bottle_slot_click, apply_furnace_slot_click,
        apply_instant_status_effect_to_player_health, apply_primary_drag_distribution,
        apply_primary_drag_distribution_with_dispenser,
        apply_primary_drag_distribution_with_hopper, apply_slot_click, armor_piece_from_core_stack,
        armor_piece_to_core_stack, check_crafting_recipe, consume_crafting_inputs_3x3,
        core_item_to_enchanting_id, crafting_max_crafts_2x2, crafting_max_crafts_3x3,
        cursor_can_accept_full_stack, frames_to_complete, furnace_try_insert, get_crafting_recipes,
        interactive_blocks, item_ids, match_crafting_recipe, potion_ids,
        tick_health_over_time_status_effects, try_activate_end_portal, try_add_stack_to_cursor,
        try_autofill_crafting_grid, try_shift_move_core_stack_into_brewing_stand,
        try_shift_move_core_stack_into_chest, try_shift_move_core_stack_into_enchanting_table,
        try_shift_move_core_stack_into_furnace, ArmorPiece, ArmorSlot, BlockPropertiesRegistry,
        BrewingStandState, ChestState, Chunk, ChunkPos, CraftingGridSize, DispenserState,
        DroppedItemType, EnchantingTableState, Enchantment, EnchantmentType, FluidSimulator,
        FluidType, FurnaceSlotKind, FurnaceState, GameWorld, HopperState, Hotbar, ItemManager,
        ItemStack, ItemType, MainInventory, MobType, PlayerHealth, PlayerPhysics, StatusEffectType,
        StatusEffects, ToolMaterial, ToolType, UiCoreSlotId, UiSlotClick, Voxel, AABB, BLOCK_AIR,
        BLOCK_BOOKSHELF, BLOCK_BREWING_STAND, BLOCK_BROWN_MUSHROOM, BLOCK_COBBLESTONE,
        BLOCK_CRAFTING_TABLE, BLOCK_CRYING_OBSIDIAN, BLOCK_ENCHANTING_TABLE, BLOCK_END_PORTAL,
        BLOCK_END_PORTAL_FRAME, BLOCK_FURNACE, BLOCK_GLOWSTONE, BLOCK_NETHER_PORTAL, BLOCK_OAK_LOG,
        BLOCK_OAK_PLANKS, BLOCK_OBSIDIAN, BLOCK_RESPAWN_ANCHOR, BLOCK_SUGAR_CANE,
        CORE_ITEM_BLAZE_POWDER, CORE_ITEM_BOOK, CORE_ITEM_BUCKET, CORE_ITEM_ENDER_PEARL,
        CORE_ITEM_EYE_OF_ENDER, CORE_ITEM_FERMENTED_SPIDER_EYE, CORE_ITEM_FLINT_AND_STEEL,
        CORE_ITEM_GHAST_TEAR, CORE_ITEM_GLASS_BOTTLE, CORE_ITEM_GLISTERING_MELON,
        CORE_ITEM_GLOWSTONE_DUST, CORE_ITEM_GUNPOWDER, CORE_ITEM_LAVA_BUCKET,
        CORE_ITEM_MAGMA_CREAM, CORE_ITEM_NETHER_QUARTZ, CORE_ITEM_NETHER_WART, CORE_ITEM_PAPER,
        CORE_ITEM_PHANTOM_MEMBRANE, CORE_ITEM_PUFFERFISH, CORE_ITEM_RABBIT_FOOT,
        CORE_ITEM_REDSTONE_DUST, CORE_ITEM_SPIDER_EYE, CORE_ITEM_SUGAR, CORE_ITEM_WATER_BOTTLE,
        CORE_ITEM_WATER_BUCKET, CORE_ITEM_WHEAT, CORE_ITEM_WHEAT_SEEDS,
    };
    use crate::content_pack_loot;
    use mdminecraft_core::DimensionId;
    use mdminecraft_world::StatusEffect;

    fn local_y(world_y: i32) -> usize {
        mdminecraft_world::world_y_to_local_y(world_y).expect("world y in bounds")
    }

    #[test]
    fn column_ground_height_returns_world_space_y() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            0,
            0,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let block_properties = BlockPropertiesRegistry::new();
        let height = GameWorld::column_ground_height(&chunks, &block_properties, 0.5, 0.5);
        let expected = mdminecraft_world::local_y_to_world_y(0) as f32 + 1.0;
        assert_eq!(height, expected);
    }

    #[test]
    fn mob_bow_drop_metadata_is_deterministic_and_valid() {
        let world_seed = 123_456_789;
        let sim_tick = mdminecraft_core::SimTick(1_234_567);
        let mob_id = 42;

        let max_durability = ItemStack::new(ItemType::Item(1), 1)
            .durability
            .expect("bow should have durability");

        let pos = (10, 64, -20);
        let a = GameWorld::mob_bow_drop_metadata(world_seed, sim_tick, mob_id, pos);
        let b = GameWorld::mob_bow_drop_metadata(world_seed, sim_tick, mob_id, pos);
        assert_eq!(a, b);

        let (durability, enchantments) = a;
        let durability = durability.expect("bow drops should carry durability metadata");
        assert!((1..=max_durability).contains(&durability));

        // Ensure the enchantment path is exercised deterministically.
        let mut scanned = None;
        for x in 0..256 {
            let (_, ench) =
                GameWorld::mob_bow_drop_metadata(world_seed, sim_tick, mob_id, (x, 64, 0));
            if ench.is_some() {
                scanned = ench;
                break;
            }
        }

        if let Some(enchants) = scanned.or(enchantments) {
            assert!(!enchants.is_empty());
            for (idx, ench) in enchants.iter().enumerate() {
                assert!(ench.level >= 1);
                assert!(ench.level <= ench.enchantment_type.max_level());
                for other in enchants.iter().skip(idx + 1) {
                    assert!(
                        ench.enchantment_type
                            .is_compatible_with(&other.enchantment_type),
                        "incompatible enchantments: {:?} vs {:?}",
                        ench.enchantment_type,
                        other.enchantment_type
                    );
                }
            }
        }
    }

    #[test]
    fn spill_core_stack_to_world_preserves_metadata() {
        let mut item_manager = ItemManager::new();

        let mut bow = ItemStack::new(ItemType::Item(1), 1);
        bow.durability = Some(42);
        let enchantments = vec![Enchantment::new(EnchantmentType::Power, 3)];
        bow.enchantments = Some(enchantments.clone());

        let drop_pos = (0.5, 64.5, 0.5);
        assert_eq!(
            GameWorld::spill_core_stack_to_world(
                &mut item_manager,
                DimensionId::Overworld,
                drop_pos,
                &bow
            ),
            Some(DroppedItemType::Bow)
        );

        let items = item_manager.items();
        assert_eq!(items.len(), 1);
        assert_eq!(items[0].item_type, DroppedItemType::Bow);
        assert_eq!(items[0].count, 1);
        assert_eq!(items[0].durability, Some(42));
        assert_eq!(items[0].enchantments, Some(enchantments));
    }

    #[test]
    fn mob_meat_drop_type_cooks_when_burning() {
        assert_eq!(
            GameWorld::mob_meat_drop_type(MobType::Pig, false),
            Some(DroppedItemType::RawPork)
        );
        assert_eq!(
            GameWorld::mob_meat_drop_type(MobType::Pig, true),
            Some(DroppedItemType::CookedPork)
        );

        assert_eq!(
            GameWorld::mob_meat_drop_type(MobType::Cow, false),
            Some(DroppedItemType::RawBeef)
        );
        assert_eq!(
            GameWorld::mob_meat_drop_type(MobType::Cow, true),
            Some(DroppedItemType::CookedBeef)
        );

        assert_eq!(GameWorld::mob_meat_drop_type(MobType::Sheep, true), None);
    }

    #[test]
    fn zombie_rare_drop_rolls_expected_items() {
        assert_eq!(
            GameWorld::zombie_rare_drop(0, 0, 0),
            Some(DroppedItemType::Carrot)
        );
        assert_eq!(
            GameWorld::zombie_rare_drop(2, 0, 0),
            Some(DroppedItemType::Potato)
        );
        assert_eq!(
            GameWorld::zombie_rare_drop(4, 0, 0),
            Some(DroppedItemType::IronIngot)
        );
        assert_eq!(GameWorld::zombie_rare_drop(6, 0, 0), None);
    }

    #[test]
    fn chicken_egg_laying_is_periodic_and_deterministic() {
        let world_seed = 123_456;
        let mob_id = 99;
        let pos_x = 10;
        let pos_z = -20;

        let mut ticks = Vec::new();
        for tick in 0..30_000 {
            if GameWorld::chicken_should_lay_egg(world_seed, tick, mob_id, pos_x, pos_z) {
                ticks.push(tick);
            }
        }

        assert!(ticks.len() >= 2);
        let interval = ticks[1] - ticks[0];
        assert!(interval >= super::CHICKEN_EGG_MIN_INTERVAL_TICKS);
        assert!(
            interval
                < super::CHICKEN_EGG_MIN_INTERVAL_TICKS + super::CHICKEN_EGG_INTERVAL_RANGE_TICKS
        );
        for window in ticks.windows(2) {
            assert_eq!(window[1] - window[0], interval);
        }

        let mut ticks_2 = Vec::new();
        for tick in 0..30_000 {
            if GameWorld::chicken_should_lay_egg(world_seed, tick, mob_id, pos_x, pos_z) {
                ticks_2.push(tick);
            }
        }
        assert_eq!(ticks_2, ticks);
    }

    #[test]
    fn egg_hatch_count_is_deterministic_and_vanillaish() {
        let mut zero = 0u32;
        let mut one = 0u32;
        let mut four = 0u32;

        for throw_index in 0_u64..32 {
            match GameWorld::egg_hatch_count(0, 0, throw_index, 0, 0) {
                0 => zero += 1,
                1 => one += 1,
                4 => four += 1,
                other => panic!("Unexpected hatch count: {other}"),
            }
        }

        // Vanilla: 1/8 hatch and 1/32 hatch 4 chicks.
        assert_eq!(four, 1);
        assert_eq!(one, 3);
        assert_eq!(zero, 28);

        let a = GameWorld::egg_hatch_count(123, 456, 7, 10, -20);
        let b = GameWorld::egg_hatch_count(123, 456, 7, 10, -20);
        assert_eq!(a, b);
    }

    #[test]
    fn bone_meal_grows_crops_deterministically_and_unregisters_when_fully_grown() {
        let world_seed = 123_456;
        let tick = 42;
        let chunk_pos = ChunkPos::new(0, 0);
        let (world_x, world_y, world_z) = (1, 64, 1);
        let (local_x, local_y, local_z) = (world_x as usize, local_y(world_y), world_z as usize);

        let mut chunk = Chunk::new(chunk_pos);
        chunk.set_voxel(
            local_x,
            local_y,
            local_z,
            Voxel {
                id: mdminecraft_world::farming_blocks::WHEAT_0,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(chunk_pos, chunk);

        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(world_seed);
        crop_growth.register_crop(mdminecraft_world::CropPosition {
            chunk: chunk_pos,
            x: local_x as u8,
            y: local_y as u8,
            z: local_z as u8,
        });

        assert!(GameWorld::apply_bone_meal_to_crop_at(
            world_seed,
            tick,
            glam::IVec3::new(world_x, world_y, world_z),
            &mut chunks,
            &mut crop_growth,
        ));

        let expected_delta =
            GameWorld::bone_meal_crop_growth_delta(world_seed, tick, world_x, world_y, world_z, 0);
        let expected_stage = expected_delta.min(mdminecraft_world::CropType::Wheat.max_stage());
        let expected_id = mdminecraft_world::CropType::Wheat.block_id_at_stage(expected_stage);

        let updated = chunks
            .get(&chunk_pos)
            .expect("chunk exists")
            .voxel(local_x, local_y, local_z);
        assert_eq!(updated.id, expected_id);
        assert_eq!(crop_growth.crop_count(), 1);

        // Apply bone meal near-full growth: should clamp and unregister.
        chunks.get_mut(&chunk_pos).expect("chunk exists").set_voxel(
            local_x,
            local_y,
            local_z,
            Voxel {
                id: mdminecraft_world::farming_blocks::WHEAT_6,
                ..Default::default()
            },
        );
        crop_growth.register_crop(mdminecraft_world::CropPosition {
            chunk: chunk_pos,
            x: local_x as u8,
            y: local_y as u8,
            z: local_z as u8,
        });

        assert!(GameWorld::apply_bone_meal_to_crop_at(
            world_seed,
            tick,
            glam::IVec3::new(world_x, world_y, world_z),
            &mut chunks,
            &mut crop_growth,
        ));
        let updated = chunks
            .get(&chunk_pos)
            .expect("chunk exists")
            .voxel(local_x, local_y, local_z);
        assert_eq!(updated.id, mdminecraft_world::farming_blocks::WHEAT_7);
        assert_eq!(crop_growth.crop_count(), 0);
    }

    #[test]
    fn mob_grounding_prevents_falling_through_blocks() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(0),
            0,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let block_properties = BlockPropertiesRegistry::new();

        let before_pos = (0.5, 5.0, 0.5);
        let mut mob =
            mdminecraft_world::Mob::new(0.5, -2.0, 0.5, mdminecraft_world::MobType::Zombie);
        mob.vel_y = -3.0;

        GameWorld::resolve_mob_world_collisions(&chunks, &block_properties, &mut mob, before_pos);

        let expected_y = 0.0 + 1.0 + PlayerPhysics::GROUND_EPS as f64;
        assert!(
            (mob.y - expected_y).abs() < 1e-6,
            "mob.y = {}, expected {}",
            mob.y,
            expected_y
        );
        assert_eq!(mob.vel_y, 0.0);
    }

    #[test]
    fn mob_collision_blocks_horizontal_motion_through_walls() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        // Ground blocks to stand on.
        for x in 0..=1 {
            chunk.set_voxel(
                x,
                local_y(0),
                0,
                Voxel {
                    id: BLOCK_COBBLESTONE,
                    ..Default::default()
                },
            );
        }
        // Two-block-high wall at x=1,z=0.
        chunk.set_voxel(
            1,
            local_y(1),
            0,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let block_properties = BlockPropertiesRegistry::new();

        let start_y = 0.0 + 1.0 + PlayerPhysics::GROUND_EPS as f64;
        let before_pos = (0.5, start_y, 0.5);
        let mut mob =
            mdminecraft_world::Mob::new(1.5, start_y, 0.5, mdminecraft_world::MobType::Zombie);
        mob.vel_x = 1.0;

        GameWorld::resolve_mob_world_collisions(&chunks, &block_properties, &mut mob, before_pos);

        assert_eq!(mob.x, before_pos.0);
        assert_eq!(mob.vel_x, 0.0);
    }

    fn find_nether_fortress_chest_key(world_seed: u64) -> mdminecraft_world::BlockEntityKey {
        let generator = mdminecraft_world::FortressGenerator::new(world_seed);
        let chest_id = mdminecraft_world::interactive_blocks::CHEST;

        for chunk_x in -64..=64 {
            for chunk_z in -64..=64 {
                let chunk_pos = ChunkPos::new(chunk_x, chunk_z);
                let spawns =
                    mdminecraft_world::fortress_blaze_spawns_for_chunk(world_seed, chunk_pos);
                if spawns.is_empty() {
                    continue;
                }

                let mut chunk = Chunk::new(chunk_pos);
                if !generator.try_generate_fortress(&mut chunk) {
                    continue;
                }

                let chunk_min_x = chunk_pos.x * mdminecraft_world::CHUNK_SIZE_X as i32;
                let chunk_min_z = chunk_pos.z * mdminecraft_world::CHUNK_SIZE_Z as i32;

                for spawn in spawns {
                    let world_x = spawn.x.floor() as i32;
                    let world_y = spawn.y.floor() as i32;
                    let world_z = spawn.z.floor() as i32;

                    let local_x = world_x - chunk_min_x;
                    let local_z = world_z - chunk_min_z;
                    if local_x < 0
                        || local_x >= mdminecraft_world::CHUNK_SIZE_X as i32
                        || local_z < 0
                        || local_z >= mdminecraft_world::CHUNK_SIZE_Z as i32
                    {
                        continue;
                    }

                    let voxel = chunk.voxel(local_x as usize, local_y(world_y), local_z as usize);
                    if voxel.id == chest_id {
                        return mdminecraft_world::BlockEntityKey {
                            dimension: DimensionId::Nether,
                            x: world_x,
                            y: world_y,
                            z: world_z,
                        };
                    }
                }
            }
        }

        panic!("expected to locate a Nether fortress chest for seed {world_seed}");
    }

    #[test]
    fn collisions_use_block_solidity_not_opacity() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_GLASS,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_WATER,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            2,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::TORCH,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let block_properties = BlockPropertiesRegistry::new();

        let glass_aabb = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(1.0, 65.0, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &glass_aabb
        ));

        let water_aabb = AABB {
            min: glam::Vec3::new(1.0, 64.0, 0.0),
            max: glam::Vec3::new(2.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &water_aabb
        ));

        let torch_aabb = AABB {
            min: glam::Vec3::new(2.0, 64.0, 0.0),
            max: glam::Vec3::new(3.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &torch_aabb
        ));
    }

    #[test]
    fn worldgen_chest_loot_is_deterministic_and_non_empty() {
        let key = mdminecraft_world::BlockEntityKey {
            dimension: mdminecraft_core::DimensionId::Overworld,
            x: 10,
            y: 30,
            z: -5,
        };

        let mut chest_a = ChestState::new();
        let mut chest_b = ChestState::new();
        let loot_tables = content_pack_loot::LootTables::default();

        GameWorld::populate_worldgen_chest_loot(&mut chest_a, 12345, key, &loot_tables);
        GameWorld::populate_worldgen_chest_loot(&mut chest_b, 12345, key, &loot_tables);

        assert_eq!(chest_a.slots, chest_b.slots);
        assert!(
            chest_a.slots.iter().any(|slot| slot.is_some()),
            "expected worldgen chest loot to fill at least one slot"
        );

        let mut chest_with_item = ChestState::new();
        chest_with_item.slots[0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        let before = chest_with_item.slots.clone();
        GameWorld::populate_worldgen_chest_loot(&mut chest_with_item, 12345, key, &loot_tables);
        assert_eq!(chest_with_item.slots, before);
    }

    #[test]
    fn worldgen_chest_loot_respects_content_pack_table_overrides() {
        let key = mdminecraft_world::BlockEntityKey {
            dimension: mdminecraft_core::DimensionId::Nether,
            x: 10,
            y: 5,
            z: -5,
        };

        let mut loot_tables = content_pack_loot::LootTables::default();
        let override_table =
            content_pack_loot::WorldgenChestLootTableDefinition::from_weighted_entries(vec![(
                ItemType::Item(14),
                1,
                1,
                1,
            )])
            .expect("override table should build");
        loot_tables
            .worldgen_chests
            .insert(super::WorldgenChestLootTable::Generic, override_table);

        let mut chest = ChestState::new();
        GameWorld::populate_worldgen_chest_loot(&mut chest, 12345, key, &loot_tables);

        let expected = ItemStack::new(ItemType::Item(14), 1);
        assert!(
            chest.slots.iter().any(|slot| slot.is_some()),
            "expected overridden loot table to populate at least one slot"
        );
        for slot in chest.slots.iter().flatten() {
            assert_eq!(slot, &expected);
        }
    }

    #[test]
    fn nether_fortress_chest_selects_nether_fortress_loot_table() {
        let world_seed = 0x46_4F_52_54_52_45_53_53_u64; // "FORTRESS"
        let key = find_nether_fortress_chest_key(world_seed);
        assert_eq!(
            GameWorld::worldgen_chest_loot_table_for_key(world_seed, key),
            super::WorldgenChestLootTable::NetherFortress
        );
    }

    #[test]
    fn nether_fortress_chest_loot_respects_content_pack_table_overrides() {
        let world_seed = 0x46_4F_52_54_52_45_53_53_u64; // "FORTRESS"
        let key = find_nether_fortress_chest_key(world_seed);

        let mut loot_tables = content_pack_loot::LootTables::default();
        let override_table =
            content_pack_loot::WorldgenChestLootTableDefinition::from_weighted_entries(vec![(
                ItemType::Item(14),
                1,
                1,
                1,
            )])
            .expect("override table should build");
        loot_tables.worldgen_chests.insert(
            super::WorldgenChestLootTable::NetherFortress,
            override_table,
        );

        let mut chest = ChestState::new();
        GameWorld::populate_worldgen_chest_loot(&mut chest, world_seed, key, &loot_tables);

        let expected = ItemStack::new(ItemType::Item(14), 1);
        assert!(
            chest.slots.iter().any(|slot| slot.is_some()),
            "expected overridden loot table to populate at least one slot"
        );
        for slot in chest.slots.iter().flatten() {
            assert_eq!(slot, &expected);
        }
    }

    #[test]
    fn villager_trade_offers_are_deterministic_for_seed_and_id() {
        let (profession_a, offers_a) = super::villager_trade_offers(12345, 99);
        let (profession_b, offers_b) = super::villager_trade_offers(12345, 99);
        assert_eq!(profession_a, profession_b);
        assert_eq!(offers_a, offers_b);
    }

    #[test]
    fn effective_spawn_light_level_scales_skylight_and_respects_block_light() {
        // `SimTime` uses Minecraft-style tick semantics:
        // - tick 6000 = noon
        // - tick 18000 = midnight
        let mut noon = mdminecraft_world::SimTime::new(24000);
        noon.tick = mdminecraft_core::SimTick(6000);

        let voxel = Voxel {
            id: BLOCK_AIR,
            state: 0,
            light_sky: 15,
            light_block: 0,
        };
        assert_eq!(GameWorld::effective_spawn_light_level(voxel, &noon), 15);

        let mut midnight = mdminecraft_world::SimTime::new(24000);
        midnight.tick = mdminecraft_core::SimTick(18000);
        assert_eq!(GameWorld::effective_spawn_light_level(voxel, &midnight), 3);

        let torchlit = Voxel {
            id: BLOCK_AIR,
            state: 0,
            light_sky: 0,
            light_block: 10,
        };
        assert_eq!(
            GameWorld::effective_spawn_light_level(torchlit, &midnight),
            10
        );
    }

    #[test]
    fn column_is_clear_to_sky_detects_cover_blocks() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        let x = 0;
        let z = 0;

        assert!(GameWorld::column_is_clear_to_sky(&chunk, x, local_y(64), z));

        chunk.set_voxel(
            x,
            local_y(70),
            z,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        assert!(!GameWorld::column_is_clear_to_sky(
            &chunk,
            x,
            local_y(64),
            z
        ));
        assert!(GameWorld::column_is_clear_to_sky(&chunk, x, local_y(71), z));
    }

    #[test]
    fn undead_sunlight_helpers_match_expected_rules() {
        assert!(GameWorld::undead_should_extinguish(true, false, false));
        assert!(GameWorld::undead_should_extinguish(true, true, true));

        // Rain should not extinguish if the mob is under cover.
        assert!(!GameWorld::undead_should_extinguish(false, true, false));

        // Rain extinguishes exposed mobs.
        assert!(GameWorld::undead_should_extinguish(false, true, true));

        // Daylight burn: day + exposed + bright skylight.
        assert!(GameWorld::undead_should_burn_in_sun(
            false, false, false, 15, true
        ));

        // No burn at night.
        assert!(!GameWorld::undead_should_burn_in_sun(
            true, false, false, 15, true
        ));

        // No burn while wet.
        assert!(!GameWorld::undead_should_burn_in_sun(
            false, false, true, 15, true
        ));

        // No burn during rain/snow when exposed.
        assert!(!GameWorld::undead_should_burn_in_sun(
            false, true, false, 15, true
        ));

        // No burn in shade.
        assert!(!GameWorld::undead_should_burn_in_sun(
            false, false, false, 15, false
        ));

        // No burn when skylight is low.
        assert!(!GameWorld::undead_should_burn_in_sun(
            false,
            false,
            false,
            super::UNDEAD_SUNLIGHT_MIN_SKY_LIGHT - 1,
            true
        ));
    }

    #[test]
    fn torch_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::TORCH,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::interactive_blocks::TORCH
            )),
            "Expected torch to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Torch should be cleared when its support is removed"
        );
    }

    #[test]
    fn wall_torch_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::TORCH,
                state: mdminecraft_world::torch_wall_state(mdminecraft_world::Facing::East),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(1, 64, 0),
                mdminecraft_world::interactive_blocks::TORCH
            )),
            "Expected wall torch to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(1, local_y(64), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Wall torch should be cleared when its support is removed"
        );
    }

    #[test]
    fn wall_button_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::STONE_BUTTON,
                state: mdminecraft_world::wall_mount_state(mdminecraft_world::Facing::East),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(1, 64, 0),
                mdminecraft_world::redstone_blocks::STONE_BUTTON
            )),
            "Expected wall button to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(1, local_y(64), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Wall button should be cleared when its support is removed"
        );
    }

    #[test]
    fn pressure_plates_trigger_vanillaish_for_players_and_items() {
        use mdminecraft_core::DimensionId;

        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        // Support blocks.
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        // Plates sit in the voxel above the support.
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let mut item_manager = ItemManager::new();
        let oak_item = item_manager.spawn_item(
            DimensionId::Overworld,
            0.5,
            65.25,
            0.5,
            DroppedItemType::Arrow,
            1,
        );
        let stone_item = item_manager.spawn_item(
            DimensionId::Overworld,
            1.5,
            65.25,
            0.5,
            DroppedItemType::Arrow,
            1,
        );
        item_manager
            .get_mut(oak_item)
            .expect("oak item exists")
            .on_ground = true;
        item_manager
            .get_mut(stone_item)
            .expect("stone item exists")
            .on_ground = true;

        let items_only = GameWorld::collect_pressed_pressure_plates(
            &chunks,
            DimensionId::Overworld,
            None,
            &[],
            &item_manager,
        );
        assert!(items_only.contains(&mdminecraft_world::RedstonePos::new(0, 65, 0)));
        assert!(
            !items_only.contains(&mdminecraft_world::RedstonePos::new(1, 65, 0)),
            "Stone plates should not be triggered by dropped items"
        );

        let player_eye = glam::Vec3::new(1.5, 66.5, 0.5);
        let with_player = GameWorld::collect_pressed_pressure_plates(
            &chunks,
            DimensionId::Overworld,
            Some((player_eye, 1.5)),
            &[],
            &item_manager,
        );
        assert!(with_player.contains(&mdminecraft_world::RedstonePos::new(0, 65, 0)));
        assert!(with_player.contains(&mdminecraft_world::RedstonePos::new(1, 65, 0)));

        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let prev = std::collections::BTreeSet::new();
        GameWorld::apply_pressure_plate_transitions(
            &prev,
            &with_player,
            &mut redstone_sim,
            &mut chunks,
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).expect("chunk exists");
        assert!(mdminecraft_world::is_active(
            chunk.voxel(0, local_y(65), 0).state
        ));
        assert!(mdminecraft_world::is_active(
            chunk.voxel(1, local_y(65), 0).state
        ));

        let next = std::collections::BTreeSet::new();
        GameWorld::apply_pressure_plate_transitions(
            &with_player,
            &next,
            &mut redstone_sim,
            &mut chunks,
        );
        let chunk = chunks.get(&ChunkPos::new(0, 0)).expect("chunk exists");
        assert!(!mdminecraft_world::is_active(
            chunk.voxel(0, local_y(65), 0).state
        ));
        assert!(!mdminecraft_world::is_active(
            chunk.voxel(1, local_y(65), 0).state
        ));
    }

    #[test]
    fn ceiling_lever_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(63),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::LEVER,
                state: mdminecraft_world::ceiling_mount_state(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 63, 0),
                mdminecraft_world::redstone_blocks::LEVER
            )),
            "Expected ceiling lever to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(63), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Ceiling lever should be cleared when its support is removed"
        );
    }

    #[test]
    fn fire_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_FIRE,
                state: mdminecraft_world::set_fire_age(0, 3),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::BLOCK_FIRE
            )),
            "Expected fire to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Fire should be cleared when its support is removed"
        );
    }

    #[test]
    fn ladder_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::LADDER,
                state: mdminecraft_world::Facing::West.to_state(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(1, 64, 0),
                mdminecraft_world::interactive_blocks::LADDER
            )),
            "Expected ladder to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(1, local_y(64), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Ladder should be cleared when its support is removed"
        );
    }

    #[test]
    fn redstone_wire_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::REDSTONE_WIRE,
                state: 0,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::redstone_blocks::REDSTONE_WIRE
            )),
            "Expected redstone wire to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Redstone wire should be cleared when its support is removed"
        );
    }

    #[test]
    fn sand_falls_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(66),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_SAND,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 65, 0)],
        );

        assert!(
            support_changes.removed.is_empty(),
            "Expected sand to fall instead of being removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(chunk.voxel(0, local_y(65), 0).id, mdminecraft_world::BLOCK_SAND);
        assert_eq!(chunk.voxel(0, local_y(66), 0).id, mdminecraft_world::BLOCK_AIR);
    }

    #[test]
    fn sugar_cane_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_DIRT,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: BLOCK_SUGAR_CANE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(66),
            0,
            Voxel {
                id: BLOCK_SUGAR_CANE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );

        assert!(
            support_changes
                .removed
                .contains(&(glam::IVec3::new(0, 65, 0), BLOCK_SUGAR_CANE)),
            "Expected sugar cane base to be removed, got: {:?}",
            support_changes.removed
        );
        assert!(
            support_changes
                .removed
                .contains(&(glam::IVec3::new(0, 66, 0), BLOCK_SUGAR_CANE)),
            "Expected sugar cane above to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR
        );
        assert_eq!(
            chunk.voxel(0, local_y(66), 0).id,
            mdminecraft_world::BLOCK_AIR
        );
    }

    #[test]
    fn door_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let door_state = mdminecraft_world::Facing::North.to_state();
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
                state: door_state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(66),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER,
                state: door_state,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        if let Some(chunk) = chunks.get_mut(&ChunkPos::new(0, 0)) {
            chunk.set_voxel(0, local_y(64), 0, Voxel::default());
        }

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(0, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER
            )),
            "Expected door lower to be removed, got: {:?}",
            support_changes.removed
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 66, 0),
                mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER
            )),
            "Expected door upper to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Door lower should be cleared when its support is removed"
        );
        assert_eq!(
            chunk.voxel(0, local_y(66), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Door upper should be cleared when its support is removed"
        );
    }

    #[test]
    fn support_removed_drop_skips_door_upper_when_lower_removed() {
        let removed_support = vec![
            (
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
            ),
            (
                glam::IVec3::new(0, 66, 0),
                mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER,
            ),
        ];

        assert!(GameWorld::should_drop_support_removed_block(
            &removed_support,
            glam::IVec3::new(0, 65, 0),
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER
        ));
        assert!(!GameWorld::should_drop_support_removed_block(
            &removed_support,
            glam::IVec3::new(0, 66, 0),
            mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER
        ));
    }

    #[test]
    fn support_removed_drop_skips_bed_head_when_both_halves_removed() {
        let removed_support = vec![
            (
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::interactive_blocks::BED_FOOT,
            ),
            (
                glam::IVec3::new(1, 65, 0),
                mdminecraft_world::interactive_blocks::BED_HEAD,
            ),
        ];

        assert!(GameWorld::should_drop_support_removed_block(
            &removed_support,
            glam::IVec3::new(0, 65, 0),
            mdminecraft_world::interactive_blocks::BED_FOOT
        ));
        assert!(!GameWorld::should_drop_support_removed_block(
            &removed_support,
            glam::IVec3::new(1, 65, 0),
            mdminecraft_world::interactive_blocks::BED_HEAD
        ));
    }

    #[test]
    fn bed_breaks_when_support_removed() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let bed_state = mdminecraft_world::Facing::East.to_state();
        chunk.set_voxel(
            0,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::BED_FOOT,
                state: bed_state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::BED_HEAD,
                state: bed_state,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Remove the support under the head.
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(1, local_y(64), 0, Voxel::default());

        let support_changes = GameWorld::remove_unsupported_blocks(
            &mut chunks,
            &block_properties,
            [glam::IVec3::new(1, 64, 0)],
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(0, 65, 0),
                mdminecraft_world::interactive_blocks::BED_FOOT
            )),
            "Expected bed foot to be removed, got: {:?}",
            support_changes.removed
        );
        assert!(
            support_changes.removed.contains(&(
                glam::IVec3::new(1, 65, 0),
                mdminecraft_world::interactive_blocks::BED_HEAD
            )),
            "Expected bed head to be removed, got: {:?}",
            support_changes.removed
        );

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        assert_eq!(
            chunk.voxel(0, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Bed foot should be cleared when its support is removed"
        );
        assert_eq!(
            chunk.voxel(1, local_y(65), 0).id,
            mdminecraft_world::BLOCK_AIR,
            "Bed head should be cleared when its support is removed"
        );
    }

    #[test]
    fn bed_pair_removal_works_across_chunks() {
        let bed_state = mdminecraft_world::Facing::East.to_state();

        // Case 1: removing from the foot clears the head in the neighboring +X chunk.
        {
            let mut left = Chunk::new(ChunkPos::new(0, 0));
            let mut right = Chunk::new(ChunkPos::new(1, 0));

            left.set_voxel(
                15,
                local_y(65),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::BED_FOOT,
                    state: bed_state,
                    ..Default::default()
                },
            );
            right.set_voxel(
                0,
                local_y(65),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::BED_HEAD,
                    state: bed_state,
                    ..Default::default()
                },
            );

            let mut chunks = std::collections::HashMap::new();
            chunks.insert(ChunkPos::new(0, 0), left);
            chunks.insert(ChunkPos::new(1, 0), right);

            let removed = GameWorld::try_remove_other_bed_half(
                &mut chunks,
                glam::IVec3::new(15, 65, 0),
                mdminecraft_world::interactive_blocks::BED_FOOT,
                bed_state,
            );
            assert_eq!(removed, Some(glam::IVec3::new(16, 65, 0)));

            let right = chunks.get(&ChunkPos::new(1, 0)).unwrap();
            assert_eq!(
                right.voxel(0, local_y(65), 0).id,
                mdminecraft_world::BLOCK_AIR
            );
        }

        // Case 2: removing from the head clears the foot in the neighboring -X chunk.
        {
            let mut left = Chunk::new(ChunkPos::new(0, 0));
            let mut right = Chunk::new(ChunkPos::new(1, 0));

            left.set_voxel(
                15,
                local_y(65),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::BED_FOOT,
                    state: bed_state,
                    ..Default::default()
                },
            );
            right.set_voxel(
                0,
                local_y(65),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::BED_HEAD,
                    state: bed_state,
                    ..Default::default()
                },
            );

            let mut chunks = std::collections::HashMap::new();
            chunks.insert(ChunkPos::new(0, 0), left);
            chunks.insert(ChunkPos::new(1, 0), right);

            let removed = GameWorld::try_remove_other_bed_half(
                &mut chunks,
                glam::IVec3::new(16, 65, 0),
                mdminecraft_world::interactive_blocks::BED_HEAD,
                bed_state,
            );
            assert_eq!(removed, Some(glam::IVec3::new(15, 65, 0)));

            let left = chunks.get(&ChunkPos::new(0, 0)).unwrap();
            assert_eq!(
                left.voxel(15, local_y(65), 0).id,
                mdminecraft_world::BLOCK_AIR
            );
        }
    }

    #[test]
    fn collision_shapes_respect_slabs_and_trapdoors() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::STONE_SLAB,
                state: 0,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::STONE_SLAB,
                state: 0x04, // top slab
                ..Default::default()
            },
        );
        chunk.set_voxel(
            2,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::TRAPDOOR,
                state: 0,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            3,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::TRAPDOOR,
                state: mdminecraft_world::set_trapdoor_open(0, true),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Bottom slab occupies y..y+0.5.
        let above_bottom_slab = AABB {
            min: glam::Vec3::new(0.0, 64.6, 0.0),
            max: glam::Vec3::new(1.0, 64.9, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &above_bottom_slab
        ));

        // Top slab occupies y+0.5..y+1.0.
        let below_top_slab = AABB {
            min: glam::Vec3::new(1.0, 64.1, 0.0),
            max: glam::Vec3::new(2.0, 64.4, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &below_top_slab
        ));
        let inside_top_slab = AABB {
            min: glam::Vec3::new(1.0, 64.6, 0.0),
            max: glam::Vec3::new(2.0, 64.9, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &inside_top_slab
        ));

        // Closed trapdoor occupies only the bottom plate.
        let above_trapdoor = AABB {
            min: glam::Vec3::new(2.0, 64.3, 0.0),
            max: glam::Vec3::new(3.0, 64.5, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &above_trapdoor
        ));
        let inside_trapdoor_plate = AABB {
            min: glam::Vec3::new(2.0, 64.05, 0.0),
            max: glam::Vec3::new(3.0, 64.1, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &inside_trapdoor_plate
        ));

        // Open trapdoor becomes a thin vertical plane (like a door).
        let near_north_edge = AABB {
            min: glam::Vec3::new(3.0, 64.0, 0.0),
            max: glam::Vec3::new(4.0, 65.0, 0.1),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_north_edge
        ));

        let near_south_edge = AABB {
            min: glam::Vec3::new(3.0, 64.0, 0.9),
            max: glam::Vec3::new(4.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_south_edge
        ));
    }

    #[test]
    fn door_collision_shape_is_thin_and_rotates_when_open() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let base = mdminecraft_world::Facing::North.to_state();
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
                state: base,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Closed north-facing door occupies a thin slice at the north edge (low Z).
        let near_north_edge = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(1.0, 65.0, 0.1),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_north_edge
        ));
        let near_south_edge = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.9),
            max: glam::Vec3::new(1.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_south_edge
        ));

        // Open door swings "left" (simplified), so it becomes a thin slice at the west edge (low X).
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(
                0,
                local_y(64),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
                    state: mdminecraft_world::set_door_open(base, true),
                    ..Default::default()
                },
            );

        let near_west_edge = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(0.1, 65.0, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_west_edge
        ));
        let near_east_edge = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.0),
            max: glam::Vec3::new(1.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_east_edge
        ));
    }

    #[test]
    fn projectile_block_collision_respects_thin_and_tall_shapes() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::STONE_SLAB,
                state: 0, // bottom slab
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::TRAPDOOR,
                state: mdminecraft_world::set_trapdoor_open(0, true),
                ..Default::default()
            },
        );
        let door_state =
            mdminecraft_world::set_door_open(mdminecraft_world::Facing::North.to_state(), true);
        chunk.set_voxel(
            2,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
                state: door_state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            3,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_FENCE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Bottom slab occupies y..y+0.5, so projectiles above it should pass.
        assert!(!GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            0.5,
            64.75,
            0.5,
        ));
        assert!(GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            0.5,
            64.25,
            0.5,
        ));

        // Open trapdoor becomes a thin vertical plane at the north edge (low Z, default facing).
        assert!(GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            1.5,
            64.5,
            0.05,
        ));
        assert!(!GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            1.5,
            64.5,
            0.95,
        ));

        // Open north-facing door swings left (west edge, low X).
        assert!(GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            2.05,
            64.5,
            0.5,
        ));
        assert!(!GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            2.95,
            64.5,
            0.5,
        ));

        // Fence collision extends to y+1.5, so points in the upper half of the next voxel collide.
        assert!(GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            3.5,
            65.4,
            0.5,
        ));
        assert!(!GameWorld::projectile_point_collides_with_world(
            &chunks,
            &block_properties,
            3.5,
            65.6,
            0.5,
        ));
    }

    #[test]
    fn projectile_segment_collision_detects_thin_door_planes() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        let door_state =
            mdminecraft_world::set_door_open(mdminecraft_world::Facing::North.to_state(), true);
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
                state: door_state,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let from = (0.9, 64.5, 0.5);
        let to = (2.0, 64.5, 0.5);

        assert!(
            !GameWorld::projectile_point_collides_with_world(
                &chunks,
                &block_properties,
                to.0,
                to.1,
                to.2
            ),
            "Point collision at the end of the tick should miss thin geometry"
        );

        let hit = GameWorld::projectile_first_block_hit_along_segment(
            &chunks,
            &block_properties,
            from,
            to,
        )
        .expect("Expected the swept segment to hit the door plane");
        assert!(
            (1.0..=1.25).contains(&hit.0),
            "Expected hit x to be within the door plane, got {}",
            hit.0
        );
        assert!((hit.1 - 64.5).abs() < 1.0e-6);
        assert!((hit.2 - 0.5).abs() < 1.0e-6);
    }

    #[test]
    fn projectile_collision_detects_wall_buttons() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::STONE_BUTTON,
                state: mdminecraft_world::wall_mount_state(mdminecraft_world::Facing::East),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        assert!(
            GameWorld::projectile_point_collides_with_world(
                &chunks,
                &block_properties,
                1.05,
                64.5,
                0.5,
            ),
            "Expected projectile collision to detect the wall button hitbox"
        );
        assert!(
            !GameWorld::projectile_point_collides_with_world(
                &chunks,
                &block_properties,
                1.25,
                64.5,
                0.5,
            ),
            "Expected point outside the wall button thickness to be clear"
        );

        let from = (2.0, 64.5, 0.5);
        let to = (1.0, 64.5, 0.5);
        let hit = GameWorld::projectile_first_block_hit_along_segment_with_block(
            &chunks,
            &block_properties,
            from,
            to,
        )
        .expect("Expected swept segment to hit the wall button");
        assert_eq!(
            hit.1,
            glam::IVec3::new(1, 64, 0),
            "Expected button voxel to be reported as the hit block"
        );
        assert!(
            (1.0..=1.2).contains(&hit.0 .0),
            "Expected hit x near the button face, got {}",
            hit.0 .0
        );
    }

    #[test]
    fn arrows_activate_buttons_on_hit() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::redstone_blocks::STONE_BUTTON,
                state: mdminecraft_world::wall_mount_state(mdminecraft_world::Facing::East),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();

        let hit_block = glam::IVec3::new(1, 64, 0);
        assert!(GameWorld::try_activate_button_from_projectile_hit(
            mdminecraft_world::ProjectileType::Arrow,
            hit_block,
            &mut chunks,
            &mut redstone_sim,
        ));

        let activated_voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .voxel(1, local_y(64), 0);
        assert!(mdminecraft_world::is_active(activated_voxel.state));

        assert!(
            !GameWorld::try_activate_button_from_projectile_hit(
                mdminecraft_world::ProjectileType::Arrow,
                hit_block,
                &mut chunks,
                &mut redstone_sim,
            ),
            "Second activation should be a no-op while the button is already active"
        );
    }

    #[test]
    fn aabb_segment_entry_fraction_detects_tunneling() {
        let aabb = AABB::from_center_size(glam::Vec3::ZERO, glam::Vec3::new(1.2, 1.2, 1.2));
        let from = glam::Vec3::new(-2.0, 0.0, 0.0);
        let to = glam::Vec3::new(2.0, 0.0, 0.0);
        let t = aabb
            .segment_entry_fraction(from, to)
            .expect("Segment should hit the AABB");
        assert!((t - 0.35).abs() < 1.0e-4, "Expected t0.35, got {}", t);
    }

    #[test]
    fn line_of_sight_respects_collision_shapes() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let from = glam::Vec3::new(0.5, 64.8, 0.5);
        let to = glam::Vec3::new(2.5, 64.8, 0.5);
        assert!(
            !GameWorld::line_of_sight_clear(&chunks, &block_properties, from, to),
            "Full blocks should block line of sight"
        );

        // Replace the block with a bottom slab (0..0.5): the ray above the slab should pass.
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(
                1,
                local_y(64),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::STONE_SLAB,
                    state: 0,
                    ..Default::default()
                },
            );

        assert!(
            GameWorld::line_of_sight_clear(&chunks, &block_properties, from, to),
            "Rays above partial-height collision should not be blocked"
        );

        let low_from = glam::Vec3::new(0.5, 64.25, 0.5);
        let low_to = glam::Vec3::new(2.5, 64.25, 0.5);
        assert!(
            !GameWorld::line_of_sight_clear(&chunks, &block_properties, low_from, low_to),
            "Rays through partial-height collision should be blocked"
        );

        // Replace with a fence: collision extends to 1.5 blocks tall.
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(
                1,
                local_y(64),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::OAK_FENCE,
                    ..Default::default()
                },
            );

        let fence_from = glam::Vec3::new(0.5, 65.4, 0.5);
        let fence_to = glam::Vec3::new(2.5, 65.4, 0.5);
        assert!(
            !GameWorld::line_of_sight_clear(&chunks, &block_properties, fence_from, fence_to),
            "Tall collision should block line of sight above the base voxel"
        );

        let above_fence_from = glam::Vec3::new(0.5, 65.6, 0.5);
        let above_fence_to = glam::Vec3::new(2.5, 65.6, 0.5);
        assert!(
            GameWorld::line_of_sight_clear(
                &chunks,
                &block_properties,
                above_fence_from,
                above_fence_to
            ),
            "Line of sight above tall collision should be clear"
        );
    }

    #[test]
    fn explosion_exposure_is_reduced_by_walls() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        // Two-block-high wall at x=1 blocks all rays from x=0.5 to x~2.5.
        for world_y in [64, 65] {
            chunk.set_voxel(
                1,
                local_y(world_y),
                0,
                Voxel {
                    id: mdminecraft_world::BLOCK_STONE,
                    ..Default::default()
                },
            );
        }

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let explosion_center = glam::Vec3::new(0.5, 64.9, 0.5);
        let player_aabb = AABB {
            min: glam::Vec3::new(2.2, 64.0, 0.2),
            max: glam::Vec3::new(2.8, 65.8, 0.8),
        };

        let blocked = GameWorld::explosion_exposure(
            &chunks,
            &block_properties,
            explosion_center,
            &player_aabb,
        );
        assert!(
            blocked < 0.01,
            "Expected near-zero exposure, got {}",
            blocked
        );

        let clear = GameWorld::explosion_exposure(
            &std::collections::HashMap::new(),
            &block_properties,
            explosion_center,
            &player_aabb,
        );
        assert!(clear > 0.99, "Expected near-full exposure, got {}", clear);
    }

    #[test]
    fn explosion_origin_is_nudged_out_of_solid_blocks() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let origin = glam::Vec3::new(1.5, 64.5, 0.5);
        assert!(
            GameWorld::projectile_point_collides_with_world(
                &chunks,
                &block_properties,
                origin.x as f64,
                origin.y as f64,
                origin.z as f64
            ),
            "Precondition: origin should start inside collision"
        );

        let incoming_velocity = glam::Vec3::new(1.0, 0.0, 0.0);
        let adjusted = GameWorld::nudge_explosion_origin_out_of_collision(
            &chunks,
            &block_properties,
            origin,
            incoming_velocity,
        );
        assert!(
            !GameWorld::projectile_point_collides_with_world(
                &chunks,
                &block_properties,
                adjusted.x as f64,
                adjusted.y as f64,
                adjusted.z as f64
            ),
            "Expected adjusted origin to be outside collision, got {:?}",
            adjusted
        );
    }

    #[test]
    fn explosion_visibility_sampling_works_when_block_impact_point_is_inside_collision() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let inside_block = glam::Vec3::new(1.5, 64.5, 0.5);
        let target_aabb = AABB {
            min: glam::Vec3::new(0.2, 64.0, 0.2),
            max: glam::Vec3::new(0.8, 65.8, 0.8),
        };

        let blocked =
            GameWorld::explosion_exposure(&chunks, &block_properties, inside_block, &target_aabb);
        assert!(
            blocked < 0.01,
            "Expected near-zero exposure from inside collision, got {}",
            blocked
        );

        let incoming_velocity = glam::Vec3::new(1.0, 0.0, 0.0);
        let nudged = GameWorld::nudge_explosion_origin_out_of_collision(
            &chunks,
            &block_properties,
            inside_block,
            incoming_velocity,
        );
        let clear = GameWorld::explosion_exposure(&chunks, &block_properties, nudged, &target_aabb);
        assert!(
            clear > 0.99,
            "Expected near-full exposure after nudging out of collision, got {}",
            clear
        );
    }

    #[test]
    fn fence_collision_bounds_expand_when_connected() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_FENCE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let corner_inside_block = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(0.2, 65.0, 0.2),
        };
        assert!(
            !GameWorld::aabb_collides_with_world(&chunks, &block_properties, &corner_inside_block),
            "Isolated fence post should not fill the block corner"
        );

        let center_of_post = AABB {
            min: glam::Vec3::new(0.45, 64.0, 0.45),
            max: glam::Vec3::new(0.55, 65.0, 0.55),
        };
        assert!(
            GameWorld::aabb_collides_with_world(&chunks, &block_properties, &center_of_post),
            "Fence post should collide in the center"
        );

        // Add a solid neighbor to the east so the fence expands in +X.
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(
                1,
                local_y(64),
                0,
                Voxel {
                    id: mdminecraft_world::BLOCK_STONE,
                    ..Default::default()
                },
            );

        let east_edge_slice = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.45),
            max: glam::Vec3::new(1.0, 65.0, 0.55),
        };
        assert!(
            GameWorld::aabb_collides_with_world(&chunks, &block_properties, &east_edge_slice),
            "Fence should expand its collision bounds toward a connected neighbor"
        );
    }

    #[test]
    fn cobblestone_wall_collision_post_is_thicker_than_fence() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::COBBLESTONE_WALL,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Fence posts start at x=0.375; walls start at x=0.3125 (6/16 thick).
        let thin_slice_inside_wall_post = AABB {
            min: glam::Vec3::new(0.33, 64.0, 0.45),
            max: glam::Vec3::new(0.34, 65.0, 0.55),
        };
        assert!(
            GameWorld::aabb_collides_with_world(
                &chunks,
                &block_properties,
                &thin_slice_inside_wall_post
            ),
            "Wall post should collide further out than the fence post thickness"
        );
    }

    #[test]
    fn stone_brick_wall_collision_post_is_thicker_than_fence() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::STONE_BRICK_WALL,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Fence posts start at x=0.375; walls start at x=0.3125 (6/16 thick).
        let thin_slice_inside_wall_post = AABB {
            min: glam::Vec3::new(0.33, 64.0, 0.45),
            max: glam::Vec3::new(0.34, 65.0, 0.55),
        };
        assert!(
            GameWorld::aabb_collides_with_world(
                &chunks,
                &block_properties,
                &thin_slice_inside_wall_post
            ),
            "Wall post should collide further out than the fence post thickness"
        );
    }

    #[test]
    fn fence_collision_does_not_fill_corners_when_connected() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_FENCE,
                ..Default::default()
            },
        );

        // Connect fence to east and south.
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(64),
            1,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let east_arm_slice = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.45),
            max: glam::Vec3::new(1.0, 65.0, 0.55),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &east_arm_slice
        ));

        let south_arm_slice = AABB {
            min: glam::Vec3::new(0.45, 64.0, 0.9),
            max: glam::Vec3::new(0.55, 65.0, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &south_arm_slice
        ));

        // Connected fence should still leave the far corner empty (no union bbox).
        let far_corner = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.9),
            max: glam::Vec3::new(1.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &far_corner
        ));
    }

    #[test]
    fn fence_gate_closed_collides_and_open_does_not() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let base = mdminecraft_world::Facing::North.to_state();
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_FENCE_GATE,
                state: base,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Closed gate: thin centered plane, should collide in the middle.
        let center_probe = AABB {
            min: glam::Vec3::new(0.45, 64.0, 0.45),
            max: glam::Vec3::new(0.55, 65.0, 0.55),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &center_probe
        ));

        // Open gate: swings "left" (simplified), so center should be passable while the hinge side
        // still collides.
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(
                0,
                local_y(64),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::OAK_FENCE_GATE,
                    state: mdminecraft_world::set_fence_gate_open(base, true),
                    ..Default::default()
                },
            );
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &center_probe
        ));

        let near_hinge_corner = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(0.1, 65.0, 0.1),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &near_hinge_corner
        ));
    }

    #[test]
    fn glass_pane_collision_is_thin() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::GLASS_PANE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let corner_inside_block = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(0.2, 65.0, 0.2),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &corner_inside_block
        ));

        let center_slice = AABB {
            min: glam::Vec3::new(0.45, 64.0, 0.45),
            max: glam::Vec3::new(0.55, 65.0, 0.55),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &center_slice
        ));
    }

    #[test]
    fn iron_bars_collision_is_thin() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::IRON_BARS,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let corner_inside_block = AABB {
            min: glam::Vec3::new(0.0, 64.0, 0.0),
            max: glam::Vec3::new(0.2, 65.0, 0.2),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &corner_inside_block
        ));

        let center_slice = AABB {
            min: glam::Vec3::new(0.45, 64.0, 0.45),
            max: glam::Vec3::new(0.55, 65.0, 0.55),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &center_slice
        ));
    }

    #[test]
    fn glass_pane_collision_connects_without_filling_corners() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::GLASS_PANE,
                ..Default::default()
            },
        );

        // Connect to east and south.
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            0,
            local_y(64),
            1,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let east_arm_slice = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.45),
            max: glam::Vec3::new(1.0, 65.0, 0.55),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &east_arm_slice
        ));

        let south_arm_slice = AABB {
            min: glam::Vec3::new(0.45, 64.0, 0.9),
            max: glam::Vec3::new(0.55, 65.0, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &south_arm_slice
        ));

        // Even with two arms, the far corner stays empty (multi-AABB, not union bbox).
        let far_corner = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.9),
            max: glam::Vec3::new(1.0, 65.0, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &far_corner
        ));
    }

    #[test]
    fn glass_pane_collision_connects_to_iron_bars() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::GLASS_PANE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::IRON_BARS,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let east_arm_slice = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.45),
            max: glam::Vec3::new(1.0, 65.0, 0.55),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &east_arm_slice
        ));
    }

    #[test]
    fn glass_pane_collision_does_not_connect_to_door() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::GLASS_PANE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
                state: mdminecraft_world::Facing::North.to_state(),
                ..Default::default()
            },
        );
        chunk.set_voxel(
            1,
            local_y(65),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER,
                state: mdminecraft_world::Facing::North.to_state(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let east_arm_slice = AABB {
            min: glam::Vec3::new(0.9, 64.0, 0.45),
            max: glam::Vec3::new(1.0, 65.0, 0.55),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &east_arm_slice
        ));
    }

    #[test]
    fn walking_steps_up_onto_bottom_slab() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        // Solid floor at y=0.
        for x in 0..3 {
            chunk.set_voxel(
                x,
                local_y(0),
                0,
                Voxel {
                    id: mdminecraft_world::BLOCK_STONE,
                    ..Default::default()
                },
            );
        }

        // A bottom slab one block ahead (requires a 0.5-block step).
        chunk.set_voxel(
            1,
            local_y(1),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::STONE_SLAB,
                state: 0,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let start_feet_y = 1.0;
        let current_aabb = AABB::from_center_size(
            glam::Vec3::new(0.5, start_feet_y + 0.9, 0.5),
            glam::Vec3::new(0.6, 1.8, 0.6),
        );

        let move_right = glam::Vec3::new(0.6, 0.0, 0.0);

        let (no_step_offset, _) = GameWorld::move_with_collision(
            &chunks,
            &block_properties,
            &current_aabb,
            move_right,
            0.0,
        );
        assert!(
            no_step_offset.x.abs() < 1e-6,
            "Without step-up, the slab should block horizontal movement"
        );

        let (step_offset, _) = GameWorld::move_with_collision(
            &chunks,
            &block_properties,
            &current_aabb,
            move_right,
            PlayerPhysics::STEP_HEIGHT,
        );
        assert!(
            step_offset.x > 0.5,
            "Step-up should allow moving onto the slab"
        );
        assert!(
            (step_offset.y - 0.5).abs() < 1e-6,
            "Stepping onto a bottom slab should raise feet by 0.5 (got {})",
            step_offset.y
        );
    }

    #[test]
    fn walking_steps_up_onto_stairs() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        // Solid floor at y=0.
        for x in 0..3 {
            chunk.set_voxel(
                x,
                local_y(0),
                0,
                Voxel {
                    id: mdminecraft_world::BLOCK_STONE,
                    ..Default::default()
                },
            );
        }

        // Stairs one block ahead. Collision is simplified to a 0.5-block step.
        chunk.set_voxel(
            1,
            local_y(1),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_STAIRS,
                state: mdminecraft_world::Facing::East.to_state(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let start_feet_y = 1.0;
        let current_aabb = AABB::from_center_size(
            glam::Vec3::new(0.5, start_feet_y + 0.9, 0.5),
            glam::Vec3::new(0.6, 1.8, 0.6),
        );

        let move_right = glam::Vec3::new(0.6, 0.0, 0.0);

        let (step_offset, _) = GameWorld::move_with_collision(
            &chunks,
            &block_properties,
            &current_aabb,
            move_right,
            PlayerPhysics::STEP_HEIGHT,
        );
        assert!(
            step_offset.x > 0.5,
            "Step-up should allow moving onto the stairs"
        );
        assert!(
            (step_offset.y - 0.5).abs() < 1e-6,
            "Stepping onto stairs should raise feet by 0.5 (got {})",
            step_offset.y
        );
    }

    #[test]
    fn top_stairs_collision_is_inverted() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_STAIRS,
                state: mdminecraft_world::Facing::East.to_state() | 0x04,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        // Upper half is a full block for upside-down stairs.
        let upper_inside = AABB {
            min: glam::Vec3::new(0.1, 64.6, 0.1),
            max: glam::Vec3::new(0.9, 64.9, 0.9),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &upper_inside
        ));

        // Lower half only occupies the facing half-footprint (east side).
        let lower_west_clear = AABB {
            min: glam::Vec3::new(0.0, 64.1, 0.0),
            max: glam::Vec3::new(0.4, 64.4, 1.0),
        };
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &lower_west_clear
        ));

        let lower_east_solid = AABB {
            min: glam::Vec3::new(0.6, 64.1, 0.0),
            max: glam::Vec3::new(0.9, 64.4, 1.0),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &lower_east_solid
        ));
    }

    #[test]
    fn stairs_inner_corner_adds_quarter_to_step_collision() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_STAIRS,
                state: mdminecraft_world::Facing::South.to_state(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let extra_quarter_in_northeast = AABB {
            min: glam::Vec3::new(1.6, 64.6, 1.1),
            max: glam::Vec3::new(1.9, 64.9, 1.4),
        };
        assert!(
            !GameWorld::aabb_collides_with_world(
                &chunks,
                &block_properties,
                &extra_quarter_in_northeast
            ),
            "Straight south-facing stair should not occupy the NE quarter of its upper step"
        );

        // Back stair facing east creates an inner-left corner on the south-facing stair.
        chunks
            .get_mut(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .set_voxel(
                1,
                local_y(64),
                0,
                Voxel {
                    id: mdminecraft_world::interactive_blocks::OAK_STAIRS,
                    state: mdminecraft_world::Facing::East.to_state(),
                    ..Default::default()
                },
            );

        assert!(
            GameWorld::aabb_collides_with_world(
                &chunks,
                &block_properties,
                &extra_quarter_in_northeast
            ),
            "Inner corner stair should add collision for the extra quarter of the upper step"
        );
    }

    #[test]
    fn stairs_outer_corner_removes_quarter_from_step_collision() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_STAIRS,
                state: mdminecraft_world::Facing::South.to_state(),
                ..Default::default()
            },
        );

        // Front stair facing east creates an outer-left corner on the south-facing stair.
        chunk.set_voxel(
            1,
            local_y(64),
            2,
            Voxel {
                id: mdminecraft_world::interactive_blocks::OAK_STAIRS,
                state: mdminecraft_world::Facing::East.to_state(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let removed_quarter_in_southwest = AABB {
            min: glam::Vec3::new(1.1, 64.6, 1.6),
            max: glam::Vec3::new(1.4, 64.9, 1.9),
        };
        assert!(
            !GameWorld::aabb_collides_with_world(
                &chunks,
                &block_properties,
                &removed_quarter_in_southwest
            ),
            "Outer corner stair should remove collision from the SW quarter of the upper step"
        );

        let remaining_quarter_in_southeast = AABB {
            min: glam::Vec3::new(1.6, 64.6, 1.6),
            max: glam::Vec3::new(1.9, 64.9, 1.9),
        };
        assert!(GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &remaining_quarter_in_southeast
        ));
    }

    #[test]
    fn ladder_is_detected_without_blocking_movement() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            0,
            local_y(1),
            0,
            Voxel {
                id: mdminecraft_world::interactive_blocks::LADDER,
                state: 0,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let block_properties = BlockPropertiesRegistry::new();

        let player_aabb = AABB::from_center_size(
            glam::Vec3::new(0.5, 1.0 + 0.9, 0.5),
            glam::Vec3::new(0.6, 1.8, 0.6),
        );

        assert!(GameWorld::aabb_touches_ladder(&chunks, &player_aabb));
        assert!(!GameWorld::aabb_collides_with_world(
            &chunks,
            &block_properties,
            &player_aabb
        ));
    }

    #[test]
    fn ladder_placement_state_is_opposite_face_normal() {
        let state = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::LADDER,
            0.0,
            glam::IVec3::new(-1, 0, 0),
            0.0,
        )
        .expect("ladder state should be set when placed on a wall");
        assert_eq!(state, mdminecraft_world::Facing::East.to_state());

        let state = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::LADDER,
            0.0,
            glam::IVec3::new(0, 0, 1),
            0.0,
        )
        .expect("ladder state should be set when placed on a wall");
        assert_eq!(state, mdminecraft_world::Facing::North.to_state());

        assert!(GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::LADDER,
            0.0,
            glam::IVec3::new(0, 1, 0),
            0.0,
        )
        .is_none());
    }

    #[test]
    fn torch_placement_state_allows_wall_mounts() {
        let floor = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::TORCH,
            0.0,
            glam::IVec3::new(0, 1, 0),
            0.0,
        )
        .expect("torch placement should produce a state on top faces");
        assert!(!mdminecraft_world::is_torch_wall(floor));

        let wall = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::TORCH,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.0,
        )
        .expect("torch placement should produce a state on side faces");
        assert!(mdminecraft_world::is_torch_wall(wall));
        assert_eq!(
            mdminecraft_world::torch_facing(wall),
            mdminecraft_world::Facing::East
        );

        assert!(GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::TORCH,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.0,
        )
        .is_none());
    }

    #[test]
    fn button_placement_state_allows_wall_and_ceiling_mounts() {
        let floor = GameWorld::placement_state_for_block(
            mdminecraft_world::redstone_blocks::STONE_BUTTON,
            0.0,
            glam::IVec3::new(0, 1, 0),
            0.0,
        )
        .expect("button placement should produce a state on top faces");
        assert!(!mdminecraft_world::is_wall_mounted(floor));
        assert!(!mdminecraft_world::is_ceiling_mounted(floor));

        let wall = GameWorld::placement_state_for_block(
            mdminecraft_world::redstone_blocks::STONE_BUTTON,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.0,
        )
        .expect("button placement should produce a state on side faces");
        assert!(mdminecraft_world::is_wall_mounted(wall));
        assert_eq!(
            mdminecraft_world::wall_mounted_facing(wall),
            mdminecraft_world::Facing::East
        );
        assert!(!mdminecraft_world::is_ceiling_mounted(wall));

        let ceiling = GameWorld::placement_state_for_block(
            mdminecraft_world::redstone_blocks::STONE_BUTTON,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.0,
        )
        .expect("button placement should produce a state on bottom faces");
        assert!(!mdminecraft_world::is_wall_mounted(ceiling));
        assert!(mdminecraft_world::is_ceiling_mounted(ceiling));
    }

    #[test]
    fn hopper_placement_state_outputs_down_on_top_bottom_faces_and_opposite_on_side_faces() {
        let top = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::HOPPER,
            0.0,
            glam::IVec3::new(0, 1, 0),
            0.0,
        )
        .expect("hopper placement should produce a state on top faces");
        assert!(mdminecraft_world::hopper_outputs_down(top));

        let east_side = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::HOPPER,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.0,
        )
        .expect("hopper placement should produce a state on side faces");
        assert!(!mdminecraft_world::hopper_outputs_down(east_side));
        assert_eq!(
            mdminecraft_world::hopper_facing(east_side),
            mdminecraft_world::Facing::West
        );

        let bottom = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::HOPPER,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.0,
        )
        .expect("hopper placement should produce a state on bottom faces");
        assert!(mdminecraft_world::hopper_outputs_down(bottom));
    }

    #[test]
    fn piston_placement_state_is_opposite_on_side_faces_and_rejects_bottom() {
        let top = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::PISTON,
            0.0,
            glam::IVec3::new(0, 1, 0),
            0.0,
        )
        .expect("piston placement should produce a state on top faces");
        assert_eq!(
            mdminecraft_world::piston_facing(top),
            mdminecraft_world::Facing::South
        );

        let east_side = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::PISTON,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.0,
        )
        .expect("piston placement should produce a state on side faces");
        assert_eq!(
            mdminecraft_world::piston_facing(east_side),
            mdminecraft_world::Facing::West
        );

        assert!(GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::PISTON,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.0,
        )
        .is_none());
    }

    #[test]
    fn dispenser_and_dropper_placement_state_is_opposite_on_side_faces_and_rejects_bottom() {
        let top = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::DISPENSER,
            0.0,
            glam::IVec3::new(0, 1, 0),
            0.0,
        )
        .expect("dispenser placement should produce a state on top faces");
        assert_eq!(
            mdminecraft_world::dispenser_facing(top),
            mdminecraft_world::Facing::South
        );

        let north_side = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::DISPENSER,
            0.0,
            glam::IVec3::new(0, 0, -1),
            0.0,
        )
        .expect("dispenser placement should produce a state on side faces");
        assert_eq!(
            mdminecraft_world::dispenser_facing(north_side),
            mdminecraft_world::Facing::South
        );

        assert!(GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::DISPENSER,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.0,
        )
        .is_none());

        let dropper_north_side = GameWorld::placement_state_for_block(
            mdminecraft_world::mechanical_blocks::DROPPER,
            0.0,
            glam::IVec3::new(0, 0, -1),
            0.0,
        )
        .expect("dropper placement should produce a state on side faces");
        assert_eq!(
            mdminecraft_world::dropper_facing(dropper_north_side),
            mdminecraft_world::Facing::South
        );
    }

    #[test]
    fn dispenser_dispenses_arrows_as_projectiles() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(1, 64, 1);
        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::East);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(2), 1));
        dispensers.insert(key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );
        assert!(
            changed.is_empty(),
            "Arrow dispense should not change world voxels, changed={changed:?}"
        );

        assert_eq!(projectiles.count(), 1);
        assert_eq!(item_manager.count(), 0);

        let dispenser = dispensers.get(&key).expect("dispenser state should remain");
        assert_eq!(dispenser.cooldown_ticks, 4);
        assert!(dispenser.slots.iter().all(|slot| slot.is_none()));
    }

    #[test]
    fn dispenser_inserts_into_chests_before_dispensing_projectiles() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let dispenser_pos = glam::IVec3::new(1, 64, 1);
        let chest_pos = glam::IVec3::new(2, 64, 1);

        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::East);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            dispenser_pos.x as usize,
            local_y(dispenser_pos.y),
            dispenser_pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            chest_pos.x as usize,
            local_y(chest_pos.y),
            chest_pos.z as usize,
            Voxel {
                id: mdminecraft_world::interactive_blocks::CHEST,
                ..Default::default()
            },
        );

        chunks.insert(ChunkPos::new(0, 0), chunk);

        let dispenser_key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: dispenser_pos.x,
            y: dispenser_pos.y,
            z: dispenser_pos.z,
        };
        let chest_key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: chest_pos.x,
            y: chest_pos.y,
            z: chest_pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(2), 1));
        dispensers.insert(dispenser_key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(
            changed.is_empty(),
            "Container insertion should not report voxel changes, changed={changed:?}"
        );
        assert_eq!(projectiles.count(), 0);
        assert_eq!(item_manager.count(), 0);

        let chest = chests
            .get(&chest_key)
            .expect("chest state should be created");
        assert_eq!(
            chest.slots[0],
            Some(ItemStack::new(ItemType::Item(2), 1)),
            "Expected arrow inserted into first chest slot"
        );

        let dispenser = dispensers
            .get(&dispenser_key)
            .expect("dispenser state should remain");
        assert_eq!(dispenser.cooldown_ticks, 4);
        assert!(dispenser.slots.iter().all(|slot| slot.is_none()));
    }

    #[test]
    fn dispenser_fills_glass_bottles_from_water() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let dispenser_pos = glam::IVec3::new(1, 64, 1);
        let water_pos = glam::IVec3::new(2, 64, 1);

        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::East);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            dispenser_pos.x as usize,
            local_y(dispenser_pos.y),
            dispenser_pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            water_pos.x as usize,
            local_y(water_pos.y),
            water_pos.z as usize,
            Voxel {
                id: mdminecraft_world::BLOCK_WATER,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let dispenser_key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: dispenser_pos.x,
            y: dispenser_pos.y,
            z: dispenser_pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLASS_BOTTLE), 1));
        dispensers.insert(dispenser_key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(
            changed.is_empty(),
            "Bottle filling should not report voxel changes, changed={changed:?}"
        );
        assert_eq!(projectiles.count(), 0);
        assert_eq!(item_manager.count(), 0);

        let dispenser = dispensers
            .get(&dispenser_key)
            .expect("dispenser state should remain");
        assert_eq!(dispenser.cooldown_ticks, 4);
        assert_eq!(
            dispenser.slots[0],
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1))
        );

        let water = chunks
            .get(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .voxel(
                water_pos.x as usize,
                local_y(water_pos.y),
                water_pos.z as usize,
            );
        assert_eq!(
            water.id,
            mdminecraft_world::BLOCK_WATER,
            "Dispenser bottle fill should not drain water"
        );
    }

    #[test]
    fn dispenser_uses_bone_meal_on_crops_in_front() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let dispenser_pos = glam::IVec3::new(1, 64, 1);
        let crop_pos = glam::IVec3::new(2, 64, 1);

        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::East);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            dispenser_pos.x as usize,
            local_y(dispenser_pos.y),
            dispenser_pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );

        let crop_type = mdminecraft_world::CropType::Wheat;
        let initial_stage: u8 = 0;
        chunk.set_voxel(
            crop_pos.x as usize,
            local_y(crop_pos.y),
            crop_pos.z as usize,
            Voxel {
                id: crop_type.block_id_at_stage(initial_stage),
                state: 0,
                ..Default::default()
            },
        );

        chunks.insert(ChunkPos::new(0, 0), chunk);

        let dispenser_key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: dispenser_pos.x,
            y: dispenser_pos.y,
            z: dispenser_pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        // Item(18) = Bone Meal.
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(18), 1));
        dispensers.insert(dispenser_key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();

        let world_seed = 0;
        let sim_tick = mdminecraft_core::SimTick::ZERO;
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(world_seed);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            world_seed,
            sim_tick,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(changed.contains(&crop_pos));
        assert_eq!(projectiles.count(), 0);
        assert_eq!(
            item_manager.count(),
            0,
            "Bone meal use should not drop items"
        );

        let delta = GameWorld::bone_meal_crop_growth_delta(
            world_seed,
            sim_tick.0,
            crop_pos.x,
            crop_pos.y,
            crop_pos.z,
            initial_stage,
        );
        let expected_stage = initial_stage
            .saturating_add(delta)
            .min(crop_type.max_stage());
        let expected_id = crop_type.block_id_at_stage(expected_stage);

        let crop = chunks
            .get(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .voxel(
                crop_pos.x as usize,
                local_y(crop_pos.y),
                crop_pos.z as usize,
            );
        assert_eq!(crop.id, expected_id);

        let dispenser = dispensers
            .get(&dispenser_key)
            .expect("dispenser state should remain");
        assert_eq!(dispenser.cooldown_ticks, 4);
        assert!(dispenser.slots.iter().all(|slot| slot.is_none()));
    }

    #[test]
    fn dispenser_throws_splash_potions_as_projectiles() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(2, 64, 2);
        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state =
            mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::North);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(
            ItemType::SplashPotion(potion_ids::AWKWARD),
            1,
        ));
        dispensers.insert(key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );
        assert!(changed.is_empty());
        assert_eq!(projectiles.count(), 1);
        assert_eq!(item_manager.count(), 0);
        assert!(
            matches!(
                projectiles.projectiles[0].projectile_type,
                mdminecraft_world::ProjectileType::SplashPotion(potion_ids::AWKWARD)
            ),
            "Expected a splash potion projectile, got: {:?}",
            projectiles.projectiles[0].projectile_type
        );
    }

    #[test]
    fn dispenser_throws_eggs_as_projectiles() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(2, 64, 2);
        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state =
            mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::North);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(104), 1));
        dispensers.insert(key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();

        let world_seed = 123;
        let mut tick = 0_u64;
        let (sim_tick, expected_hatch_count) = loop {
            let hatch_count = GameWorld::egg_hatch_count(world_seed, tick, 0, pos.x, pos.z);
            if hatch_count > 0 {
                break (mdminecraft_core::SimTick(tick), hatch_count);
            }
            tick += 1;
            assert!(tick < 10_000, "Failed to find a non-zero hatch count");
        };

        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(world_seed);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            world_seed,
            sim_tick,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(changed.is_empty());
        assert_eq!(projectiles.count(), 1);
        assert_eq!(item_manager.count(), 0);

        assert_eq!(
            projectiles.projectiles[0].projectile_type,
            mdminecraft_world::ProjectileType::Egg
        );
        assert_eq!(
            projectiles.projectiles[0].egg_hatch_count,
            expected_hatch_count
        );
        assert!(!projectiles.projectiles[0].can_pick_up);
    }

    #[test]
    fn dispenser_throws_ender_pearls_as_projectiles_without_owner() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(1, 64, 1);
        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state =
            mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::North);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_ENDER_PEARL), 1));
        dispensers.insert(key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(changed.is_empty());
        assert_eq!(projectiles.count(), 1);
        assert_eq!(item_manager.count(), 0);

        assert_eq!(
            projectiles.projectiles[0].projectile_type,
            mdminecraft_world::ProjectileType::EnderPearl
        );
        assert_eq!(
            projectiles.projectiles[0].owner,
            mdminecraft_world::ProjectileOwner::None
        );
        assert!(!projectiles.projectiles[0].can_pick_up);
    }

    #[test]
    fn dispenser_inserts_eye_of_ender_into_end_portal_frames() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(1, 64, 1);
        let frame_pos = glam::IVec3::new(2, 64, 1);

        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::East);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            frame_pos.x as usize,
            local_y(frame_pos.y),
            frame_pos.z as usize,
            Voxel {
                id: BLOCK_END_PORTAL_FRAME,
                state: 0,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_EYE_OF_ENDER), 1));
        dispensers.insert(key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(changed.contains(&frame_pos));
        assert_eq!(projectiles.count(), 0);
        assert_eq!(item_manager.count(), 0);

        let frame = chunks
            .get(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .voxel(
                frame_pos.x as usize,
                local_y(frame_pos.y),
                frame_pos.z as usize,
            );
        assert_eq!(frame.id, BLOCK_END_PORTAL_FRAME);
        assert_ne!(frame.state & 0x01, 0, "Expected inserted eye bit");

        let dispenser = dispensers.get(&key).expect("dispenser exists");
        assert!(dispenser.slots[0].is_none(), "Eye should be consumed");
    }

    #[test]
    fn dispenser_uses_flint_and_steel_to_place_fire() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(1, 64, 1);
        let ignite_pos = glam::IVec3::new(2, 64, 1);
        let support_pos = glam::IVec3::new(2, 63, 1);

        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dispenser_facing(0, mdminecraft_world::Facing::East);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            support_pos.x as usize,
            local_y(support_pos.y),
            support_pos.z as usize,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut dispensers = BTreeMap::new();
        let mut dispenser = DispenserState::default();
        dispenser.slots[0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_FLINT_AND_STEEL), 1));
        dispensers.insert(key, dispenser);

        let mut droppers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert_eq!(projectiles.count(), 0);
        assert_eq!(item_manager.count(), 0);
        assert!(changed.contains(&ignite_pos));

        let fire_voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .expect("chunk exists")
            .voxel(
                ignite_pos.x as usize,
                local_y(ignite_pos.y),
                ignite_pos.z as usize,
            );
        assert_eq!(fire_voxel.id, mdminecraft_world::BLOCK_FIRE);

        let dispenser = dispensers.get(&key).expect("dispenser state remains");
        assert_eq!(dispenser.cooldown_ticks, 4);
        let flint = dispenser.slots[0].as_ref().expect("flint remains");
        assert_eq!(flint.item_type, ItemType::Item(CORE_ITEM_FLINT_AND_STEEL));
        assert_eq!(flint.durability, Some(63));
    }

    #[test]
    fn dropper_inserts_into_chests_before_dropping_items() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let dropper_pos = glam::IVec3::new(3, 64, 3);
        let chest_pos = glam::IVec3::new(2, 64, 3);

        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dropper_facing(0, mdminecraft_world::Facing::West);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            dropper_pos.x as usize,
            local_y(dropper_pos.y),
            dropper_pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DROPPER,
                state,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            chest_pos.x as usize,
            local_y(chest_pos.y),
            chest_pos.z as usize,
            Voxel {
                id: mdminecraft_world::interactive_blocks::CHEST,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let dropper_key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: dropper_pos.x,
            y: dropper_pos.y,
            z: dropper_pos.z,
        };
        let chest_key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: chest_pos.x,
            y: chest_pos.y,
            z: chest_pos.z,
        };

        let mut droppers = BTreeMap::new();
        let mut dropper = DispenserState::default();
        dropper.slots[0] = Some(ItemStack::new(ItemType::Item(2), 1));
        droppers.insert(dropper_key, dropper);

        let mut dispensers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        assert!(
            changed.is_empty(),
            "Container insertion should not report voxel changes, changed={changed:?}"
        );
        assert_eq!(projectiles.count(), 0);
        assert_eq!(item_manager.count(), 0);

        let chest = chests
            .get(&chest_key)
            .expect("chest state should be created");
        assert_eq!(
            chest.slots[0],
            Some(ItemStack::new(ItemType::Item(2), 1)),
            "Expected arrow inserted into first chest slot"
        );

        let dropper = droppers
            .get(&dropper_key)
            .expect("dropper state should remain");
        assert_eq!(dropper.cooldown_ticks, 4);
        assert!(dropper.slots.iter().all(|slot| slot.is_none()));
    }

    #[test]
    fn dropper_still_drops_arrows_as_items() {
        use mdminecraft_core::DimensionId;
        use std::collections::{BTreeMap, HashMap};

        let pos = glam::IVec3::new(3, 64, 3);
        let mut chunks = HashMap::new();
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        let mut state = mdminecraft_world::set_dropper_facing(0, mdminecraft_world::Facing::West);
        state = mdminecraft_world::set_active(state, true);

        chunk.set_voxel(
            pos.x as usize,
            local_y(pos.y),
            pos.z as usize,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DROPPER,
                state,
                ..Default::default()
            },
        );
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: pos.x,
            y: pos.y,
            z: pos.z,
        };

        let mut droppers = BTreeMap::new();
        let mut dropper = DispenserState::default();
        dropper.slots[0] = Some(ItemStack::new(ItemType::Item(2), 1));
        droppers.insert(key, dropper);

        let mut dispensers = BTreeMap::new();
        let mut chests = BTreeMap::new();
        let mut hoppers = BTreeMap::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut item_manager = mdminecraft_world::ItemManager::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);

        let changed = GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );
        assert!(changed.is_empty());
        assert_eq!(projectiles.count(), 0);
        assert_eq!(item_manager.count(), 1);
    }

    #[test]
    fn slab_placement_state_uses_hit_height_for_top_bottom() {
        let bottom = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::STONE_SLAB,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.25,
        )
        .expect("slab placement should always produce a state");
        assert_eq!(bottom, mdminecraft_world::SlabPosition::Bottom.to_state(0));

        let top = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::STONE_SLAB,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.75,
        )
        .expect("slab placement should always produce a state");
        assert_eq!(top, mdminecraft_world::SlabPosition::Top.to_state(0));

        // Placing against the bottom face forces a top slab.
        let forced_top = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::STONE_SLAB,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.25,
        )
        .expect("slab placement should always produce a state");
        assert_eq!(forced_top, mdminecraft_world::SlabPosition::Top.to_state(0));
    }

    #[test]
    fn double_slab_mapping_is_defined_for_supported_slabs() {
        assert_eq!(
            GameWorld::double_slab_block_id(mdminecraft_world::interactive_blocks::STONE_SLAB),
            Some(mdminecraft_world::BLOCK_DOUBLE_STONE_SLAB)
        );
        assert_eq!(
            GameWorld::double_slab_block_id(mdminecraft_world::interactive_blocks::OAK_SLAB),
            Some(mdminecraft_world::BLOCK_DOUBLE_OAK_SLAB)
        );
        assert_eq!(
            GameWorld::double_slab_block_id(
                mdminecraft_world::interactive_blocks::STONE_BRICK_SLAB
            ),
            Some(mdminecraft_world::BLOCK_DOUBLE_STONE_BRICK_SLAB)
        );
    }

    #[test]
    fn slab_merge_rules_match_vanillaish_expectations() {
        let bottom = mdminecraft_world::SlabPosition::Bottom.to_state(0);
        let top = mdminecraft_world::SlabPosition::Top.to_state(0);

        // Clicking the top face merges only with a bottom slab.
        assert!(GameWorld::should_merge_slab(
            bottom,
            glam::IVec3::new(0, 1, 0),
            0.0
        ));
        assert!(!GameWorld::should_merge_slab(
            top,
            glam::IVec3::new(0, 1, 0),
            0.0
        ));

        // Clicking the bottom face merges only with a top slab.
        assert!(GameWorld::should_merge_slab(
            top,
            glam::IVec3::new(0, -1, 0),
            0.0
        ));
        assert!(!GameWorld::should_merge_slab(
            bottom,
            glam::IVec3::new(0, -1, 0),
            0.0
        ));

        // Side clicks merge when targeting the missing half.
        assert!(GameWorld::should_merge_slab(
            bottom,
            glam::IVec3::new(1, 0, 0),
            0.75
        ));
        assert!(!GameWorld::should_merge_slab(
            bottom,
            glam::IVec3::new(1, 0, 0),
            0.25
        ));
        assert!(GameWorld::should_merge_slab(
            top,
            glam::IVec3::new(1, 0, 0),
            0.25
        ));
        assert!(!GameWorld::should_merge_slab(
            top,
            glam::IVec3::new(1, 0, 0),
            0.75
        ));
    }

    #[test]
    fn trapdoor_placement_state_sets_top_bit_from_hit_height() {
        let bottom = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::TRAPDOOR,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.25,
        )
        .expect("trapdoor placement should always produce a state");
        assert!(!mdminecraft_world::is_trapdoor_open(bottom));
        assert!(!mdminecraft_world::is_trapdoor_top(bottom));

        let top = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::TRAPDOOR,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.75,
        )
        .expect("trapdoor placement should always produce a state");
        assert!(!mdminecraft_world::is_trapdoor_open(top));
        assert!(mdminecraft_world::is_trapdoor_top(top));

        // Placing against the bottom face forces a top trapdoor.
        let forced_top = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::TRAPDOOR,
            0.0,
            glam::IVec3::new(0, -1, 0),
            0.25,
        )
        .expect("trapdoor placement should always produce a state");
        assert!(mdminecraft_world::is_trapdoor_top(forced_top));
    }

    #[test]
    fn stairs_placement_state_sets_top_bit_from_hit_height() {
        let bottom = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::OAK_STAIRS,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.25,
        )
        .expect("stairs placement should always produce a state");
        assert_eq!(bottom & 0x04, 0);

        let top = GameWorld::placement_state_for_block(
            mdminecraft_world::interactive_blocks::OAK_STAIRS,
            0.0,
            glam::IVec3::new(1, 0, 0),
            0.75,
        )
        .expect("stairs placement should always produce a state");
        assert_ne!(top & 0x04, 0);
    }

    #[test]
    fn door_placement_places_upper_and_lower() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        let state = mdminecraft_world::Facing::West.to_state();
        assert!(GameWorld::try_place_door(
            &mut chunk,
            1,
            64,
            1,
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
            state,
        ));

        let lower = chunk.voxel(1, 64, 1);
        assert_eq!(
            lower.id,
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER
        );
        assert_eq!(lower.state, state);

        let upper = chunk.voxel(1, 65, 1);
        assert_eq!(
            upper.id,
            mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER
        );
        assert_eq!(upper.state, state);
    }

    #[test]
    fn door_placement_fails_when_upper_is_occupied() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            65,
            1,
            Voxel {
                id: mdminecraft_world::BLOCK_STONE,
                ..Default::default()
            },
        );

        assert!(!GameWorld::try_place_door(
            &mut chunk,
            1,
            64,
            1,
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
            mdminecraft_world::Facing::North.to_state(),
        ));
        assert_eq!(chunk.voxel(1, 64, 1).id, mdminecraft_world::BLOCK_AIR);
    }

    #[test]
    fn door_break_removes_the_other_half() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        let state = mdminecraft_world::Facing::North.to_state();
        assert!(GameWorld::try_place_door(
            &mut chunk,
            1,
            64,
            1,
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
            state,
        ));

        // Break the lower half.
        chunk.set_voxel(1, 64, 1, Voxel::default());
        assert_eq!(
            chunk.voxel(1, 65, 1).id,
            mdminecraft_world::interactive_blocks::OAK_DOOR_UPPER
        );

        let removed = GameWorld::try_remove_other_door_half(
            &mut chunk,
            1,
            64,
            1,
            mdminecraft_world::interactive_blocks::OAK_DOOR_LOWER,
        );
        assert_eq!(removed, Some(65));
        assert_eq!(chunk.voxel(1, 65, 1).id, mdminecraft_world::BLOCK_AIR);
    }

    #[test]
    fn stage3_first_night_scenario_survives_save_load() {
        let mut hotbar = Hotbar {
            slots: std::array::from_fn(|_| None),
            selected: 0,
        };
        let mut main_inventory = MainInventory::new();
        let blocks = super::test_blocks();
        let recipes = get_crafting_recipes();
        let planks_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(BLOCK_OAK_PLANKS))
            .expect("planks recipe exists");
        let crafting_table_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(BLOCK_CRAFTING_TABLE))
            .expect("crafting table recipe exists");
        let sticks_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Item(3))
            .expect("sticks recipe exists");
        let torches_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(interactive_blocks::TORCH))
            .expect("torches recipe exists");

        // "Gather": give the player a couple logs + some coal.
        assert!(add_stack_to_storage(
            &mut hotbar,
            &mut main_inventory,
            ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 2),
        )
        .is_none());
        assert!(add_stack_to_storage(
            &mut hotbar,
            &mut main_inventory,
            ItemStack::new(ItemType::Item(8), 1), // coal
        )
        .is_none());

        // Craft: 2 logs -> 8 planks.
        for _ in 0..2 {
            let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
            assert!(try_autofill_crafting_grid(
                &mut grid,
                &mut hotbar,
                &mut main_inventory,
                planks_recipe,
                blocks,
            ));
            let recipe = match_crafting_recipe(&grid, CraftingGridSize::TwoByTwo, blocks)
                .expect("planks recipe matches");
            assert_eq!(recipe.output, ItemType::Block(BLOCK_OAK_PLANKS));
            assert!(consume_crafting_inputs_3x3(&mut grid, &recipe, blocks));
            assert!(add_stack_to_storage(
                &mut hotbar,
                &mut main_inventory,
                ItemStack::new(recipe.output, recipe.output_count),
            )
            .is_none());
        }

        // Craft: 4 planks -> crafting table.
        {
            let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
            assert!(try_autofill_crafting_grid(
                &mut grid,
                &mut hotbar,
                &mut main_inventory,
                crafting_table_recipe,
                blocks,
            ));
            let recipe = match_crafting_recipe(&grid, CraftingGridSize::TwoByTwo, blocks)
                .expect("table recipe matches");
            assert_eq!(recipe.output, ItemType::Block(BLOCK_CRAFTING_TABLE));
            assert!(consume_crafting_inputs_3x3(&mut grid, &recipe, blocks));
            assert!(add_stack_to_storage(
                &mut hotbar,
                &mut main_inventory,
                ItemStack::new(recipe.output, recipe.output_count),
            )
            .is_none());
        }

        // Craft: 2 planks -> 4 sticks.
        {
            let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
            assert!(try_autofill_crafting_grid(
                &mut grid,
                &mut hotbar,
                &mut main_inventory,
                sticks_recipe,
                blocks,
            ));
            let recipe = match_crafting_recipe(&grid, CraftingGridSize::TwoByTwo, blocks)
                .expect("sticks recipe matches");
            assert_eq!(recipe.output, ItemType::Item(3));
            assert!(consume_crafting_inputs_3x3(&mut grid, &recipe, blocks));
            assert!(add_stack_to_storage(
                &mut hotbar,
                &mut main_inventory,
                ItemStack::new(recipe.output, recipe.output_count),
            )
            .is_none());
        }

        // Craft: 1 coal + 1 stick -> 4 torches.
        {
            let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
            assert!(try_autofill_crafting_grid(
                &mut grid,
                &mut hotbar,
                &mut main_inventory,
                torches_recipe,
                blocks,
            ));
            let recipe = match_crafting_recipe(&grid, CraftingGridSize::TwoByTwo, blocks)
                .expect("torch recipe matches");
            assert_eq!(recipe.output, ItemType::Block(interactive_blocks::TORCH));
            assert!(consume_crafting_inputs_3x3(&mut grid, &recipe, blocks));
            assert!(add_stack_to_storage(
                &mut hotbar,
                &mut main_inventory,
                ItemStack::new(recipe.output, recipe.output_count),
            )
            .is_none());
        }

        // Survival tick: moving drains hunger.
        let mut health = PlayerHealth::new();
        health.set_active(true);
        for _ in 0..610 {
            health.update(0.05);
        }
        assert!(health.hunger < 20.0);

        // Sleep: bed sets spawn point.
        let mut bed = mdminecraft_world::BedSystem::new();
        assert_eq!(
            bed.try_sleep((10, 64, 10), true, false),
            mdminecraft_world::SleepResult::Success
        );
        let spawn = bed.spawn_point().expect("spawn point set");

        // Save world state (including player) and reload it.
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos();
        let dir = std::env::temp_dir().join(format!("mdminecraft_stage3_first_night_{timestamp}"));
        let store = mdminecraft_world::RegionStore::new(&dir).expect("region store");

        let player_save = mdminecraft_world::PlayerSave {
            transform: mdminecraft_world::PlayerTransform {
                dimension: mdminecraft_core::DimensionId::DEFAULT,
                x: 0.0,
                y: 65.0,
                z: 0.0,
                yaw: 0.0,
                pitch: 0.0,
            },
            spawn_point: mdminecraft_world::WorldPoint {
                dimension: mdminecraft_core::DimensionId::DEFAULT,
                x: spawn.0 as f64,
                y: spawn.1 as f64,
                z: spawn.2 as f64,
            },
            hotbar: hotbar.slots.clone(),
            hotbar_selected: hotbar.selected,
            inventory: GameWorld::persisted_inventory_from_main_inventory(&main_inventory),
            health: health.current,
            hunger: health.hunger,
            xp_level: 0,
            xp_current: 0,
            xp_next_level_xp: 0,
            armor: mdminecraft_world::PlayerArmor::default(),
            status_effects: mdminecraft_world::StatusEffects::new(),
        };

        let state = mdminecraft_world::WorldState {
            tick: mdminecraft_core::SimTick::ZERO,
            sim_time: mdminecraft_world::SimTime::default(),
            weather: mdminecraft_world::WeatherToggle::default(),
            weather_next_change_tick: mdminecraft_core::SimTick::ZERO,
            player: Some(player_save.clone()),
            entities: mdminecraft_world::WorldEntitiesState::default(),
            block_entities: mdminecraft_world::BlockEntitiesState::default(),
        };
        store.save_world_state(&state).expect("save world state");
        let loaded = store.load_world_state().expect("load world state");
        let loaded_player = loaded.player.expect("player loaded");

        // Ensure core survival + inventory state survives save/load.
        assert_eq!(loaded_player.spawn_point, player_save.spawn_point);
        assert_eq!(loaded_player.hotbar, player_save.hotbar);

        let loaded_main =
            GameWorld::main_inventory_from_persisted_inventory(loaded_player.inventory.clone());
        assert_eq!(loaded_main.slots, main_inventory.slots);

        assert!((loaded_player.health - health.current).abs() < 1e-6);
        assert!((loaded_player.hunger - health.hunger).abs() < 1e-6);
    }

    #[test]
    fn mining_completion_is_fps_independent() {
        let required = 1.2_f32; // seconds
        let frames_60hz: Vec<f32> = std::iter::repeat_n(1.0 / 60.0, 200).collect();
        let frames_30hz: Vec<f32> = std::iter::repeat_n(1.0 / 30.0, 200).collect();

        let f60 = frames_to_complete(required, &frames_60hz);
        let f30 = frames_to_complete(required, &frames_30hz);

        let t60 = (f60 as f32) * (1.0 / 60.0);
        let t30 = (f30 as f32) * (1.0 / 30.0);

        assert!(t60 >= required - 1e-3);
        assert!(t30 >= required - 1e-3);
    }

    #[test]
    fn drowning_triggers_after_air_depletes() {
        let mut health = PlayerHealth::new();

        for _ in 0..300 {
            assert!(!health.tick_air(true, 300, false));
        }
        for _ in 0..19 {
            assert!(!health.tick_air(true, 300, false));
        }
        assert!(health.tick_air(true, 300, false));

        // Leaving water regenerates air and clears drowning timer.
        assert!(!health.tick_air(false, 300, false));
        assert!(health.air_ticks > 0);

        // Water breathing keeps air full.
        assert!(!health.tick_air(true, 300, true));
        assert_eq!(health.air_ticks, 300);
    }

    #[test]
    fn max_air_ticks_extends_drowning_time() {
        let mut health = PlayerHealth::new();

        // Simulate Respiration increasing max air to 600 ticks.
        health.air_ticks = 600;
        for _ in 0..600 {
            assert!(!health.tick_air(true, 600, false));
        }
        for _ in 0..19 {
            assert!(!health.tick_air(true, 600, false));
        }
        assert!(health.tick_air(true, 600, false));
    }

    #[test]
    fn burning_triggers_periodic_damage_and_can_be_extinguished() {
        let mut health = PlayerHealth::new();
        health.ignite(40);

        let mut events = 0;
        for _ in 0..40 {
            if health.tick_burning(false, false) {
                events += 1;
            }
        }
        assert_eq!(events, 2);

        // Fire resistance suppresses damage ticks.
        health.ignite(40);
        for _ in 0..40 {
            assert!(!health.tick_burning(false, true));
        }

        // Water extinguishes.
        health.ignite(40);
        assert!(!health.tick_burning(true, false));
        assert_eq!(health.burning_ticks, 0);
    }

    #[test]
    fn crafting_log_to_planks() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_OAK_PLANKS), 4))
        );
    }

    #[test]
    fn ui_slot_primary_click_picks_up_places_merges_and_swaps() {
        let mut slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 10));
        let mut cursor = None;

        apply_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert!(slot.is_none());
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 10))
        );

        apply_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 10))
        );
        assert!(cursor.is_none());

        cursor = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 5));
        apply_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 15))
        );
        assert!(cursor.is_none());

        cursor = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1));
        apply_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 15))
        );
    }

    #[test]
    fn ui_slot_secondary_click_splits_picks_and_places_one() {
        let mut slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 9));
        let mut cursor = None;

        apply_slot_click(&mut slot, &mut cursor, UiSlotClick::Secondary);
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 5))
        );
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 4))
        );

        let mut empty_slot = None;
        apply_slot_click(&mut empty_slot, &mut cursor, UiSlotClick::Secondary);
        assert_eq!(
            empty_slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 4))
        );

        apply_slot_click(&mut empty_slot, &mut cursor, UiSlotClick::Secondary);
        assert_eq!(
            empty_slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 2))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 3))
        );

        // Different stack: right click does nothing.
        let mut different_slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1));
        apply_slot_click(&mut different_slot, &mut cursor, UiSlotClick::Secondary);
        assert_eq!(
            different_slot,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 3))
        );
    }

    #[test]
    fn furnace_ui_output_slot_takes_and_merges_into_cursor() {
        let mut output = Some((DroppedItemType::IronIngot, 10));
        let mut cursor = None;

        apply_furnace_slot_click(
            &mut output,
            &mut cursor,
            FurnaceSlotKind::Output,
            UiSlotClick::Secondary,
        );
        assert_eq!(output, Some((DroppedItemType::IronIngot, 5)));
        assert_eq!(cursor, Some(ItemStack::new(ItemType::Item(7), 5)));

        cursor = Some(ItemStack::new(ItemType::Item(7), 60));
        apply_furnace_slot_click(
            &mut output,
            &mut cursor,
            FurnaceSlotKind::Output,
            UiSlotClick::Primary,
        );
        assert_eq!(cursor, Some(ItemStack::new(ItemType::Item(7), 64)));
        assert_eq!(output, Some((DroppedItemType::IronIngot, 1)));
    }

    #[test]
    fn furnace_ui_input_slot_rejects_non_smeltable_and_allows_swap() {
        // Reject planks (not smeltable).
        let mut input_slot = None;
        let mut cursor = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 4));
        apply_furnace_slot_click(
            &mut input_slot,
            &mut cursor,
            FurnaceSlotKind::Input,
            UiSlotClick::Primary,
        );
        assert!(input_slot.is_none());
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 4))
        );

        // Accept cobblestone (smeltable into stone).
        cursor = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 8));
        apply_furnace_slot_click(
            &mut input_slot,
            &mut cursor,
            FurnaceSlotKind::Input,
            UiSlotClick::Primary,
        );
        assert_eq!(input_slot, Some((DroppedItemType::Cobblestone, 8)));
        assert!(cursor.is_none());

        // Swap to oak log (smeltable into coal/charcoal).
        cursor = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 3));
        apply_furnace_slot_click(
            &mut input_slot,
            &mut cursor,
            FurnaceSlotKind::Input,
            UiSlotClick::Primary,
        );
        assert_eq!(input_slot, Some((DroppedItemType::OakLog, 3)));
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 8))
        );
    }

    #[test]
    fn furnace_try_insert_merges_up_to_stack_limit() {
        let mut slot = None;

        let moved = furnace_try_insert(&mut slot, DroppedItemType::Coal, 10);
        assert_eq!(moved, 10);
        assert_eq!(slot, Some((DroppedItemType::Coal, 10)));

        let moved = furnace_try_insert(&mut slot, DroppedItemType::Coal, 60);
        assert_eq!(moved, 54);
        assert_eq!(slot, Some((DroppedItemType::Coal, 64)));
    }

    #[test]
    fn shift_move_core_stack_into_furnace_prefers_input_over_fuel() {
        let mut furnace = FurnaceState::default();
        let mut stack = ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 5);

        assert!(try_shift_move_core_stack_into_furnace(
            &mut stack,
            &mut furnace
        ));
        assert_eq!(stack.count, 0);
        assert_eq!(furnace.input, Some((DroppedItemType::OakLog, 5)));
        assert!(furnace.fuel.is_none());
    }

    #[test]
    fn shift_move_core_stack_into_furnace_falls_back_to_fuel_when_input_blocked() {
        let mut furnace = FurnaceState {
            input: Some((DroppedItemType::Cobblestone, 1)),
            ..Default::default()
        };

        let mut stack = ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 3);
        assert!(try_shift_move_core_stack_into_furnace(
            &mut stack,
            &mut furnace
        ));
        assert_eq!(stack.count, 0);
        assert_eq!(furnace.fuel, Some((DroppedItemType::OakLog, 3)));
    }

    #[test]
    fn shift_move_core_stack_into_furnace_inserts_fuel() {
        let mut furnace = FurnaceState::default();
        let mut stack = ItemStack::new(ItemType::Item(8), 10); // coal

        assert!(try_shift_move_core_stack_into_furnace(
            &mut stack,
            &mut furnace
        ));
        assert_eq!(stack.count, 0);
        assert_eq!(furnace.fuel, Some((DroppedItemType::Coal, 10)));
    }

    #[test]
    fn shift_move_core_stack_into_chest_merges_then_fills_empty_slots() {
        let mut chest = ChestState::default();
        chest.slots[0] = Some(ItemStack::new(ItemType::Item(3), 60));

        let mut stack = ItemStack::new(ItemType::Item(3), 10);
        assert!(try_shift_move_core_stack_into_chest(&mut stack, &mut chest));
        assert_eq!(stack.count, 0);
        assert_eq!(chest.slots[0].as_ref().unwrap().count, 64);
        assert_eq!(chest.slots[1].as_ref().unwrap().count, 6);
    }

    #[test]
    fn shift_move_core_stack_into_chest_returns_false_when_full() {
        let mut chest = ChestState::default();
        let full_stack = ItemStack::new(ItemType::Item(3), 64);
        for slot in &mut chest.slots {
            *slot = Some(full_stack.clone());
        }

        let mut stack = ItemStack::new(ItemType::Item(3), 1);
        assert!(!try_shift_move_core_stack_into_chest(
            &mut stack, &mut chest
        ));
        assert_eq!(stack.count, 1);
    }

    #[test]
    fn primary_drag_distribution_places_into_hopper_slots() {
        let mut hotbar = Hotbar::new();
        let mut main_inventory = MainInventory::new();
        let mut hopper = HopperState::default();
        let mut cursor = Some(ItemStack::new(ItemType::Item(3), 3));
        let visited = vec![UiCoreSlotId::Hopper(0), UiCoreSlotId::Hopper(1)];

        apply_primary_drag_distribution_with_hopper(
            &mut cursor,
            &visited,
            &mut hotbar,
            &mut main_inventory,
            &mut hopper,
        );

        assert!(cursor.is_none());
        assert_eq!(hopper.slots[0].as_ref().unwrap().count, 2);
        assert_eq!(hopper.slots[1].as_ref().unwrap().count, 1);
    }

    #[test]
    fn primary_drag_distribution_places_into_dispenser_slots() {
        let mut hotbar = Hotbar::new();
        let mut main_inventory = MainInventory::new();
        let mut dispenser = DispenserState::default();
        let mut cursor = Some(ItemStack::new(ItemType::Item(3), 3));
        let visited = vec![UiCoreSlotId::Dispenser(0), UiCoreSlotId::Dispenser(1)];

        apply_primary_drag_distribution_with_dispenser(
            &mut cursor,
            &visited,
            &mut hotbar,
            &mut main_inventory,
            &mut dispenser,
        );

        assert!(cursor.is_none());
        assert_eq!(dispenser.slots[0].as_ref().unwrap().count, 2);
        assert_eq!(dispenser.slots[1].as_ref().unwrap().count, 1);
    }

    #[test]
    fn crafting_planks_to_sticks() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));

        assert_eq!(check_crafting_recipe(&grid), Some((ItemType::Item(3), 4)));
    }

    #[test]
    fn crafting_planks_to_crafting_table() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_CRAFTING_TABLE), 1))
        );
    }

    #[test]
    fn crafting_cobblestone_to_furnace() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for (r, row) in grid.iter_mut().enumerate() {
            for (c, slot) in row.iter_mut().enumerate() {
                if r == 1 && c == 1 {
                    continue;
                }
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_FURNACE), 1))
        );
    }

    #[test]
    fn crafting_planks_to_chest() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for (r, row) in grid.iter_mut().enumerate() {
            for (c, slot) in row.iter_mut().enumerate() {
                if r == 1 && c == 1 {
                    continue;
                }
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::CHEST), 1))
        );
    }

    #[test]
    fn crafting_planks_vertical_makes_sticks_and_horizontal_makes_pressure_plate() {
        let plank = ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1);

        // Vertical: sticks.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[1][0] = Some(plank.clone());
        assert_eq!(check_crafting_recipe(&grid), Some((ItemType::Item(3), 4)));

        // Horizontal: pressure plate.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[0][1] = Some(plank);
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::OAK_PRESSURE_PLATE),
                1
            ))
        );
    }

    #[test]
    fn crafting_buttons_lever_and_stone_pressure_plate() {
        // Oak button.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::OAK_BUTTON),
                1
            ))
        );

        // Stone button.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::STONE_BUTTON),
                1
            ))
        );

        // Lever.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(3), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::LEVER),
                1
            ))
        );

        // Stone pressure plate.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        grid[0][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::STONE_PRESSURE_PLATE),
                1
            ))
        );

        // Redstone torch.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Item(3), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
                1
            ))
        );

        // Redstone lamp.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_LAMP),
                1
            ))
        );

        // Redstone repeater.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
            1,
        ));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[0][2] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
            1,
        ));
        grid[1][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        grid[1][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        grid[1][2] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_REPEATER),
                1
            ))
        );

        // Redstone comparator.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
            1,
        ));
        grid[1][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
            1,
        ));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_NETHER_QUARTZ), 1));
        grid[1][2] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_TORCH),
            1,
        ));
        grid[2][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        grid[2][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        grid[2][2] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE),
            1,
        ));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_COMPARATOR),
                1
            ))
        );

        // Observer.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_NETHER_QUARTZ), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::redstone_blocks::REDSTONE_OBSERVER),
                1
            ))
        );

        // Piston.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::mechanical_blocks::PISTON),
                1
            ))
        );

        // Hopper.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[1][1] = Some(ItemStack::new(
            ItemType::Block(interactive_blocks::CHEST),
            1,
        ));
        grid[1][2] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Item(7), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::mechanical_blocks::HOPPER),
                1
            ))
        );

        // Dropper.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::mechanical_blocks::DROPPER),
                1
            ))
        );

        // Dispenser.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(1), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Block(mdminecraft_world::mechanical_blocks::DISPENSER),
                1
            ))
        );
    }

    #[test]
    fn crafting_planks_to_oak_door() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in &mut grid {
            for slot in row.iter_mut().take(2) {
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::OAK_DOOR_LOWER), 3))
        );
    }

    #[test]
    fn crafting_iron_ingots_to_iron_door() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in &mut grid {
            for slot in row.iter_mut().take(2) {
                *slot = Some(ItemStack::new(ItemType::Item(7), 1));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::IRON_DOOR_LOWER), 3))
        );
    }

    #[test]
    fn crafting_bucket_vanillaish_recipe() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Item(7), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(7), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_BUCKET), 1))
        );
    }

    #[test]
    fn crafting_flint_and_steel_vanillaish_recipe() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(7), 1)); // iron ingot
        grid[1][1] = Some(ItemStack::new(ItemType::Item(5), 1)); // flint
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_FLINT_AND_STEEL), 1))
        );

        // Mirrored variant should also match.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][1] = Some(ItemStack::new(ItemType::Item(7), 1)); // iron ingot
        grid[1][0] = Some(ItemStack::new(ItemType::Item(5), 1)); // flint
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_FLINT_AND_STEEL), 1))
        );
    }

    #[test]
    fn bucket_picks_up_water_source_block() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: FluidType::Water.source_block_id(),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut fluid_sim = FluidSimulator::new();

        let hit = super::RaycastHit {
            block_pos: glam::IVec3::new(1, 64, 1),
            face_normal: glam::IVec3::ZERO,
            distance: 0.0,
            hit_pos: glam::Vec3::ZERO,
        };

        let result = super::try_bucket_interaction(
            DimensionId::Overworld,
            CORE_ITEM_BUCKET,
            hit,
            &mut chunks,
            &mut fluid_sim,
        );
        assert_eq!(
            result,
            Some((CORE_ITEM_WATER_BUCKET, vec![glam::IVec3::new(1, 64, 1)]))
        );

        let voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .unwrap()
            .voxel(1, local_y(64), 1);
        assert_eq!(voxel.id, BLOCK_AIR);
    }

    #[test]
    fn bucket_picks_up_water_from_waterlogged_slab() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: interactive_blocks::STONE_SLAB,
                state: mdminecraft_world::set_waterlogged(0, true),
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut fluid_sim = FluidSimulator::new();

        let hit = super::RaycastHit {
            block_pos: glam::IVec3::new(1, 64, 1),
            face_normal: glam::IVec3::ZERO,
            distance: 0.0,
            hit_pos: glam::Vec3::ZERO,
        };

        let result = super::try_bucket_interaction(
            DimensionId::Overworld,
            CORE_ITEM_BUCKET,
            hit,
            &mut chunks,
            &mut fluid_sim,
        );
        assert_eq!(
            result,
            Some((CORE_ITEM_WATER_BUCKET, vec![glam::IVec3::new(1, 64, 1)]))
        );

        let voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .unwrap()
            .voxel(1, local_y(64), 1);
        assert_eq!(voxel.id, interactive_blocks::STONE_SLAB);
        assert!(!mdminecraft_world::is_waterlogged(voxel.state));
        assert_eq!(fluid_sim.pending_count(), 0);
    }

    #[test]
    fn water_bucket_waterlogs_slab() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: interactive_blocks::STONE_SLAB,
                state: 0,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut fluid_sim = FluidSimulator::new();

        let hit = super::RaycastHit {
            block_pos: glam::IVec3::new(1, 64, 1),
            face_normal: glam::IVec3::ZERO,
            distance: 0.0,
            hit_pos: glam::Vec3::ZERO,
        };

        let result = super::try_bucket_interaction(
            DimensionId::Overworld,
            CORE_ITEM_WATER_BUCKET,
            hit,
            &mut chunks,
            &mut fluid_sim,
        );
        assert_eq!(
            result,
            Some((CORE_ITEM_BUCKET, vec![glam::IVec3::new(1, 64, 1)]))
        );

        let voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .unwrap()
            .voxel(1, local_y(64), 1);
        assert_eq!(voxel.id, interactive_blocks::STONE_SLAB);
        assert!(mdminecraft_world::is_waterlogged(voxel.state));
        assert_eq!(fluid_sim.pending_count(), 1);
    }

    #[test]
    fn water_bucket_places_water_source_into_adjacent_air() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut fluid_sim = FluidSimulator::new();

        let hit = super::RaycastHit {
            block_pos: glam::IVec3::new(1, 64, 1),
            face_normal: glam::IVec3::new(1, 0, 0),
            distance: 0.0,
            hit_pos: glam::Vec3::ZERO,
        };

        let result = super::try_bucket_interaction(
            DimensionId::Overworld,
            CORE_ITEM_WATER_BUCKET,
            hit,
            &mut chunks,
            &mut fluid_sim,
        );
        assert_eq!(
            result,
            Some((CORE_ITEM_BUCKET, vec![glam::IVec3::new(2, 64, 1)]))
        );

        let voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .unwrap()
            .voxel(2, local_y(64), 1);
        assert_eq!(voxel.id, FluidType::Water.source_block_id());
        assert_eq!(fluid_sim.pending_count(), 1);
    }

    #[test]
    fn water_bucket_extinguishes_fire_block() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            2,
            local_y(64),
            1,
            Voxel {
                id: mdminecraft_world::BLOCK_FIRE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut fluid_sim = FluidSimulator::new();

        let hit = super::RaycastHit {
            block_pos: glam::IVec3::new(1, 64, 1),
            face_normal: glam::IVec3::new(1, 0, 0),
            distance: 0.0,
            hit_pos: glam::Vec3::ZERO,
        };

        let result = super::try_bucket_interaction(
            DimensionId::Overworld,
            CORE_ITEM_WATER_BUCKET,
            hit,
            &mut chunks,
            &mut fluid_sim,
        );
        assert_eq!(
            result,
            Some((CORE_ITEM_BUCKET, vec![glam::IVec3::new(2, 64, 1)]))
        );

        let voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .unwrap()
            .voxel(2, local_y(64), 1);
        assert_eq!(voxel.id, FluidType::Water.source_block_id());
        assert_eq!(fluid_sim.pending_count(), 1);
    }

    #[test]
    fn water_bucket_evaporates_in_nether() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: BLOCK_COBBLESTONE,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut fluid_sim = FluidSimulator::new();

        let hit = super::RaycastHit {
            block_pos: glam::IVec3::new(1, 64, 1),
            face_normal: glam::IVec3::new(1, 0, 0),
            distance: 0.0,
            hit_pos: glam::Vec3::ZERO,
        };

        let result = super::try_bucket_interaction(
            DimensionId::Nether,
            CORE_ITEM_WATER_BUCKET,
            hit,
            &mut chunks,
            &mut fluid_sim,
        );
        assert_eq!(result, Some((CORE_ITEM_BUCKET, Vec::new())));

        let voxel = chunks
            .get(&ChunkPos::new(0, 0))
            .unwrap()
            .voxel(2, local_y(64), 1);
        assert_eq!(voxel.id, BLOCK_AIR);
        assert_eq!(fluid_sim.pending_count(), 0);
    }

    #[test]
    fn nether_portal_activation_fills_minimal_frame_axis_x() {
        let origin = glam::IVec3::new(1, 10, 1);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        for w in 0..4 {
            for h in 0..5 {
                let is_border = w == 0 || w == 3 || h == 0 || h == 4;
                if !is_border {
                    continue;
                }

                chunk.set_voxel(
                    (origin.x + w) as usize,
                    local_y(origin.y + h),
                    origin.z as usize,
                    Voxel {
                        id: BLOCK_OBSIDIAN,
                        ..Default::default()
                    },
                );
            }
        }

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let ignite_pos = glam::IVec3::new(2, 11, 1);
        let changed =
            super::try_activate_nether_portal(&mut chunks, ignite_pos).expect("portal activates");
        assert_eq!(changed.len(), 6);

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        for x in 2..=3 {
            for y in 11..=13 {
                let voxel = chunk.voxel(x as usize, local_y(y), 1);
                assert_eq!(voxel.id, BLOCK_NETHER_PORTAL);
                assert_eq!(voxel.state, 0);
            }
        }
    }

    #[test]
    fn nether_portal_activation_fills_minimal_frame_axis_z() {
        let origin = glam::IVec3::new(1, 10, 1);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        for w in 0..4 {
            for h in 0..5 {
                let is_border = w == 0 || w == 3 || h == 0 || h == 4;
                if !is_border {
                    continue;
                }

                chunk.set_voxel(
                    origin.x as usize,
                    local_y(origin.y + h),
                    (origin.z + w) as usize,
                    Voxel {
                        id: BLOCK_OBSIDIAN,
                        ..Default::default()
                    },
                );
            }
        }

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let ignite_pos = glam::IVec3::new(1, 11, 2);
        let changed =
            super::try_activate_nether_portal(&mut chunks, ignite_pos).expect("portal activates");
        assert_eq!(changed.len(), 6);

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        for z in 2..=3 {
            for y in 11..=13 {
                let voxel = chunk.voxel(1, local_y(y), z as usize);
                assert_eq!(voxel.id, BLOCK_NETHER_PORTAL);
                assert_eq!(voxel.state, 1);
            }
        }
    }

    #[test]
    fn end_portal_activation_fills_3x3_interior() {
        let origin = glam::IVec3::new(1, 10, 1);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        for dx in 0..=4 {
            for dz in 0..=4 {
                let is_border = dx == 0 || dx == 4 || dz == 0 || dz == 4;
                let pos = glam::IVec3::new(origin.x + dx, origin.y, origin.z + dz);
                if is_border {
                    chunk.set_voxel(
                        pos.x as usize,
                        local_y(pos.y),
                        pos.z as usize,
                        Voxel {
                            id: BLOCK_END_PORTAL_FRAME,
                            state: 0x01,
                            ..Default::default()
                        },
                    );
                } else {
                    chunk.set_voxel(
                        pos.x as usize,
                        local_y(pos.y),
                        pos.z as usize,
                        Voxel {
                            id: BLOCK_AIR,
                            ..Default::default()
                        },
                    );
                }
            }
        }

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let frame_pos = glam::IVec3::new(origin.x, origin.y, origin.z);
        let changed = try_activate_end_portal(&mut chunks, frame_pos).expect("portal activates");
        assert_eq!(changed.len(), 9);

        let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
        for x in (origin.x + 1)..=(origin.x + 3) {
            for z in (origin.z + 1)..=(origin.z + 3) {
                let voxel = chunk.voxel(x as usize, local_y(origin.y), z as usize);
                assert_eq!(voxel.id, BLOCK_END_PORTAL);
            }
        }
    }

    #[test]
    fn end_portal_activation_requires_all_eyes() {
        let origin = glam::IVec3::new(1, 10, 1);
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));

        for dx in 0..=4 {
            for dz in 0..=4 {
                let is_border = dx == 0 || dx == 4 || dz == 0 || dz == 4;
                if !is_border {
                    continue;
                }

                let state = if dx == 0 && dz == 0 { 0x00 } else { 0x01 };
                chunk.set_voxel(
                    (origin.x + dx) as usize,
                    local_y(origin.y),
                    (origin.z + dz) as usize,
                    Voxel {
                        id: BLOCK_END_PORTAL_FRAME,
                        state,
                        ..Default::default()
                    },
                );
            }
        }

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let frame_pos = glam::IVec3::new(origin.x, origin.y, origin.z);
        assert!(try_activate_end_portal(&mut chunks, frame_pos).is_none());
    }

    #[test]
    fn crafting_ender_pearl_and_blaze_powder_to_eye_of_ender() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_ENDER_PEARL), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_BLAZE_POWDER), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_EYE_OF_ENDER), 1))
        );
    }

    #[test]
    fn crafting_glowstone_dust_to_glowstone() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_GLOWSTONE), 1))
        );
    }

    #[test]
    fn crafting_obsidian_and_ghast_tear_to_crying_obsidian() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_GHAST_TEAR), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_CRYING_OBSIDIAN), 1))
        );
    }

    #[test]
    fn crafting_respawn_anchor_vanillaish_recipe() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();

        for row in &mut grid {
            row[0] = Some(ItemStack::new(ItemType::Block(BLOCK_CRYING_OBSIDIAN), 1));
            row[1] = Some(ItemStack::new(ItemType::Block(BLOCK_GLOWSTONE), 1));
            row[2] = Some(ItemStack::new(ItemType::Block(BLOCK_CRYING_OBSIDIAN), 1));
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_RESPAWN_ANCHOR), 1))
        );
    }

    #[test]
    fn crafting_obsidian_stone_bricks_and_quartz_to_end_portal_frame() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();

        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), 1));
        grid[0][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), 1));
        grid[1][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[1][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_NETHER_QUARTZ), 1));
        grid[1][2] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), 1));
        grid[2][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_END_PORTAL_FRAME), 1))
        );
    }

    #[test]
    fn crafting_planks_to_trapdoor() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            for slot in row {
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::TRAPDOOR), 2))
        );
    }

    #[test]
    fn crafting_planks_and_sticks_to_oak_fence_and_gate() {
        let plank = ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1);
        let stick = ItemStack::new(ItemType::Item(3), 1);

        // Fence: P S P / P S P
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            row[0] = Some(plank.clone());
            row[1] = Some(stick.clone());
            row[2] = Some(plank.clone());
        }
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::OAK_FENCE), 3))
        );

        // Gate: S P S / S P S
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            row[0] = Some(stick.clone());
            row[1] = Some(plank.clone());
            row[2] = Some(stick.clone());
        }
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::OAK_FENCE_GATE), 1))
        );
    }

    #[test]
    fn crafting_cobblestone_to_walls() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            for slot in row {
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::COBBLESTONE_WALL), 6))
        );
    }

    #[test]
    fn crafting_stone_to_stone_bricks() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            for slot in row.iter_mut().take(2) {
                *slot = Some(ItemStack::new(
                    ItemType::Block(mdminecraft_world::BLOCK_STONE),
                    1,
                ));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS), 4))
        );
    }

    #[test]
    fn crafting_stone_bricks_to_stone_brick_slabs() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for slot in &mut grid[0] {
            *slot = Some(ItemStack::new(
                ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
                1,
            ));
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::STONE_BRICK_SLAB), 6))
        );
    }

    #[test]
    fn crafting_stone_bricks_to_stone_brick_stairs() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[1][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[1][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[2][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[2][1] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        grid[2][2] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
            1,
        ));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::STONE_BRICK_STAIRS), 4))
        );
    }

    #[test]
    fn crafting_stone_bricks_to_stone_brick_walls() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            for slot in row {
                *slot = Some(ItemStack::new(
                    ItemType::Block(mdminecraft_world::BLOCK_STONE_BRICKS),
                    1,
                ));
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::STONE_BRICK_WALL), 6))
        );
    }

    #[test]
    fn crafting_cobblestone_and_planks_to_slabs_and_stairs() {
        // Stone slabs.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for slot in &mut grid[0] {
            *slot = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        }
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::STONE_SLAB), 6))
        );

        // Oak slabs.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for slot in &mut grid[0] {
            *slot = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        }
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::OAK_SLAB), 6))
        );

        // Stone stairs.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::STONE_STAIRS), 4))
        );

        // Stone stairs (mirrored).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::STONE_STAIRS), 4))
        );

        // Oak stairs.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::OAK_STAIRS), 4))
        );

        // Oak stairs (mirrored).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[1][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[2][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[2][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        grid[2][2] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1));
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::OAK_STAIRS), 4))
        );
    }

    #[test]
    fn crafting_recipes_respect_grid_size() {
        let blocks = super::test_blocks();
        // Furnace is a 3x3-only recipe (crafting table required).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for (r, row) in grid.iter_mut().enumerate() {
            for (c, slot) in row.iter_mut().enumerate() {
                if r == 1 && c == 1 {
                    continue;
                }
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
            }
        }

        assert!(match_crafting_recipe(&grid, CraftingGridSize::TwoByTwo, blocks).is_none());
        let recipe = match_crafting_recipe(&grid, CraftingGridSize::ThreeByThree, blocks)
            .expect("furnace recipe should match");
        assert_eq!(recipe.output, ItemType::Block(BLOCK_FURNACE));
    }

    #[test]
    fn content_pack_can_add_block_and_recipe() {
        let registry = crate::config::load_block_registry_strict()
            .expect("block registry should load (including content packs)");
        let polished_id = registry
            .id_by_name("example:polished_stone")
            .expect("example pack block should be registered");

        let recipes =
            super::load_pack_crafting_recipes_strict(&registry).expect("pack recipes should load");
        let recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(polished_id))
            .expect("pack recipe should produce example:polished_stone");

        assert_eq!(recipe.output_count, 1);
        assert_eq!(recipe.min_grid_size, CraftingGridSize::TwoByTwo);
        assert_eq!(recipe.inputs, vec![(ItemType::Block(1).into(), 4)]);

        let pattern = recipe
            .pattern
            .as_ref()
            .expect("example pack recipe should be shaped");
        assert_eq!(pattern.width, 2);
        assert_eq!(pattern.height, 2);
        assert_eq!(pattern.cells[0][0], Some(ItemType::Block(1).into()));
        assert_eq!(pattern.cells[0][1], Some(ItemType::Block(1).into()));
        assert_eq!(pattern.cells[1][0], Some(ItemType::Block(1).into()));
        assert_eq!(pattern.cells[1][1], Some(ItemType::Block(1).into()));
    }

    #[test]
    fn pack_crafting_ingredient_parses_block_tags() {
        let blocks = mdminecraft_assets::BlockRegistry::new(vec![
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:plank".to_string(),
                    key: None,
                    tags: vec!["test:planks".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
        ]);

        let tag = mdminecraft_core::RegistryKey::parse("test:planks").expect("tag parses");
        assert_eq!(
            super::parse_pack_crafting_ingredient("#test:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag.clone()))
        );
        assert_eq!(
            super::parse_pack_crafting_ingredient("tag:test:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag.clone()))
        );
        assert_eq!(
            super::parse_pack_crafting_ingredient("block_tag:test:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag))
        );
        assert!(super::parse_pack_crafting_ingredient("#test:missing", &blocks).is_none());
    }

    #[test]
    fn pack_crafting_ingredient_accepts_minecraft_tag_alias() {
        let blocks = mdminecraft_assets::BlockRegistry::new(vec![
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:plank".to_string(),
                    key: None,
                    tags: vec!["planks".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
        ]);

        let tag = mdminecraft_core::RegistryKey::parse("planks").expect("tag parses");
        assert_eq!(
            super::parse_pack_crafting_ingredient("#minecraft:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag.clone()))
        );
        assert_eq!(
            super::parse_pack_crafting_ingredient("tag:minecraft:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag.clone()))
        );
        assert_eq!(
            super::parse_pack_crafting_ingredient("block_tag:minecraft:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag))
        );
    }

    #[test]
    fn pack_crafting_ingredient_prefers_explicit_minecraft_tag() {
        let blocks = mdminecraft_assets::BlockRegistry::new(vec![
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:plank".to_string(),
                    key: None,
                    tags: vec!["minecraft:planks".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
        ]);

        let tag = mdminecraft_core::RegistryKey::parse("minecraft:planks").expect("tag parses");
        assert_eq!(
            super::parse_pack_crafting_ingredient("#minecraft:planks", &blocks),
            Some(super::CraftingIngredient::BlockTag(tag))
        );
    }

    #[test]
    fn tag_requirement_allocation_handles_overlapping_tags() {
        let wood = mdminecraft_core::RegistryKey::parse("test:wood").expect("wood tag parses");
        let logs = mdminecraft_core::RegistryKey::parse("test:logs").expect("logs tag parses");

        let blocks = mdminecraft_assets::BlockRegistry::new(vec![
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:plank".to_string(),
                    key: None,
                    tags: vec!["test:wood".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:log".to_string(),
                    key: None,
                    tags: vec!["test:wood".to_string(), "test:logs".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
        ]);

        let available = vec![(ItemType::Block(0), 1), (ItemType::Block(1), 1)];
        let requirements = vec![
            (super::CraftingIngredient::BlockTag(wood), 1),
            (super::CraftingIngredient::BlockTag(logs), 1),
        ];
        let allocation = super::allocate_crafting_requirements(&available, &requirements, &blocks)
            .expect("allocation should succeed");

        assert_eq!(allocation.used_by_requirement.len(), 2);
        assert_eq!(allocation.used_by_requirement[0], vec![(0, 1)]);
        assert_eq!(allocation.used_by_requirement[1], vec![(1, 1)]);
    }

    #[test]
    fn crafting_chest_accepts_any_planks_tag() {
        let blocks = mdminecraft_assets::BlockRegistry::new(vec![
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:planks_a".to_string(),
                    key: None,
                    tags: vec!["planks".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
            mdminecraft_assets::BlockDescriptor::from_definition(
                mdminecraft_assets::BlockDefinition {
                    name: "test:planks_b".to_string(),
                    key: None,
                    tags: vec!["planks".to_string()],
                    opaque: true,
                    light_opacity: None,
                    light_emission: None,
                    emissive: None,
                    texture: None,
                    textures: None,
                    harvest_level: None,
                },
            ),
        ]);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for (r, row) in grid.iter_mut().enumerate() {
            for (c, slot) in row.iter_mut().enumerate() {
                if r == 1 && c == 1 {
                    continue;
                }
                *slot = Some(ItemStack::new(ItemType::Block(1), 1));
            }
        }

        let recipe = match_crafting_recipe(&grid, CraftingGridSize::ThreeByThree, &blocks)
            .expect("chest recipe should match any planks tag");
        assert_eq!(recipe.output, ItemType::Block(interactive_blocks::CHEST));
    }

    #[test]
    fn disabled_packs_are_ignored_when_loading_pack_recipes() {
        let registry = crate::config::load_block_registry_strict().expect("block registry loads");
        let stone_id = registry.id_by_name("stone").expect("stone id");
        let dirt_id = registry.id_by_name("dirt").expect("dirt id");

        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos();
        let packs_root = std::env::temp_dir().join(format!("mdminecraft_pack_recipes_{timestamp}"));
        std::fs::create_dir_all(&packs_root).expect("packs root create");

        let enabled_pack = packs_root.join("enabled_pack");
        std::fs::create_dir_all(&enabled_pack).expect("enabled pack create");
        std::fs::write(
            enabled_pack.join("recipes.json"),
            r#"[{"name":"enabled:stone_from_dirt","inputs":[{"item":"block:dirt","count":1}],"output":{"item":"block:stone","count":1}}]"#,
        )
        .expect("write enabled recipes");

        let disabled_pack = packs_root.join("disabled_pack");
        std::fs::create_dir_all(&disabled_pack).expect("disabled pack create");
        std::fs::write(disabled_pack.join("pack.json"), r#"{"enabled":false}"#)
            .expect("write disabled manifest");
        std::fs::write(
            disabled_pack.join("recipes.json"),
            r#"[{"name":"disabled:dirt_from_stone","inputs":[{"item":"block:stone","count":1}],"output":{"item":"block:dirt","count":1}}]"#,
        )
        .expect("write disabled recipes");

        let recipes = super::load_pack_crafting_recipes_strict_from_root(&registry, &packs_root)
            .expect("pack recipes load");
        assert_eq!(recipes.len(), 1);
        assert_eq!(recipes[0].output, ItemType::Block(stone_id));
        assert!(!recipes.iter().any(|r| r.output == ItemType::Block(dirt_id)));

        let _ = std::fs::remove_dir_all(&packs_root);
    }

    #[test]
    fn autofill_crafting_grid_consumes_items_from_storage() {
        let blocks = super::test_blocks();
        let mut hotbar = Hotbar::new();
        hotbar.slots = Default::default();
        hotbar.selected = 0;
        let recipes = get_crafting_recipes();
        let furnace_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(BLOCK_FURNACE))
            .expect("furnace recipe exists");

        let mut main_inventory = MainInventory::new();
        main_inventory.slots[0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 8));

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        assert!(try_autofill_crafting_grid(
            &mut grid,
            &mut hotbar,
            &mut main_inventory,
            furnace_recipe,
            blocks,
        ));
        assert!(main_inventory.slots[0].is_none());
        for (r, row) in grid.iter().enumerate() {
            for (c, slot) in row.iter().enumerate() {
                if r == 1 && c == 1 {
                    assert!(slot.is_none());
                    continue;
                }

                assert_eq!(
                    *slot,
                    Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1))
                );
            }
        }

        // Not enough items: should be a no-op.
        let mut main_inventory = MainInventory::new();
        main_inventory.slots[0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 7));
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        assert!(!try_autofill_crafting_grid(
            &mut grid,
            &mut hotbar,
            &mut main_inventory,
            furnace_recipe,
            blocks,
        ));
        assert_eq!(
            main_inventory.slots[0],
            Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 7))
        );
        assert!(grid.iter().flatten().all(|slot| slot.is_none()));
    }

    #[test]
    fn crafting_coal_and_stick_to_torches() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(8), 1));
        grid[1][0] = Some(ItemStack::new(ItemType::Item(3), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::TORCH), 4))
        );
    }

    #[test]
    fn crafting_wheat_to_bread() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WHEAT), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WHEAT), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WHEAT), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Food(mdminecraft_core::item::FoodType::Bread), 1))
        );
    }

    #[test]
    fn crafting_sugar_cane_to_sugar() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_SUGAR_CANE), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_SUGAR), 1))
        );
    }

    #[test]
    fn crafting_sugar_cane_to_paper() {
        let cane = ItemStack::new(ItemType::Block(BLOCK_SUGAR_CANE), 1);
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(cane.clone());
        grid[0][1] = Some(cane.clone());
        grid[0][2] = Some(cane);

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_PAPER), 3))
        );
    }

    #[test]
    fn crafting_paper_and_leather_to_book() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_PAPER), 3));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(102), 1)); // Item(102) = Leather

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_BOOK), 1))
        );
    }

    #[test]
    fn crafting_mushroom_sugar_spider_eye_to_fermented_spider_eye() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_BROWN_MUSHROOM), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_SUGAR), 1));
        grid[0][2] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_SPIDER_EYE), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE), 1))
        );
    }

    #[test]
    fn crafting_carrot_and_gold_ingot_to_golden_carrot() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(
            ItemType::Food(mdminecraft_core::item::FoodType::Carrot),
            1,
        ));
        grid[0][1] = Some(ItemStack::new(ItemType::Item(9), 1));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((
                ItemType::Food(mdminecraft_core::item::FoodType::GoldenCarrot),
                1
            ))
        );
    }

    #[test]
    fn crafting_planks_and_books_to_bookshelf() {
        let plank = ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1);
        let book = ItemStack::new(ItemType::Item(CORE_ITEM_BOOK), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for slot in &mut grid[0] {
            *slot = Some(plank.clone());
        }
        for slot in &mut grid[1] {
            *slot = Some(book.clone());
        }
        for slot in &mut grid[2] {
            *slot = Some(plank.clone());
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_BOOKSHELF), 1))
        );
    }

    #[test]
    fn crafting_bed_is_shaped() {
        let wool = ItemStack::new(ItemType::Item(103), 1);
        let plank = ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(wool.clone());
        grid[0][1] = Some(wool.clone());
        grid[0][2] = Some(wool);
        grid[1][0] = Some(plank.clone());
        grid[1][1] = Some(plank.clone());
        grid[1][2] = Some(plank);

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::BED_FOOT), 1))
        );
    }

    #[test]
    fn crafting_glass_to_glass_panes() {
        let glass = ItemStack::new(ItemType::Block(interactive_blocks::GLASS), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(glass.clone());
        grid[0][1] = Some(glass.clone());
        grid[0][2] = Some(glass.clone());
        grid[1][0] = Some(glass.clone());
        grid[1][1] = Some(glass.clone());
        grid[1][2] = Some(glass);

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::GLASS_PANE), 16))
        );
    }

    #[test]
    fn crafting_iron_ingots_to_iron_bars() {
        let ingot = ItemStack::new(ItemType::Item(7), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in grid.iter_mut().take(2) {
            for slot in row {
                *slot = Some(ingot.clone());
            }
        }

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(interactive_blocks::IRON_BARS), 16))
        );
    }

    #[test]
    fn crafting_glass_to_glass_bottles() {
        let glass = ItemStack::new(ItemType::Block(interactive_blocks::GLASS), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(glass.clone());
        grid[0][2] = Some(glass.clone());
        grid[1][1] = Some(glass);

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_GLASS_BOTTLE), 3))
        );
    }

    #[test]
    fn crafting_bone_to_bone_meal() {
        let bone_stack = ItemStack::new(ItemType::Item(16), 5);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(bone_stack);

        assert_eq!(check_crafting_recipe(&grid), Some((ItemType::Item(18), 3)));
    }

    #[test]
    fn crafting_nether_wart_block_to_nether_wart_items() {
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(
            ItemType::Block(mdminecraft_world::BLOCK_NETHER_WART_BLOCK),
            1,
        ));

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Item(CORE_ITEM_NETHER_WART), 9))
        );
    }

    #[test]
    fn crafting_brewing_stand_requires_blaze_powder_and_cobblestone() {
        let blaze_powder = ItemStack::new(ItemType::Item(CORE_ITEM_BLAZE_POWDER), 1);
        let cobble = ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][1] = Some(blaze_powder);
        grid[1][0] = Some(cobble.clone());
        grid[1][1] = Some(cobble.clone());
        grid[1][2] = Some(cobble);

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_BREWING_STAND), 1))
        );
    }

    #[test]
    fn crafting_enchanting_table_vanillaish_recipe() {
        let lapis = ItemStack::new(ItemType::Item(15), 1);
        let diamond = ItemStack::new(ItemType::Item(14), 1);
        let obsidian = ItemStack::new(ItemType::Block(BLOCK_OBSIDIAN), 1);

        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][1] = Some(lapis);
        grid[1][0] = Some(diamond.clone());
        grid[1][1] = Some(obsidian.clone());
        grid[1][2] = Some(diamond);
        grid[2][0] = Some(obsidian.clone());
        grid[2][1] = Some(obsidian.clone());
        grid[2][2] = Some(obsidian);

        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Block(BLOCK_ENCHANTING_TABLE), 1))
        );
    }

    #[test]
    fn crafting_bow_and_arrow_are_shaped_and_bow_is_mirrorable() {
        let stick = ItemStack::new(ItemType::Item(3), 1);
        let string = ItemStack::new(ItemType::Item(4), 1);

        // Bow (canonical orientation).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(stick.clone());
        grid[1][0] = Some(stick.clone());
        grid[2][0] = Some(stick.clone());
        grid[0][1] = Some(string.clone());
        grid[2][1] = Some(string.clone());
        grid[1][2] = Some(string.clone());
        assert_eq!(check_crafting_recipe(&grid), Some((ItemType::Item(1), 1)));

        // Bow (mirrored).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][2] = Some(stick.clone());
        grid[1][2] = Some(stick.clone());
        grid[2][2] = Some(stick);
        grid[0][1] = Some(string.clone());
        grid[2][1] = Some(string.clone());
        grid[1][0] = Some(string);
        assert_eq!(check_crafting_recipe(&grid), Some((ItemType::Item(1), 1)));

        // Arrow.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Item(5), 1)); // flint
        grid[1][0] = Some(ItemStack::new(ItemType::Item(3), 1)); // stick
        grid[2][0] = Some(ItemStack::new(ItemType::Item(6), 1)); // feather
        assert_eq!(check_crafting_recipe(&grid), Some((ItemType::Item(2), 4)));
    }

    #[test]
    fn crafting_tools_are_shaped_and_axes_and_hoes_mirror() {
        let plank = ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 1);
        let stick = ItemStack::new(ItemType::Item(3), 1);

        // Wooden pickaxe.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[0][1] = Some(plank.clone());
        grid[0][2] = Some(plank.clone());
        grid[1][1] = Some(stick.clone());
        grid[2][1] = Some(stick.clone());
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Wood), 1))
        );

        // Wooden axe (canonical orientation).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[0][1] = Some(plank.clone());
        grid[1][0] = Some(plank.clone());
        grid[1][1] = Some(stick.clone());
        grid[2][1] = Some(stick.clone());
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Tool(ToolType::Axe, ToolMaterial::Wood), 1))
        );

        // Wooden axe (mirrored).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[0][1] = Some(plank.clone());
        grid[1][1] = Some(plank.clone());
        grid[1][0] = Some(stick.clone());
        grid[2][0] = Some(stick.clone());
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Tool(ToolType::Axe, ToolMaterial::Wood), 1))
        );

        // Wooden hoe (canonical orientation).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[0][1] = Some(plank.clone());
        grid[1][1] = Some(stick.clone());
        grid[2][1] = Some(stick.clone());
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Tool(ToolType::Hoe, ToolMaterial::Wood), 1))
        );

        // Wooden hoe (mirrored).
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(plank.clone());
        grid[0][1] = Some(plank.clone());
        grid[1][0] = Some(stick.clone());
        grid[2][0] = Some(stick);
        assert_eq!(
            check_crafting_recipe(&grid),
            Some((ItemType::Tool(ToolType::Hoe, ToolMaterial::Wood), 1))
        );
    }

    #[test]
    fn crafting_planks_allows_extra_logs_and_consumes_one() {
        let blocks = super::test_blocks();
        // Planks are intentionally allowed to match even with extra logs present,
        // so players can craft multiple times without clearing the grid.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1));
        grid[0][1] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 1));
        let recipe = match_crafting_recipe(&grid, CraftingGridSize::ThreeByThree, blocks)
            .expect("planks recipe should match");
        assert_eq!(
            (recipe.output, recipe.output_count),
            (ItemType::Block(BLOCK_OAK_PLANKS), 4)
        );
        assert!(consume_crafting_inputs_3x3(&mut grid, &recipe, blocks));
        let remaining_logs: u32 = grid
            .iter()
            .flatten()
            .flatten()
            .filter(|stack| stack.item_type == ItemType::Block(BLOCK_OAK_LOG))
            .map(|stack| stack.count)
            .sum();
        assert_eq!(remaining_logs, 1);

        // A single stack with multiple logs should still match and only consume one.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 2));
        let recipe = match_crafting_recipe(&grid, CraftingGridSize::ThreeByThree, blocks)
            .expect("planks recipe should match");
        assert!(consume_crafting_inputs_3x3(&mut grid, &recipe, blocks));
        let remaining_logs: u32 = grid
            .iter()
            .flatten()
            .flatten()
            .filter(|stack| stack.item_type == ItemType::Block(BLOCK_OAK_LOG))
            .map(|stack| stack.count)
            .sum();
        assert_eq!(remaining_logs, 1);

        // 9 cobblestone shouldn't match the 8-cobblestone furnace recipe.
        let mut grid: [[Option<ItemStack>; 3]; 3] = Default::default();
        for row in &mut grid {
            for slot in row {
                *slot = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1));
            }
        }
        assert_eq!(check_crafting_recipe(&grid), None);
    }

    #[test]
    fn try_add_stack_to_cursor_clamps_to_max_stack_size() {
        let mut cursor = None;
        let stack = ItemStack::new(ItemType::Item(3), 200);

        let remainder = try_add_stack_to_cursor(&mut cursor, stack).expect("should overflow");
        let cursor_stack = cursor.expect("cursor should be filled");

        assert_eq!(cursor_stack.count, cursor_stack.max_stack_size());
        assert_eq!(
            remainder.count,
            200_u32.saturating_sub(cursor_stack.max_stack_size())
        );
    }

    #[test]
    fn crafting_max_crafts_computes_min_over_inputs() {
        let blocks = super::test_blocks();
        let recipes = get_crafting_recipes();
        let torches_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(interactive_blocks::TORCH))
            .expect("torch recipe exists");
        let planks_recipe = recipes
            .iter()
            .find(|recipe| recipe.output == ItemType::Block(BLOCK_OAK_PLANKS))
            .expect("planks recipe exists");

        let mut grid_2x2: [[Option<ItemStack>; 2]; 2] = Default::default();
        grid_2x2[0][0] = Some(ItemStack::new(ItemType::Item(8), 10)); // coal
        grid_2x2[1][0] = Some(ItemStack::new(ItemType::Item(3), 3)); // stick
        assert_eq!(
            crafting_max_crafts_2x2(&grid_2x2, torches_recipe, blocks),
            3
        );

        let mut grid_3x3: [[Option<ItemStack>; 3]; 3] = Default::default();
        grid_3x3[0][0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_LOG), 5));
        assert_eq!(crafting_max_crafts_3x3(&grid_3x3, planks_recipe, blocks), 5);
    }

    #[test]
    fn cursor_can_accept_full_stack_requires_space() {
        let mut cursor = Some(ItemStack::new(ItemType::Item(3), 63));
        let output = ItemStack::new(ItemType::Item(3), 1);
        assert!(cursor_can_accept_full_stack(&cursor, &output));

        // Can't take a full output stack if it would overflow the max stack size.
        let output = ItemStack::new(ItemType::Item(3), 2);
        assert!(!cursor_can_accept_full_stack(&cursor, &output));

        // Incompatible cursor contents prevent taking output.
        let output = ItemStack::new(ItemType::Item(8), 1);
        assert!(!cursor_can_accept_full_stack(&cursor, &output));

        // Empty cursor accepts.
        cursor = None;
        let output = ItemStack::new(ItemType::Item(3), 64);
        assert!(cursor_can_accept_full_stack(&cursor, &output));
    }

    #[test]
    fn primary_drag_distribution_round_robins_until_cursor_empty() {
        let mut hotbar = Hotbar::new();
        hotbar.slots = Default::default();
        hotbar.selected = 0;
        let mut main_inventory = MainInventory::new();
        let mut personal: [[Option<ItemStack>; 2]; 2] = Default::default();
        let mut crafting: [[Option<ItemStack>; 3]; 3] = Default::default();

        let mut cursor = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 5));
        let visited = vec![UiCoreSlotId::Hotbar(0), UiCoreSlotId::Hotbar(1)];

        apply_primary_drag_distribution(
            &mut cursor,
            &visited,
            &mut hotbar,
            &mut main_inventory,
            &mut personal,
            &mut crafting,
        );

        assert!(cursor.is_none());
        assert_eq!(hotbar.slots[0].as_ref().unwrap().count, 3);
        assert_eq!(hotbar.slots[1].as_ref().unwrap().count, 2);
    }

    #[test]
    fn primary_drag_distribution_skips_full_and_incompatible_slots() {
        let mut hotbar = Hotbar::new();
        hotbar.slots = Default::default();
        hotbar.selected = 0;
        hotbar.slots[0] = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 64));
        hotbar.slots[1] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 10));
        let mut main_inventory = MainInventory::new();
        let mut personal: [[Option<ItemStack>; 2]; 2] = Default::default();
        let mut crafting: [[Option<ItemStack>; 3]; 3] = Default::default();

        let mut cursor = Some(ItemStack::new(ItemType::Block(BLOCK_OAK_PLANKS), 3));
        let visited = vec![
            UiCoreSlotId::Hotbar(0),
            UiCoreSlotId::Hotbar(1),
            UiCoreSlotId::Hotbar(2),
        ];

        apply_primary_drag_distribution(
            &mut cursor,
            &visited,
            &mut hotbar,
            &mut main_inventory,
            &mut personal,
            &mut crafting,
        );

        assert!(cursor.is_none());
        assert_eq!(hotbar.slots[0].as_ref().unwrap().count, 64);
        assert_eq!(hotbar.slots[1].as_ref().unwrap().count, 10);
        assert_eq!(hotbar.slots[2].as_ref().unwrap().count, 3);
    }

    #[test]
    fn hotbar_selected_block_maps_redstone_dust_to_redstone_wire() {
        let mut hotbar = Hotbar::new();
        hotbar.slots = Default::default();
        hotbar.selected = 0;
        hotbar.slots[0] = Some(ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 3));

        assert_eq!(
            hotbar.selected_block(),
            Some(mdminecraft_world::redstone_blocks::REDSTONE_WIRE)
        );
    }

    #[test]
    fn armor_piece_roundtrips_via_core_stack_preserving_durability_and_enchantments() {
        let mut piece = ArmorPiece::from_item_with_enchantments(
            DroppedItemType::IronHelmet,
            vec![Enchantment::new(EnchantmentType::Protection, 2)],
        )
        .expect("iron helmet should be armor");
        piece.durability = 7;

        let stack = armor_piece_to_core_stack(&piece).expect("should convert to core stack");
        assert_eq!(stack.item_type, ItemType::Item(10));
        assert_eq!(stack.count, 1);
        assert_eq!(stack.durability, Some(7));
        assert_eq!(stack.enchantments.as_ref().unwrap().len(), 1);

        let piece2 = armor_piece_from_core_stack(&stack).expect("should convert back to armor");
        assert_eq!(piece2.item_type, DroppedItemType::IronHelmet);
        assert_eq!(piece2.slot, ArmorSlot::Helmet);
        assert_eq!(piece2.durability, 7);
        assert_eq!(piece2.enchantments.len(), 1);
        assert_eq!(
            piece2.enchantments[0].enchantment_type,
            EnchantmentType::Protection
        );
        assert_eq!(piece2.enchantments[0].level, 2);
    }

    #[test]
    fn lapis_converts_between_dropped_and_core_item_ids() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::LapisLazuli),
            Some(ItemType::Item(15))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(15)),
            Some(DroppedItemType::LapisLazuli)
        );
    }

    #[test]
    fn diamond_converts_between_dropped_and_core_item_ids() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Diamond),
            Some(ItemType::Item(14))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(14)),
            Some(DroppedItemType::Diamond)
        );
    }

    #[test]
    fn bone_converts_between_dropped_and_core_item_ids() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Bone),
            Some(ItemType::Item(16))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(16)),
            Some(DroppedItemType::Bone)
        );
    }

    #[test]
    fn bone_meal_converts_between_dropped_and_core_item_ids() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::BoneMeal),
            Some(ItemType::Item(18))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(18)),
            Some(DroppedItemType::BoneMeal)
        );
    }

    #[test]
    fn emerald_converts_between_dropped_and_core_item_ids() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Emerald),
            Some(ItemType::Item(17))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(17)),
            Some(DroppedItemType::Emerald)
        );
    }

    #[test]
    fn tools_convert_between_dropped_and_core_item_types() {
        let tool = ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Iron);
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(tool),
            Some(DroppedItemType::IronPickaxe)
        );
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::IronPickaxe),
            Some(tool)
        );

        let tool = ItemType::Tool(ToolType::Shovel, ToolMaterial::Wood);
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(tool),
            Some(DroppedItemType::WoodenShovel)
        );
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::WoodenShovel),
            Some(tool)
        );
    }

    #[test]
    fn brewing_items_convert_between_dropped_and_core_item_types() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::NetherWart),
            Some(ItemType::Item(CORE_ITEM_NETHER_WART))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_NETHER_WART)),
            Some(DroppedItemType::NetherWart)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::BlazePowder),
            Some(ItemType::Item(CORE_ITEM_BLAZE_POWDER))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_BLAZE_POWDER)),
            Some(DroppedItemType::BlazePowder)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Gunpowder),
            Some(ItemType::Item(CORE_ITEM_GUNPOWDER))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_GUNPOWDER)),
            Some(DroppedItemType::Gunpowder)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::SpiderEye),
            Some(ItemType::Item(CORE_ITEM_SPIDER_EYE))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_SPIDER_EYE)),
            Some(DroppedItemType::SpiderEye)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::FermentedSpiderEye),
            Some(ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(
                CORE_ITEM_FERMENTED_SPIDER_EYE
            )),
            Some(DroppedItemType::FermentedSpiderEye)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::MagmaCream),
            Some(ItemType::Item(CORE_ITEM_MAGMA_CREAM))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_MAGMA_CREAM)),
            Some(DroppedItemType::MagmaCream)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::GhastTear),
            Some(ItemType::Item(CORE_ITEM_GHAST_TEAR))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_GHAST_TEAR)),
            Some(DroppedItemType::GhastTear)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::GlisteringMelon),
            Some(ItemType::Item(CORE_ITEM_GLISTERING_MELON))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(
                CORE_ITEM_GLISTERING_MELON
            )),
            Some(DroppedItemType::GlisteringMelon)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::RabbitFoot),
            Some(ItemType::Item(CORE_ITEM_RABBIT_FOOT))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_RABBIT_FOOT)),
            Some(DroppedItemType::RabbitFoot)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::PhantomMembrane),
            Some(ItemType::Item(CORE_ITEM_PHANTOM_MEMBRANE))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(
                CORE_ITEM_PHANTOM_MEMBRANE
            )),
            Some(DroppedItemType::PhantomMembrane)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::RedstoneDust),
            Some(ItemType::Item(CORE_ITEM_REDSTONE_DUST))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_REDSTONE_DUST)),
            Some(DroppedItemType::RedstoneDust)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::GlowstoneDust),
            Some(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST)),
            Some(DroppedItemType::GlowstoneDust)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Pufferfish),
            Some(ItemType::Item(CORE_ITEM_PUFFERFISH))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_PUFFERFISH)),
            Some(DroppedItemType::Pufferfish)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::NetherQuartz),
            Some(ItemType::Item(CORE_ITEM_NETHER_QUARTZ))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_NETHER_QUARTZ)),
            Some(DroppedItemType::NetherQuartz)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Sugar),
            Some(ItemType::Item(CORE_ITEM_SUGAR))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_SUGAR)),
            Some(DroppedItemType::Sugar)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::GoldenCarrot),
            Some(ItemType::Food(
                mdminecraft_core::item::FoodType::GoldenCarrot
            ))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Food(
                mdminecraft_core::item::FoodType::GoldenCarrot
            )),
            Some(DroppedItemType::GoldenCarrot)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::PotionAwkward),
            Some(ItemType::Potion(potion_ids::AWKWARD))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Potion(potion_ids::AWKWARD)),
            Some(DroppedItemType::PotionAwkward)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::PotionSlowFalling),
            Some(ItemType::Potion(potion_ids::SLOW_FALLING))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Potion(
                potion_ids::SLOW_FALLING
            )),
            Some(DroppedItemType::PotionSlowFalling)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::PotionSwiftnessLong),
            Some(ItemType::Potion(potion_ids::SWIFTNESS_LONG))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Potion(
                potion_ids::SWIFTNESS_LONG
            )),
            Some(DroppedItemType::PotionSwiftnessLong)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::SplashPotionStrength),
            Some(ItemType::SplashPotion(potion_ids::STRENGTH))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::SplashPotion(
                potion_ids::STRENGTH
            )),
            Some(DroppedItemType::SplashPotionStrength)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::SplashPotionHealingStrong),
            Some(ItemType::SplashPotion(potion_ids::HEALING_STRONG))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::SplashPotion(
                potion_ids::HEALING_STRONG
            )),
            Some(DroppedItemType::SplashPotionHealingStrong)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::SplashPotionSlowFalling),
            Some(ItemType::SplashPotion(potion_ids::SLOW_FALLING))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::SplashPotion(
                potion_ids::SLOW_FALLING
            )),
            Some(DroppedItemType::SplashPotionSlowFalling)
        );
    }

    #[test]
    fn buckets_convert_between_dropped_and_core_item_types() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Bucket),
            Some(ItemType::Item(CORE_ITEM_BUCKET))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_BUCKET)),
            Some(DroppedItemType::Bucket)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::WaterBucket),
            Some(ItemType::Item(CORE_ITEM_WATER_BUCKET))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_WATER_BUCKET)),
            Some(DroppedItemType::WaterBucket)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::LavaBucket),
            Some(ItemType::Item(CORE_ITEM_LAVA_BUCKET))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_LAVA_BUCKET)),
            Some(DroppedItemType::LavaBucket)
        );
    }

    #[test]
    fn books_and_paper_convert_between_dropped_and_core_item_types() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Paper),
            Some(ItemType::Item(CORE_ITEM_PAPER))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_PAPER)),
            Some(DroppedItemType::Paper)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Book),
            Some(ItemType::Item(CORE_ITEM_BOOK))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_BOOK)),
            Some(DroppedItemType::Book)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::SugarCane),
            Some(ItemType::Block(BLOCK_SUGAR_CANE))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Block(BLOCK_SUGAR_CANE)),
            Some(DroppedItemType::SugarCane)
        );
    }

    #[test]
    fn farming_items_convert_between_dropped_and_core_item_types() {
        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::WheatSeeds),
            Some(ItemType::Item(CORE_ITEM_WHEAT_SEEDS))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_WHEAT_SEEDS)),
            Some(DroppedItemType::WheatSeeds)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Wheat),
            Some(ItemType::Item(CORE_ITEM_WHEAT))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Item(CORE_ITEM_WHEAT)),
            Some(DroppedItemType::Wheat)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Bread),
            Some(ItemType::Food(mdminecraft_core::item::FoodType::Bread))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Food(
                mdminecraft_core::item::FoodType::Bread
            )),
            Some(DroppedItemType::Bread)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Carrot),
            Some(ItemType::Food(mdminecraft_core::item::FoodType::Carrot))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Food(
                mdminecraft_core::item::FoodType::Carrot
            )),
            Some(DroppedItemType::Carrot)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::Potato),
            Some(ItemType::Food(mdminecraft_core::item::FoodType::Potato))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Food(
                mdminecraft_core::item::FoodType::Potato
            )),
            Some(DroppedItemType::Potato)
        );

        assert_eq!(
            GameWorld::convert_dropped_item_type(DroppedItemType::BakedPotato),
            Some(ItemType::Food(
                mdminecraft_core::item::FoodType::BakedPotato
            ))
        );
        assert_eq!(
            GameWorld::convert_core_item_type_to_dropped(ItemType::Food(
                mdminecraft_core::item::FoodType::BakedPotato
            )),
            Some(DroppedItemType::BakedPotato)
        );
    }

    #[test]
    fn instant_status_effects_apply_to_player_health() {
        let mut health = PlayerHealth::new();
        health.damage(10.0);
        assert_eq!(health.current, 10.0);

        apply_instant_status_effect_to_player_health(
            &mut health,
            StatusEffectType::InstantHealth,
            0,
        );
        assert_eq!(health.current, 14.0);

        // Reset invulnerability so damage applies in the unit test.
        health.invulnerability_time = 0.0;
        apply_instant_status_effect_to_player_health(
            &mut health,
            StatusEffectType::InstantDamage,
            0,
        );
        assert_eq!(health.current, 8.0);
    }

    #[test]
    fn regeneration_and_poison_tick_player_health_over_time() {
        let mut effects = StatusEffects::new();

        let mut regen_timer = 0u8;
        let mut poison_timer = 0u8;

        // Regeneration heals 1 health every 50 ticks at amplifier 0.
        let mut health = PlayerHealth::new();
        health.damage(10.0);
        assert_eq!(health.current, 10.0);

        effects.add(StatusEffect::new(StatusEffectType::Regeneration, 0, 100));
        for _ in 0..49 {
            tick_health_over_time_status_effects(
                &mut health,
                &effects,
                &mut regen_timer,
                &mut poison_timer,
            );
        }
        assert_eq!(health.current, 10.0);

        tick_health_over_time_status_effects(
            &mut health,
            &effects,
            &mut regen_timer,
            &mut poison_timer,
        );
        assert_eq!(health.current, 11.0);

        // Poison deals 1 damage every 25 ticks at amplifier 0 (and does not kill below 1.0).
        effects.clear();
        regen_timer = 0;
        poison_timer = 0;

        effects.add(StatusEffect::new(StatusEffectType::Poison, 0, 100));
        health.invulnerability_time = 0.0;
        health.current = 5.0;

        for _ in 0..24 {
            tick_health_over_time_status_effects(
                &mut health,
                &effects,
                &mut regen_timer,
                &mut poison_timer,
            );
        }
        assert_eq!(health.current, 5.0);

        health.invulnerability_time = 0.0;
        tick_health_over_time_status_effects(
            &mut health,
            &effects,
            &mut regen_timer,
            &mut poison_timer,
        );
        assert_eq!(health.current, 4.0);

        regen_timer = 0;
        poison_timer = 0;
        health.invulnerability_time = 0.0;
        health.current = 1.0;
        for _ in 0..25 {
            tick_health_over_time_status_effects(
                &mut health,
                &effects,
                &mut regen_timer,
                &mut poison_timer,
            );
        }
        assert_eq!(health.current, 1.0);
    }

    #[test]
    fn main_inventory_persists_via_world_inventory_roundtrip() {
        let mut main = super::MainInventory::new();
        main.slots[0] = Some(ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 64));

        let mut tool = ItemStack::new(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Iron), 1);
        tool.durability = Some(7);
        tool.enchantments = Some(vec![
            mdminecraft_core::Enchantment::new(mdminecraft_core::EnchantmentType::Efficiency, 3),
            mdminecraft_core::Enchantment::new(mdminecraft_core::EnchantmentType::Unbreaking, 2),
        ]);
        main.slots[1] = Some(tool.clone());

        let bread = ItemStack::new(ItemType::Food(mdminecraft_core::item::FoodType::Bread), 3);
        main.slots[2] = Some(bread.clone());

        let persisted = GameWorld::persisted_inventory_from_main_inventory(&main);
        let loaded = GameWorld::main_inventory_from_persisted_inventory(persisted);

        assert_eq!(loaded.slots[0], main.slots[0]);
        assert_eq!(loaded.slots[1], main.slots[1]);
        assert_eq!(loaded.slots[2], main.slots[2]);
    }

    #[test]
    fn brewing_bottle_slot_places_only_one_water_bottle_from_stack() {
        let mut slot = None;
        let mut cursor = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 5));
        apply_brewing_bottle_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 4))
        );

        let mut slot = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1));
        let mut cursor = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 3));
        apply_brewing_bottle_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert!(slot.is_none());
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 4))
        );

        let mut slot = Some(ItemStack::new(ItemType::Potion(potion_ids::AWKWARD), 1));
        let mut cursor = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1));
        apply_brewing_bottle_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 1))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Potion(potion_ids::AWKWARD), 1))
        );

        // Cursor stacks with >1 bottles can't be swapped into an occupied bottle slot.
        let mut slot = Some(ItemStack::new(ItemType::Potion(potion_ids::AWKWARD), 1));
        let mut cursor = Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 2));
        apply_brewing_bottle_slot_click(&mut slot, &mut cursor, UiSlotClick::Primary);
        assert_eq!(
            slot,
            Some(ItemStack::new(ItemType::Potion(potion_ids::AWKWARD), 1))
        );
        assert_eq!(
            cursor,
            Some(ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 2))
        );
    }

    #[test]
    fn brewing_shift_move_prefers_fuel_then_falls_back_to_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut powder = ItemStack::new(ItemType::Item(CORE_ITEM_BLAZE_POWDER), 5);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut powder,
            &mut stand
        ));
        assert_eq!(stand.fuel, 5);
        assert_eq!(powder.count, 0);

        stand.fuel = 64;
        let mut powder = ItemStack::new(ItemType::Item(CORE_ITEM_BLAZE_POWDER), 3);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut powder,
            &mut stand
        ));
        assert_eq!(stand.fuel, 64);
        assert_eq!(stand.ingredient, Some((item_ids::BLAZE_POWDER, 3)));
        assert_eq!(powder.count, 0);
    }

    #[test]
    fn brewing_shift_move_inserts_gunpowder_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut gunpowder = ItemStack::new(ItemType::Item(CORE_ITEM_GUNPOWDER), 4);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut gunpowder,
            &mut stand
        ));
        assert_eq!(gunpowder.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::GUNPOWDER, 4)));
    }

    #[test]
    fn brewing_shift_move_inserts_sugar_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut sugar = ItemStack::new(ItemType::Item(CORE_ITEM_SUGAR), 7);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut sugar, &mut stand
        ));
        assert_eq!(sugar.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::SUGAR, 7)));
    }

    #[test]
    fn brewing_shift_move_inserts_fermented_spider_eye_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut eye = ItemStack::new(ItemType::Item(CORE_ITEM_FERMENTED_SPIDER_EYE), 3);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut eye, &mut stand
        ));
        assert_eq!(eye.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::FERMENTED_SPIDER_EYE, 3)));
    }

    #[test]
    fn brewing_shift_move_inserts_magma_cream_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut cream = ItemStack::new(ItemType::Item(CORE_ITEM_MAGMA_CREAM), 2);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut cream, &mut stand
        ));
        assert_eq!(cream.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::MAGMA_CREAM, 2)));
    }

    #[test]
    fn brewing_shift_move_inserts_ghast_tear_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut tears = ItemStack::new(ItemType::Item(CORE_ITEM_GHAST_TEAR), 4);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut tears, &mut stand
        ));
        assert_eq!(tears.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::GHAST_TEAR, 4)));
    }

    #[test]
    fn brewing_shift_move_inserts_glistering_melon_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut melons = ItemStack::new(ItemType::Item(CORE_ITEM_GLISTERING_MELON), 2);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut melons,
            &mut stand
        ));
        assert_eq!(melons.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::GLISTERING_MELON, 2)));
    }

    #[test]
    fn brewing_shift_move_inserts_rabbit_foot_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut feet = ItemStack::new(ItemType::Item(CORE_ITEM_RABBIT_FOOT), 1);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut feet, &mut stand
        ));
        assert_eq!(feet.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::RABBIT_FOOT, 1)));
    }

    #[test]
    fn brewing_shift_move_inserts_phantom_membrane_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut membranes = ItemStack::new(ItemType::Item(CORE_ITEM_PHANTOM_MEMBRANE), 3);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut membranes,
            &mut stand
        ));
        assert_eq!(membranes.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::PHANTOM_MEMBRANE, 3)));
    }

    #[test]
    fn brewing_shift_move_inserts_redstone_dust_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut dust = ItemStack::new(ItemType::Item(CORE_ITEM_REDSTONE_DUST), 4);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut dust, &mut stand
        ));
        assert_eq!(dust.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::REDSTONE_DUST, 4)));
    }

    #[test]
    fn brewing_shift_move_inserts_glowstone_dust_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut dust = ItemStack::new(ItemType::Item(CORE_ITEM_GLOWSTONE_DUST), 2);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut dust, &mut stand
        ));
        assert_eq!(dust.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::GLOWSTONE_DUST, 2)));
    }

    #[test]
    fn brewing_shift_move_inserts_pufferfish_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut fish = ItemStack::new(ItemType::Item(CORE_ITEM_PUFFERFISH), 3);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut fish, &mut stand
        ));
        assert_eq!(fish.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::PUFFERFISH, 3)));
    }

    #[test]
    fn brewing_shift_move_inserts_golden_carrots_as_ingredient() {
        let mut stand = BrewingStandState::new();

        let mut carrots = ItemStack::new(
            ItemType::Food(mdminecraft_core::item::FoodType::GoldenCarrot),
            2,
        );
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut carrots,
            &mut stand
        ));
        assert_eq!(carrots.count, 0);
        assert_eq!(stand.ingredient, Some((item_ids::GOLDEN_CARROT, 2)));
    }

    #[test]
    fn brewing_shift_move_inserts_bottles_into_empty_slots() {
        let mut stand = BrewingStandState::new();

        let mut bottles = ItemStack::new(ItemType::Item(CORE_ITEM_WATER_BOTTLE), 5);
        assert!(try_shift_move_core_stack_into_brewing_stand(
            &mut bottles,
            &mut stand
        ));
        assert_eq!(bottles.count, 2);
        assert_eq!(
            stand.bottles,
            [Some(mdminecraft_world::PotionType::Water); 3]
        );
    }

    #[test]
    fn enchanting_shift_move_inserts_lapis() {
        let mut table = EnchantingTableState::new();

        let mut lapis = ItemStack::new(ItemType::Item(15), 10);
        assert!(try_shift_move_core_stack_into_enchanting_table(
            &mut lapis, &mut table
        ));
        assert_eq!(table.lapis_count, 10);
        assert_eq!(lapis.count, 0);

        table.lapis_count = 60;
        let mut lapis = ItemStack::new(ItemType::Item(15), 10);
        assert!(try_shift_move_core_stack_into_enchanting_table(
            &mut lapis, &mut table
        ));
        assert_eq!(table.lapis_count, 64);
        assert_eq!(lapis.count, 6);

        let mut cobble = ItemStack::new(ItemType::Block(BLOCK_COBBLESTONE), 1);
        assert!(!try_shift_move_core_stack_into_enchanting_table(
            &mut cobble,
            &mut table
        ));
        assert_eq!(cobble.count, 1);
    }

    #[test]
    fn enchanting_table_id_mapping_matches_world_conventions() {
        let pickaxe = ItemStack::new(ItemType::Tool(ToolType::Pickaxe, ToolMaterial::Wood), 1);
        assert_eq!(
            core_item_to_enchanting_id(&pickaxe),
            Some(mdminecraft_world::TOOL_ID_START)
        );

        let sword = ItemStack::new(ItemType::Tool(ToolType::Sword, ToolMaterial::Gold), 1);
        assert_eq!(
            core_item_to_enchanting_id(&sword),
            Some(mdminecraft_world::TOOL_ID_START + 20 + ToolMaterial::Gold as u16)
        );

        let bow = ItemStack::new(ItemType::Item(1), 1);
        assert_eq!(
            core_item_to_enchanting_id(&bow),
            Some(mdminecraft_world::BOW_ID)
        );

        let leather_boots = ItemStack::new(ItemType::Item(23), 1);
        assert_eq!(
            core_item_to_enchanting_id(&leather_boots),
            Some(mdminecraft_world::ARMOR_ID_START + 12)
        );
    }

    #[test]
    fn update_container_signal_only_mutates_container_blocks() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        chunk.set_voxel(
            1,
            local_y(64),
            1,
            Voxel {
                id: BLOCK_COBBLESTONE,
                state: 0x1234,
                ..Default::default()
            },
        );
        chunk.set_voxel(
            2,
            local_y(64),
            1,
            Voxel {
                id: interactive_blocks::CHEST,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();

        let mut slots: [Option<ItemStack>; 27] = std::array::from_fn(|_| None);
        slots[0] = Some(ItemStack::new(ItemType::Item(7), 1));
        let desired = mdminecraft_world::comparator_signal_from_core_slots(&slots);
        assert!(desired > 0);

        mdminecraft_world::update_container_signal(
            &mut chunks,
            &mut redstone_sim,
            mdminecraft_world::RedstonePos::new(1, 64, 1),
            &slots,
        );
        {
            let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
            assert_eq!(chunk.voxel(1, local_y(64), 1).state, 0x1234);
        }

        mdminecraft_world::update_container_signal(
            &mut chunks,
            &mut redstone_sim,
            mdminecraft_world::RedstonePos::new(2, 64, 1),
            &slots,
        );
        {
            let chunk = chunks.get(&ChunkPos::new(0, 0)).unwrap();
            let chest = chunk.voxel(2, local_y(64), 1);
            assert_eq!(mdminecraft_world::get_power_level(chest.state), desired);
        }
    }

    #[test]
    fn dispenser_drops_preserve_durability_metadata() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        let mut state = 0;
        state = mdminecraft_world::set_active(state, true);
        state = mdminecraft_world::set_dispenser_facing(state, mdminecraft_world::Facing::North);
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DISPENSER,
                state,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: 0,
            y: 64,
            z: 0,
        };

        let mut dispensers = std::collections::BTreeMap::new();
        let mut dispenser = DispenserState::new();
        let mut bow = ItemStack::new(ItemType::Item(1), 1);
        bow.durability = Some(42);
        let enchantments = vec![Enchantment {
            enchantment_type: EnchantmentType::Power,
            level: 4,
        }];
        bow.enchantments = Some(enchantments.clone());
        dispenser.slots[0] = Some(bow);
        dispensers.insert(key, dispenser);

        let mut item_manager = mdminecraft_world::ItemManager::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);
        let mut droppers = std::collections::BTreeMap::new();
        let mut chests = std::collections::BTreeMap::new();
        let mut hoppers = std::collections::BTreeMap::new();

        GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        let items = item_manager.items();
        assert_eq!(items.len(), 1);
        assert_eq!(items[0].item_type, DroppedItemType::Bow);
        assert_eq!(items[0].durability, Some(42));
        assert_eq!(items[0].enchantments, Some(enchantments));
    }

    #[test]
    fn dropper_drops_preserve_durability_metadata() {
        let mut chunk = Chunk::new(ChunkPos::new(0, 0));
        let mut state = 0;
        state = mdminecraft_world::set_active(state, true);
        state = mdminecraft_world::set_dropper_facing(state, mdminecraft_world::Facing::North);
        chunk.set_voxel(
            0,
            local_y(64),
            0,
            Voxel {
                id: mdminecraft_world::mechanical_blocks::DROPPER,
                state,
                ..Default::default()
            },
        );

        let mut chunks = std::collections::HashMap::new();
        chunks.insert(ChunkPos::new(0, 0), chunk);

        let key = mdminecraft_world::BlockEntityKey {
            dimension: DimensionId::Overworld,
            x: 0,
            y: 64,
            z: 0,
        };

        let mut droppers = std::collections::BTreeMap::new();
        let mut dropper = DispenserState::new();
        let mut bow = ItemStack::new(ItemType::Item(1), 1);
        bow.durability = Some(7);
        let enchantments = vec![Enchantment {
            enchantment_type: EnchantmentType::Punch,
            level: 2,
        }];
        bow.enchantments = Some(enchantments.clone());
        dropper.slots[0] = Some(bow);
        droppers.insert(key, dropper);

        let mut item_manager = mdminecraft_world::ItemManager::new();
        let block_properties = BlockPropertiesRegistry::new();
        let mut redstone_sim = mdminecraft_world::RedstoneSimulator::new();
        let mut fluid_sim = FluidSimulator::new();
        let mut projectiles = mdminecraft_world::ProjectileManager::new();
        let mut crop_growth = mdminecraft_world::CropGrowthSystem::new(0);
        let mut dispensers = std::collections::BTreeMap::new();
        let mut chests = std::collections::BTreeMap::new();
        let mut hoppers = std::collections::BTreeMap::new();

        GameWorld::tick_dispensers_and_droppers(
            4,
            DimensionId::Overworld,
            0,
            mdminecraft_core::SimTick::ZERO,
            super::DispenserTickContext {
                chunks: &mut chunks,
                crop_growth: &mut crop_growth,
                block_properties: &block_properties,
                redstone_sim: &mut redstone_sim,
                item_manager: &mut item_manager,
                fluid_sim: &mut fluid_sim,
                projectiles: &mut projectiles,
                dispensers: &mut dispensers,
                droppers: &mut droppers,
                chests: &mut chests,
                hoppers: &mut hoppers,
            },
        );

        let items = item_manager.items();
        assert_eq!(items.len(), 1);
        assert_eq!(items[0].item_type, DroppedItemType::Bow);
        assert_eq!(items[0].durability, Some(7));
        assert_eq!(items[0].enchantments, Some(enchantments));
    }
}
