# High-Level Design: Rust Voxel Sandbox Engine with Automated Testing

**Version:** 1.0
**Date:** 2025-11-12
**Status:** Design Phase
**Target:** MVP Rust-based voxel engine with deterministic testing infrastructure

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [System Overview](#2-system-overview)
3. [Architecture](#3-architecture)
4. [Core Subsystems Design](#4-core-subsystems-design)
5. [Testing Infrastructure Design](#5-testing-infrastructure-design)
6. [Data Models & Formats](#6-data-models--formats)
7. [Implementation Strategy](#7-implementation-strategy)
8. [Risk Analysis & Mitigation](#8-risk-analysis--mitigation)
9. [Success Criteria](#9-success-criteria)
10. [Appendices](#10-appendices)

---

## 1. Executive Summary

### 1.1 Project Goals

Build a performant, moddable voxel sandbox game in Rust with a **first-class automated testing story** as a core architectural requirement. The system treats the game as a deterministic system under test, with three primary verification surfaces:

1. **Event stream** (JSONL) for black-box testing and replay
2. **Headless rendering** for visual regression testing
3. **World DSL** for declarative scenario testing

### 1.2 Key Design Principles

- **Determinism-first**: Fixed timestep, seeded RNG, no wall-clock dependencies in simulation
- **Testability-by-design**: Every subsystem emits structured events for validation
- **Performance targets**: 20 TPS simulation, 60 FPS rendering, <8ms chunk generation
- **Modular architecture**: Clean separation between core, server, client, and rendering
- **Cross-platform**: wgpu rendering with headless backend for CI

### 1.3 Scope

**In Scope for MVP:**
- Infinite chunked terrain with day/night cycle
- Core gameplay loop: mine, place, craft, inventory
- Entities: player, item drops, passive mob placeholders
- Lighting system (skylight + emissive blocks)
- Save/load with seed-based generation
- Singleplayer and LAN multiplayer
- Full automated testing infrastructure

**Out of Scope for MVP:**
- Redstone-like circuits
- Complex combat systems
- Advanced AI
- Shader mods

---

## 2. System Overview

### 2.1 Current State Analysis

**Existing V1 Implementation (HTML/Three.js prototype):**
- Single HTML file with embedded JavaScript
- Client-side only rendering with THREE.js
- SimplexNoise-based terrain generation
- Instanced mesh rendering per block type
- Basic physics with AABB collisions
- Day/night cycle
- Undo/redo for block placement

**Gap Analysis:**

| Feature | V1 Status | MVP Target | Gap |
|---------|-----------|------------|-----|
| Language/Platform | JS/Three.js | Rust/wgpu | Complete rewrite |
| Architecture | Monolithic | ECS-based modular | New architecture |
| Networking | None | Client-server | New subsystem |
| Testing | None | Full automation | New infrastructure |
| Persistence | None | Region files + saves | New subsystem |
| Determinism | None | Fully deterministic | Core requirement |
| Modding | None | WASM API | New subsystem |

### 2.2 Target System Characteristics

```
┌─────────────────────────────────────────────────────────────┐
│                    Rust Voxel Engine                        │
├─────────────────────────────────────────────────────────────┤
│  Game Client          Server                    Testkit     │
│  ┌──────────┐       ┌──────────┐              ┌──────────┐ │
│  │ Renderer │◄─────►│   Sim    │◄────────────►│ Harness  │ │
│  │ Input    │       │  World   │              │ DSL      │ │
│  │ UI       │       │  ECS     │              │ Events   │ │
│  └──────────┘       └──────────┘              └──────────┘ │
│       │                  │                          │       │
│       └──────────────────┴──────────────────────────┘       │
│                    Network (QUIC)                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. Architecture

### 3.1 Workspace Structure

```
workspace/
├── Cargo.toml                    # Workspace manifest
├── crates/
│   ├── core/                     # Foundation types
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── math.rs           # Vector, matrix, AABB types
│   │   │   ├── id.rs             # BlockId, EntityId, ChunkId
│   │   │   ├── coord.rs          # World/chunk coordinate transforms
│   │   │   ├── time.rs           # Tick counter, deterministic time
│   │   │   ├── rng.rs            # Seeded RNG wrapper
│   │   │   └── error.rs          # Error types
│   │   └── Cargo.toml
│   │
│   ├── ecs/                      # ECS facade
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── world.rs          # bevy_ecs World wrapper
│   │   │   ├── components.rs     # Core components
│   │   │   ├── resources.rs      # Global resources
│   │   │   └── systems.rs        # System registration
│   │   └── Cargo.toml
│   │
│   ├── world/                    # Voxel world management
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── block.rs          # Block definitions & registry
│   │   │   ├── chunk.rs          # Chunk storage (16x256x16)
│   │   │   ├── region.rs         # Region grouping (32x32 chunks)
│   │   │   ├── biome.rs          # Biome definitions
│   │   │   ├── gen/              # Generation pipeline
│   │   │   │   ├── mod.rs
│   │   │   │   ├── noise.rs      # Simplex/Perlin noise
│   │   │   │   ├── heightmap.rs  # Terrain heightmap
│   │   │   │   ├── surface.rs    # Surface composition
│   │   │   │   ├── caves.rs      # Cave carving
│   │   │   │   ├── structures.rs # Trees, huts, ores
│   │   │   │   └── population.rs # Final population pass
│   │   │   ├── lighting.rs       # Skylight + block light
│   │   │   ├── persistence.rs    # Save/load to .rg files
│   │   │   └── migration.rs      # World version migration
│   │   └── Cargo.toml
│   │
│   ├── physics/                  # Physics & collision
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── aabb.rs           # Axis-aligned bounding boxes
│   │   │   ├── collider.rs       # Collider components
│   │   │   ├── movement.rs       # Physics integration
│   │   │   ├── collision.rs      # Collision resolution
│   │   │   └── raycast.rs        # DDA voxel raycasting
│   │   └── Cargo.toml
│   │
│   ├── render/                   # Rendering subsystem
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── backend.rs        # wgpu initialization
│   │   │   ├── mesh/             # Meshing
│   │   │   │   ├── mod.rs
│   │   │   │   ├── greedy.rs     # Greedy meshing algorithm
│   │   │   │   ├── builder.rs    # Vertex/index builder
│   │   │   │   └── cache.rs      # Per-chunk mesh cache
│   │   │   ├── material.rs       # Material atlas & pipelines
│   │   │   ├── camera.rs         # Camera management
│   │   │   ├── frustum.rs        # Frustum culling
│   │   │   ├── headless.rs       # Headless rendering backend
│   │   │   └── shaders/          # WGSL shaders
│   │   │       ├── block.wgsl
│   │   │       ├── entity.wgsl
│   │   │       └── post.wgsl
│   │   └── Cargo.toml
│   │
│   ├── net/                      # Networking
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── protocol.rs       # Message definitions
│   │   │   ├── transport.rs      # QUIC transport (quinn)
│   │   │   ├── serialization.rs  # bincode/postcard
│   │   │   ├── delta.rs          # Delta compression
│   │   │   └── sync.rs           # State synchronization
│   │   └── Cargo.toml
│   │
│   ├── server/                   # Server logic
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── sim.rs            # Simulation tick loop
│   │   │   ├── headless.rs       # Headless mode
│   │   │   ├── world_manager.rs  # Chunk loading/unloading
│   │   │   ├── player.rs         # Player management
│   │   │   ├── crafting.rs       # Crafting logic
│   │   │   └── inventory.rs      # Inventory management
│   │   └── Cargo.toml
│   │
│   ├── client/                   # Client logic
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── input.rs          # Input handling
│   │   │   ├── prediction.rs     # Client-side prediction
│   │   │   ├── interpolation.rs  # Entity interpolation
│   │   │   ├── ui/               # UI components
│   │   │   │   ├── mod.rs
│   │   │   │   ├── hud.rs        # HUD (hotbar, crosshair)
│   │   │   │   ├── inventory.rs  # Inventory screen
│   │   │   │   └── menu.rs       # Menus
│   │   │   └── sound.rs          # Audio (optional MVP)
│   │   └── Cargo.toml
│   │
│   ├── assets/                   # Asset management
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── registry.rs       # Asset registry
│   │   │   ├── loader.rs         # Asset loading
│   │   │   ├── pack.rs           # Data pack system
│   │   │   └── validation.rs     # Asset validation
│   │   └── Cargo.toml
│   │
│   ├── scripting/                # Modding API (post-MVP)
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── wasm_host.rs      # WASM runtime (wasmtime)
│   │   │   ├── api.rs            # Exposed API
│   │   │   └── sandbox.rs        # Sandboxing & limits
│   │   └── Cargo.toml
│   │
│   ├── testkit/                  # Testing infrastructure
│   │   ├── src/
│   │   │   ├── lib.rs
│   │   │   ├── events/           # Event system
│   │   │   │   ├── mod.rs
│   │   │   │   ├── bus.rs        # Event bus
│   │   │   │   ├── sink.rs       # Event sinks
│   │   │   │   ├── recorder.rs   # JSONL recorder
│   │   │   │   └── schema.rs     # Event schemas
│   │   │   ├── replay.rs         # Replay system
│   │   │   ├── world_dsl/        # World test DSL
│   │   │   │   ├── mod.rs
│   │   │   │   ├── parser.rs     # TOML parser
│   │   │   │   ├── executor.rs   # DSL executor
│   │   │   │   └── assertions.rs # Expectation checks
│   │   │   ├── snapshot.rs       # Headless snapshot testing
│   │   │   ├── fixtures.rs       # Test fixtures
│   │   │   ├── metrics.rs        # Performance metrics
│   │   │   └── golden.rs         # Golden file management
│   │   └── Cargo.toml
│   │
│   └── cli/                      # Binary crates
│       ├── src/
│       │   ├── bin/
│       │   │   ├── game_client.rs    # Game client executable
│       │   │   ├── game_server.rs    # Server executable
│       │   │   ├── worldtool.rs      # World generation tool
│       │   │   └── worldtest.rs      # Test runner
│       │   └── lib.rs
│       └── Cargo.toml
│
├── assets/                       # Game assets
│   ├── blocks.toml               # Block definitions
│   ├── recipes.json              # Crafting recipes
│   ├── textures/
│   └── sounds/
│
├── scenarios/                    # Test scenarios
│   ├── superflat.worldtest.toml
│   ├── torch_light.worldtest.toml
│   ├── collision.worldtest.toml
│   └── ...
│
└── goldens/                      # Golden test files
    ├── linux_vulkan/
    ├── win_dx12/
    └── macos_metal/
```

### 3.2 Technology Stack

| Layer | Technology | Rationale |
|-------|------------|-----------|
| Language | Rust (stable) | Memory safety, performance, concurrency |
| ECS | bevy_ecs | Pure ECS crate, no engine lock-in, proven |
| Rendering | wgpu | Cross-platform, headless support, modern |
| Networking | quinn (QUIC) | Reliable, encrypted, low latency |
| Serialization | bincode/postcard | Fast binary serialization |
| Compression | zstd | Fast, high compression ratio |
| Noise | noise-rs or custom | Procedural terrain generation |
| Testing | proptest, cargo-fuzz | Property-based and fuzz testing |
| WASM | wasmtime | Secure, performant WASM runtime |

### 3.3 Data Flow Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     SIMULATION TICK (50ms)                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Ingest Input                                            │
│     ┌────────────┐                                          │
│     │ Client N   │──→ Input Events ──→ [Input Queue]       │
│     └────────────┘                                          │
│                                                             │
│  2. World Updates                                           │
│     [Chunk Gen] → [Lighting] → [Block Ticks] → [Fluids]    │
│                                                             │
│  3. Entity Updates (ECS Systems)                            │
│     [AI] → [Physics] → [Collision] → [Inventory/Craft]     │
│                                                             │
│  4. Emit Events                                             │
│     ┌──────────────────────────────────────────┐           │
│     │         Event Bus (GameEvent)            │           │
│     └──────────────────────────────────────────┘           │
│              │         │          │                         │
│         [JSONL]   [Metrics]   [UI]                          │
│                                                             │
│  5. State Sync                                              │
│     [Delta Compress] → [Network Send] → Clients            │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    RENDER LOOP (16.67ms)                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [Interpolate State] → [Frustum Cull] → [Mesh Render]      │
│         ↓                                                   │
│     [UI Overlay] → [Swap Buffers]                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Core Subsystems Design

### 4.1 Coordinate System & World Model

#### 4.1.1 Coordinate System

```rust
// Right-handed coordinate system
// X: East (+) / West (-)
// Y: Up (+) / Down (-)
// Z: South (+) / North (-)

pub type IVec3 = glam::IVec3;  // Block positions
pub type Vec3 = glam::Vec3;     // Entity positions

// Chunk size: 16 x 256 x 16 (X, Y, Z)
pub const CHUNK_SIZE_X: i32 = 16;
pub const CHUNK_SIZE_Y: i32 = 256;
pub const CHUNK_SIZE_Z: i32 = 16;

// Convert world coords to chunk coords
pub fn world_to_chunk(world_pos: IVec3) -> IVec3 {
    IVec3::new(
        world_pos.x.div_euclid(CHUNK_SIZE_X),
        0,  // Chunks span full height
        world_pos.z.div_euclid(CHUNK_SIZE_Z),
    )
}

// Convert world coords to local chunk coords (0-15)
pub fn world_to_local(world_pos: IVec3) -> IVec3 {
    IVec3::new(
        world_pos.x.rem_euclid(CHUNK_SIZE_X),
        world_pos.y,
        world_pos.z.rem_euclid(CHUNK_SIZE_Z),
    )
}
```

#### 4.1.2 Block Model

```rust
/// Block type identifier (0 = air)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct BlockId(pub u16);

/// Block state (orientation, moisture, etc.)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct BlockState(pub u16);

/// Voxel data (4 bytes)
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Voxel {
    pub id: BlockId,           // 2 bytes
    pub state: BlockState,     // 2 bytes (upper byte reserved)
    // Lighting stored separately for better cache locality
}

/// Separate lighting data
#[derive(Clone, Copy)]
pub struct LightData {
    pub sky: u8,    // 0-15 (stored in lower 4 bits)
    pub block: u8,  // 0-15 (stored in upper 4 bits)
}

impl LightData {
    pub fn pack(&self) -> u8 {
        (self.sky & 0x0F) | ((self.block & 0x0F) << 4)
    }

    pub fn unpack(packed: u8) -> Self {
        Self {
            sky: packed & 0x0F,
            block: (packed >> 4) & 0x0F,
        }
    }
}
```

#### 4.1.3 Chunk Storage

```rust
/// Chunk data structure
pub struct Chunk {
    /// Position in chunk coordinates
    pub pos: IVec3,

    /// Voxel data (16x256x16 = 65,536 voxels)
    /// Stored as Y-X-Z order for vertical locality
    voxels: Box<[Voxel; CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z]>,

    /// Lighting data (packed)
    lighting: Box<[u8; CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z]>,

    /// Chunk state flags
    flags: ChunkFlags,

    /// Generation stage
    gen_stage: GenStage,
}

bitflags::bitflags! {
    pub struct ChunkFlags: u8 {
        const DIRTY_MESH = 0b0000_0001;
        const DIRTY_LIGHT = 0b0000_0010;
        const FULLY_GENERATED = 0b0000_0100;
        const HAS_ENTITIES = 0b0000_1000;
    }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum GenStage {
    Empty,
    Heightmap,
    Surface,
    Caves,
    Structures,
    Population,
    Lighting,
    Complete,
}

impl Chunk {
    #[inline]
    fn index(x: i32, y: i32, z: i32) -> usize {
        // Y-major order for vertical locality
        (y * CHUNK_SIZE_X * CHUNK_SIZE_Z + x * CHUNK_SIZE_Z + z) as usize
    }

    pub fn get(&self, local_pos: IVec3) -> Voxel {
        self.voxels[Self::index(local_pos.x, local_pos.y, local_pos.z)]
    }

    pub fn set(&mut self, local_pos: IVec3, voxel: Voxel) {
        self.voxels[Self::index(local_pos.x, local_pos.y, local_pos.z)] = voxel;
        self.flags |= ChunkFlags::DIRTY_MESH | ChunkFlags::DIRTY_LIGHT;
    }

    pub fn get_light(&self, local_pos: IVec3) -> LightData {
        let packed = self.lighting[Self::index(local_pos.x, local_pos.y, local_pos.z)];
        LightData::unpack(packed)
    }
}
```

#### 4.1.4 Region Storage (Disk Format)

```
Region File Format (.rg):
┌────────────────────────────────────────┐
│ Header (1024 bytes)                    │
│  - Magic: "RGON" (4 bytes)             │
│  - Version: u16                        │
│  - Chunk count: u16                    │
│  - Index: [(offset: u32, len: u24,    │
│             timestamp: u32)] x 1024    │
└────────────────────────────────────────┘
│ Chunk Records (variable)               │
│  ┌──────────────────────────┐          │
│  │ Record Header:           │          │
│  │  - CRC32: u32            │          │
│  │  - Compressed size: u32  │          │
│  │  - Uncompressed: u32     │          │
│  │  - Compression: u8       │          │
│  │  - Version: u8           │          │
│  ├──────────────────────────┤          │
│  │ Compressed Data (zstd)   │          │
│  │  - Voxels (bincode)      │          │
│  │  - Lighting (packed)     │          │
│  │  - Metadata              │          │
│  └──────────────────────────┘          │
└────────────────────────────────────────┘
```

### 4.2 World Generation

#### 4.2.1 Generation Pipeline

```rust
/// Multi-stage generation pipeline
pub struct GenerationPipeline {
    seed: u64,
    noise: NoiseGenerator,
    biomes: BiomeManager,
}

impl GenerationPipeline {
    /// Generate a chunk through all stages
    pub fn generate(&self, chunk_pos: IVec3) -> Chunk {
        let mut chunk = Chunk::new(chunk_pos);

        // Stage 1: Heightmap
        let heights = self.generate_heightmap(chunk_pos);

        // Stage 2: Surface composition
        self.apply_surface(&mut chunk, &heights);

        // Stage 3: Caves
        self.carve_caves(&mut chunk);

        // Stage 4: Structures (trees, ores)
        self.place_structures(&mut chunk, &heights);

        // Stage 5: Lighting precompute
        self.compute_initial_lighting(&mut chunk);

        chunk.gen_stage = GenStage::Complete;
        chunk.flags |= ChunkFlags::FULLY_GENERATED;

        chunk
    }

    fn generate_heightmap(&self, chunk_pos: IVec3) -> [[f32; 16]; 16] {
        let mut heights = [[0.0; 16]; 16];

        for x in 0..16 {
            for z in 0..16 {
                let world_x = chunk_pos.x * 16 + x;
                let world_z = chunk_pos.z * 16 + z;

                // Multi-octave noise
                let base = self.noise.fbm_2d(
                    world_x as f32,
                    world_z as f32,
                    5,      // octaves
                    2.0,    // lacunarity
                    0.55,   // persistence
                    0.008,  // scale
                );

                let detail = self.noise.fbm_2d(
                    world_x as f32 + 1000.0,
                    world_z as f32 + 1000.0,
                    3,
                    2.1,
                    0.5,
                    0.02,
                );

                heights[x as usize][z as usize] = 64.0 + base * 24.0 + detail * 8.0;
            }
        }

        heights
    }
}
```

#### 4.2.2 Noise System

```rust
/// Deterministic noise generator
pub struct NoiseGenerator {
    seed: u64,
    simplex: SimplexNoise,
    perlin: PerlinNoise,
}

impl NoiseGenerator {
    /// Create seeded noise generator
    pub fn new(seed: u64) -> Self {
        Self {
            seed,
            simplex: SimplexNoise::new(seed),
            perlin: PerlinNoise::new(seed),
        }
    }

    /// Fractional Brownian Motion
    pub fn fbm_2d(
        &self,
        x: f32,
        z: f32,
        octaves: u32,
        lacunarity: f32,
        persistence: f32,
        scale: f32,
    ) -> f32 {
        let mut amplitude = 1.0;
        let mut frequency = 1.0;
        let mut sum = 0.0;
        let mut normalization = 0.0;

        for _ in 0..octaves {
            sum += amplitude * self.simplex.noise_2d(
                x * scale * frequency,
                z * scale * frequency,
            );
            normalization += amplitude;
            amplitude *= persistence;
            frequency *= lacunarity;
        }

        sum / normalization
    }
}
```

### 4.3 Lighting System

#### 4.3.1 Lighting Model

```
Lighting Propagation:
- Two channels: skylight (0-15) and block light (0-15)
- Manhattan distance propagation with attenuation
- Skylight floods from top of world downward
- Block light spreads from emissive blocks

Algorithm: BFS with dual queues
1. Light addition queue: start from sources
2. Light removal queue: track removed lights
3. Process additions: propagate to neighbors with attenuation
4. Process removals: recompute affected regions
```

```rust
pub struct LightingEngine {
    add_queue: VecDeque<LightNode>,
    remove_queue: VecDeque<LightNode>,
}

struct LightNode {
    pos: IVec3,
    light_level: u8,
}

impl LightingEngine {
    /// Update lighting after block change
    pub fn update_block(&mut self, world: &mut VoxelWorld, pos: IVec3, old_block: Voxel, new_block: Voxel) {
        // Handle removal of light source
        if old_block.id.is_emissive() {
            self.remove_light(world, pos, LightChannel::Block);
        }

        // Handle addition of light source
        if new_block.id.is_emissive() {
            let emission = new_block.id.light_emission();
            self.add_light(world, pos, emission, LightChannel::Block);
        }

        // Handle opacity changes
        if old_block.id.is_transparent() != new_block.id.is_transparent() {
            self.propagate_sunlight(world, pos);
        }

        // Process queues
        self.process_add_queue(world);
        self.process_remove_queue(world);
    }

    fn propagate_light(&mut self, world: &mut VoxelWorld, pos: IVec3, level: u8, channel: LightChannel) {
        if level <= 1 {
            return;
        }

        let neighbors = [
            pos + IVec3::new(1, 0, 0),
            pos + IVec3::new(-1, 0, 0),
            pos + IVec3::new(0, 1, 0),
            pos + IVec3::new(0, -1, 0),
            pos + IVec3::new(0, 0, 1),
            pos + IVec3::new(0, 0, -1),
        ];

        let new_level = level.saturating_sub(1);

        for neighbor_pos in neighbors {
            let voxel = world.get(neighbor_pos);
            if voxel.id.is_transparent() {
                let current = world.get_light(neighbor_pos, channel);
                if new_level > current {
                    world.set_light(neighbor_pos, new_level, channel);
                    self.add_queue.push_back(LightNode {
                        pos: neighbor_pos,
                        light_level: new_level,
                    });
                }
            }
        }
    }
}
```

### 4.4 Rendering System

#### 4.4.1 Greedy Meshing Algorithm

```rust
/// Greedy meshing for optimal quad reduction
pub struct GreedyMesher {
    vertex_buffer: Vec<Vertex>,
    index_buffer: Vec<u32>,
}

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct Vertex {
    pub position: [f32; 3],
    pub normal: [f32; 3],
    pub uv: [f32; 2],
    pub light: [f32; 4],  // AO + sky + block
    pub color: [f32; 3],
}

impl GreedyMesher {
    pub fn mesh_chunk(&mut self, chunk: &Chunk, world: &VoxelWorld) -> ChunkMesh {
        self.vertex_buffer.clear();
        self.index_buffer.clear();

        // Mesh each axis direction
        for axis in [Axis::X, Axis::Y, Axis::Z] {
            for dir in [Direction::Pos, Direction::Neg] {
                self.mesh_face(chunk, world, axis, dir);
            }
        }

        ChunkMesh {
            vertices: self.vertex_buffer.clone(),
            indices: self.index_buffer.clone(),
            vertex_hash: self.compute_hash(&self.vertex_buffer),
        }
    }

    fn mesh_face(&mut self, chunk: &Chunk, world: &VoxelWorld, axis: Axis, dir: Direction) {
        let (u_axis, v_axis) = axis.tangent_axes();
        let normal = axis.normal(dir);

        // Mask for greedy meshing
        let mut mask = [None; 16 * 256];

        // Slice along axis
        for slice in 0..16 {
            // Build mask
            self.build_face_mask(chunk, world, axis, dir, slice, &mut mask);

            // Greedy merge
            for v in 0..256 {
                for u in 0..16 {
                    let idx = v * 16 + u;
                    if let Some(block_id) = mask[idx] {
                        // Find max width
                        let width = self.find_run_width(&mask, u, v, block_id);

                        // Find max height
                        let height = self.find_run_height(&mask, u, v, width, block_id);

                        // Emit quad
                        self.emit_quad(
                            chunk.pos,
                            axis,
                            dir,
                            u, v, slice,
                            width, height,
                            block_id,
                            chunk,
                        );

                        // Clear merged region
                        for dv in 0..height {
                            for du in 0..width {
                                mask[(v + dv) * 16 + (u + du)] = None;
                            }
                        }
                    }
                }
            }
        }
    }

    fn emit_quad(
        &mut self,
        chunk_pos: IVec3,
        axis: Axis,
        dir: Direction,
        u: usize, v: usize, slice: usize,
        width: usize, height: usize,
        block_id: BlockId,
        chunk: &Chunk,
    ) {
        let base_idx = self.vertex_buffer.len() as u32;

        // Calculate world positions
        let positions = self.calculate_quad_positions(
            chunk_pos, axis, dir, u, v, slice, width, height,
        );

        // Calculate lighting (per-vertex with AO)
        let lights = self.calculate_quad_lighting(
            chunk, axis, dir, u, v, slice, width, height,
        );

        // Emit 4 vertices
        for i in 0..4 {
            self.vertex_buffer.push(Vertex {
                position: positions[i],
                normal: axis.normal(dir).to_array(),
                uv: QUAD_UVS[i],
                light: lights[i],
                color: [1.0, 1.0, 1.0],
            });
        }

        // Emit 2 triangles (6 indices)
        self.index_buffer.extend_from_slice(&[
            base_idx, base_idx + 1, base_idx + 2,
            base_idx + 2, base_idx + 3, base_idx,
        ]);
    }
}
```

#### 4.4.2 Render Pipeline

```rust
/// wgpu rendering pipeline
pub struct Renderer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    surface: Option<wgpu::Surface>,

    // Pipelines
    opaque_pipeline: wgpu::RenderPipeline,
    transparent_pipeline: wgpu::RenderPipeline,

    // Resources
    camera_buffer: wgpu::Buffer,
    atlas_texture: wgpu::Texture,
    depth_texture: wgpu::Texture,

    // Mesh cache
    chunk_meshes: HashMap<IVec3, GpuMesh>,
}

pub struct GpuMesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
}

impl Renderer {
    pub fn render_frame(&mut self, world: &VoxelWorld, camera: &Camera) {
        // Update camera uniform
        self.update_camera_buffer(camera);

        // Frustum culling
        let visible_chunks = self.cull_chunks(world, camera);

        // Begin render pass
        let frame = self.surface.as_ref().unwrap().get_current_texture().unwrap();
        let view = frame.texture.create_view(&Default::default());

        let mut encoder = self.device.create_command_encoder(&Default::default());

        {
            let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("main_pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color {
                            r: 0.53,
                            g: 0.71,
                            b: 1.0,
                            a: 1.0,
                        }),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                    view: &self.depth_texture_view,
                    depth_ops: Some(wgpu::Operations {
                        load: wgpu::LoadOp::Clear(1.0),
                        store: wgpu::StoreOp::Store,
                    }),
                    stencil_ops: None,
                }),
                ..Default::default()
            });

            // Render opaque
            pass.set_pipeline(&self.opaque_pipeline);
            for chunk_pos in &visible_chunks {
                if let Some(mesh) = self.chunk_meshes.get(chunk_pos) {
                    pass.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                    pass.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                    pass.draw_indexed(0..mesh.index_count, 0, 0..1);
                }
            }

            // Render transparent (back-to-front sort)
            pass.set_pipeline(&self.transparent_pipeline);
            // ... transparent rendering
        }

        self.queue.submit(std::iter::once(encoder.finish()));
        frame.present();
    }
}
```

#### 4.4.3 Headless Rendering

```rust
/// Headless renderer for testing
pub struct HeadlessRenderer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    render_texture: wgpu::Texture,
    staging_buffer: wgpu::Buffer,
}

impl HeadlessRenderer {
    pub async fn new(width: u32, height: u32) -> Self {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
            backends: wgpu::Backends::all(),
            ..Default::default()
        });

        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference: wgpu::PowerPreference::HighPerformance,
                force_fallback_adapter: false,
                compatible_surface: None,
            })
            .await
            .unwrap();

        let (device, queue) = adapter
            .request_device(&Default::default(), None)
            .await
            .unwrap();

        let render_texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("render_target"),
            size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
            view_formats: &[],
        });

        let staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("staging"),
            size: (width * height * 4) as u64,
            usage: wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::MAP_READ,
            mapped_at_creation: false,
        });

        Self {
            device,
            queue,
            render_texture,
            staging_buffer,
        }
    }

    pub async fn render_snapshot(&mut self, world: &VoxelWorld, camera: &Camera) -> SnapshotResult {
        // Render to texture
        // ... (similar to normal rendering)

        // Copy to staging buffer
        let mut encoder = self.device.create_command_encoder(&Default::default());
        encoder.copy_texture_to_buffer(
            wgpu::ImageCopyTexture {
                texture: &self.render_texture,
                mip_level: 0,
                origin: wgpu::Origin3d::ZERO,
                aspect: wgpu::TextureAspect::All,
            },
            wgpu::ImageCopyBuffer {
                buffer: &self.staging_buffer,
                layout: wgpu::ImageDataLayout {
                    offset: 0,
                    bytes_per_row: Some(self.width * 4),
                    rows_per_image: Some(self.height),
                },
            },
            self.render_texture.size(),
        );
        self.queue.submit(std::iter::once(encoder.finish()));

        // Read pixels
        let buffer_slice = self.staging_buffer.slice(..);
        let (tx, rx) = tokio::sync::oneshot::channel();
        buffer_slice.map_async(wgpu::MapMode::Read, move |result| {
            tx.send(result).unwrap();
        });
        self.device.poll(wgpu::Maintain::Wait);
        rx.await.unwrap().unwrap();

        let data = buffer_slice.get_mapped_range();
        let pixels = data.to_vec();
        drop(data);
        self.staging_buffer.unmap();

        // Compute SHA-256
        let hash = sha256::digest(&pixels);

        SnapshotResult {
            hash,
            width: self.width,
            height: self.height,
            pixels,
        }
    }
}
```

### 4.5 Physics & Collision

```rust
/// AABB collider component
#[derive(Component, Clone, Copy)]
pub struct Collider {
    pub half_extents: Vec3,  // Capsule approximated as tall box
}

/// Collision system
pub fn collision_system(
    mut query: Query<(&mut Transform, &mut Velocity, &Collider)>,
    world: Res<VoxelWorld>,
) {
    for (mut transform, mut velocity, collider) in query.iter_mut() {
        let prev_pos = transform.translation;
        let next_pos = prev_pos + velocity.linear * FIXED_DT;

        let resolved = resolve_collisions(
            prev_pos,
            next_pos,
            collider,
            &world,
        );

        transform.translation = resolved.position;
        velocity.linear = resolved.velocity;
    }
}

fn resolve_collisions(
    prev: Vec3,
    next: Vec3,
    collider: &Collider,
    world: &VoxelWorld,
) -> ResolveResult {
    let mut pos = next;
    let mut vel = (next - prev) / FIXED_DT;
    let mut on_ground = false;

    // Expand AABB
    let min = pos - collider.half_extents;
    let max = pos + collider.half_extents;

    // Find overlapping blocks
    let blocks = world.query_aabb(min, max);

    // Resolve Y first (gravity)
    for block in &blocks {
        if prev.y >= block.max.y && pos.y < block.max.y {
            // Landing on top
            pos.y = block.max.y;
            vel.y = 0.0;
            on_ground = true;
        } else if prev.y + collider.half_extents.y * 2.0 <= block.min.y
            && pos.y + collider.half_extents.y * 2.0 > block.min.y
        {
            // Hitting head
            pos.y = block.min.y - collider.half_extents.y * 2.0;
            vel.y = 0.0;
        }
    }

    // Recompute overlaps after Y
    let min = pos - collider.half_extents;
    let max = pos + collider.half_extents;
    let blocks = world.query_aabb(min, max);

    // Resolve X and Z
    for block in &blocks {
        // X axis
        if prev.x + collider.half_extents.x <= block.min.x
            && pos.x + collider.half_extents.x > block.min.x
        {
            pos.x = block.min.x - collider.half_extents.x;
            vel.x = 0.0;
        } else if prev.x - collider.half_extents.x >= block.max.x
            && pos.x - collider.half_extents.x < block.max.x
        {
            pos.x = block.max.x + collider.half_extents.x;
            vel.x = 0.0;
        }

        // Z axis
        if prev.z + collider.half_extents.z <= block.min.z
            && pos.z + collider.half_extents.z > block.min.z
        {
            pos.z = block.min.z - collider.half_extents.z;
            vel.z = 0.0;
        } else if prev.z - collider.half_extents.z >= block.max.z
            && pos.z - collider.half_extents.z < block.max.z
        {
            pos.z = block.max.z + collider.half_extents.z;
            vel.z = 0.0;
        }
    }

    ResolveResult {
        position: pos,
        velocity: vel,
        on_ground,
    }
}
```

### 4.6 Networking

#### 4.6.1 Protocol Design

```rust
/// Network protocol messages
#[derive(Serialize, Deserialize, Debug)]
pub enum ClientMessage {
    /// Join request
    Join {
        username: String,
        protocol_version: u16,
    },

    /// Player input
    Input {
        tick: u64,
        movement: Vec3,
        look: Vec2,
        actions: InputActions,
    },

    /// Block interaction
    BlockInteraction {
        tick: u64,
        action: BlockAction,
    },

    /// Keepalive
    Ping { timestamp: u64 },
}

#[derive(Serialize, Deserialize, Debug)]
pub enum ServerMessage {
    /// Join response
    JoinResponse {
        player_id: EntityId,
        spawn_pos: Vec3,
        world_seed: u64,
        tick: u64,
    },

    /// Full world state (initial sync)
    InitialState {
        tick: u64,
        chunks: Vec<ChunkData>,
        entities: Vec<EntitySnapshot>,
    },

    /// Delta update (per tick)
    StateDelta {
        tick: u64,
        block_updates: Vec<BlockUpdate>,
        entity_updates: Vec<EntityDelta>,
    },

    /// Chunk data
    ChunkData {
        pos: IVec3,
        data: CompressedChunk,
    },

    /// Keepalive response
    Pong { timestamp: u64 },
}

bitflags::bitflags! {
    pub struct InputActions: u8 {
        const JUMP = 0b0000_0001;
        const CROUCH = 0b0000_0010;
        const SPRINT = 0b0000_0100;
        const USE = 0b0000_1000;
        const ATTACK = 0b0001_0000;
        const DROP = 0b0010_0000;
    }
}
```

#### 4.6.2 Client Prediction

```rust
/// Client-side prediction system
pub struct PredictionSystem {
    /// History of inputs sent to server
    input_history: VecDeque<InputFrame>,

    /// Last acknowledged tick from server
    last_ack_tick: u64,
}

struct InputFrame {
    tick: u64,
    input: PlayerInput,
    predicted_state: TransformSnapshot,
}

impl PredictionSystem {
    pub fn update(&mut self, local_player: &mut Transform, server_state: Option<&EntityDelta>) {
        if let Some(delta) = server_state {
            // Server correction received
            self.reconcile(local_player, delta);
        } else {
            // No correction, continue prediction
            self.predict(local_player);
        }
    }

    fn reconcile(&mut self, transform: &mut Transform, server_state: &EntityDelta) {
        // Find input frame corresponding to server tick
        self.input_history.retain(|frame| frame.tick >= server_state.tick);

        // Check if prediction was correct
        let error = (transform.translation - server_state.position).length();

        if error > 0.1 {
            // Significant misprediction, snap to server state
            transform.translation = server_state.position;
            transform.rotation = server_state.rotation;

            // Re-simulate from server state with queued inputs
            for frame in &self.input_history {
                self.simulate_input(transform, &frame.input);
            }
        }
    }

    fn predict(&mut self, transform: &mut Transform) {
        // Apply current input immediately
        let input = self.gather_current_input();
        self.simulate_input(transform, &input);

        // Store for reconciliation
        self.input_history.push_back(InputFrame {
            tick: self.current_tick,
            input: input.clone(),
            predicted_state: TransformSnapshot::from(transform),
        });
    }

    fn simulate_input(&self, transform: &mut Transform, input: &PlayerInput) {
        // Simulate one tick of movement
        // (matches server physics exactly)
        // ...
    }
}
```

### 4.7 ECS Architecture

```rust
/// Core ECS components
#[derive(Component)]
pub struct Transform {
    pub translation: Vec3,
    pub rotation: Quat,
    pub scale: Vec3,
}

#[derive(Component)]
pub struct Velocity {
    pub linear: Vec3,
    pub angular: Vec3,
}

#[derive(Component)]
pub struct PlayerTag {
    pub player_id: u64,
    pub username: String,
}

#[derive(Component)]
pub struct Health {
    pub current: f32,
    pub max: f32,
}

#[derive(Component)]
pub struct Inventory {
    pub slots: Vec<ItemStack>,
}

#[derive(Component, Clone, Copy)]
pub struct ItemStack {
    pub item_id: ItemId,
    pub count: u16,
}

/// Global resources
#[derive(Resource)]
pub struct VoxelWorld {
    chunks: HashMap<IVec3, Chunk>,
    // ...
}

#[derive(Resource)]
pub struct GameTick {
    pub current: u64,
}

#[derive(Resource)]
pub struct EventBus {
    sinks: Vec<Box<dyn EventSink>>,
}

/// System ordering
pub fn build_simulation_schedule() -> Schedule {
    Schedule::default()
        .add_systems(
            Update,
            (
                // Input
                process_input_system,

                // World updates
                chunk_generation_system,
                lighting_update_system,
                block_tick_system,

                // Entity updates
                ai_system,
                physics_system,
                collision_system,

                // Game logic
                crafting_system,
                inventory_system,
                health_system,

                // Events
                emit_events_system,
            )
            .chain(),
        )
}
```

---

## 5. Testing Infrastructure Design

### 5.1 Event Stream System

#### 5.1.1 Event Schema

```rust
/// Core game event enum
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "kind")]
pub enum GameEvent {
    // Tick events
    TickStart { tick: u64 },
    TickEnd { tick: u64, duration_us: u64 },

    // World events
    BlockPlaced {
        tick: u64,
        pos: [i32; 3],
        by: String,
        block: String,
        state: u16,
    },
    BlockBroken {
        tick: u64,
        pos: [i32; 3],
        by: String,
        block: String,
    },
    ChunkGenerated {
        tick: u64,
        chunk: [i32; 3],
        duration_us: u64,
    },
    ChunkMeshed {
        tick: u64,
        chunk: [i32; 3],
        triangles: u32,
        mesh_sha: String,
    },
    LightingUpdated {
        tick: u64,
        region: [i32; 2],
        updates: u32,
    },

    // Entity events
    EntitySpawned {
        tick: u64,
        entity: String,
        entity_type: String,
        pos: [f32; 3],
    },
    EntityDespawned {
        tick: u64,
        entity: String,
    },
    EntityMoved {
        tick: u64,
        entity: String,
        from: [f32; 3],
        to: [f32; 3],
    },
    EntityDamaged {
        tick: u64,
        entity: String,
        amount: f32,
        source: String,
    },

    // Player events
    InputApplied {
        tick: u64,
        player: String,
        input: String,
    },
    CommandExecuted {
        tick: u64,
        player: String,
        command: String,
    },

    // Network events
    ClientJoined {
        tick: u64,
        player: String,
    },
    ClientLeft {
        tick: u64,
        player: String,
        reason: String,
    },
    PacketStats {
        tick: u64,
        sent_bytes: u64,
        recv_bytes: u64,
        packet_loss: f32,
    },

    // Render events
    SnapshotSaved {
        tick: u64,
        camera: String,
        image_sha: String,
        width: u32,
        height: u32,
    },
    MeshBuilt {
        tick: u64,
        chunk: [i32; 3],
        vertices: u32,
        indices: u32,
    },

    // System events
    Warning {
        tick: u64,
        message: String,
        source: String,
    },
    Error {
        tick: u64,
        message: String,
        source: String,
    },
}
```

#### 5.1.2 Event Bus

```rust
/// Event bus for distributing game events
pub struct EventBus {
    sinks: Vec<Box<dyn EventSink>>,
}

pub trait EventSink: Send + Sync {
    fn on_event(&mut self, event: &GameEvent);
    fn flush(&mut self) -> Result<()>;
}

impl EventBus {
    pub fn emit(&mut self, event: GameEvent) {
        for sink in &mut self.sinks {
            sink.on_event(&event);
        }
    }

    pub fn add_sink(&mut self, sink: Box<dyn EventSink>) {
        self.sinks.push(sink);
    }
}

/// JSONL file recorder
pub struct JsonlRecorder {
    writer: BufWriter<File>,
}

impl EventSink for JsonlRecorder {
    fn on_event(&mut self, event: &GameEvent) {
        let json = serde_json::to_string(event).unwrap();
        writeln!(self.writer, "{}", json).unwrap();
    }

    fn flush(&mut self) -> Result<()> {
        self.writer.flush()?;
        Ok(())
    }
}

/// In-memory collector for tests
pub struct InMemoryCollector {
    events: Vec<GameEvent>,
}

impl EventSink for InMemoryCollector {
    fn on_event(&mut self, event: &GameEvent) {
        self.events.push(event.clone());
    }

    fn flush(&mut self) -> Result<()> {
        Ok(())
    }
}

impl InMemoryCollector {
    pub fn events(&self) -> &[GameEvent] {
        &self.events
    }

    pub fn count_by_kind(&self, kind: &str) -> usize {
        self.events
            .iter()
            .filter(|e| e.kind() == kind)
            .count()
    }

    pub fn find_warnings(&self) -> Vec<&GameEvent> {
        self.events
            .iter()
            .filter(|e| matches!(e, GameEvent::Warning { .. }))
            .collect()
    }
}
```

### 5.2 World Test DSL

#### 5.2.1 DSL Format

```toml
# Example: torch_light.worldtest.toml

[world]
seed = 42
spawn = [0, 65, 0]
time_of_day = "noon"
flat = true
size = [32, 32]  # 32x32 chunks

[[blocks.fill]]
from = [-10, 64, -10]
to = [10, 64, 10]
block = "stone"

[[blocks.fill]]
from = [-10, 65, -10]
to = [10, 70, 10]
block = "air"

[[script]]
tick = 1
action = { spawn_player = { id = "test_player", pos = [0, 66, 0] } }

[[script]]
tick = 5
action = { place = { at = [0, 65, 0], block = "torch", by = "test_player" } }

[[script]]
tick = 10
action = { break = { at = [0, 65, 0], by = "test_player" } }

[[expect]]
by_tick = 6
light = { at = [0, 65, 0], block = 14 }

[[expect]]
by_tick = 6
light = { at = [1, 65, 0], block = 13 }

[[expect]]
by_tick = 11
light = { at = [0, 65, 0], block = 0 }

[[expect]]
by_tick = 100
event = "Warning"
count = 0

[[expect]]
by_tick = 100
event = "Error"
count = 0

[[camera]]
name = "overview"
pos = [8, 72, -8]
look = [0, 65, 0]
fov = 70

[[expect]]
by_tick = 6
snapshot = { camera = "overview", sha = "abc123..." }
```

#### 5.2.2 DSL Parser & Executor

```rust
/// World test scenario
#[derive(Deserialize, Debug)]
pub struct WorldTest {
    pub world: WorldConfig,
    pub blocks: Option<BlockSetup>,
    pub script: Vec<ScriptAction>,
    pub expect: Vec<Expectation>,
    pub camera: Vec<CameraRig>,
}

#[derive(Deserialize, Debug)]
pub struct WorldConfig {
    pub seed: u64,
    pub spawn: [i32; 3],
    pub time_of_day: String,
    pub flat: bool,
    pub size: Option<[i32; 2]>,
}

#[derive(Deserialize, Debug)]
pub struct ScriptAction {
    pub tick: u64,
    pub action: Action,
}

#[derive(Deserialize, Debug)]
#[serde(untagged)]
pub enum Action {
    Place { at: [i32; 3], block: String, by: Option<String> },
    Break { at: [i32; 3], by: Option<String> },
    SpawnPlayer { id: String, pos: [f32; 3] },
    PlayerMove { id: String, to: [f32; 3] },
    Wait { ticks: u64 },
}

#[derive(Deserialize, Debug)]
pub struct Expectation {
    pub by_tick: u64,
    #[serde(flatten)]
    pub condition: ExpectCondition,
}

#[derive(Deserialize, Debug)]
#[serde(untagged)]
pub enum ExpectCondition {
    Light {
        light: LightExpectation,
    },
    Event {
        event: String,
        count: CountCondition,
    },
    Snapshot {
        snapshot: SnapshotExpectation,
    },
    BlockAt {
        block: String,
        at: [i32; 3],
    },
}

#[derive(Deserialize, Debug)]
pub struct LightExpectation {
    pub at: [i32; 3],
    #[serde(default)]
    pub sky: Option<ComparisonValue>,
    #[serde(default)]
    pub block: Option<ComparisonValue>,
}

#[derive(Debug)]
pub enum ComparisonValue {
    Exact(u8),
    GreaterThan(u8),
    LessThan(u8),
}

/// World test executor
pub struct WorldTestExecutor {
    world: VoxelWorld,
    event_bus: EventBus,
    event_collector: InMemoryCollector,
}

impl WorldTestExecutor {
    pub fn run(test: &WorldTest) -> TestResult {
        let mut executor = Self::new(test);

        // Initialize world
        executor.init_world(&test.world);
        executor.setup_blocks(&test.blocks);

        // Execute script
        let max_tick = test.expect.iter()
            .map(|e| e.by_tick)
            .max()
            .unwrap_or(100);

        for tick in 1..=max_tick {
            // Execute scripted actions
            for action in &test.script {
                if action.tick == tick {
                    executor.execute_action(&action.action);
                }
            }

            // Tick simulation
            executor.tick();

            // Check expectations
            for expectation in &test.expect {
                if expectation.by_tick == tick {
                    executor.check_expectation(expectation)?;
                }
            }
        }

        // Generate snapshots
        for camera in &test.camera {
            executor.render_snapshot(camera)?;
        }

        TestResult::Pass
    }

    fn check_expectation(&self, expect: &Expectation) -> Result<()> {
        match &expect.condition {
            ExpectCondition::Light { light } => {
                let actual = self.world.get_light(light.at.into());

                if let Some(sky) = &light.sky {
                    sky.check(actual.sky)?;
                }

                if let Some(block) = &light.block {
                    block.check(actual.block)?;
                }

                Ok(())
            }
            ExpectCondition::Event { event, count } => {
                let actual_count = self.event_collector.count_by_kind(event);
                count.check(actual_count)?;
                Ok(())
            }
            ExpectCondition::Snapshot { snapshot } => {
                // Snapshot comparison handled separately
                Ok(())
            }
            ExpectCondition::BlockAt { block, at } => {
                let actual = self.world.get((*at).into());
                if actual.id.name() != block {
                    return Err(TestError::BlockMismatch {
                        expected: block.clone(),
                        actual: actual.id.name().to_string(),
                        pos: *at,
                    });
                }
                Ok(())
            }
        }
    }
}
```

### 5.3 Headless Snapshot Testing

```rust
/// Snapshot test configuration
pub struct SnapshotTest {
    pub name: String,
    pub camera: CameraRig,
    pub resolution: (u32, u32),
    pub expected_sha: Option<String>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct CameraRig {
    pub name: String,
    pub pos: [f32; 3],
    pub look: [f32; 3],
    pub fov: f32,
}

/// Snapshot result
pub struct SnapshotResult {
    pub hash: String,
    pub width: u32,
    pub height: u32,
    pub pixels: Vec<u8>,
}

/// Golden file manager
pub struct GoldenManager {
    platform: String,
    goldens_dir: PathBuf,
}

impl GoldenManager {
    pub fn new() -> Self {
        let platform = Self::detect_platform();
        let goldens_dir = PathBuf::from("goldens").join(&platform);

        Self {
            platform,
            goldens_dir,
        }
    }

    fn detect_platform() -> String {
        #[cfg(target_os = "linux")]
        return "linux_vulkan".to_string();

        #[cfg(target_os = "windows")]
        return "win_dx12".to_string();

        #[cfg(target_os = "macos")]
        return "macos_metal".to_string();
    }

    pub fn check_snapshot(&self, test_name: &str, result: &SnapshotResult) -> TestResult {
        let golden_path = self.goldens_dir.join(format!("{}.sha256", test_name));

        if !golden_path.exists() {
            // First run, save as golden
            std::fs::create_dir_all(&self.goldens_dir).unwrap();
            std::fs::write(&golden_path, &result.hash).unwrap();

            // Also save PNG for human inspection
            let png_path = self.goldens_dir.join(format!("{}.png", test_name));
            self.save_png(&png_path, result);

            return TestResult::NewGolden;
        }

        let expected_hash = std::fs::read_to_string(&golden_path).unwrap();

        if result.hash == expected_hash.trim() {
            TestResult::Pass
        } else {
            // Save actual for comparison
            let actual_path = self.goldens_dir.join(format!("{}.actual.png", test_name));
            self.save_png(&actual_path, result);

            TestResult::SnapshotMismatch {
                expected: expected_hash.trim().to_string(),
                actual: result.hash.clone(),
            }
        }
    }

    fn save_png(&self, path: &Path, result: &SnapshotResult) {
        // Save PNG using image crate
        image::save_buffer(
            path,
            &result.pixels,
            result.width,
            result.height,
            image::ColorType::Rgba8,
        )
        .unwrap();
    }
}
```

### 5.4 Property-Based Testing

```rust
/// Property tests for lighting
#[cfg(test)]
mod lighting_properties {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn light_propagation_is_monotonic(
            source_pos in any_block_pos(),
            emission in 1u8..=15,
        ) {
            let mut world = VoxelWorld::new_empty();
            let mut lighting = LightingEngine::new();

            // Place emissive block
            world.set(source_pos, Voxel::new(BlockId::TORCH, BlockState::default()));
            lighting.add_light(&mut world, source_pos, emission, LightChannel::Block);
            lighting.process(&mut world);

            // Check monotonicity: light never increases away from source
            for neighbor in adjacent_blocks(source_pos) {
                let source_light = world.get_light(source_pos, LightChannel::Block);
                let neighbor_light = world.get_light(neighbor, LightChannel::Block);

                prop_assert!(neighbor_light <= source_light);
            }
        }

        #[test]
        fn light_is_bounded(
            source_pos in any_block_pos(),
            emission in 1u8..=15,
        ) {
            let mut world = VoxelWorld::new_empty();
            let mut lighting = LightingEngine::new();

            world.set(source_pos, Voxel::new(BlockId::TORCH, BlockState::default()));
            lighting.add_light(&mut world, source_pos, emission, LightChannel::Block);
            lighting.process(&mut world);

            // Check all blocks have light <= emission
            for pos in world.all_positions() {
                let light = world.get_light(pos, LightChannel::Block);
                prop_assert!(light <= emission);
            }
        }
    }
}

/// Property tests for meshing
#[cfg(test)]
mod meshing_properties {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn greedy_meshing_reduces_quads(chunk in any_chunk()) {
            let greedy_mesh = GreedyMesher::new().mesh_chunk(&chunk, &world);
            let naive_mesh = NaiveMesher::new().mesh_chunk(&chunk, &world);

            let greedy_quads = greedy_mesh.indices.len() / 6;
            let naive_quads = naive_mesh.indices.len() / 6;

            prop_assert!(greedy_quads <= naive_quads);
        }

        #[test]
        fn mesh_is_deterministic(chunk in any_chunk()) {
            let mesh1 = GreedyMesher::new().mesh_chunk(&chunk, &world);
            let mesh2 = GreedyMesher::new().mesh_chunk(&chunk, &world);

            prop_assert_eq!(mesh1.vertex_hash, mesh2.vertex_hash);
        }

        #[test]
        fn no_overlapping_quads(chunk in any_chunk()) {
            let mesh = GreedyMesher::new().mesh_chunk(&chunk, &world);

            // Extract quads and check for overlaps
            let quads = extract_quads(&mesh);
            for (i, q1) in quads.iter().enumerate() {
                for q2 in quads.iter().skip(i + 1) {
                    prop_assert!(!quads_overlap(q1, q2));
                }
            }
        }
    }
}
```

### 5.5 Performance Regression Testing

```rust
/// Performance metrics collector
pub struct MetricsCollector {
    metrics: HashMap<String, MetricSeries>,
}

#[derive(Serialize, Deserialize)]
pub struct MetricSeries {
    pub name: String,
    pub samples: Vec<MetricSample>,
}

#[derive(Serialize, Deserialize)]
pub struct MetricSample {
    pub timestamp: u64,
    pub value: f64,
    pub unit: String,
}

impl MetricsCollector {
    pub fn record(&mut self, name: &str, value: f64, unit: &str) {
        let series = self.metrics.entry(name.to_string()).or_insert_with(|| {
            MetricSeries {
                name: name.to_string(),
                samples: Vec::new(),
            }
        });

        series.samples.push(MetricSample {
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            value,
            unit: unit.to_string(),
        });
    }

    pub fn save(&self, path: &Path) -> Result<()> {
        let json = serde_json::to_string_pretty(&self.metrics)?;
        std::fs::write(path, json)?;
        Ok(())
    }
}

/// Performance test scenario
#[derive(Deserialize)]
pub struct PerfTest {
    pub name: String,
    pub scenario: String,
    pub thresholds: HashMap<String, Threshold>,
}

#[derive(Deserialize)]
pub struct Threshold {
    pub p95: f64,
    pub p99: f64,
    pub max: f64,
}

/// Performance test runner
pub fn run_perf_test(test: &PerfTest) -> Result<PerfResult> {
    let mut metrics = MetricsCollector::new();

    // Load scenario
    let scenario = load_worldtest(&test.scenario)?;

    // Run scenario with timing
    let mut executor = WorldTestExecutor::new(&scenario);

    for tick in 0..1000 {
        let start = Instant::now();
        executor.tick();
        let duration = start.elapsed();

        metrics.record("tick_time_us", duration.as_micros() as f64, "microseconds");

        // Record subsystem times
        if let Some(gen_time) = executor.last_gen_time() {
            metrics.record("chunk_gen_us", gen_time.as_micros() as f64, "microseconds");
        }

        if let Some(mesh_time) = executor.last_mesh_time() {
            metrics.record("mesh_time_us", mesh_time.as_micros() as f64, "microseconds");
        }
    }

    // Analyze metrics
    let results = analyze_metrics(&metrics, &test.thresholds)?;

    metrics.save(Path::new(&format!("metrics/{}.json", test.name)))?;

    Ok(results)
}

fn analyze_metrics(
    metrics: &MetricsCollector,
    thresholds: &HashMap<String, Threshold>,
) -> Result<PerfResult> {
    let mut passed = true;
    let mut violations = Vec::new();

    for (metric_name, threshold) in thresholds {
        let series = metrics.metrics.get(metric_name)
            .ok_or_else(|| anyhow!("Metric {} not found", metric_name))?;

        let mut values: Vec<f64> = series.samples.iter().map(|s| s.value).collect();
        values.sort_by(|a, b| a.partial_cmp(b).unwrap());

        let p95 = percentile(&values, 0.95);
        let p99 = percentile(&values, 0.99);
        let max = values.last().copied().unwrap_or(0.0);

        if p95 > threshold.p95 {
            passed = false;
            violations.push(format!(
                "{}: p95 {:.2} > threshold {:.2}",
                metric_name, p95, threshold.p95
            ));
        }

        if p99 > threshold.p99 {
            passed = false;
            violations.push(format!(
                "{}: p99 {:.2} > threshold {:.2}",
                metric_name, p99, threshold.p99
            ));
        }

        if max > threshold.max {
            passed = false;
            violations.push(format!(
                "{}: max {:.2} > threshold {:.2}",
                metric_name, max, threshold.max
            ));
        }
    }

    Ok(PerfResult {
        passed,
        violations,
    })
}
```

---

## 6. Data Models & Formats

### 6.1 Block Registry Format

```toml
# assets/blocks.toml

[[block]]
name = "air"
id = 0
opaque = false
transparent = true
collidable = false
solid = false
light_emission = 0
light_attenuation = 0
render_model = "none"

[[block]]
name = "stone"
id = 1
opaque = true
transparent = false
collidable = true
solid = true
hardness = 1.5
tool = "pickaxe"
render_model = "cube"
texture = "stone"

[[block]]
name = "grass"
id = 2
opaque = true
transparent = false
collidable = true
solid = true
hardness = 0.6
tool = "shovel"
render_model = "cube"
texture_top = "grass_top"
texture_side = "grass_side"
texture_bottom = "dirt"

[[block]]
name = "torch"
id = 50
opaque = false
transparent = true
collidable = false
solid = false
light_emission = 14
render_model = "sprite"
texture = "torch"
```

### 6.2 Recipe Format

```json
{
  "recipes": [
    {
      "type": "shaped",
      "pattern": [
        "SS",
        "SS"
      ],
      "key": {
        "S": { "block": "stone" }
      },
      "result": {
        "item": "stone_bricks",
        "count": 4
      }
    },
    {
      "type": "shapeless",
      "ingredients": [
        { "block": "wood" }
      ],
      "result": {
        "item": "planks",
        "count": 4
      }
    }
  ]
}
```

### 6.3 Save Format

```
World Save Structure:

world_name/
├── level.json              # World metadata
│   {
│     "version": "1.0.0",
│     "seed": 123456789,
│     "spawn": [0, 65, 0],
│     "time": 1000,
│     "game_mode": "survival"
│   }
│
├── region/                 # Region files
│   ├── r.0.0.rg           # Region (0, 0)
│   ├── r.0.1.rg           # Region (0, 1)
│   └── ...
│
└── players/                # Player data
    ├── player1.json
    │   {
    │     "id": "player1",
    │     "pos": [12.5, 67.0, -3.2],
    │     "health": 20.0,
    │     "inventory": [
    │       {"item": "stone", "count": 64},
    │       {"item": "torch", "count": 12}
    │     ]
    │   }
    └── ...
```

---

## 7. Implementation Strategy

### 7.1 Development Phases

#### Phase 0: Foundation (Week 1-2)

**Goals:**
- Workspace setup with all crates
- Core types (IVec3, BlockId, Voxel, etc.)
- ECS integration (bevy_ecs)
- Basic testkit structure

**Deliverables:**
- Compiling workspace
- Core types with unit tests
- ECS hello-world
- Event bus with JSONL recorder

**Acceptance:**
- `cargo test --all` passes
- Can record and replay simple event stream

#### Phase 1: World & Rendering (Week 3-6)

**Goals:**
- Chunk storage and management
- Noise-based terrain generation
- Greedy meshing
- wgpu renderer (window + headless)
- Basic camera controls

**Deliverables:**
- Chunk store with get/set
- Terrain generator (superflat + noise-based)
- Greedy mesher with deterministic output
- wgpu renderer rendering chunks
- Headless renderer for snapshots

**Acceptance:**
- Load superflat world, 60 FPS with 9x9 chunks
- "Superflat Basics" worldtest passes
- Headless snapshot generates deterministic SHA
- Mesh hashes stable across runs

#### Phase 2: Lighting & Persistence (Week 7-9)

**Goals:**
- Skylight system
- Block light (emissive blocks)
- Lighting propagation (BFS)
- Region file save/load (zstd compressed)
- World versioning

**Deliverables:**
- Lighting engine with sky + block light
- "Torch Light" worldtest passes
- Save/load to .rg files
- World migration system

**Acceptance:**
- Torch placement updates light within 2 ticks
- Removing torch clears light correctly
- Save/load preserves world bit-exactly
- No light seams at chunk borders

#### Phase 3: Physics & Interaction (Week 10-11)

**Goals:**
- AABB collision system
- Player movement (walk, jump, fly)
- Block raycasting (pick)
- Block place/break
- Inventory & crafting basics

**Deliverables:**
- Physics system with AABB collision
- Player controller
- Raycast block targeting
- Place/break with undo
- Inventory UI
- Recipe loading

**Acceptance:**
- No tunneling at normal speeds
- Standing on block is stable
- Can place/break blocks accurately
- Crafting simple recipes works

#### Phase 4: Networking (Week 12-14)

**Goals:**
- QUIC transport (quinn)
- Client-server architecture
- Chunk streaming
- Client prediction & reconciliation
- State delta compression

**Deliverables:**
- Server binary (headless)
- Client binary (windowed)
- Join/leave protocol
- Chunk streaming near players
- Input prediction with reconciliation

**Acceptance:**
- Two clients can join server
- Both see synchronized world state
- Block placement replicates correctly
- No desync under 100ms RTT scenario

#### Phase 5: Polish & Testing (Week 15-16)

**Goals:**
- Complete worldtest suite
- Golden snapshots for all scenarios
- Performance regression tests
- Property-based test coverage
- Documentation

**Deliverables:**
- 20+ worldtest scenarios
- Golden snapshot coverage
- Perf test suite
- Proptest coverage for core systems
- README and architecture docs

**Acceptance:**
- All worldtests pass in CI
- No warnings/errors in test runs
- Performance within targets
- 80%+ code coverage

### 7.2 Milestone Definitions

#### Milestone A: Engine Core

**Duration:** 6 weeks
**Deliverables:**
- Chunk store with generation
- Greedy meshing
- wgpu renderer (window + headless)
- Camera & player movement
- Block place/break

**Acceptance Criteria:**
1. Load superflat world
2. Render 9x9 chunks at 60 FPS
3. Place/break blocks
4. Fly mode functional
5. "Superflat Basics" worldtest passes
6. Event stream stable
7. Headless snapshot deterministic

#### Milestone B: Lighting & Save

**Duration:** 3 weeks
**Deliverables:**
- Skylight + emissive lighting
- Region file persistence
- Save/load world
- Crafting/inventory basics

**Acceptance Criteria:**
1. "Torch Light" worldtest passes
2. Torch updates light within 2 ticks
3. Save/reload preserves world exactly
4. No chunk border lighting seams
5. Can craft simple recipes

#### Milestone C: Networking (LAN)

**Duration:** 3 weeks
**Deliverables:**
- Server authoritative simulation
- Chunk streaming
- Client prediction
- Multiplayer sync

**Acceptance Criteria:**
1. Two clients build same tower
2. Server event stream matches clients
3. No desync in 100ms RTT test
4. Chunk streaming works within 10 chunks
5. "Multiplayer Sync" worldtest passes

#### Milestone D: Biomes & Polish

**Duration:** 4 weeks
**Deliverables:**
- Biome system
- Trees, ores, structures
- Weather toggle
- Full test coverage
- Performance tuning

**Acceptance Criteria:**
1. Biome transitions seamless
2. No terrain/mesh seams
3. All worldtests pass
4. Performance targets met
5. Golden snapshots locked

### 7.3 Testing Strategy per Phase

| Phase | Unit Tests | Integration Tests | World Tests | Snapshots | Property Tests |
|-------|-----------|-------------------|-------------|-----------|----------------|
| 0 | ✓ | - | - | - | - |
| 1 | ✓ | ✓ | Superflat | Basic | Mesh |
| 2 | ✓ | ✓ | Lighting | Full | Lighting |
| 3 | ✓ | ✓ | Physics | Full | Collision |
| 4 | ✓ | ✓ | Network | Full | - |
| 5 | ✓ | ✓ | Complete | Locked | Complete |

---

## 8. Risk Analysis & Mitigation

### 8.1 Technical Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Cross-platform render variance** | High | High | - Per-backend golden sets<br>- Lock atlas hashing<br>- Disable temporal effects<br>- Test on all platforms early |
| **Determinism drift** | Medium | High | - Unit tests for replay<br>- Schema versioning<br>- Seed audit system<br>- CI replay validation |
| **Mesh hash instability** | Medium | Medium | - Integer-only mesh gen<br>- Vertex ordering guarantee<br>- Hash validation tests |
| **CI GPU availability** | Medium | Medium | - Headless + software fallback (SwiftShader)<br>- Cache goldens per adapter<br>- Optional GPU tests |
| **Network desync** | High | High | - Extensive sync tests<br>- Reconciliation validation<br>- Replay server logs<br>- Delta verification |
| **Performance degradation** | Medium | High | - Continuous perf tests<br>- Baseline comparison in CI<br>- Profiling integration<br>- Budget alerts |

### 8.2 Schedule Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Greedy meshing complexity** | Low | Medium | - Start with naive mesher<br>- Optimize incrementally |
| **Lighting edge cases** | Medium | Medium | - Extensive property tests<br>- Reference implementation<br>- Visualize propagation |
| **QUIC integration issues** | Medium | Medium | - Use proven library (quinn)<br>- Prototype early<br>- Fallback to TCP |
| **Test infrastructure overhead** | High | Low | - Build incrementally<br>- Reuse test fixtures<br>- Parallelize tests |

### 8.3 Quality Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| **Incomplete test coverage** | Low | High | - Coverage tracking<br>- Mandatory tests for PRs<br>- Test review process |
| **Golden file drift** | Medium | Medium | - Automated updates via PR<br>- Visual diff tools<br>- Approval workflow |
| **Event schema breaking changes** | Low | High | - Schema versioning<br>- Migration tests<br>- Compatibility suite |

---

## 9. Success Criteria

### 9.1 Functional Requirements

- [ ] Infinite terrain generation (chunked, seeded)
- [ ] Day/night cycle
- [ ] Core block loop: mine, place, craft
- [ ] Inventory with 36 slots
- [ ] Lighting (skylight + emissive)
- [ ] Save/load world
- [ ] Singleplayer mode
- [ ] LAN/online multiplayer
- [ ] Creative & survival modes
- [ ] Basic UI (hotbar, crosshair, inventory)

### 9.2 Non-Functional Requirements

**Performance:**
- [ ] 20 TPS simulation tick
- [ ] 60 FPS rendering (typical scene)
- [ ] <8ms chunk generation
- [ ] <2.5ms sim tick (single player, 4 chunk radius)
- [ ] <6ms GPU frame (entry-level dGPU)
- [ ] <1.5GB memory (9x9 chunks @ 256 height)

**Determinism:**
- [ ] Fixed timestep simulation
- [ ] Seeded RNG (no wall-clock in sim)
- [ ] Replay input logs produce identical output
- [ ] Mesh generation deterministic (hash stable)

**Testing:**
- [ ] 20+ worldtest scenarios pass
- [ ] Golden snapshots match on all platforms
- [ ] No warnings/errors in test runs
- [ ] Property tests for core systems
- [ ] 80%+ code coverage

**Quality:**
- [ ] Clippy clean (no warnings)
- [ ] Rustfmt formatted
- [ ] All CI checks pass
- [ ] Documentation complete

### 9.3 Milestone Acceptance Gates

**Milestone A:**
- [ ] Render 9x9 chunks @ 60 FPS
- [ ] "Superflat Basics" worldtest passes
- [ ] Headless snapshot SHA deterministic
- [ ] Place/break blocks functional
- [ ] Mesh hash stable

**Milestone B:**
- [ ] "Torch Light" worldtest passes
- [ ] Light updates within 2 ticks
- [ ] Save/reload bit-exact
- [ ] No lighting seams

**Milestone C:**
- [ ] 2 clients sync correctly
- [ ] "Multiplayer Sync" worldtest passes
- [ ] No desync under 100ms RTT
- [ ] Event streams match

**Milestone D:**
- [ ] All worldtests pass
- [ ] Performance targets met
- [ ] Golden snapshots locked
- [ ] Biomes seamless

---

## 10. Appendices

### 10.1 Performance Targets (Detailed)

```
Target Hardware: Mid-range desktop
- CPU: 4+ cores @ 3.0 GHz
- GPU: GTX 1060 / RX 580 / M1
- RAM: 8 GB

Simulation:
- Tick rate: 20 TPS (50ms budget)
- Tick time: <2.5ms (single player, 4 chunk radius)
- Chunk gen: <8ms/chunk (single-threaded)
- Lighting update: <1ms/tick (typical)
- Physics: <0.5ms/tick (10 entities)

Rendering:
- Frame rate: 60 FPS (16.67ms budget)
- GPU time: <6ms (typical scene)
- Mesh generation: <10ms/chunk (greedy)
- Frustum culling: <0.2ms (100 chunks)

Memory:
- Base: 200 MB
- Per chunk: ~80 KB (16x256x16 @ 3 bytes/voxel)
- 9x9 area (81 chunks): ~800 MB
- Target: <1.5 GB (with overhead)

Network:
- Latency: <30ms avg reconciliation under 100ms RTT
- Bandwidth: <50 KB/s per client (typical)
- Delta compression: >80% reduction
```

### 10.2 Testing Infrastructure Cost

```
CI Cost Estimate:

Per PR:
- Lint + unit tests: 5 min
- Worldtests (20 scenarios): 10 min
- Snapshot tests: 8 min (3 platforms)
- Property tests: 5 min
- Perf tests: 10 min
Total: ~40 min/PR

Artifact Storage:
- Event streams: 1 MB/test × 20 = 20 MB
- Snapshots: 2 MB/test × 20 × 3 = 120 MB
- Metrics: 100 KB/test × 5 = 500 KB
Total per run: ~140 MB

Retention: 30 days
Estimated monthly storage: ~15 GB (assuming 100 PRs/month)
```

### 10.3 Example worldtest Scenarios

```
scenarios/
├── superflat.worldtest.toml          # Basic flat world
├── torch_light.worldtest.toml        # Lighting propagation
├── cave_lighting.worldtest.toml      # Cave lighting edge cases
├── chunk_border.worldtest.toml       # Chunk border seams
├── collision_basic.worldtest.toml    # AABB collision
├── collision_stairs.worldtest.toml   # Step-height
├── raycast_pick.worldtest.toml       # Block targeting
├── crafting_basic.worldtest.toml     # Simple recipes
├── inventory_full.worldtest.toml     # Inventory edge cases
├── multiplayer_sync.worldtest.toml   # Network sync
├── chunk_streaming.worldtest.toml    # Chunk load/unload
├── save_reload.worldtest.toml        # Persistence
├── biome_transition.worldtest.toml   # Biome borders
├── structure_gen.worldtest.toml      # Tree/ore placement
├── mesh_stability.worldtest.toml     # Mesh hash stability
├── lighting_removal.worldtest.toml   # Light source removal
├── water_spread.worldtest.toml       # Fluid simulation (if enabled)
├── perf_megaforest.worldtest.toml    # Performance stress test
├── perf_cavecity.worldtest.toml      # Performance stress test
└── regression_*.worldtest.toml       # Bug regression tests
```

### 10.4 Event Stream Examples

```jsonl
{"kind":"TickStart","tick":1}
{"kind":"ChunkGenerated","tick":1,"chunk":[0,0,0],"duration_us":6234}
{"kind":"ChunkMeshed","tick":1,"chunk":[0,0,0],"triangles":18240,"mesh_sha":"3bc2e7..."}
{"kind":"LightingUpdated","tick":1,"region":[0,0],"updates":65536}
{"kind":"TickEnd","tick":1,"duration_us":8912}

{"kind":"TickStart","tick":5}
{"kind":"InputApplied","tick":5,"player":"test_player","input":"place_block"}
{"kind":"BlockPlaced","tick":5,"pos":[0,65,0],"by":"Player(test_player)","block":"torch","state":0}
{"kind":"LightingUpdated","tick":5,"region":[0,0],"updates":127}
{"kind":"TickEnd","tick":5,"duration_us":1234}

{"kind":"TickStart","tick":6}
{"kind":"SnapshotSaved","tick":6,"camera":"overview","image_sha":"6a49c7...","width":1280,"height":720}
{"kind":"TickEnd","tick":6,"duration_us":892}
```

### 10.5 Dependency List

```toml
[dependencies]
# Core
glam = "0.24"           # Math library
bytemuck = "1.14"       # Type casting
bitflags = "2.4"        # Bit flags

# ECS
bevy_ecs = "0.12"       # Entity-component-system

# Rendering
wgpu = "0.18"           # Graphics API
image = "0.24"          # Image loading/saving

# Networking
quinn = "0.10"          # QUIC transport
rustls = "0.22"         # TLS

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"      # JSON
bincode = "1.3"         # Binary serialization
postcard = "1.0"        # Compact binary

# Compression
zstd = "0.13"           # Compression

# Noise
noise = "0.8"           # Procedural noise

# Async
tokio = { version = "1.35", features = ["full"] }

# Logging
tracing = "0.1"         # Structured logging
tracing-subscriber = "0.3"

# Testing
proptest = "1.4"        # Property-based testing
criterion = "0.5"       # Benchmarking

# Hashing
sha2 = "0.10"           # SHA-256

# Parsing
toml = "0.8"            # TOML parsing

# WASM (optional)
wasmtime = { version = "16.0", optional = true }

[dev-dependencies]
cargo-fuzz = "0.11"     # Fuzz testing
```

---

## Conclusion

This High-Level Design provides a comprehensive blueprint for building a performant, testable, and moddable voxel sandbox engine in Rust. The design prioritizes:

1. **Deterministic simulation** for reliable testing and replay
2. **Testing infrastructure** as a first-class architectural concern
3. **Modular architecture** with clear separation of concerns
4. **Performance targets** validated through automated testing
5. **Cross-platform compatibility** with per-backend verification

The phased implementation strategy breaks the project into manageable milestones with clear acceptance criteria. Each phase builds incrementally on the previous, with testing infrastructure developed in parallel to ensure quality throughout.

**Next Steps:**
1. Review and approve design
2. Set up workspace and CI pipeline
3. Begin Phase 0: Foundation
4. Establish baseline worldtests
5. Iterate with continuous testing and validation

**Key Success Factors:**
- Maintain determinism discipline from day one
- Build testing infrastructure alongside features
- Validate performance continuously
- Keep golden snapshots up to date
- Document edge cases and gotchas

This design serves as the foundation for a robust, well-tested voxel engine that can be validated automatically without human-in-the-loop visual inspection.
