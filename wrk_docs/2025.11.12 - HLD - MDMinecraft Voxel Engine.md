# High-Level Design: MDMinecraft Voxel Engine

**Document Version:** 1.0
**Date:** 2025.11.12
**Author:** System Design
**Status:** Initial Design

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [System Overview](#2-system-overview)
3. [Architecture Design](#3-architecture-design)
4. [Component Design](#4-component-design)
5. [Data Models & Formats](#5-data-models--formats)
6. [Simulation & Timing](#6-simulation--timing)
7. [Rendering Pipeline](#7-rendering-pipeline)
8. [Networking Architecture](#8-networking-architecture)
9. [Testing Architecture](#9-testing-architecture)
10. [Performance Design](#10-performance-design)
11. [Deployment & Operations](#11-deployment--operations)
12. [Security Considerations](#12-security-considerations)
13. [Extensibility & Modding](#13-extensibility--modding)
14. [Risks & Mitigations](#14-risks--mitigations)
15. [Development Roadmap](#15-development-roadmap)

---

## 1. Executive Summary

### 1.1 Project Vision

MDMinecraft is a high-performance, moddable voxel sandbox game written in Rust, distinguished by its **deterministic simulation** and **comprehensive automated testing story**. Unlike traditional game engines that treat testing as an afterthought, MDMinecraft is designed from the ground up to be testable, reproducible, and verifiable through multiple complementary verification surfaces.

### 1.2 Core Design Principles

1. **Determinism First**: Every system designed for reproducible behavior
2. **Test-Driven Architecture**: Testing capabilities are first-class features, not bolt-ons
3. **Performance by Design**: Target 60 FPS on modest hardware with large worlds
4. **Data-Driven Flexibility**: Blocks, items, and recipes defined in data files
5. **Clean Separation**: ECS-based architecture with clear boundaries
6. **Cross-Platform**: Linux, Windows, macOS with consistent behavior

### 1.3 Key Technical Decisions

| Decision | Rationale |
|----------|-----------|
| **Rust** | Memory safety, performance, fearless concurrency, modern tooling |
| **bevy_ecs** | Pure ECS without engine lock-in, excellent parallelism |
| **wgpu** | Cross-platform graphics with headless testing support |
| **QUIC (quinn)** | Modern transport with built-in encryption and reliability |
| **Fixed timestep** | Essential for determinism and physics stability |
| **Event stream architecture** | Enables testing, replay, debugging, and observability |

---

## 2. System Overview

### 2.1 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        CLIENT                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Renderer   │  │     Input    │  │      UI      │      │
│  │   (wgpu)     │  │   Manager    │  │  (ImGUI-like)│      │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘      │
│         │                  │                  │              │
│  ┌──────┴──────────────────┴──────────────────┴───────┐    │
│  │         Client Prediction & Interpolation           │    │
│  └──────────────────────┬──────────────────────────────┘    │
│                         │                                    │
└─────────────────────────┼────────────────────────────────────┘
                          │ QUIC (encrypted)
┌─────────────────────────┼────────────────────────────────────┐
│                         │           SERVER                    │
│  ┌──────────────────────┴──────────────────────────────┐    │
│  │         Authoritative Simulation (20 TPS)            │    │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐│    │
│  │  │  World  │  │ Physics │  │   ECS   │  │  Event  ││    │
│  │  │ Manager │  │  Engine │  │ Systems │  │  Stream ││    │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘│    │
│  └────────────────────────────────────────────────────┘    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Chunk      │  │   Lighting   │  │ Persistence  │      │
│  │  Generation  │  │   System     │  │   (Regions)  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
               ┌──────────────────────┐
               │   Event Stream       │
               │   (JSONL output)     │
               │                      │
               │  • Testing           │
               │  • Replay            │
               │  • Metrics           │
               │  • Debugging         │
               └──────────────────────┘
```

### 2.2 Crate Structure

```
mdminecraft/
├── Cargo.toml (workspace)
└── crates/
    ├── core/           # Foundation: math, IDs, coords, time, RNG
    ├── ecs/            # ECS facade (wraps bevy_ecs)
    ├── world/          # Blocks, chunks, biomes, generation, lighting
    ├── physics/        # AABB collision, raycasting, movement
    ├── render/         # wgpu renderer, meshing, materials
    ├── net/            # Protocol, serialization, transport
    ├── server/         # Authoritative game loop + headless mode
    ├── client/         # Input, prediction, interpolation, UI
    ├── assets/         # Asset registry, pack loading, validation
    ├── scripting/      # Optional WASM modding API
    ├── testkit/        # Event stream, replay, fixtures, golden tests
    └── cli/            # Binaries: game, server, worldtest tool
```

### 2.3 Data Flow

```
Input → Server Sim (20 TPS) → State Delta → Client Prediction → Render (60 FPS)
                ↓
           Event Stream
                ↓
        Testing/Replay/Metrics
```

---

## 3. Architecture Design

### 3.1 Entity-Component-System (ECS)

**Choice: bevy_ecs**

We use `bevy_ecs` as a standalone ECS library (not the full Bevy engine) for:
- Predictable data layout (cache-friendly)
- Built-in parallelism via system scheduling
- No engine lock-in
- Battle-tested in production games

**Core Components:**

```rust
// Transform & Physics
struct Transform { position: Vec3, rotation: Quat }
struct Velocity { linear: Vec3, angular: Vec3 }
struct Collider { shape: ColliderShape, material: PhysicsMaterial }

// Gameplay
struct Health { current: f32, max: f32 }
struct Inventory { slots: Vec<ItemStack>, size: usize }
struct PlayerTag { id: PlayerId, name: String }

// Rendering
struct MeshInstance { chunk_pos: IVec3, mesh_handle: Handle<Mesh> }
struct LightSource { intensity: u8, radius: u8 }
```

**System Scheduling:**

```rust
// Tick-based scheduling (server)
App::new()
    .add_system_set(
        SystemSet::new()
            .with_run_criteria(FixedTimestep::step(0.05)) // 20 TPS
            .with_system(input_system)
            .with_system(physics_system)
            .with_system(world_tick_system)
            .with_system(entity_ai_system)
            .with_system(event_emit_system)
    )
```

### 3.2 Coordinate Systems

**World Space:**
- Right-handed: **X+ east, Y+ up, Z+ south**
- Infinite horizontal (X/Z), finite vertical (Y ∈ [0, 512))
- Default height: 256 (configurable via feature flag)

**Chunk Space:**
- Size: **16×256×16** (X, Y, Z)
- Chunks aligned to world grid (chunk coords = world coords >> 4)
- Voxel index: `y * 256 + z * 16 + x`

**Region Space (Disk Layout):**
- **32×32 chunks** per region file (.rg)
- Region coords: `(chunk_x >> 5, chunk_z >> 5)`
- File path: `world/region/r.{rx}.{rz}.rg`

### 3.3 Threading Model

```
Main Thread:
  - Input handling
  - Render command submission
  - UI updates

Simulation Thread:
  - Fixed 20 TPS tick
  - ECS system execution
  - Event emission
  - Network I/O

Worker Thread Pool:
  - Chunk generation
  - Mesh building
  - Lighting propagation
  - File I/O (save/load)

Render Thread:
  - Mesh uploads to GPU
  - Draw call submission
  - Present
```

**Synchronization:**
- Lock-free queues for chunk data (crossbeam channels)
- Triple-buffering for render state
- Atomic counters for metrics

---

## 4. Component Design

### 4.1 Core Crate (`crates/core`)

**Purpose:** Foundation types used across all crates

**Key Types:**

```rust
// Identifiers
#[derive(Copy, Clone, Hash, Eq, PartialEq)]
pub struct BlockId(pub u16);  // 0 = air, max 65535 blocks

#[derive(Copy, Clone)]
pub struct BlockState(pub u16); // Orientation, moisture, age, etc.

#[derive(Copy, Clone, Hash)]
pub struct ChunkPos(pub IVec3);  // Chunk coordinates

// Math primitives
pub use glam::{Vec3, Vec2, IVec3, IVec2, Quat, Mat4};

// Time
pub struct SimTick(pub u64);  // Increments every 50ms
pub const TICK_RATE: u32 = 20;
pub const TICK_DT: f32 = 1.0 / TICK_RATE as f32;

// RNG (deterministic)
pub struct SeededRng {
    seed: u64,
    state: WyRand,  // Fast, high-quality RNG
}

impl SeededRng {
    pub fn from_tick_and_pos(tick: SimTick, pos: IVec3, world_seed: u64) -> Self {
        let seed = world_seed
            ^ (tick.0 << 32)
            ^ ((pos.x as u64) << 16)
            ^ (pos.z as u64);
        Self::new(seed)
    }
}

// Error handling
pub enum GameError {
    ChunkNotLoaded(ChunkPos),
    InvalidBlockId(u16),
    IoError(std::io::Error),
    NetworkError(String),
}
```

### 4.2 World Crate (`crates/world`)

**Purpose:** Voxel data, chunk management, generation, lighting

#### 4.2.1 Block Definition

```rust
#[derive(Clone, Copy)]
pub struct Voxel {
    pub id: BlockId,
    pub state: BlockState,
    pub light_sky: u8,    // 0-15
    pub light_block: u8,  // 0-15
}

pub struct BlockDef {
    pub id: BlockId,
    pub name: String,
    pub opaque: bool,
    pub transparent: bool,
    pub collidable: bool,
    pub light_emission: u8,
    pub light_attenuation: u8,
    pub hardness: f32,
    pub render_model: RenderModel,
}

pub enum RenderModel {
    Cube,
    Cross,      // For flowers, saplings
    CustomMesh(Handle<Mesh>),
}
```

#### 4.2.2 Chunk Storage

```rust
pub struct Chunk {
    pos: ChunkPos,
    voxels: Box<[Voxel; 16 * 256 * 16]>,  // 64KB per chunk
    dirty_lighting: bool,
    dirty_mesh: bool,
    last_modified: SimTick,
}

impl Chunk {
    #[inline]
    pub fn get(&self, local_x: u8, local_y: u8, local_z: u8) -> Voxel {
        let idx = (local_y as usize) * 256
                + (local_z as usize) * 16
                + (local_x as usize);
        self.voxels[idx]
    }

    #[inline]
    pub fn set(&mut self, local_x: u8, local_y: u8, local_z: u8, voxel: Voxel) {
        let idx = (local_y as usize) * 256
                + (local_z as usize) * 16
                + (local_x as usize);
        self.voxels[idx] = voxel;
        self.dirty_lighting = true;
        self.dirty_mesh = true;
    }
}

pub struct ChunkManager {
    chunks: HashMap<ChunkPos, Chunk>,
    load_queue: VecDeque<ChunkPos>,
    unload_queue: VecDeque<ChunkPos>,
    gen_jobs: JobQueue<ChunkGenJob>,
}
```

#### 4.2.3 World Generation Pipeline

```rust
pub struct WorldGenerator {
    seed: u64,
    noise: NoiseStack,
    biome_map: BiomeMapper,
}

impl WorldGenerator {
    pub fn generate_chunk(&self, pos: ChunkPos) -> Chunk {
        let mut chunk = Chunk::new(pos);

        // 1. Heightmap
        let heights = self.generate_heightmap(pos);

        // 2. Biome assignment
        let biomes = self.biome_map.sample(pos);

        // 3. Base terrain
        self.place_terrain(&mut chunk, &heights, &biomes);

        // 4. Caves & tunnels
        self.carve_caves(&mut chunk);

        // 5. Ores & features
        self.populate_ores(&mut chunk);

        // 6. Skylight precompute
        self.compute_skylight(&mut chunk);

        chunk
    }
}

// Noise abstraction for determinism
pub struct NoiseStack {
    octaves: Vec<SimplexNoise>,
    frequencies: Vec<f32>,
    amplitudes: Vec<f32>,
}
```

#### 4.2.4 Lighting System

```rust
pub struct LightingEngine {
    sky_queue: VecDeque<LightNode>,
    block_queue: VecDeque<LightNode>,
}

struct LightNode {
    pos: IVec3,
    level: u8,
}

impl LightingEngine {
    // BFS propagation with attenuation
    pub fn propagate_light(&mut self, world: &mut ChunkManager) {
        while let Some(node) = self.block_queue.pop_front() {
            if node.level == 0 { continue; }

            for neighbor in self.get_neighbors(node.pos) {
                let current_light = world.get_block_light(neighbor);
                let new_light = node.level.saturating_sub(1);

                if new_light > current_light {
                    world.set_block_light(neighbor, new_light);
                    self.block_queue.push_back(LightNode {
                        pos: neighbor,
                        level: new_light,
                    });
                }
            }
        }
    }

    // Light removal (when breaking torch, etc.)
    pub fn remove_light(&mut self, pos: IVec3, world: &mut ChunkManager) {
        // Flood-fill removal + re-propagation
        // See: https://www.seedofandromeda.com/blogs/29-fast-flood-fill-lighting
    }
}
```

### 4.3 Physics Crate (`crates/physics`)

**Purpose:** Collision detection, resolution, raycasting

```rust
pub struct PhysicsWorld {
    gravity: Vec3,
    entities: HashMap<Entity, RigidBody>,
}

pub struct RigidBody {
    pub collider: Collider,
    pub velocity: Vec3,
    pub mass: f32,
    pub friction: f32,
}

pub enum Collider {
    Aabb(Aabb),
    Capsule { radius: f32, height: f32 },
}

pub struct Aabb {
    pub min: Vec3,
    pub max: Vec3,
}

impl PhysicsWorld {
    // Semi-implicit Euler integration
    pub fn step(&mut self, dt: f32, world: &ChunkManager) {
        for (entity, body) in &mut self.entities {
            // Apply gravity
            body.velocity.y -= self.gravity.y * dt;

            // Integrate position
            let prev_pos = body.collider.center();
            let next_pos = prev_pos + body.velocity * dt;

            // Resolve collisions
            let resolved = self.resolve_voxel_collisions(
                prev_pos,
                next_pos,
                &body.collider,
                world
            );

            body.collider.set_center(resolved.position);
            body.velocity = resolved.velocity;
        }
    }

    // AABB vs voxel grid
    fn resolve_voxel_collisions(
        &self,
        prev: Vec3,
        next: Vec3,
        collider: &Collider,
        world: &ChunkManager,
    ) -> ResolvedState {
        // Swept AABB or separating axis
        // Return corrected position + velocity
        todo!("See specs section 7: Physics & Collisions")
    }
}

// DDA voxel raycast
pub fn raycast_voxel(
    origin: Vec3,
    direction: Vec3,
    max_dist: f32,
    world: &ChunkManager,
) -> Option<RayHit> {
    // Amanatides & Woo DDA algorithm
    // Returns: hit position, face normal, block ID
}
```

### 4.4 Render Crate (`crates/render`)

**Purpose:** wgpu rendering, meshing, materials

#### 4.4.1 Mesher

```rust
pub struct ChunkMesher {
    block_registry: Arc<BlockRegistry>,
}

pub struct ChunkMesh {
    pub opaque: MeshBuffer,
    pub transparent: MeshBuffer,
    pub cutout: MeshBuffer,
    pub hash: u64,  // For stability testing
}

pub struct MeshBuffer {
    pub vertices: Vec<Vertex>,
    pub indices: Vec<u32>,
}

#[repr(C)]
pub struct Vertex {
    pub position: [f32; 3],
    pub normal: [f32; 3],
    pub uv: [f32; 2],
    pub light: u8,      // Combined sky/block light
    pub ao: u8,         // Ambient occlusion
}

impl ChunkMesher {
    // Greedy meshing: merge adjacent same-face quads
    pub fn mesh_chunk(&self, chunk: &Chunk, neighbors: &ChunkNeighbors) -> ChunkMesh {
        let mut mesh = ChunkMesh::default();

        for y in 0..256 {
            for z in 0..16 {
                for x in 0..16 {
                    let voxel = chunk.get(x, y, z);
                    if voxel.id.0 == 0 { continue; }  // Skip air

                    let def = self.block_registry.get(voxel.id);

                    // Check each face for visibility
                    for face in &FACES {
                        if self.is_face_visible(chunk, neighbors, x, y, z, face) {
                            self.add_face(&mut mesh, x, y, z, voxel, def, face);
                        }
                    }
                }
            }
        }

        // Compute hash for determinism testing
        mesh.hash = self.compute_mesh_hash(&mesh);
        mesh
    }

    fn compute_mesh_hash(&self, mesh: &ChunkMesh) -> u64 {
        use std::hash::{Hash, Hasher};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        mesh.opaque.vertices.hash(&mut hasher);
        mesh.opaque.indices.hash(&mut hasher);
        hasher.finish()
    }
}
```

#### 4.4.2 Renderer

```rust
pub struct VoxelRenderer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    pipeline: wgpu::RenderPipeline,
    atlas: TextureAtlas,
    camera_buffer: wgpu::Buffer,
    chunk_meshes: HashMap<ChunkPos, GpuMesh>,
}

pub struct GpuMesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
}

impl VoxelRenderer {
    pub fn render(&mut self, camera: &Camera, visible_chunks: &[ChunkPos]) {
        let mut encoder = self.device.create_command_encoder(&Default::default());

        {
            let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                color_attachments: &[/* ... */],
                depth_stencil_attachment: Some(/* ... */),
                /* ... */
            });

            pass.set_pipeline(&self.pipeline);
            pass.set_bind_group(0, &self.camera_bind_group, &[]);
            pass.set_bind_group(1, &self.atlas.bind_group, &[]);

            for chunk_pos in visible_chunks {
                if let Some(mesh) = self.chunk_meshes.get(chunk_pos) {
                    pass.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                    pass.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                    pass.draw_indexed(0..mesh.index_count, 0, 0..1);
                }
            }
        }

        self.queue.submit(std::iter::once(encoder.finish()));
    }
}
```

#### 4.4.3 Headless Mode

```rust
pub struct HeadlessRenderer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    render_target: wgpu::Texture,
    pipeline: wgpu::RenderPipeline,
}

impl HeadlessRenderer {
    pub fn new(width: u32, height: u32) -> Self {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
            backends: wgpu::Backends::VULKAN | wgpu::Backends::DX12,
            ..Default::default()
        });

        // Request adapter in headless mode
        let adapter = pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            force_fallback_adapter: false,
            compatible_surface: None,  // No window surface
        })).unwrap();

        // Create render target texture
        let render_target = device.create_texture(&wgpu::TextureDescriptor {
            size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
            /* ... */
        });

        // ...
    }

    pub fn render_snapshot(&mut self, world: &World, camera: &Camera) -> SnapshotResult {
        // Render to texture
        self.render_to_texture(world, camera);

        // Copy to CPU
        let image_data = self.copy_texture_to_cpu();

        // Compute SHA-256
        let sha = sha256::digest(&image_data);

        SnapshotResult {
            sha256: sha,
            width: self.render_target.size().width,
            height: self.render_target.size().height,
            data: image_data,
        }
    }
}
```

### 4.5 Networking Crate (`crates/net`)

**Purpose:** QUIC transport, protocol, serialization

#### 4.5.1 Protocol

```rust
#[derive(Serialize, Deserialize)]
pub enum ClientMessage {
    Join { username: String, version: u32 },
    Input { tick: SimTick, actions: PlayerInput },
    ChunkRequest { pos: ChunkPos },
    Disconnect,
}

#[derive(Serialize, Deserialize)]
pub enum ServerMessage {
    Welcome { player_id: PlayerId, spawn: Vec3 },
    ChunkData { pos: ChunkPos, data: CompressedChunk },
    StateDelta { tick: SimTick, delta: WorldDelta },
    PlayerJoined { id: PlayerId, name: String },
    PlayerLeft { id: PlayerId },
    Kick { reason: String },
}

#[derive(Serialize, Deserialize)]
pub struct PlayerInput {
    pub forward: f32,
    pub right: f32,
    pub jump: bool,
    pub crouch: bool,
    pub action: Option<PlayerAction>,
}

#[derive(Serialize, Deserialize)]
pub enum PlayerAction {
    BreakBlock { pos: IVec3 },
    PlaceBlock { pos: IVec3, block: BlockId },
    UseItem { slot: u8 },
}
```

#### 4.5.2 Transport

```rust
pub struct QuicServer {
    endpoint: quinn::Endpoint,
    connections: HashMap<PlayerId, quinn::Connection>,
}

impl QuicServer {
    pub async fn listen(addr: SocketAddr) -> Result<Self> {
        let cert = rcgen::generate_simple_self_signed(vec!["localhost".into()])?;
        let key = rustls::PrivateKey(cert.serialize_private_key_der());
        let cert = rustls::Certificate(cert.serialize_der()?);

        let server_config = quinn::ServerConfig::with_single_cert(vec![cert], key)?;
        let endpoint = quinn::Endpoint::server(server_config, addr)?;

        Ok(Self {
            endpoint,
            connections: HashMap::new(),
        })
    }

    pub async fn accept_connections(&mut self) {
        while let Some(conn) = self.endpoint.accept().await {
            tokio::spawn(self.handle_connection(conn));
        }
    }
}
```

### 4.6 Server Crate (`crates/server`)

**Purpose:** Authoritative simulation loop

```rust
pub struct GameServer {
    world: World,  // bevy_ecs World
    chunk_manager: ChunkManager,
    physics: PhysicsWorld,
    event_sink: Box<dyn EventSink>,
    net: QuicServer,
    current_tick: SimTick,
}

impl GameServer {
    pub fn run(&mut self) {
        let tick_duration = Duration::from_millis(50);  // 20 TPS
        let mut accumulator = Duration::ZERO;
        let mut last_frame = Instant::now();

        loop {
            let now = Instant::now();
            accumulator += now - last_frame;
            last_frame = now;

            // Fixed timestep
            while accumulator >= tick_duration {
                self.tick();
                accumulator -= tick_duration;
            }

            // Sleep to avoid busy-waiting
            let remaining = tick_duration.saturating_sub(accumulator);
            if remaining > Duration::from_millis(1) {
                std::thread::sleep(remaining / 2);
            }
        }
    }

    fn tick(&mut self) {
        self.current_tick.0 += 1;

        self.emit_event(GameEvent::TickStart { tick: self.current_tick });

        // 1. Ingest network inputs
        self.process_client_inputs();

        // 2. Run ECS systems
        self.world.run_schedule(&mut self.tick_schedule);

        // 3. Update world (block ticks, fluids, lighting)
        self.chunk_manager.tick(&mut self.world);

        // 4. Physics
        self.physics.step(TICK_DT, &self.chunk_manager);

        // 5. Send state deltas to clients
        self.send_state_updates();

        self.emit_event(GameEvent::TickEnd { tick: self.current_tick });
    }
}
```

### 4.7 Testkit Crate (`crates/testkit`)

**Purpose:** Event recording, replay, world DSL, golden tests

```rust
pub enum GameEvent {
    TickStart { tick: u64 },
    TickEnd { tick: u64 },
    BlockPlaced { tick: u64, pos: IVec3, by: Entity, block: BlockId },
    BlockBroken { tick: u64, pos: IVec3, by: Entity },
    ChunkGenerated { tick: u64, chunk: ChunkPos },
    ChunkMeshed { tick: u64, chunk: ChunkPos, hash: u64, triangles: usize },
    LightingUpdated { tick: u64, region: IVec2, updates: usize },
    EntitySpawned { tick: u64, entity: Entity, kind: String },
    SnapshotSaved { tick: u64, camera: String, sha: String, width: u32, height: u32 },
}

pub trait EventSink: Send + Sync {
    fn on_event(&self, event: &GameEvent);
}

pub struct JsonlRecorder {
    file: Mutex<BufWriter<File>>,
}

impl EventSink for JsonlRecorder {
    fn on_event(&self, event: &GameEvent) {
        let mut file = self.file.lock().unwrap();
        serde_json::to_writer(&mut *file, event).unwrap();
        writeln!(file).unwrap();
    }
}

// World test DSL
pub struct WorldTest {
    pub world_config: WorldConfig,
    pub script: Vec<ScriptAction>,
    pub expectations: Vec<Expectation>,
    pub cameras: Vec<CameraRig>,
}

#[derive(Deserialize)]
pub struct ScriptAction {
    pub tick: u64,
    pub action: Action,
}

#[derive(Deserialize)]
pub enum Action {
    PlaceBlock { at: IVec3, block: String },
    BreakBlock { at: IVec3 },
    PlayerMove { id: u8, dir: Vec3, seconds: f32 },
}

#[derive(Deserialize)]
pub struct Expectation {
    pub by_tick: u64,
    pub condition: Condition,
}

#[derive(Deserialize)]
pub enum Condition {
    EventCount { kind: String, count: usize },
    Light { at: IVec3, sky: Option<u8>, block: Option<u8> },
    Snapshot { camera: String, sha: String },
}

pub fn run_world_test(test_path: &Path) -> TestResult {
    let test: WorldTest = toml::from_str(&fs::read_to_string(test_path)?)?;

    // Create headless server
    let mut server = GameServer::new_headless(test.world_config);

    // Run script
    for action in test.script {
        server.run_until_tick(action.tick);
        server.apply_action(action.action);
    }

    // Check expectations
    let mut results = Vec::new();
    for expectation in test.expectations {
        server.run_until_tick(expectation.by_tick);
        let passed = expectation.condition.check(&server);
        results.push((expectation, passed));
    }

    TestResult { results }
}
```

---

## 5. Data Models & Formats

### 5.1 Block Registry (TOML)

```toml
[[block]]
name = "stone"
id = 1
opaque = true
collidable = true
solid = true
light_attenuation = 15
hardness = 1.5
render_model = "cube"
texture = "stone"

[[block]]
name = "torch"
id = 50
opaque = false
collidable = false
solid = false
light_emission = 14
light_attenuation = 0
render_model = "sprite"
texture = "torch"
```

### 5.2 Recipe Format (JSON)

```json
{
  "type": "shaped",
  "pattern": [
    "SS",
    "SS"
  ],
  "key": {
    "S": "stone"
  },
  "result": {
    "item": "stone_bricks",
    "count": 4
  }
}
```

### 5.3 Region File Format

```
Region File (.rg):
┌─────────────────────┐
│   Header (8KB)      │  Lookup table: 1024 chunk offsets (32×32)
│   [offset, length]  │  Each entry: u32 offset (sectors), u32 length
├─────────────────────┤
│   Chunk 0,0         │
│   ┌──────────────┐  │
│   │ CRC32        │  │  4 bytes
│   │ Version      │  │  2 bytes
│   │ Uncompressed │  │  4 bytes
│   │ Compressed   │  │  4 bytes
│   │ Zstd Data    │  │  Variable
│   └──────────────┘  │
│   Chunk 0,1         │
│   ...               │
└─────────────────────┘
```

### 5.4 Player Data (MessagePack)

```rust
#[derive(Serialize, Deserialize)]
pub struct PlayerData {
    pub uuid: Uuid,
    pub name: String,
    pub position: Vec3,
    pub rotation: Quat,
    pub health: f32,
    pub inventory: Inventory,
    pub experience: u32,
    pub game_mode: GameMode,
}
```

---

## 6. Simulation & Timing

### 6.1 Fixed Timestep Architecture

```rust
const TICK_RATE: u32 = 20;
const TICK_DT: f64 = 1.0 / TICK_RATE as f64;
const MAX_TICK_ACCUMULATION: u32 = 5;  // Prevent spiral of death

pub struct TickScheduler {
    accumulator: Duration,
    current_tick: u64,
    target_fps: u32,
}

impl TickScheduler {
    pub fn update(&mut self, dt: Duration) -> Vec<TickCommand> {
        self.accumulator += dt;
        let mut commands = Vec::new();

        let mut ticks_this_frame = 0;
        while self.accumulator >= TICK_DURATION && ticks_this_frame < MAX_TICK_ACCUMULATION {
            commands.push(TickCommand::SimulateTick(self.current_tick));
            self.current_tick += 1;
            self.accumulator -= TICK_DURATION;
            ticks_this_frame += 1;
        }

        // Interpolation alpha for rendering
        let alpha = self.accumulator.as_secs_f64() / TICK_DT;
        commands.push(TickCommand::Render(alpha));

        commands
    }
}
```

### 6.2 Determinism Guarantees

1. **Seeded RNG**: All randomness from `SeededRng::from_tick_and_pos()`
2. **No wall-clock time**: Use `SimTick` everywhere in gameplay logic
3. **Integer coordinates**: Block positions are `IVec3`
4. **Quantized thresholds**: Floating-point comparisons avoided in branching
5. **Fixed iteration order**: `HashMap` → `BTreeMap` for deterministic iteration

```rust
// Example: Deterministic entity update order
fn update_entities(world: &mut World) {
    let mut entities: Vec<Entity> = world.query::<Entity>().iter().collect();
    entities.sort();  // Deterministic order

    for entity in entities {
        // Update logic
    }
}
```

---

## 7. Rendering Pipeline

### 7.1 Frame Flow

```
CPU Thread                          GPU
──────────────────────────────────────────────────
Frustum Culling
  ↓
Mesh Upload (dirty chunks only)
  ↓
Build Command Buffer
  ↓
Submit                            ─→  Execute
  ↓                                   │
Present                           ←──┘
```

### 7.2 Shader Pipeline

**Vertex Shader:**
```wgsl
struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) light: u32,  // packed sky + block
    @location(4) ao: u32,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_pos: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) light: f32,
    @location(4) ao: f32,
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.clip_position = camera.proj * camera.view * vec4(in.position, 1.0);
    out.world_pos = in.position;
    out.normal = in.normal;
    out.uv = in.uv;

    // Unpack lighting
    let sky = f32((in.light >> 4) & 0xF) / 15.0;
    let block = f32(in.light & 0xF) / 15.0;
    out.light = max(sky, block);
    out.ao = f32(in.ao) / 3.0;

    return out;
}
```

**Fragment Shader:**
```wgsl
@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let albedo = textureSample(atlas, atlas_sampler, in.uv);

    // Lighting
    let diffuse = max(dot(in.normal, sun_direction), 0.0);
    let ambient = 0.3;
    let lighting = mix(ambient, 1.0, diffuse * in.light);

    // Apply AO
    let final_light = lighting * (0.4 + 0.6 * in.ao);

    var color = albedo.rgb * final_light;

    // Fog
    let dist = length(in.world_pos - camera_pos);
    let fog_factor = smoothstep(fog_start, fog_end, dist);
    color = mix(color, fog_color, fog_factor);

    return vec4(color, albedo.a);
}
```

---

## 8. Networking Architecture

### 8.1 Client-Server Model

**Server Authoritative:**
- Server owns ground truth
- Client sends inputs only, not positions
- Server validates all actions

**Client Prediction:**
- Client simulates locally for responsiveness
- Server sends corrections via state deltas
- Client reconciles differences

### 8.2 State Synchronization

```rust
pub struct StateDelta {
    pub tick: SimTick,
    pub block_updates: Vec<BlockUpdate>,
    pub entity_updates: Vec<EntityUpdate>,
}

pub struct BlockUpdate {
    pub pos: IVec3,
    pub new_voxel: Voxel,
}

pub struct EntityUpdate {
    pub id: Entity,
    pub transform: Transform,
    pub velocity: Velocity,
}

// Delta compression
impl StateDelta {
    pub fn encode(&self) -> Vec<u8> {
        // Only send changed data
        // Use variable-length encoding for positions
        // Quantize velocities to 16-bit fixed-point
    }
}
```

### 8.3 Lag Compensation

```rust
pub struct ClientPrediction {
    input_buffer: VecDeque<(SimTick, PlayerInput)>,
    last_acked_tick: SimTick,
    predicted_state: PlayerState,
}

impl ClientPrediction {
    pub fn on_server_update(&mut self, server_tick: SimTick, server_state: PlayerState) {
        // Discard inputs server has processed
        self.input_buffer.retain(|(tick, _)| *tick > server_tick);

        // Check for misprediction
        let error = (self.predicted_state.position - server_state.position).length();

        if error > RECONCILIATION_THRESHOLD {
            // Snap to server state
            self.predicted_state = server_state;

            // Re-simulate pending inputs
            for (_, input) in &self.input_buffer {
                self.simulate_local(input);
            }
        }
    }
}
```

---

## 9. Testing Architecture

### 9.1 Testing Pyramid

```
           ┌──────────────────┐
           │  E2E World Tests │  (Headless server + snapshot)
           │   (~100 tests)   │
           └──────────────────┘
         ┌────────────────────────┐
         │  Integration Tests      │  (ECS systems + physics)
         │    (~500 tests)         │
         └────────────────────────┘
      ┌─────────────────────────────────┐
      │     Unit Tests                   │  (Pure functions)
      │      (~2000 tests)               │
      └─────────────────────────────────┘
```

### 9.2 Event Stream Testing

**Example Test:**

```rust
#[test]
fn test_torch_lighting() {
    let mut server = GameServer::new_test();
    let recorder = JsonlRecorder::new("test_torch.jsonl");
    server.add_event_sink(Box::new(recorder));

    // Place torch
    server.place_block(IVec3::new(0, 65, 0), BlockId::TORCH);
    server.tick();
    server.tick();

    // Verify event stream
    let events = parse_jsonl("test_torch.jsonl");
    assert_event_exists(&events, |e| matches!(e, GameEvent::LightingUpdated { .. }));

    // Verify light level
    let light = server.get_block_light(IVec3::new(0, 65, 0));
    assert_eq!(light, 14);
}
```

### 9.3 Snapshot Testing

```rust
#[test]
fn test_village_render() {
    let test = WorldTest::load("scenarios/village.worldtest.toml");
    let mut server = GameServer::new_headless(test.world_config);

    // Generate world
    server.run_until_tick(100);

    // Render snapshot
    let snapshot = server.render_snapshot(&test.cameras[0]);

    // Compare SHA
    let golden = fs::read_to_string("goldens/linux_vulkan/village.sha256").unwrap();
    assert_eq!(snapshot.sha256, golden.trim());
}
```

### 9.4 Property-Based Testing

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn lighting_monotonic(
        start_pos in any::<IVec3>(),
        light_level in 0u8..=15
    ) {
        let mut world = ChunkManager::new_empty();
        let mut lighting = LightingEngine::new();

        // Place light source
        world.set_block_light(start_pos, light_level);
        lighting.propagate_light(&mut world);

        // Check monotonicity
        for neighbor in get_neighbors(start_pos) {
            let neighbor_light = world.get_block_light(neighbor);
            prop_assert!(neighbor_light <= light_level);
        }
    }
}
```

---

## 10. Performance Design

### 10.1 Optimization Strategy

| System | Target | Strategy |
|--------|--------|----------|
| **Chunk Gen** | <8ms/chunk | Parallel job queue, SIMD noise |
| **Meshing** | <5ms/chunk | Greedy meshing, worker threads |
| **Lighting** | <2ms/update | BFS queues, chunk-local updates |
| **Physics** | <1ms/tick | Spatial partitioning, early-out |
| **Rendering** | <10ms/frame | Frustum culling, instancing |

### 10.2 Memory Budget

```
Chunk (16³×256 voxels):
  - Voxels: 4 bytes × 65536 = 256 KB
  - Mesh (avg): 100 KB
  - Total per chunk: ~350 KB

Target: 9×9 loaded chunks = 81 chunks × 350 KB = 28 MB

With render distance 12: 25×25 = 625 chunks × 350 KB = 219 MB

Headroom for ECS, textures, etc.: ~800 MB
Total: ~1 GB resident
```

### 10.3 Profiling Points

```rust
use tracing::{span, Level};

fn generate_chunk(pos: ChunkPos) -> Chunk {
    let _span = span!(Level::INFO, "chunk_gen", ?pos).entered();

    // Generation logic...

    metrics::histogram!("chunk_gen_time_ms").record(start.elapsed().as_millis());
}
```

**Metrics to Track:**
- Frame time (P50, P95, P99)
- Chunk generation time
- Mesh build time
- Network RTT
- Memory usage
- Draw calls per frame

---

## 11. Deployment & Operations

### 11.1 Build Matrix

| Platform | Graphics API | Notes |
|----------|--------------|-------|
| **Windows** | DX12 | Primary target |
| **Linux** | Vulkan | CI headless tests |
| **macOS** | Metal | ARM + Intel |

### 11.2 CI Pipeline

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable

      # Unit tests
      - run: cargo test --all-features

      # Clippy
      - run: cargo clippy -- -D warnings

      # Format check
      - run: cargo fmt -- --check

      # World tests (headless)
      - run: cargo run -p cli -- worldtest scenarios/*.worldtest.toml

      # Upload artifacts
      - uses: actions/upload-artifact@v3
        with:
          name: test-artifacts-${{ matrix.os }}
          path: |
            test_outputs/*.jsonl
            test_outputs/*.png
            test_outputs/metrics.json
```

### 11.3 Release Packaging

```bash
# Linux
cargo build --release
strip target/release/mdminecraft-client
tar czf mdminecraft-linux-x64.tar.gz \
  target/release/mdminecraft-client \
  target/release/mdminecraft-server \
  assets/

# Windows
cargo build --release --target x86_64-pc-windows-msvc
7z a mdminecraft-windows-x64.zip \
  target/x86_64-pc-windows-msvc/release/mdminecraft-client.exe \
  target/x86_64-pc-windows-msvc/release/mdminecraft-server.exe \
  assets/
```

---

## 12. Security Considerations

### 12.1 Server Security

**Input Validation:**
```rust
fn validate_player_action(action: &PlayerAction, player: &Player) -> Result<()> {
    match action {
        PlayerAction::BreakBlock { pos } => {
            // Check range
            let dist = (pos.as_vec3() - player.position).length();
            if dist > MAX_REACH_DISTANCE {
                return Err(GameError::OutOfRange);
            }

            // Check rate limit
            if player.last_action_time.elapsed() < MIN_ACTION_INTERVAL {
                return Err(GameError::RateLimited);
            }
        }
        // ...
    }
    Ok(())
}
```

**Rate Limiting:**
```rust
pub struct RateLimiter {
    buckets: HashMap<PlayerId, TokenBucket>,
}

struct TokenBucket {
    tokens: f32,
    max_tokens: f32,
    refill_rate: f32,  // tokens per second
}
```

### 12.2 Asset Validation

```rust
fn validate_asset_pack(pack_path: &Path) -> Result<()> {
    // Check file sizes
    for entry in WalkDir::new(pack_path) {
        let size = entry.metadata()?.len();
        if size > MAX_ASSET_SIZE {
            return Err(GameError::AssetTooLarge);
        }
    }

    // Validate textures
    for texture in pack.textures() {
        let img = image::load_from_memory(texture)?;
        if img.width() > MAX_TEXTURE_DIM || img.height() > MAX_TEXTURE_DIM {
            return Err(GameError::TextureTooLarge);
        }
    }

    Ok(())
}
```

---

## 13. Extensibility & Modding

### 13.1 Data Pack System

**Structure:**
```
my_datapack/
├── pack.toml
├── blocks/
│   ├── ruby_ore.toml
│   └── ruby_block.toml
├── items/
│   └── ruby.toml
├── recipes/
│   └── ruby_block.json
└── textures/
    ├── ruby_ore.png
    └── ruby_block.png
```

**pack.toml:**
```toml
name = "Ruby Mod"
version = "1.0.0"
author = "PlayerName"
description = "Adds ruby ore and blocks"

[dependencies]
game_version = ">=0.1.0"
```

### 13.2 WASM Modding API

```rust
// Host (Rust game engine)
pub struct WasmHost {
    engine: wasmtime::Engine,
    modules: HashMap<String, wasmtime::Module>,
}

impl WasmHost {
    pub fn register_mod(&mut self, path: &Path) -> Result<()> {
        let module = wasmtime::Module::from_file(&self.engine, path)?;

        // Set fuel limit (10M instructions per tick)
        let mut store = wasmtime::Store::new(&self.engine, ());
        store.set_fuel(10_000_000)?;

        // Instantiate with limited API
        let instance = wasmtime::Instance::new(&mut store, &module, &[])?;

        // Call init
        let init = instance.get_typed_func::<(), ()>(&mut store, "mod_init")?;
        init.call(&mut store, ())?;

        Ok(())
    }
}

// Guest (Rust mod compiled to WASM)
#[no_mangle]
pub extern "C" fn mod_init() {
    // Register custom block
    game_api::register_block(BlockDef {
        name: "ruby_ore",
        hardness: 3.0,
        // ...
    });
}

#[no_mangle]
pub extern "C" fn on_block_break(x: i32, y: i32, z: i32, block: u16) {
    if block == RUBY_ORE_ID {
        game_api::spawn_item(x, y, z, RUBY_ITEM_ID, 1);
    }
}
```

---

## 14. Risks & Mitigations

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Determinism drift** | High | Medium | Unit tests for replay; schema versioning; audit all RNG |
| **Cross-platform render variance** | Medium | High | Per-backend goldens; software rasterizer fallback |
| **Performance regression** | High | Medium | Benchmark CI job; metrics dashboard; profiling in tests |
| **Mesh hash instability** | Medium | Medium | Integer-only meshing; stable HashMap → BTreeMap |
| **WASM security** | High | Low | Fuel limits; memory sandbox; API surface audit |
| **Network desync** | High | Medium | Snapshot-based reconciliation; player position validation |
| **Save corruption** | High | Low | CRC32 checks; version guards; backup on write |

---

## 15. Development Roadmap

### Milestone A: Engine Core (4-6 weeks)

**Deliverables:**
- [ ] Core crate: math, IDs, RNG, time
- [ ] World crate: chunk storage, basic gen, block registry
- [ ] Render crate: wgpu setup, greedy mesher, camera
- [ ] Physics crate: AABB collision, raycast
- [ ] CLI: basic client that loads a world

**Acceptance:**
- Superflat world loads
- Place/break blocks at 60 FPS
- 9×9 chunk render distance
- Pass "Superflat Basics" worldtest

### Milestone B: Lighting & Persistence (3-4 weeks)

**Deliverables:**
- [ ] Lighting: skylight + emissive blocks
- [ ] Region file format + save/load
- [ ] Inventory & crafting basics
- [ ] Testkit: event stream, JsonlRecorder

**Acceptance:**
- "Torch Light" worldtest passes
- Light updates within 2 ticks
- Save/reload preserves world exactly
- Event stream goldens stable

### Milestone C: Networking (4-5 weeks)

**Deliverables:**
- [ ] Net crate: QUIC transport, protocol
- [ ] Server crate: authoritative sim loop
- [ ] Client crate: prediction, interpolation
- [ ] Chunk streaming

**Acceptance:**
- Two clients can build together
- Event streams match server's log
- <30ms rubber-band on 100ms RTT

### Milestone D: Biomes & Polish (3-4 weeks)

**Deliverables:**
- [ ] Biome system: noise-based generation
- [ ] Structures: trees, ores, caves
- [ ] Weather toggle
- [ ] Headless renderer + snapshot goldens
- [ ] UI: hotbar, crosshair, menus

**Acceptance:**
- Biome borders seamless
- Mesh hashes stable across runs
- All snapshot tests pass in CI
- Playable single + multiplayer MVP

---

## Appendix A: File Structure

```
mdminecraft/
├── Cargo.toml
├── .github/
│   └── workflows/
│       └── ci.yml
├── crates/
│   ├── core/
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── math.rs
│   │       ├── id.rs
│   │       ├── time.rs
│   │       └── rng.rs
│   ├── ecs/
│   ├── world/
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── voxel.rs
│   │       ├── chunk.rs
│   │       ├── manager.rs
│   │       ├── gen/
│   │       │   ├── mod.rs
│   │       │   ├── noise.rs
│   │       │   ├── heightmap.rs
│   │       │   └── biome.rs
│   │       └── lighting.rs
│   ├── physics/
│   ├── render/
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── mesher.rs
│   │       ├── renderer.rs
│   │       ├── headless.rs
│   │       └── shaders/
│   │           ├── vertex.wgsl
│   │           └── fragment.wgsl
│   ├── net/
│   ├── server/
│   ├── client/
│   ├── assets/
│   ├── scripting/
│   ├── testkit/
│   └── cli/
├── assets/
│   ├── blocks/
│   ├── items/
│   ├── recipes/
│   └── textures/
├── scenarios/
│   ├── superflat.worldtest.toml
│   ├── torch_light.worldtest.toml
│   └── village.worldtest.toml
├── goldens/
│   ├── linux_vulkan/
│   ├── windows_dx12/
│   └── macos_metal/
└── docs/
    ├── reqs-spec.md
    └── api/
```

---

## Appendix B: Key Dependencies

```toml
[dependencies]
# ECS
bevy_ecs = "0.14"

# Math
glam = { version = "0.29", features = ["serde"] }

# Graphics
wgpu = "23.0"
winit = "0.30"

# Networking
quinn = "0.11"
tokio = { version = "1.40", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bincode = "1.3"
toml = "0.8"

# Compression
zstd = "0.13"

# Noise
noise = "0.9"

# Testing
proptest = "1.5"
criterion = "0.5"

# Logging
tracing = "0.1"
tracing-subscriber = "0.3"

# Metrics
metrics = "0.24"
```

---

## Appendix C: Glossary

| Term | Definition |
|------|------------|
| **Voxel** | Volume pixel; a single block in 3D space |
| **Chunk** | 16×256×16 region of voxels |
| **Region** | 32×32 chunks stored in one file |
| **SimTick** | Simulation tick; increments every 50ms (20 TPS) |
| **Greedy Meshing** | Optimization that merges adjacent same-type quads |
| **BFS** | Breadth-first search; used in lighting propagation |
| **AABB** | Axis-aligned bounding box; used in collisions |
| **DDA** | Digital Differential Analyzer; voxel raycast algorithm |
| **ECS** | Entity-Component-System; data-oriented architecture |
| **QUIC** | Modern transport protocol over UDP with encryption |
| **JSONL** | JSON Lines; newline-delimited JSON for event streams |

---

**End of High-Level Design Document**

---

## Change Log

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025.11.12 | System Design | Initial comprehensive design |

---

## Approval

This design document requires review and approval from:

- [ ] Technical Lead
- [ ] Product Owner
- [ ] QA Lead
- [ ] DevOps Lead

**Next Steps:**
1. Review and approve HLD
2. Create detailed task breakdown for Milestone A
3. Set up repository structure
4. Begin implementation of `core` and `world` crates
