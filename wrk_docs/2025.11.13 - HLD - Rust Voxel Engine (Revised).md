# High-Level Design: Rust Voxel Game Engine (mdminecraft) - Revised

**Document Version:** 2.0
**Date:** 2025.11.13
**Project:** mdminecraft - Performant, Moddable Voxel Sandbox
**Target Language:** Rust
**Architecture:** ECS-based, Client-Server with Headless Testing

**Revision Notes:**
- Comprehensive review conducted 2025.11.13
- 30+ critical issues identified and resolved
- Major improvements to data structures, threading, and networking
- Added missing subsystems and clarifications

---

## 1. Executive Summary

### 1.1 Purpose
This document provides the high-level design for a production-grade voxel sandbox game engine written in Rust. The system emphasizes:
- **Deterministic simulation** for reproducible testing
- **First-class automated testing** via event streams, headless rendering, and replay logs
- **Moddability** through data-driven configuration and optional WASM API
- **Performance** targeting 60 FPS rendering and 20 TPS simulation
- **Cross-platform support** (Windows/Linux/macOS) via wgpu

### 1.2 Design Scope
This HLD covers the transition from the existing JavaScript/Three.js prototype (V1/index.html) to a Rust-based production engine with:
- Multi-crate workspace architecture
- ECS-based entity management (bevy_ecs)
- Authoritative server architecture with client prediction
- Comprehensive testing infrastructure (event streams, world DSL, snapshot tests)
- Infinite terrain generation with chunked storage

### 1.3 Key Design Principles
1. **Separation of Concerns**: Core simulation decoupled from rendering and networking
2. **Determinism First**: Seeded RNG, fixed timestep, no wall-clock dependencies in simulation
3. **Testability**: Event-driven architecture with observable, replayable state changes
4. **Performance**: Cache-friendly data layouts, parallel processing, efficient memory usage
5. **Extensibility**: Plugin system for blocks/items/recipes, WASM modding hooks
6. **Safety**: Type-safe APIs, ownership-based resource management, validated inputs

---

## 2. System Architecture

### 2.1 Workspace Structure

```
workspace/
├── Cargo.toml           # Workspace manifest
├── crates/
│   ├── core/            # Foundation: math, IDs, coordinates, time, RNG, errors
│   ├── ecs/             # ECS facade over bevy_ecs
│   ├── world/           # Blocks, chunks, biomes, generation, lighting, persistence
│   ├── physics/         # AABB collision, movement, raycasting
│   ├── render/          # wgpu renderer, meshing, materials, post-processing
│   ├── net/             # Protocol, serialization, QUIC transport, network IDs
│   ├── server/          # Authoritative simulation loop, headless mode
│   ├── client/          # Input handling, prediction, interpolation, UI shell
│   ├── assets/          # Asset registry, pack loading, validation, hot-reload
│   ├── scripting/       # WASM modding API (post-MVP)
│   ├── testkit/         # Event streams, replay engine, world DSL, golden tests
│   └── cli/             # Binary targets: game-client, game-server, worldtool, worldtest
├── assets/
│   ├── blocks.toml      # Block registry
│   ├── items.toml       # Item registry
│   ├── recipes.json     # Crafting recipes
│   ├── textures/        # Block textures (individual files)
│   ├── atlas.png        # Compiled texture atlas
│   ├── atlas.json       # Atlas UV mapping
│   └── shaders/         # WGSL shaders
├── scenarios/           # .worldtest.toml test scenarios
├── goldens/             # Platform-specific render snapshot hashes
├── config/              # Runtime configuration files
│   ├── server.toml      # Server settings
│   └── client.toml      # Client settings
└── docs/                # Design docs, API references
```

### 2.2 Crate Responsibilities

| Crate | Purpose | Key Dependencies | Thread Safety |
|-------|---------|------------------|---------------|
| **core** | Shared primitives (math, IDs, time, RNG, errors) | None (no_std compatible) | Send + Sync |
| **ecs** | Entity-Component-System abstraction | bevy_ecs | Send + Sync (where applicable) |
| **world** | Chunk storage, blocks, generation, lighting, persistence | core, ecs, fastnoise_lite, rayon | Send (chunks), Sync (registry) |
| **physics** | Collision detection/resolution, raycasting | core, ecs | Send + Sync |
| **render** | Meshing, wgpu pipelines, camera, headless backend | core, world, wgpu, bytemuck | !Send (wgpu types) |
| **net** | Protocol, state sync, network IDs | core, ecs, world, quinn, bincode | Send + Sync |
| **server** | Authoritative tick loop, world management | core, ecs, world, physics, net | Send + Sync |
| **client** | Input, prediction, interpolation, UI | core, ecs, render, net, egui | !Send (window/render) |
| **assets** | Resource loading, pack validation, hot-reload | serde, image, notify | Send + Sync (registry) |
| **scripting** | WASM host API (post-MVP) | wasmtime | Send (runtime isolation) |
| **testkit** | Event recording, replay, DSL, snapshot diffing | serde_json, image, sha2 | Send + Sync |
| **cli** | Binary entry points, command-line interface | all above | N/A (main thread) |

### 2.3 High-Level Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client Binary                            │
│  ┌────────────┐  ┌────────────┐  ┌──────────────────────────┐  │
│  │   Input    │─▶│Prediction  │─▶│  Render Pipeline        │  │
│  │  Handler   │  │Engine      │  │  - Chunk Mesher (async) │  │
│  │  (winit)   │  │            │  │  - Frustum Culling      │  │
│  └────────────┘  └────────────┘  │  - wgpu Renderer        │  │
│         │                │         │  - UI (egui)            │  │
│         └────────────────┴────────▶│  - Post-FX              │  │
│                          │         └──────────────────────────┘  │
│                          ▼                                       │
│                   ┌─────────────┐                                │
│                   │  Net Client │                                │
│                   │  (QUIC)     │◀───────────────────────────────┤
│                   └─────────────┘                                │
└──────────────────────┬──────────────────────────────────────────┘
                       │ QUIC (encrypted, reliable UDP)
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Server Binary                            │
│  ┌────────────┐  ┌────────────┐  ┌──────────────────────────┐  │
│  │ Net Server │─▶│  Tick Loop │─▶│  World Manager          │  │
│  │  (QUIC)    │  │  (20 TPS)  │  │  - Chunk Store          │  │
│  │            │  │  (fixed Δt)│  │  - Generation Queue     │  │
│  └────────────┘  └────────────┘  │  - Light Propagation    │  │
│         ▲                │         │  - Physics System       │  │
│         │                │         └──────────────────────────┘  │
│         │                ▼                      │                │
│         │         ┌─────────────┐               ▼                │
│         │         │     ECS     │        ┌─────────────┐         │
│         │         │  (bevy_ecs) │───────▶│  Event Bus  │         │
│         │         └─────────────┘        │  (testkit)  │         │
│         │                │                └─────────────┘         │
│         │                ▼                       │                │
│         │         ┌─────────────┐               ▼                │
│         └─────────│ State Sync  │        ┌─────────────┐         │
│                   │  (delta)    │        │ Persistence │         │
│                   └─────────────┘        │ (.rg files) │         │
│                                          └─────────────┘         │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 Threading Model

```
Main Thread
├── Window Event Loop (client only)
├── Render Command Submission
└── Network I/O (main coordination)

Simulation Thread (server/integrated)
├── Fixed 20 TPS tick loop
├── ECS system execution
├── Physics integration
└── Event emission

Worker Pool (rayon)
├── Chunk Generation (parallel)
├── Chunk Meshing (parallel)
├── Lighting Propagation (batched)
└── Save/Load I/O (parallel)

Network Thread (tokio)
├── QUIC connection handling
├── Packet serialization/deserialization
└── Compression/decompression

Asset Thread (notify)
├── File watching for hot-reload
├── Texture loading/compilation
└── Asset validation
```

**Thread Safety Guarantees:**
- World state protected by RwLock for read-heavy access
- Chunk generation isolated (no shared state)
- ECS systems scheduled with conflict detection
- Network messages passed via channels (mpsc)

---

## 3. Core Subsystems Design

### 3.1 Coordinate System & Data Model

#### 3.1.1 World Coordinates
- **System**: Right-handed, Y-up (X=east, Y=up, Z=south)
- **Chunk Size**: 16×256×16 voxels (X, Y, Z)
- **Chunk Coordinates**: 2D (X, Z) - chunks span full Y range
- **World Bounds**: Infinite horizontal (lazy chunk loading), Y ∈ [0, 256) (MVP), expandable to [0, 512)
- **Region Files**: 32×32 chunk groups (2D grid) saved as `.rg` files

**Coordinate Conversion:**
```rust
// core/src/coords.rs
pub const CHUNK_SIZE_X: i32 = 16;
pub const CHUNK_SIZE_Y: i32 = 256;
pub const CHUNK_SIZE_Z: i32 = 16;

pub type BlockPos = IVec3;      // World block position
pub type ChunkPos = IVec2;      // Chunk position (X, Z only)
pub type LocalPos = IVec3;      // Local position within chunk [0..16, 0..256, 0..16)

pub fn block_to_chunk(pos: BlockPos) -> ChunkPos {
    IVec2::new(
        pos.x.div_euclid(CHUNK_SIZE_X),
        pos.z.div_euclid(CHUNK_SIZE_Z),
    )
}

pub fn block_to_local(pos: BlockPos) -> LocalPos {
    IVec3::new(
        pos.x.rem_euclid(CHUNK_SIZE_X),
        pos.y,
        pos.z.rem_euclid(CHUNK_SIZE_Z),
    )
}

pub fn local_to_index(local: LocalPos) -> usize {
    debug_assert!(local.x >= 0 && local.x < CHUNK_SIZE_X);
    debug_assert!(local.y >= 0 && local.y < CHUNK_SIZE_Y);
    debug_assert!(local.z >= 0 && local.z < CHUNK_SIZE_Z);

    ((local.y * CHUNK_SIZE_Z * CHUNK_SIZE_X) + (local.z * CHUNK_SIZE_X) + local.x) as usize
}
```

#### 3.1.2 Block Representation

```rust
// core/src/block.rs
#[derive(Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(transparent)]
pub struct BlockId(pub u16);  // Index into registry, 0 = air

impl BlockId {
    pub const AIR: BlockId = BlockId(0);
    pub const MAX: BlockId = BlockId(u16::MAX);
}

/// Block state stores orientation, moisture, growth stage, etc.
/// Bit layout (16 bits):
/// - [0-3]:   Rotation (0-15, typically 0-3 for 90° increments)
/// - [4-7]:   Growth/Damage stage (0-15)
/// - [8-11]:  Moisture/Wetness (0-15)
/// - [12-15]: Custom flags (powered, open, etc.)
#[derive(Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[repr(transparent)]
pub struct BlockState(pub u16);

impl BlockState {
    pub const DEFAULT: BlockState = BlockState(0);

    pub fn rotation(self) -> u8 { (self.0 & 0xF) as u8 }
    pub fn with_rotation(self, rot: u8) -> Self { Self((self.0 & !0xF) | (rot as u16 & 0xF)) }

    pub fn growth_stage(self) -> u8 { ((self.0 >> 4) & 0xF) as u8 }
    pub fn with_growth(self, stage: u8) -> Self { Self((self.0 & !0xF0) | ((stage as u16 & 0xF) << 4)) }
}

/// Voxel data: 6 bytes per block (compressed via palette in future)
#[derive(Clone, Copy)]
#[repr(C, packed)]
pub struct Voxel {
    pub id: BlockId,           // 2 bytes
    pub state: BlockState,     // 2 bytes
    pub light_sky: u8,         // 1 byte: skylight 0-15
    pub light_block: u8,       // 1 byte: block light 0-15
}

impl Voxel {
    pub const AIR: Voxel = Voxel {
        id: BlockId::AIR,
        state: BlockState::DEFAULT,
        light_sky: 15,
        light_block: 0,
    };

    #[inline]
    pub fn is_air(&self) -> bool {
        self.id == BlockId::AIR
    }

    pub fn combined_light(&self) -> u8 {
        self.light_sky.max(self.light_block)
    }
}
```

#### 3.1.3 Chunk Storage (Revised)

**Issue:** Original design used `Box<[Voxel; 16*256*16]>` (4MB per chunk on heap, fragmentation risk)

**Solution:** Use `Vec<Voxel>` with capacity pre-allocated, add chunk state machine

```rust
// world/src/chunk.rs
pub const CHUNK_VOLUME: usize = (CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z) as usize; // 65,536

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChunkState {
    Empty,           // Not yet requested
    Queued,          // In generation queue
    Generating,      // Currently being generated
    Generated,       // Generation complete, needs lighting
    Lighting,        // Lighting pass in progress
    Ready,           // Ready for meshing/use
    Unloading,       // Marked for save and unload
}

pub struct Chunk {
    pub position: ChunkPos,
    voxels: Vec<Voxel>,              // Always CHUNK_VOLUME elements when state >= Generated
    pub state: ChunkState,
    pub dirty_mesh: bool,
    pub light_dirty: bool,
    pub modified: bool,              // Needs saving
    pub last_access: u64,            // Tick number for LRU
    light_queue: VecDeque<(LocalPos, u8, bool)>, // (pos, level, is_skylight)
}

impl Chunk {
    pub fn new(position: ChunkPos) -> Self {
        Self {
            position,
            voxels: Vec::new(),
            state: ChunkState::Empty,
            dirty_mesh: false,
            light_dirty: false,
            modified: false,
            last_access: 0,
            light_queue: VecDeque::new(),
        }
    }

    pub fn allocate(&mut self) {
        if self.voxels.is_empty() {
            self.voxels = vec![Voxel::AIR; CHUNK_VOLUME];
        }
    }

    #[inline]
    pub fn get_local(&self, local: LocalPos) -> Option<Voxel> {
        if local.x < 0 || local.y < 0 || local.z < 0
            || local.x >= CHUNK_SIZE_X
            || local.y >= CHUNK_SIZE_Y
            || local.z >= CHUNK_SIZE_Z {
            return None;
        }
        Some(self.voxels[local_to_index(local)])
    }

    #[inline]
    pub fn set_local(&mut self, local: LocalPos, voxel: Voxel) -> bool {
        if local.x < 0 || local.y < 0 || local.z < 0
            || local.x >= CHUNK_SIZE_X
            || local.y >= CHUNK_SIZE_Y
            || local.z >= CHUNK_SIZE_Z {
            return false;
        }
        let idx = local_to_index(local);
        if self.voxels[idx].id != voxel.id || self.voxels[idx].state != voxel.state {
            self.voxels[idx] = voxel;
            self.dirty_mesh = true;
            self.modified = true;
        }
        true
    }

    pub fn fill(&mut self, voxel: Voxel) {
        self.voxels.fill(voxel);
        self.dirty_mesh = true;
        self.modified = true;
    }
}

pub struct ChunkManager {
    chunks: HashMap<ChunkPos, Chunk>,
    generation_queue: VecDeque<ChunkPos>,
    load_radius: u32,
    unload_distance: u32,           // load_radius + 2
    max_loaded_chunks: usize,       // Memory limit
}

impl ChunkManager {
    pub fn new() -> Self {
        Self {
            chunks: HashMap::with_capacity(1024),
            generation_queue: VecDeque::new(),
            load_radius: 8,
            unload_distance: 10,
            max_loaded_chunks: 2048, // ~8GB at 4MB per chunk
        }
    }

    pub fn request_chunk(&mut self, pos: ChunkPos) {
        if !self.chunks.contains_key(&pos) {
            let mut chunk = Chunk::new(pos);
            chunk.state = ChunkState::Queued;
            self.generation_queue.push_back(pos);
            self.chunks.insert(pos, chunk);
        }
    }

    pub fn get_voxel(&self, pos: BlockPos) -> Option<Voxel> {
        let chunk_pos = block_to_chunk(pos);
        let local = block_to_local(pos);
        self.chunks.get(&chunk_pos)?.get_local(local)
    }

    pub fn set_voxel(&mut self, pos: BlockPos, voxel: Voxel) -> bool {
        let chunk_pos = block_to_chunk(pos);
        let local = block_to_local(pos);
        if let Some(chunk) = self.chunks.get_mut(&chunk_pos) {
            chunk.set_local(local, voxel)
        } else {
            false
        }
    }

    /// Unload distant chunks based on LRU + distance
    pub fn unload_distant_chunks(&mut self, center: ChunkPos, current_tick: u64) {
        let mut to_unload = Vec::new();

        for (pos, chunk) in &self.chunks {
            let dx = (pos.x - center.x).abs();
            let dz = (pos.y - center.y).abs();
            let dist = (dx * dx + dz * dz) as f32;

            if dist > (self.unload_distance * self.unload_distance) as f32 {
                to_unload.push(*pos);
            }
        }

        // LRU eviction if over memory limit
        if self.chunks.len() > self.max_loaded_chunks {
            let mut chunks_by_access: Vec<_> = self.chunks.iter()
                .map(|(pos, chunk)| (*pos, chunk.last_access))
                .collect();
            chunks_by_access.sort_by_key(|(_, access)| *access);

            let num_to_evict = self.chunks.len() - self.max_loaded_chunks;
            to_unload.extend(chunks_by_access.iter().take(num_to_evict).map(|(pos, _)| pos));
        }

        for pos in to_unload {
            if let Some(chunk) = self.chunks.get_mut(&pos) {
                if chunk.modified {
                    chunk.state = ChunkState::Unloading;
                    // Schedule save (handled by persistence system)
                } else {
                    self.chunks.remove(&pos);
                }
            }
        }
    }
}
```

### 3.2 Entity Component System (ECS)

#### 3.2.1 Component Design

**Issue:** Missing item/entity metadata, no network ID mapping

**Solution:** Add comprehensive component set + network ID system

```rust
// ecs/src/components.rs
use glam::{Quat, Vec3};
use bevy_ecs::prelude::*;

// === Transform & Physics ===

#[derive(Component, Clone, Debug)]
pub struct Transform {
    pub position: Vec3,
    pub rotation: Quat,
}

#[derive(Component, Clone, Copy, Debug)]
pub struct Velocity(pub Vec3);

#[derive(Component, Clone, Copy, Debug)]
pub struct Acceleration(pub Vec3);

#[derive(Component, Clone, Copy, Debug)]
pub struct Collider {
    pub kind: ColliderKind,
    pub radius: f32,
    pub height: f32,
}

#[derive(Clone, Copy, Debug)]
pub enum ColliderKind {
    Capsule,
    AABB,
    Sphere,
}

#[derive(Component, Clone, Copy, Debug)]
pub struct RigidBody {
    pub mass: f32,
    pub friction: f32,
    pub restitution: f32,
    pub gravity_scale: f32,
}

#[derive(Component, Clone, Copy, Debug)]
pub struct OnGround(pub bool);

// === Gameplay ===

#[derive(Component, Clone, Debug)]
pub struct Health {
    pub current: f32,
    pub max: f32,
    pub invulnerable_until: Option<u64>, // Tick number
}

#[derive(Component, Clone, Debug)]
pub struct Inventory {
    pub slots: Vec<Option<ItemStack>>,
    pub selected_slot: usize,
}

#[derive(Clone, Debug)]
pub struct ItemStack {
    pub item_id: u16,
    pub count: u32,
    pub durability: Option<u32>,
}

#[derive(Component, Clone, Debug)]
pub struct Hunger {
    pub food_level: f32,
    pub saturation: f32,
}

// === Entity Types ===

#[derive(Component, Clone, Copy, Debug)]
pub struct PlayerTag;

#[derive(Component, Clone, Debug)]
pub struct PlayerInfo {
    pub username: String,
    pub uuid: u128,
}

#[derive(Component, Clone, Copy, Debug)]
pub struct MobAI {
    pub state: AIState,
    pub target: Option<Entity>,
    pub path: Option<PathId>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum AIState {
    Idle,
    Wander,
    Chase,
    Flee,
    Attack,
}

#[derive(Component, Clone, Copy, Debug)]
pub struct ItemEntity {
    pub item_id: u16,
    pub count: u32,
    pub pickup_delay: u16, // Ticks until pickupable
}

// === Networking ===

/// Stable network ID (separate from ECS Entity which is not network-safe)
#[derive(Component, Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct NetworkId(pub u64);

/// Marks entities that should be synchronized over network
#[derive(Component, Clone, Copy, Debug)]
pub struct Replicated {
    pub owner_client: Option<u64>, // Client that owns this entity (for client prediction)
}

/// Interpolation state for smooth rendering between ticks
#[derive(Component, Clone, Debug)]
pub struct Interpolation {
    pub prev_position: Vec3,
    pub prev_rotation: Quat,
    pub alpha: f32, // [0, 1] between ticks
}

// === Metadata ===

#[derive(Component, Clone, Debug)]
pub struct Name(pub String);

#[derive(Component, Clone, Copy, Debug)]
pub struct Lifetime {
    pub spawn_tick: u64,
    pub max_age_ticks: u64,
}

#[derive(Component, Clone, Copy, Debug)]
pub struct ChunkAnchor {
    pub load_radius: u32, // This entity keeps nearby chunks loaded
}
```

#### 3.2.2 System Scheduling (20 TPS)

**Issue:** Missing details on system dependencies, parallel execution

**Solution:** Detailed system schedule with stages and parallel execution

```rust
// server/src/tick.rs
use bevy_ecs::schedule::{Schedule, Stage, SystemStage};

pub struct SimulationSchedule {
    schedule: Schedule,
}

impl SimulationSchedule {
    pub fn new() -> Self {
        let mut schedule = Schedule::default();

        // Stage 1: Pre-Tick (single-threaded)
        schedule.add_stage(
            "pre_tick",
            SystemStage::single_threaded()
                .with_system(start_tick_event)
                .with_system(process_input_packets)
                .with_system(update_chunk_loading),
        );

        // Stage 2: World Updates (parallel where possible)
        schedule.add_stage_after(
            "pre_tick",
            "world_update",
            SystemStage::parallel()
                .with_system(tick_random_blocks)
                .with_system(update_lighting)
                .with_system(process_block_updates)
                .with_system(update_fluids),
        );

        // Stage 3: Physics (sequential substages)
        schedule.add_stage_after(
            "world_update",
            "physics",
            SystemStage::parallel()
                .with_system(apply_acceleration)
                .with_system(apply_gravity)
                .with_system(integrate_velocity)
                .with_system(resolve_collisions)
                .with_system(update_on_ground),
        );

        // Stage 4: Gameplay Logic (parallel)
        schedule.add_stage_after(
            "physics",
            "gameplay",
            SystemStage::parallel()
                .with_system(update_mob_ai)
                .with_system(process_combat)
                .with_system(update_health)
                .with_system(process_item_pickup)
                .with_system(update_hunger)
                .with_system(process_crafting),
        );

        // Stage 5: Lifetime & Cleanup
        schedule.add_stage_after(
            "gameplay",
            "cleanup",
            SystemStage::parallel()
                .with_system(update_lifetimes)
                .with_system(despawn_dead_entities)
                .with_system(cleanup_expired_chunks),
        );

        // Stage 6: Post-Tick (single-threaded)
        schedule.add_stage_after(
            "cleanup",
            "post_tick",
            SystemStage::single_threaded()
                .with_system(emit_events)
                .with_system(prepare_state_delta)
                .with_system(send_state_updates)
                .with_system(end_tick_event),
        );

        Self { schedule }
    }

    pub fn run(&mut self, world: &mut World) {
        self.schedule.run_once(world);
    }
}
```

### 3.3 World Generation Pipeline

#### 3.3.1 Generation Stages

**Issue:** Missing biome blending, structure placement constraints, neighbor handling

**Solution:** Enhanced pipeline with neighbor cache and biome interpolation

```rust
// world/src/generation/mod.rs
use rayon::prelude::*;

pub struct GenerationPipeline {
    seed: u64,
    stages: Vec<Box<dyn GenerationStage>>,
    biome_map: BiomeMap,
}

pub trait GenerationStage: Send + Sync {
    fn name(&self) -> &str;
    fn generate(&self, chunk: &mut Chunk, ctx: &GenerationContext);
}

pub struct GenerationContext {
    pub seed: u64,
    pub chunk_pos: ChunkPos,
    pub neighbors: NeighborCache,
    pub biome_map: BiomeMap,
}

/// Cache of neighboring chunk data needed for generation
pub struct NeighborCache {
    north: Option<Arc<Chunk>>,
    south: Option<Arc<Chunk>>,
    east: Option<Arc<Chunk>>,
    west: Option<Arc<Chunk>>,
}

impl NeighborCache {
    pub fn get_voxel(&self, offset: IVec3) -> Option<Voxel> {
        // Retrieve voxel from neighbor chunk if offset is outside current chunk
        // This allows seamless structure placement across chunk boundaries
        todo!()
    }
}

/// Biome interpolation for smooth transitions
pub struct BiomeMap {
    temperature_noise: FastNoiseLite,
    moisture_noise: FastNoiseLite,
}

impl BiomeMap {
    pub fn get_biome(&self, world_x: i32, world_z: i32) -> Biome {
        let temp = self.temperature_noise.get_noise_2d(world_x as f32, world_z as f32);
        let moisture = self.moisture_noise.get_noise_2d(world_x as f32, world_z as f32);

        // Map to biome based on temperature/moisture
        match (temp, moisture) {
            (t, m) if t < -0.3 => Biome::Tundra,
            (t, m) if t > 0.5 && m < 0.0 => Biome::Desert,
            (t, m) if m > 0.3 => Biome::Forest,
            _ => Biome::Plains,
        }
    }

    /// Get interpolated biome weights for smooth transitions
    pub fn get_biome_blend(&self, world_x: i32, world_z: i32, radius: f32) -> BiomeBlend {
        let mut weights = HashMap::new();
        let mut total = 0.0;

        // Sample surrounding points
        for dx in -1..=1 {
            for dz in -1..=1 {
                let x = world_x + dx * radius as i32;
                let z = world_z + dz * radius as i32;
                let biome = self.get_biome(x, z);
                let dist = ((dx * dx + dz * dz) as f32).sqrt();
                let weight = 1.0 / (1.0 + dist);
                *weights.entry(biome).or_insert(0.0) += weight;
                total += weight;
            }
        }

        // Normalize weights
        for (_, weight) in weights.iter_mut() {
            *weight /= total;
        }

        BiomeBlend { weights }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Biome {
    Plains,
    Forest,
    Desert,
    Tundra,
    Mountains,
    Ocean,
}

pub struct BiomeBlend {
    weights: HashMap<Biome, f32>,
}

// Pipeline stages:

pub struct BaseHeightmapStage {
    noise: FastNoiseLite,
}

impl GenerationStage for BaseHeightmapStage {
    fn name(&self) -> &str { "heightmap" }

    fn generate(&self, chunk: &mut Chunk, ctx: &GenerationContext) {
        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = chunk.position.x * CHUNK_SIZE_X + local_x;
                let world_z = chunk.position.y * CHUNK_SIZE_Z + local_z;

                // Multi-octave noise
                let height = self.sample_height(world_x, world_z);
                let y = (64.0 + height * 32.0).clamp(0.0, 255.0) as i32;

                // Fill up to height
                for local_y in 0..=y {
                    let local = IVec3::new(local_x, local_y, local_z);
                    chunk.set_local(local, Voxel {
                        id: BlockId(1), // Stone placeholder
                        state: BlockState::DEFAULT,
                        light_sky: 0,
                        light_block: 0,
                    });
                }
            }
        }
    }
}

pub struct SurfaceCompositionStage;

impl GenerationStage for SurfaceCompositionStage {
    fn name(&self) -> &str { "surface" }

    fn generate(&self, chunk: &mut Chunk, ctx: &GenerationContext) {
        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = chunk.position.x * CHUNK_SIZE_X + local_x;
                let world_z = chunk.position.y * CHUNK_SIZE_Z + local_z;

                // Get blended biome
                let blend = ctx.biome_map.get_biome_blend(world_x, world_z, 8.0);

                // Find surface
                let mut surface_y = None;
                for y in (0..CHUNK_SIZE_Y).rev() {
                    let local = IVec3::new(local_x, y, local_z);
                    if let Some(voxel) = chunk.get_local(local) {
                        if !voxel.is_air() {
                            surface_y = Some(y);
                            break;
                        }
                    }
                }

                if let Some(surface) = surface_y {
                    // Apply surface layers based on biome
                    // Top: grass/sand
                    // Below: dirt/sandstone (3-5 layers)
                    // Below: stone
                    let local = IVec3::new(local_x, surface, local_z);
                    chunk.set_local(local, Voxel {
                        id: BlockId(1), // Grass
                        ..Voxel::AIR
                    });

                    for depth in 1..4 {
                        if surface >= depth {
                            let local = IVec3::new(local_x, surface - depth, local_z);
                            chunk.set_local(local, Voxel {
                                id: BlockId(2), // Dirt
                                ..Voxel::AIR
                            });
                        }
                    }
                }
            }
        }
    }
}

pub struct CaveCarverStage {
    cave_noise: FastNoiseLite,
}

impl GenerationStage for CaveCarverStage {
    fn name(&self) -> &str { "caves" }

    fn generate(&self, chunk: &mut Chunk, ctx: &GenerationContext) {
        for local_x in 0..CHUNK_SIZE_X {
            for local_y in 8..128 { // Caves only in middle elevation
                for local_z in 0..CHUNK_SIZE_Z {
                    let world_x = chunk.position.x * CHUNK_SIZE_X + local_x;
                    let world_z = chunk.position.y * CHUNK_SIZE_Z + local_z;

                    // 3D cave noise
                    let cave_value = self.cave_noise.get_noise_3d(
                        world_x as f32 * 0.02,
                        local_y as f32 * 0.02,
                        world_z as f32 * 0.02,
                    );

                    if cave_value > 0.6 { // Threshold for cave
                        let local = IVec3::new(local_x, local_y, local_z);
                        chunk.set_local(local, Voxel::AIR);
                    }
                }
            }
        }
    }
}

pub struct StructurePlacementStage;

impl GenerationStage for StructurePlacementStage {
    fn name(&self) -> &str { "structures" }

    fn generate(&self, chunk: &mut Chunk, ctx: &GenerationContext) {
        // Trees, ores, etc.
        // Use seeded RNG for deterministic placement
        let mut rng = DeterministicRng::from_world_and_chunk(ctx.seed, chunk.position);

        // Attempt tree placement at several positions
        for _ in 0..8 {
            let local_x = rng.gen_range(1, CHUNK_SIZE_X - 1);
            let local_z = rng.gen_range(1, CHUNK_SIZE_Z - 1);

            // Find surface
            let mut surface_y = None;
            for y in (0..CHUNK_SIZE_Y).rev() {
                let local = IVec3::new(local_x, y, local_z);
                if let Some(voxel) = chunk.get_local(local) {
                    if !voxel.is_air() && voxel.id == BlockId(1) { // Grass
                        surface_y = Some(y);
                        break;
                    }
                }
            }

            if let Some(y) = surface_y {
                if rng.gen_f32() < 0.1 { // 10% chance
                    self.place_tree(chunk, IVec3::new(local_x, y + 1, local_z), &mut rng);
                }
            }
        }
    }
}
```

#### 3.3.2 Determinism Guarantees

**Enhanced:**
- All noise functions seeded by `hash(world_seed, chunk_pos)`
- No cross-chunk writes during generation (reads allowed via NeighborCache)
- Floating-point operations quantized before affecting block placement
- Structure placement uses seeded RNG per-chunk
- Generation order independent (chunks can generate in any order)

### 3.4 Lighting System

#### 3.4.1 Propagation Model

**Issue:** Cross-chunk propagation unclear, missing optimization strategies

**Solution:** Chunked BFS with border queues and incremental updates

```rust
// world/src/lighting.rs
use std::collections::{VecDeque, HashSet};

pub struct LightingEngine {
    // Per-chunk queues for local propagation
    add_queue: VecDeque<(ChunkPos, LocalPos, u8, bool)>, // (chunk, local, level, is_skylight)
    remove_queue: VecDeque<(ChunkPos, LocalPos, u8, bool)>,

    // Chunks that need lighting updates
    dirty_chunks: HashSet<ChunkPos>,

    // Max updates per tick (to prevent lag spikes)
    max_updates_per_tick: usize,
}

impl LightingEngine {
    pub fn new() -> Self {
        Self {
            add_queue: VecDeque::new(),
            remove_queue: VecDeque::new(),
            dirty_chunks: HashSet::new(),
            max_updates_per_tick: 10000,
        }
    }

    /// Add a light source at world position
    pub fn add_light_source(&mut self, world_pos: BlockPos, level: u8, is_skylight: bool) {
        let chunk_pos = block_to_chunk(world_pos);
        let local_pos = block_to_local(world_pos);
        self.add_queue.push_back((chunk_pos, local_pos, level, is_skylight));
        self.dirty_chunks.insert(chunk_pos);
    }

    /// Remove light source at world position
    pub fn remove_light_source(&mut self, world_pos: BlockPos, is_skylight: bool) {
        let chunk_pos = block_to_chunk(world_pos);
        let local_pos = block_to_local(world_pos);

        // Need to know current light level to remove
        // This is stored in the voxel
        self.remove_queue.push_back((chunk_pos, local_pos, 0, is_skylight));
        self.dirty_chunks.insert(chunk_pos);
    }

    /// Process lighting updates (call once per tick)
    pub fn tick(&mut self, world: &mut ChunkManager) {
        let mut updates = 0;

        // Process removals first
        while let Some((chunk_pos, local_pos, level, is_skylight)) = self.remove_queue.pop_front() {
            if updates >= self.max_updates_per_tick {
                // Re-queue for next tick
                self.remove_queue.push_front((chunk_pos, local_pos, level, is_skylight));
                break;
            }

            self.propagate_remove(world, chunk_pos, local_pos, is_skylight);
            updates += 1;
        }

        // Process additions
        while let Some((chunk_pos, local_pos, level, is_skylight)) = self.add_queue.pop_front() {
            if updates >= self.max_updates_per_tick {
                self.add_queue.push_front((chunk_pos, local_pos, level, is_skylight));
                break;
            }

            self.propagate_add(world, chunk_pos, local_pos, level, is_skylight);
            updates += 1;
        }

        // Mark chunks dirty for remeshing
        for chunk_pos in self.dirty_chunks.drain() {
            if let Some(chunk) = world.chunks.get_mut(&chunk_pos) {
                chunk.dirty_mesh = true;
            }
        }
    }

    fn propagate_add(
        &mut self,
        world: &mut ChunkManager,
        chunk_pos: ChunkPos,
        local_pos: LocalPos,
        level: u8,
        is_skylight: bool,
    ) {
        if level == 0 {
            return;
        }

        // Get current light
        let world_pos = chunk_local_to_world(chunk_pos, local_pos);
        let current_voxel = world.get_voxel(world_pos);
        if current_voxel.is_none() {
            return;
        }

        let mut voxel = current_voxel.unwrap();
        let current_light = if is_skylight {
            voxel.light_sky
        } else {
            voxel.light_block
        };

        // Only update if new light is brighter
        if level <= current_light {
            return;
        }

        // Set new light level
        if is_skylight {
            voxel.light_sky = level;
        } else {
            voxel.light_block = level;
        }
        world.set_voxel(world_pos, voxel);

        // Propagate to neighbors
        let neighbors = [
            BlockPos::new(world_pos.x + 1, world_pos.y, world_pos.z),
            BlockPos::new(world_pos.x - 1, world_pos.y, world_pos.z),
            BlockPos::new(world_pos.x, world_pos.y + 1, world_pos.z),
            BlockPos::new(world_pos.x, world_pos.y - 1, world_pos.z),
            BlockPos::new(world_pos.x, world_pos.y, world_pos.z + 1),
            BlockPos::new(world_pos.x, world_pos.y, world_pos.z - 1),
        ];

        for neighbor_pos in neighbors {
            if let Some(neighbor) = world.get_voxel(neighbor_pos) {
                if neighbor.is_air() {
                    let next_level = level.saturating_sub(1);
                    let neighbor_chunk = block_to_chunk(neighbor_pos);
                    let neighbor_local = block_to_local(neighbor_pos);
                    self.add_queue.push_back((neighbor_chunk, neighbor_local, next_level, is_skylight));
                    self.dirty_chunks.insert(neighbor_chunk);
                }
            }
        }
    }

    fn propagate_remove(
        &mut self,
        world: &mut ChunkManager,
        chunk_pos: ChunkPos,
        local_pos: LocalPos,
        is_skylight: bool,
    ) {
        // BFS removal algorithm:
        // 1. Clear light at position
        // 2. Propagate removal to all neighbors with lower light
        // 3. Re-light from any remaining sources found during removal

        let world_pos = chunk_local_to_world(chunk_pos, local_pos);
        let current_voxel = world.get_voxel(world_pos);
        if current_voxel.is_none() {
            return;
        }

        let mut voxel = current_voxel.unwrap();
        let original_level = if is_skylight {
            voxel.light_sky
        } else {
            voxel.light_block
        };

        if original_level == 0 {
            return;
        }

        // Clear this position
        if is_skylight {
            voxel.light_sky = 0;
        } else {
            voxel.light_block = 0;
        }
        world.set_voxel(world_pos, voxel);

        // Queue to propagate removal
        let mut removal_queue = VecDeque::new();
        removal_queue.push_back((world_pos, original_level));

        // Queue to re-light from remaining sources
        let mut relight_queue = Vec::new();

        while let Some((pos, level)) = removal_queue.pop_front() {
            let neighbors = [
                BlockPos::new(pos.x + 1, pos.y, pos.z),
                BlockPos::new(pos.x - 1, pos.y, pos.z),
                BlockPos::new(pos.x, pos.y + 1, pos.z),
                BlockPos::new(pos.x, pos.y - 1, pos.z),
                BlockPos::new(pos.x, pos.y, pos.z + 1),
                BlockPos::new(pos.x, pos.y, pos.z - 1),
            ];

            for neighbor_pos in neighbors {
                if let Some(mut neighbor) = world.get_voxel(neighbor_pos) {
                    let neighbor_light = if is_skylight {
                        neighbor.light_sky
                    } else {
                        neighbor.light_block
                    };

                    if neighbor_light > 0 && neighbor_light < level {
                        // This neighbor needs removal
                        if is_skylight {
                            neighbor.light_sky = 0;
                        } else {
                            neighbor.light_block = 0;
                        }
                        world.set_voxel(neighbor_pos, neighbor);
                        removal_queue.push_back((neighbor_pos, neighbor_light));
                    } else if neighbor_light >= level {
                        // This is a source, re-light from it
                        relight_queue.push((neighbor_pos, neighbor_light));
                    }
                }
            }
        }

        // Re-light from remaining sources
        for (pos, level) in relight_queue {
            let chunk = block_to_chunk(pos);
            let local = block_to_local(pos);
            self.add_queue.push_back((chunk, local, level, is_skylight));
        }
    }
}

fn chunk_local_to_world(chunk_pos: ChunkPos, local_pos: LocalPos) -> BlockPos {
    BlockPos::new(
        chunk_pos.x * CHUNK_SIZE_X + local_pos.x,
        local_pos.y,
        chunk_pos.y * CHUNK_SIZE_Z + local_pos.z,
    )
}
```

#### 3.4.2 Skylight vs Sunlight

**Clarification:** Skylight is ambient light from above, sunlight is directional and time-dependent

```rust
// Skylight: Always 15 at top, floods down
// Sunlight: Modulated by time of day (0-15 based on sun angle)
// Block light: Emissive blocks (torches, etc.)

pub fn compute_effective_light(voxel: Voxel, time_of_day: f32) -> f32 {
    let sunlight_multiplier = compute_sunlight_multiplier(time_of_day);
    let sky_contribution = voxel.light_sky as f32 * sunlight_multiplier;
    let block_contribution = voxel.light_block as f32;
    sky_contribution.max(block_contribution) / 15.0
}

fn compute_sunlight_multiplier(time_of_day: f32) -> f32 {
    // time_of_day in [0, 1], 0.5 = noon
    let angle = (time_of_day - 0.5) * std::f32::consts::PI;
    let brightness = angle.cos();
    brightness.max(0.1) // Minimum moonlight
}
```

### 3.5 Meshing & Rendering

#### 3.5.1 Greedy Meshing Algorithm (Enhanced)

**Issue:** Missing texture atlas UV mapping, AO calculation details

**Solution:** Complete meshing with atlas support and vertex AO

```rust
// render/src/meshing.rs
use glam::{Vec2, Vec3};

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
pub struct Vertex {
    pub position: [f32; 3],      // 12 bytes
    pub uv: [f32; 2],            // 8 bytes
    pub normal: [f32; 3],        // 12 bytes (for lighting)
    pub light: u8,               // 1 byte: combined light 0-15
    pub ao: u8,                  // 1 byte: ambient occlusion 0-3
    pub _padding: [u8; 2],       // 2 bytes: padding to 36 bytes
}

impl Vertex {
    pub const LAYOUT: wgpu::VertexBufferLayout<'static> = wgpu::VertexBufferLayout {
        array_stride: std::mem::size_of::<Vertex>() as wgpu::BufferAddress,
        step_mode: wgpu::VertexStepMode::Vertex,
        attributes: &[
            wgpu::VertexAttribute {
                offset: 0,
                shader_location: 0,
                format: wgpu::VertexFormat::Float32x3,
            },
            wgpu::VertexAttribute {
                offset: 12,
                shader_location: 1,
                format: wgpu::VertexFormat::Float32x2,
            },
            wgpu::VertexAttribute {
                offset: 20,
                shader_location: 2,
                format: wgpu::VertexFormat::Float32x3,
            },
            wgpu::VertexAttribute {
                offset: 32,
                shader_location: 3,
                format: wgpu::VertexFormat::Uint8,
            },
            wgpu::VertexAttribute {
                offset: 33,
                shader_location: 4,
                format: wgpu::VertexFormat::Uint8,
            },
        ],
    };
}

pub struct ChunkMesh {
    pub opaque_vertices: Vec<Vertex>,
    pub opaque_indices: Vec<u32>,
    pub transparent_vertices: Vec<Vertex>,
    pub transparent_indices: Vec<u32>,
    pub hash: u64, // For deterministic testing
}

pub struct MeshingContext<'a> {
    pub chunk: &'a Chunk,
    pub neighbors: [Option<&'a Chunk>; 6], // [+X, -X, +Y, -Y, +Z, -Z]
    pub block_registry: &'a BlockRegistry,
    pub texture_atlas: &'a TextureAtlas,
}

pub fn greedy_mesh(ctx: MeshingContext) -> ChunkMesh {
    let mut opaque_verts = Vec::new();
    let mut opaque_indices = Vec::new();
    let mut transparent_verts = Vec::new();
    let mut transparent_indices = Vec::new();

    // Mesh each axis
    for axis in 0..3 {
        for direction in [-1, 1] {
            mesh_axis(
                &ctx,
                axis,
                direction,
                &mut opaque_verts,
                &mut opaque_indices,
                &mut transparent_verts,
                &mut transparent_indices,
            );
        }
    }

    // Compute hash for testing
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    for v in &opaque_verts {
        hasher.write(&bytemuck::bytes_of(v));
    }
    let hash = hasher.finish();

    ChunkMesh {
        opaque_vertices: opaque_verts,
        opaque_indices: opaque_indices,
        transparent_vertices: transparent_verts,
        transparent_indices: transparent_indices,
        hash,
    }
}

fn mesh_axis(
    ctx: &MeshingContext,
    axis: usize,
    direction: i32,
    opaque_verts: &mut Vec<Vertex>,
    opaque_indices: &mut Vec<u32>,
    transparent_verts: &mut Vec<Vertex>,
    transparent_indices: &mut Vec<u32>,
) {
    // Create mask for this slice direction
    let (u_axis, v_axis) = match axis {
        0 => (1, 2), // X: iterate YZ
        1 => (0, 2), // Y: iterate XZ
        2 => (0, 1), // Z: iterate XY
        _ => unreachable!(),
    };

    let dims = [CHUNK_SIZE_X, CHUNK_SIZE_Y, CHUNK_SIZE_Z];
    let u_max = dims[u_axis];
    let v_max = dims[v_axis];
    let w_max = dims[axis];

    let mut mask = vec![None; (u_max * v_max) as usize];

    // Iterate through slices perpendicular to axis
    for w in 0..w_max {
        // Fill mask for this slice
        fill_mask(ctx, axis, direction, w, &mut mask, u_max, v_max);

        // Greedy merge quads
        for v in 0..v_max {
            for u in 0..u_max {
                let idx = (v * u_max + u) as usize;
                if let Some((block_id, face_data)) = mask[idx] {
                    // Find width
                    let mut width = 1;
                    while u + width < u_max {
                        let next_idx = (v * u_max + u + width) as usize;
                        if mask[next_idx] != Some((block_id, face_data)) {
                            break;
                        }
                        width += 1;
                    }

                    // Find height
                    let mut height = 1;
                    'height_loop: while v + height < v_max {
                        for du in 0..width {
                            let check_idx = ((v + height) * u_max + u + du) as usize;
                            if mask[check_idx] != Some((block_id, face_data)) {
                                break 'height_loop;
                            }
                        }
                        height += 1;
                    }

                    // Emit quad
                    let block_def = ctx.block_registry.get(block_id).unwrap();
                    if block_def.transparent {
                        emit_quad(
                            ctx,
                            axis,
                            direction,
                            u,
                            v,
                            w,
                            width,
                            height,
                            block_id,
                            face_data,
                            transparent_verts,
                            transparent_indices,
                        );
                    } else {
                        emit_quad(
                            ctx,
                            axis,
                            direction,
                            u,
                            v,
                            w,
                            width,
                            height,
                            block_id,
                            face_data,
                            opaque_verts,
                            opaque_indices,
                        );
                    }

                    // Clear merged area
                    for dv in 0..height {
                        for du in 0..width {
                            mask[((v + dv) * u_max + u + du) as usize] = None;
                        }
                    }
                }
            }
        }
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
struct FaceData {
    light: u8,
    ao_corners: [u8; 4], // AO value for each corner
}

fn fill_mask(
    ctx: &MeshingContext,
    axis: usize,
    direction: i32,
    w: i32,
    mask: &mut [Option<(BlockId, FaceData)>],
    u_max: i32,
    v_max: i32,
) {
    for v in 0..v_max {
        for u in 0..u_max {
            let mut pos = [0; 3];
            pos[axis] = w;
            pos[(axis + 1) % 3] = u;
            pos[(axis + 2) % 3] = v;
            let local = IVec3::new(pos[0], pos[1], pos[2]);

            if let Some(voxel) = ctx.chunk.get_local(local) {
                if !voxel.is_air() {
                    // Check if face is exposed
                    let mut neighbor_pos = pos;
                    neighbor_pos[axis] += direction;
                    let neighbor_local = IVec3::new(neighbor_pos[0], neighbor_pos[1], neighbor_pos[2]);

                    let neighbor_voxel = if neighbor_local.x < 0 || neighbor_local.x >= CHUNK_SIZE_X
                        || neighbor_local.y < 0 || neighbor_local.y >= CHUNK_SIZE_Y
                        || neighbor_local.z < 0 || neighbor_local.z >= CHUNK_SIZE_Z {
                        // Check neighbor chunk
                        get_neighbor_voxel(ctx, axis, direction, neighbor_pos)
                    } else {
                        ctx.chunk.get_local(neighbor_local)
                    };

                    let exposed = neighbor_voxel.map_or(true, |v| v.is_air());

                    if exposed {
                        // Compute AO for each corner
                        let ao_corners = compute_corner_ao(ctx, local, axis, direction);

                        mask[(v * u_max + u) as usize] = Some((voxel.id, FaceData {
                            light: voxel.combined_light(),
                            ao_corners,
                        }));
                    }
                }
            }
        }
    }
}

fn compute_corner_ao(
    ctx: &MeshingContext,
    pos: LocalPos,
    axis: usize,
    direction: i32,
) -> [u8; 4] {
    // Compute ambient occlusion for 4 corners of face
    // AO value 0-3 based on how many of 3 surrounding blocks are solid
    let mut ao = [0u8; 4];

    // For each corner, check 3 adjacent blocks
    // (simplified implementation - full version needs proper neighbor checks)

    ao
}

fn emit_quad(
    ctx: &MeshingContext,
    axis: usize,
    direction: i32,
    u: i32,
    v: i32,
    w: i32,
    width: i32,
    height: i32,
    block_id: BlockId,
    face_data: FaceData,
    vertices: &mut Vec<Vertex>,
    indices: &mut Vec<u32>,
) {
    let base_index = vertices.len() as u32;

    // Get texture UVs from atlas
    let block_def = ctx.block_registry.get(block_id).unwrap();
    let texture_name = match axis {
        0 => &block_def.texture_side,
        1 => if direction > 0 { &block_def.texture_top } else { &block_def.texture_bottom },
        2 => &block_def.texture_side,
        _ => unreachable!(),
    };
    let atlas_uv = ctx.texture_atlas.get_uv(texture_name);

    // Compute 3D positions for 4 corners
    let positions = compute_quad_positions(axis, direction, u, v, w, width, height);

    // Normal vector
    let mut normal = [0.0; 3];
    normal[axis] = direction as f32;

    // Create 4 vertices
    for i in 0..4 {
        let corner_uv = match i {
            0 => Vec2::new(atlas_uv.min.x, atlas_uv.min.y),
            1 => Vec2::new(atlas_uv.min.x, atlas_uv.max.y),
            2 => Vec2::new(atlas_uv.max.x, atlas_uv.max.y),
            3 => Vec2::new(atlas_uv.max.x, atlas_uv.min.y),
            _ => unreachable!(),
        };

        vertices.push(Vertex {
            position: positions[i].to_array(),
            uv: corner_uv.to_array(),
            normal,
            light: face_data.light,
            ao: face_data.ao_corners[i],
            _padding: [0, 0],
        });
    }

    // Create 2 triangles (6 indices)
    if direction > 0 {
        indices.extend_from_slice(&[
            base_index,
            base_index + 1,
            base_index + 2,
            base_index,
            base_index + 2,
            base_index + 3,
        ]);
    } else {
        indices.extend_from_slice(&[
            base_index,
            base_index + 3,
            base_index + 2,
            base_index,
            base_index + 2,
            base_index + 1,
        ]);
    }
}

fn compute_quad_positions(
    axis: usize,
    direction: i32,
    u: i32,
    v: i32,
    w: i32,
    width: i32,
    height: i32,
) -> [Vec3; 4] {
    let w_offset = if direction > 0 { 1.0 } else { 0.0 };

    match axis {
        0 => [
            Vec3::new(w as f32 + w_offset, u as f32, v as f32),
            Vec3::new(w as f32 + w_offset, u as f32 + width as f32, v as f32),
            Vec3::new(w as f32 + w_offset, u as f32 + width as f32, v as f32 + height as f32),
            Vec3::new(w as f32 + w_offset, u as f32, v as f32 + height as f32),
        ],
        1 => [
            Vec3::new(u as f32, w as f32 + w_offset, v as f32),
            Vec3::new(u as f32, w as f32 + w_offset, v as f32 + height as f32),
            Vec3::new(u as f32 + width as f32, w as f32 + w_offset, v as f32 + height as f32),
            Vec3::new(u as f32 + width as f32, w as f32 + w_offset, v as f32),
        ],
        2 => [
            Vec3::new(u as f32, v as f32, w as f32 + w_offset),
            Vec3::new(u as f32, v as f32 + height as f32, w as f32 + w_offset),
            Vec3::new(u as f32 + width as f32, v as f32 + height as f32, w as f32 + w_offset),
            Vec3::new(u as f32 + width as f32, v as f32, w as f32 + w_offset),
        ],
        _ => unreachable!(),
    }
}
```

#### 3.5.2 Texture Atlas Design

**New Section:**

```rust
// assets/src/texture_atlas.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextureAtlas {
    pub image_path: String,
    pub width: u32,
    pub height: u32,
    pub tile_size: u32, // Size of each texture tile (e.g., 16x16)
    pub entries: HashMap<String, AtlasEntry>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AtlasEntry {
    pub name: String,
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
}

impl AtlasEntry {
    pub fn uv_rect(&self, atlas_width: u32, atlas_height: u32) -> UVRect {
        UVRect {
            min: Vec2::new(
                self.x as f32 / atlas_width as f32,
                self.y as f32 / atlas_height as f32,
            ),
            max: Vec2::new(
                (self.x + self.width) as f32 / atlas_width as f32,
                (self.y + self.height) as f32 / atlas_height as f32,
            ),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct UVRect {
    pub min: Vec2,
    pub max: Vec2,
}

impl TextureAtlas {
    pub fn load(path: &Path) -> Result<Self> {
        let json = std::fs::read_to_string(path)?;
        Ok(serde_json::from_str(&json)?)
    }

    pub fn get_uv(&self, texture_name: &str) -> UVRect {
        self.entries
            .get(texture_name)
            .map(|entry| entry.uv_rect(self.width, self.height))
            .unwrap_or(UVRect {
                min: Vec2::ZERO,
                max: Vec2::ONE,
            })
    }
}
```

### 3.6 Networking (Revised)

#### 3.6.1 Network ID System

**Issue:** bevy_ecs `Entity` is not network-safe (generation counter changes)

**Solution:** Separate NetworkId component with server-assigned stable IDs

```rust
// net/src/network_id.rs
use std::sync::atomic::{AtomicU64, Ordering};

static NEXT_NETWORK_ID: AtomicU64 = AtomicU64::new(1);

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct NetworkId(pub u64);

impl NetworkId {
    pub fn new() -> Self {
        Self(NEXT_NETWORK_ID.fetch_add(1, Ordering::SeqCst))
    }

    pub const INVALID: NetworkId = NetworkId(0);
}

/// Bidirectional mapping between ECS entities and network IDs
pub struct NetworkIdRegistry {
    entity_to_net: HashMap<Entity, NetworkId>,
    net_to_entity: HashMap<NetworkId, Entity>,
}

impl NetworkIdRegistry {
    pub fn new() -> Self {
        Self {
            entity_to_net: HashMap::new(),
            net_to_entity: HashMap::new(),
        }
    }

    pub fn register(&mut self, entity: Entity, net_id: NetworkId) {
        self.entity_to_net.insert(entity, net_id);
        self.net_to_entity.insert(net_id, entity);
    }

    pub fn unregister_entity(&mut self, entity: Entity) {
        if let Some(net_id) = self.entity_to_net.remove(&entity) {
            self.net_to_entity.remove(&net_id);
        }
    }

    pub fn get_network_id(&self, entity: Entity) -> Option<NetworkId> {
        self.entity_to_net.get(&entity).copied()
    }

    pub fn get_entity(&self, net_id: NetworkId) -> Option<Entity> {
        self.net_to_entity.get(&net_id).copied()
    }
}
```

#### 3.6.2 State Synchronization (Enhanced)

```rust
// net/src/sync.rs
#[derive(Serialize, Deserialize)]
pub struct EntitySnapshot {
    pub net_id: NetworkId,
    pub archetype: String, // "player", "item", "mob"
    pub position: Vec3,
    pub rotation: Quat,
    pub velocity: Option<Vec3>,
    pub health: Option<f32>,
    // ... other replicated components
}

#[derive(Serialize, Deserialize)]
pub struct StateDelta {
    pub tick: u64,
    pub entities: Vec<EntityUpdate>,
    pub blocks: Vec<BlockUpdate>,
}

#[derive(Serialize, Deserialize)]
pub enum EntityUpdate {
    Spawn(EntitySnapshot),
    Update {
        net_id: NetworkId,
        position: Option<Vec3>,
        rotation: Option<Quat>,
        velocity: Option<Vec3>,
        health: Option<f32>,
    },
    Despawn(NetworkId),
}

#[derive(Serialize, Deserialize)]
pub struct BlockUpdate {
    pub pos: BlockPos,
    pub new_block: BlockId,
    pub new_state: BlockState,
}

pub struct StateSynchronizer {
    pub tick: u64,
    pub last_snapshots: HashMap<NetworkId, EntitySnapshot>,
    pub dirty_chunks: HashSet<ChunkPos>,
    pub network_ids: NetworkIdRegistry,
}

impl StateSynchronizer {
    pub fn create_delta(&mut self, world: &World) -> StateDelta {
        let mut entities = Vec::new();

        // Query replicated entities
        let mut query = world.query::<(&NetworkId, &Transform, &Velocity, Option<&Health>)>();

        for (net_id, transform, velocity, health) in query.iter(world) {
            let snapshot = EntitySnapshot {
                net_id: *net_id,
                archetype: "entity".to_string(), // TODO: proper archetype
                position: transform.position,
                rotation: transform.rotation,
                velocity: Some(velocity.0),
                health: health.map(|h| h.current),
            };

            if let Some(last) = self.last_snapshots.get(net_id) {
                // Compute delta
                let mut update = EntityUpdate::Update {
                    net_id: *net_id,
                    position: None,
                    rotation: None,
                    velocity: None,
                    health: None,
                };

                if last.position.distance(snapshot.position) > 0.01 {
                    if let EntityUpdate::Update { position, .. } = &mut update {
                        *position = Some(snapshot.position);
                    }
                }

                // ... similar for other fields

                entities.push(update);
            } else {
                // New entity, send full snapshot
                entities.push(EntityUpdate::Spawn(snapshot.clone()));
            }

            self.last_snapshots.insert(*net_id, snapshot);
        }

        StateDelta {
            tick: self.tick,
            entities,
            blocks: Vec::new(), // TODO: collect dirty blocks
        }
    }
}
```

#### 3.6.3 Bandwidth Estimation

**New Section:**

```rust
// net/src/bandwidth.rs
pub struct BandwidthEstimator {
    bytes_sent: VecDeque<(Instant, usize)>,
    bytes_received: VecDeque<(Instant, usize)>,
    window: Duration,
}

impl BandwidthEstimator {
    pub fn new() -> Self {
        Self {
            bytes_sent: VecDeque::new(),
            bytes_received: VecDeque::new(),
            window: Duration::from_secs(5),
        }
    }

    pub fn record_sent(&mut self, bytes: usize) {
        let now = Instant::now();
        self.bytes_sent.push_back((now, bytes));
        self.trim_old(now);
    }

    pub fn record_received(&mut self, bytes: usize) {
        let now = Instant::now();
        self.bytes_received.push_back((now, bytes));
        self.trim_old(now);
    }

    fn trim_old(&mut self, now: Instant) {
        let cutoff = now - self.window;
        while self.bytes_sent.front().map_or(false, |(t, _)| *t < cutoff) {
            self.bytes_sent.pop_front();
        }
        while self.bytes_received.front().map_or(false, |(t, _)| *t < cutoff) {
            self.bytes_received.pop_front();
        }
    }

    pub fn upload_bps(&self) -> f32 {
        let total: usize = self.bytes_sent.iter().map(|(_, b)| b).sum();
        (total as f32 * 8.0) / self.window.as_secs_f32()
    }

    pub fn download_bps(&self) -> f32 {
        let total: usize = self.bytes_received.iter().map(|(_, b)| b).sum();
        (total as f32 * 8.0) / self.window.as_secs_f32()
    }
}
```

### 3.7 Persistence (Enhanced)

#### 3.7.1 Region File Format (Complete)

```rust
// world/src/persistence/region.rs
const REGION_SIZE: usize = 32; // 32x32 chunks
const HEADER_SIZE: usize = 8192; // 8KB header
const MAGIC: &[u8; 4] = b"RGVX";
const VERSION: u8 = 1;

pub struct RegionFile {
    file: File,
    path: PathBuf,
    header: RegionHeader,
    dirty: bool,
}

struct RegionHeader {
    offsets: [[Option<ChunkPointer>; REGION_SIZE]; REGION_SIZE],
}

#[derive(Clone, Copy)]
struct ChunkPointer {
    offset: u64,      // Byte offset in file
    length: u32,      // Compressed size
    crc32: u32,       // CRC32 checksum
    timestamp: u64,   // Last modified (Unix timestamp)
}

impl RegionFile {
    pub fn create(path: PathBuf) -> Result<Self> {
        let mut file = File::create(&path)?;

        // Write header
        file.write_all(MAGIC)?;
        file.write_all(&[VERSION])?;
        file.write_all(&[0u8; HEADER_SIZE - 5])?; // Rest of header

        Ok(Self {
            file,
            path,
            header: RegionHeader {
                offsets: [[None; REGION_SIZE]; REGION_SIZE],
            },
            dirty: false,
        })
    }

    pub fn open(path: PathBuf) -> Result<Self> {
        let mut file = File::open(&path)?;

        // Read and validate magic
        let mut magic = [0u8; 4];
        file.read_exact(&mut magic)?;
        if &magic != MAGIC {
            return Err(Error::InvalidMagic);
        }

        // Read version
        let mut version = [0u8; 1];
        file.read_exact(&mut version)?;
        if version[0] != VERSION {
            return Err(Error::UnsupportedVersion(version[0]));
        }

        // Read header (chunk pointers)
        let mut header = RegionHeader {
            offsets: [[None; REGION_SIZE]; REGION_SIZE],
        };

        for z in 0..REGION_SIZE {
            for x in 0..REGION_SIZE {
                let mut entry = [0u8; 24]; // 8+4+4+8 bytes
                file.read_exact(&mut entry)?;

                let offset = u64::from_le_bytes(entry[0..8].try_into().unwrap());
                let length = u32::from_le_bytes(entry[8..12].try_into().unwrap());
                let crc32 = u32::from_le_bytes(entry[12..16].try_into().unwrap());
                let timestamp = u64::from_le_bytes(entry[16..24].try_into().unwrap());

                if offset > 0 {
                    header.offsets[z][x] = Some(ChunkPointer {
                        offset,
                        length,
                        crc32,
                        timestamp,
                    });
                }
            }
        }

        Ok(Self {
            file,
            path,
            header,
            dirty: false,
        })
    }

    pub fn write_chunk(&mut self, local_x: u8, local_z: u8, chunk: &Chunk) -> Result<()> {
        // Serialize chunk
        let data = bincode::serialize(chunk)?;

        // Compress
        let compressed = zstd::encode_all(&data[..], 3)?;

        // Compute CRC
        let crc = crc32fast::hash(&compressed);

        // Append to end of file
        self.file.seek(SeekFrom::End(0))?;
        let offset = self.file.stream_position()?;

        // Write chunk data
        self.file.write_all(&compressed)?;

        // Update header
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        self.header.offsets[local_z as usize][local_x as usize] = Some(ChunkPointer {
            offset,
            length: compressed.len() as u32,
            crc32: crc,
            timestamp,
        });

        self.dirty = true;
        Ok(())
    }

    pub fn read_chunk(&mut self, local_x: u8, local_z: u8) -> Result<Option<Chunk>> {
        let pointer = match self.header.offsets[local_z as usize][local_x as usize] {
            Some(p) => p,
            None => return Ok(None),
        };

        // Seek and read
        self.file.seek(SeekFrom::Start(pointer.offset))?;
        let mut compressed = vec![0u8; pointer.length as usize];
        self.file.read_exact(&mut compressed)?;

        // Verify CRC
        let actual_crc = crc32fast::hash(&compressed);
        if actual_crc != pointer.crc32 {
            return Err(Error::CorruptedChunk);
        }

        // Decompress
        let data = zstd::decode_all(&compressed[..])?;

        // Deserialize
        let chunk: Chunk = bincode::deserialize(&data)?;
        Ok(Some(chunk))
    }

    pub fn flush(&mut self) -> Result<()> {
        if !self.dirty {
            return Ok(());
        }

        // Rewrite header
        self.file.seek(SeekFrom::Start(0))?;
        self.file.write_all(MAGIC)?;
        self.file.write_all(&[VERSION])?;

        for z in 0..REGION_SIZE {
            for x in 0..REGION_SIZE {
                if let Some(ptr) = self.header.offsets[z][x] {
                    self.file.write_all(&ptr.offset.to_le_bytes())?;
                    self.file.write_all(&ptr.length.to_le_bytes())?;
                    self.file.write_all(&ptr.crc32.to_le_bytes())?;
                    self.file.write_all(&ptr.timestamp.to_le_bytes())?;
                } else {
                    self.file.write_all(&[0u8; 24])?;
                }
            }
        }

        self.file.flush()?;
        self.dirty = false;
        Ok(())
    }
}
```

### 3.8 Error Handling Strategy

**New Section:**

```rust
// core/src/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum GameError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Network error: {0}")]
    Network(String),

    #[error("Invalid block ID: {0}")]
    InvalidBlockId(u16),

    #[error("Chunk not loaded: {0:?}")]
    ChunkNotLoaded(ChunkPos),

    #[error("Serialization error: {0}")]
    Serialization(#[from] bincode::Error),

    #[error("World generation failed: {0}")]
    WorldGeneration(String),

    #[error("Asset not found: {0}")]
    AssetNotFound(String),

    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),
}

pub type Result<T> = std::result::Result<T, GameError>;
```

### 3.9 Configuration Management

**New Section:**

```rust
// config/src/lib.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub world_name: String,
    pub seed: Option<u64>,
    pub port: u16,
    pub max_players: u32,
    pub view_distance: u32,
    pub simulation_distance: u32,
    pub tick_rate: u32,
    pub autosave_interval_secs: u64,
    pub enable_flight: bool,
    pub enable_pvp: bool,
}

impl Default for ServerConfig {
    fn default() -> Self {
        Self {
            world_name: "world".to_string(),
            seed: None,
            port: 25565,
            max_players: 20,
            view_distance: 10,
            simulation_distance: 8,
            tick_rate: 20,
            autosave_interval_secs: 300,
            enable_flight: false,
            enable_pvp: true,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientConfig {
    pub render_distance: u32,
    pub fov: f32,
    pub mouse_sensitivity: f32,
    pub vsync: bool,
    pub max_fps: Option<u32>,
    pub fullscreen: bool,
    pub resolution: (u32, u32),
    pub graphics_quality: GraphicsQuality,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum GraphicsQuality {
    Low,
    Medium,
    High,
    Ultra,
}

impl Default for ClientConfig {
    fn default() -> Self {
        Self {
            render_distance: 8,
            fov: 70.0,
            mouse_sensitivity: 1.0,
            vsync: true,
            max_fps: None,
            fullscreen: false,
            resolution: (1920, 1080),
            graphics_quality: GraphicsQuality::Medium,
        }
    }
}
```

---

## 4. Performance Targets & Optimization

### 4.1 Performance Budget (Enhanced)

| Metric | Target | Stretch Goal | Measurement |
|--------|--------|--------------|-------------|
| **Sim Tick Time** | ≤ 2.5 ms | ≤ 1.5 ms | Per-tick profiling (20 TPS = 50 ms budget) |
| **Frame Time (P95)** | ≤ 16.6 ms | ≤ 8.3 ms | Frame timing (60 FPS / 120 FPS target) |
| **Chunk Gen Time** | ≤ 8 ms | ≤ 4 ms | Generation pipeline timer |
| **Mesh Build Time** | ≤ 5 ms | ≤ 2 ms | Greedy meshing profiler |
| **Memory (9×9 chunks)** | < 500 MB | < 300 MB | RSS measurement (after Vec optimization) |
| **World Save Rate** | ≤ 100 MB/hr | ≤ 50 MB/hr | Disk I/O monitoring (compressed) |
| **Network Bandwidth** | ≤ 50 KB/s | ≤ 30 KB/s | Per-client upload |
| **Chunk Load Latency** | ≤ 100 ms | ≤ 50 ms | Time from request to ready |

### 4.2 Memory Optimization

**Issue:** Original design used 4MB per chunk

**Solution:**
- Use Vec instead of Box<[_; N]> (saves fragmentation)
- Unload distant chunks aggressively
- Implement chunk palette for repeated blocks (future)
- Lazy mesh allocation (only when needed)

**Memory Profile (revised):**
- Chunk voxel data: ~400 KB per chunk (65,536 voxels × 6 bytes)
- Chunk mesh: ~50-200 KB per chunk (depending on complexity)
- Total per chunk: ~450-600 KB
- 9×9 area (81 chunks): ~40 MB
- 17×17 area (289 chunks): ~150 MB
- 25×25 area (625 chunks): ~350 MB

### 4.3 Async Chunk Streaming

**New Section:**

```rust
// world/src/streaming.rs
use tokio::sync::mpsc;
use rayon::prelude::*;

pub struct ChunkStreamingSystem {
    generation_tx: mpsc::Sender<ChunkGenerationTask>,
    generation_rx: mpsc::Receiver<ChunkGenerationResult>,
    meshing_tx: mpsc::Sender<ChunkMeshingTask>,
    meshing_rx: mpsc::Receiver<ChunkMeshingResult>,
}

struct ChunkGenerationTask {
    pos: ChunkPos,
    seed: u64,
    priority: i32, // Higher = more urgent
}

struct ChunkGenerationResult {
    pos: ChunkPos,
    chunk: Chunk,
}

impl ChunkStreamingSystem {
    pub fn new() -> Self {
        let (gen_tx, mut gen_rx) = mpsc::channel(256);
        let (result_tx, result_rx) = mpsc::channel(256);

        // Spawn generation worker pool
        tokio::spawn(async move {
            while let Some(task) = gen_rx.recv().await {
                let mut chunk = Chunk::new(task.pos);
                chunk.allocate();

                // Generate on thread pool
                rayon::spawn(move || {
                    generate_chunk(&mut chunk, task.seed);
                    let _ = result_tx.blocking_send(ChunkGenerationResult {
                        pos: task.pos,
                        chunk,
                    });
                });
            }
        });

        let (mesh_tx, mut mesh_rx) = mpsc::channel(256);
        let (mesh_result_tx, mesh_result_rx) = mpsc::channel(256);

        // Spawn meshing worker pool
        tokio::spawn(async move {
            while let Some(task) = mesh_rx.recv().await {
                rayon::spawn(move || {
                    let mesh = greedy_mesh(task.ctx);
                    let _ = mesh_result_tx.blocking_send(ChunkMeshingResult {
                        pos: task.pos,
                        mesh,
                    });
                });
            }
        });

        Self {
            generation_tx: gen_tx,
            generation_rx: result_rx,
            meshing_tx: mesh_tx,
            meshing_rx: mesh_result_rx,
        }
    }

    pub fn request_chunk(&self, pos: ChunkPos, seed: u64, priority: i32) {
        let _ = self.generation_tx.try_send(ChunkGenerationTask {
            pos,
            seed,
            priority,
        });
    }

    pub fn poll_generated(&mut self) -> Vec<ChunkGenerationResult> {
        let mut results = Vec::new();
        while let Ok(result) = self.generation_rx.try_recv() {
            results.push(result);
        }
        results
    }
}
```

---

## 5. Security & Stability (Enhanced)

### 5.1 Input Validation (Complete)

```rust
// net/src/validation.rs
const MAX_INTERACTION_DISTANCE: f32 = 10.0;
const MAX_MOVEMENT_SPEED: f32 = 50.0; // Including fall speed
const MAX_CHAT_LENGTH: usize = 256;
const MAX_USERNAME_LENGTH: usize = 16;

pub fn validate_client_packet(
    packet: &ClientPacket,
    player_pos: Vec3,
    registry: &BlockRegistry,
) -> Result<()> {
    match packet {
        ClientPacket::Join { username, protocol_version } => {
            if *protocol_version != PROTOCOL_VERSION {
                return Err(ValidationError::ProtocolMismatch);
            }
            if username.len() > MAX_USERNAME_LENGTH || username.is_empty() {
                return Err(ValidationError::InvalidUsername);
            }
            if !username.chars().all(|c| c.is_alphanumeric() || c == '_') {
                return Err(ValidationError::InvalidUsername);
            }
        }

        ClientPacket::Input { tick, movement, jump, look } => {
            // Check movement magnitude
            if movement.length() > MAX_MOVEMENT_SPEED * 1.1 {
                return Err(ValidationError::SpeedHack);
            }

            // Check look direction is normalized
            if (look.length() - 1.0).abs() > 0.1 {
                return Err(ValidationError::InvalidLookDirection);
            }

            // Check tick is not too far in future/past
            // (would need current tick for proper validation)
        }

        ClientPacket::BlockPlace { pos, block } => {
            // Check block ID is valid
            if registry.get(*block).is_none() {
                return Err(ValidationError::InvalidBlockId);
            }

            // Check position is within interaction distance
            let dist = player_pos.distance(pos.as_vec3());
            if dist > MAX_INTERACTION_DISTANCE {
                return Err(ValidationError::PositionOutOfRange);
            }

            // Check position is reasonable (not at extreme coordinates)
            if pos.y < 0 || pos.y >= 256 {
                return Err(ValidationError::InvalidPosition);
            }
        }

        ClientPacket::BlockBreak { pos } => {
            let dist = player_pos.distance(pos.as_vec3());
            if dist > MAX_INTERACTION_DISTANCE {
                return Err(ValidationError::PositionOutOfRange);
            }
        }

        ClientPacket::ChatMessage { text } => {
            if text.len() > MAX_CHAT_LENGTH {
                return Err(ValidationError::MessageTooLong);
            }
            if text.is_empty() {
                return Err(ValidationError::EmptyMessage);
            }
            // Could add profanity filter here
        }
    }

    Ok(())
}
```

### 5.2 Rate Limiting

**New Section:**

```rust
// net/src/rate_limit.rs
use std::time::{Duration, Instant};

pub struct RateLimiter {
    actions: VecDeque<Instant>,
    max_actions: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_actions: usize, window: Duration) -> Self {
        Self {
            actions: VecDeque::new(),
            max_actions,
            window,
        }
    }

    pub fn check_rate_limit(&mut self) -> bool {
        let now = Instant::now();

        // Remove old actions outside window
        while let Some(time) = self.actions.front() {
            if now.duration_since(*time) > self.window {
                self.actions.pop_front();
            } else {
                break;
            }
        }

        // Check if under limit
        if self.actions.len() < self.max_actions {
            self.actions.push_back(now);
            true
        } else {
            false
        }
    }
}

pub struct ClientRateLimits {
    pub block_place: RateLimiter,
    pub block_break: RateLimiter,
    pub chat: RateLimiter,
    pub movement: RateLimiter,
}

impl ClientRateLimits {
    pub fn new() -> Self {
        Self {
            block_place: RateLimiter::new(20, Duration::from_secs(1)),
            block_break: RateLimiter::new(30, Duration::from_secs(1)),
            chat: RateLimiter::new(5, Duration::from_secs(10)),
            movement: RateLimiter::new(100, Duration::from_secs(1)),
        }
    }
}
```

---

## 6. Testing Infrastructure (Enhanced)

### 6.1 Event Stream Architecture (Fixed)

**Issue:** `JsonlRecorder` has `&mut self` in trait with `&self`

**Solution:** Use interior mutability

```rust
// testkit/src/recorder.rs
use std::sync::Mutex;

pub struct JsonlRecorder {
    writer: Mutex<BufWriter<File>>,
}

impl JsonlRecorder {
    pub fn new(path: &Path) -> std::io::Result<Self> {
        Ok(Self {
            writer: Mutex::new(BufWriter::new(File::create(path)?)),
        })
    }
}

impl EventSink for JsonlRecorder {
    fn on_event(&self, event: &GameEvent) {
        if let Ok(json) = serde_json::to_string(event) {
            let mut writer = self.writer.lock().unwrap();
            let _ = writeln!(writer, "{}", json);
        }
    }
}

impl Drop for JsonlRecorder {
    fn drop(&mut self) {
        let _ = self.writer.lock().unwrap().flush();
    }
}
```

### 6.2 Performance Regression Detection

**New Section:**

```rust
// testkit/src/perf.rs
#[derive(Serialize, Deserialize)]
pub struct PerformanceBaseline {
    pub scenario: String,
    pub metrics: HashMap<String, PerformanceMetric>,
}

#[derive(Serialize, Deserialize)]
pub struct PerformanceMetric {
    pub name: String,
    pub value: f64,
    pub unit: String,
    pub threshold_percent: f64, // Max allowed regression %
}

pub fn check_regression(
    current: &PerformanceBaseline,
    baseline: &PerformanceBaseline,
) -> Vec<Regression> {
    let mut regressions = Vec::new();

    for (name, metric) in &current.metrics {
        if let Some(baseline_metric) = baseline.metrics.get(name) {
            let change_percent = ((metric.value - baseline_metric.value) / baseline_metric.value) * 100.0;

            if change_percent > metric.threshold_percent {
                regressions.push(Regression {
                    metric: name.clone(),
                    baseline: baseline_metric.value,
                    current: metric.value,
                    change_percent,
                    threshold: metric.threshold_percent,
                });
            }
        }
    }

    regressions
}
```

---

## 7. Open Questions & Decisions (Updated)

### 7.1 Resolved Design Questions

1. **Lighting Storage**: ✅ Separate `u8` for skylight and block light (simplicity over space)
2. **Chunk Height**: ✅ Fixed 256 for MVP, expandable to 512 via compile flag
3. **Entity Interpolation**: ✅ Linear for MVP, cubic post-MVP
4. **UI Framework**: ✅ egui for MVP
5. **Chunk Storage**: ✅ Vec<Voxel> instead of Box<[Voxel; N]>
6. **Network IDs**: ✅ Separate NetworkId component (stable IDs)
7. **Chunk Coordinates**: ✅ 2D (X, Z) not 3D

### 7.2 Remaining Open Questions

1. **Block Palette Compression**: When to implement? (Post-MVP)
2. **LOD System**: Distant chunk simplification strategy?
3. **Plugin API Surface**: Which functions expose to WASM?
4. **Save Format Versioning**: Migration strategy details?
5. **Anticheat**: Server-side validation vs client trust?

---

## 8. Development Milestones (Unchanged from v1.0)

See original section 10 for milestone breakdown.

---

## 9. Risks & Mitigations (Enhanced)

| Risk | Impact | Likelihood | Mitigation | Status |
|------|--------|------------|------------|--------|
| **Cross-platform render variance** | High | High | Per-backend goldens; integer vertex coords | Designed |
| **Determinism drift** | High | Medium | Replay tests; seed auditing; no std::time | Designed |
| **ECS performance** | Medium | Medium | Profiling; sparse sets; system ordering | Designed |
| **Memory exhaustion** | High | Medium | Chunk LRU eviction; configurable limits | Mitigated |
| **Network desync** | High | Medium | NetworkId system; delta validation | Mitigated |
| **Save corruption** | High | Low | CRC checks; version guard; atomic writes | Mitigated |
| **Threading deadlocks** | Medium | Low | RwLock over Mutex; rayon isolation | Designed |
| **Asset loading perf** | Medium | Medium | Async loading; texture atlas; hot-reload | Designed |

---

## 10. Success Criteria (Enhanced)

✅ **Functionality**: All milestone acceptance tests pass
✅ **Performance**: Meets all performance budgets (§4.1)
✅ **Memory**: < 500 MB for 9×9 chunks (revised from 1.5 GB)
✅ **Network**: < 50 KB/s per client bandwidth
✅ **Testability**: 100% event coverage, stable snapshots
✅ **Maintainability**: < 1000 LOC per crate (except world), full rustdoc
✅ **Moddability**: Data packs load without code changes
✅ **Security**: All inputs validated, rate limited
✅ **Stability**: No panics in release, graceful error handling

---

## 11. Implementation Priority

**Phase 1 (MVP):**
1. Core data structures (Chunk, Voxel, coordinates)
2. Basic ECS setup
3. Superflat generation
4. Simple meshing (not greedy yet)
5. Basic wgpu renderer
6. Player movement + collision

**Phase 2 (Lighting):**
7. BFS lighting system
8. Block registry with properties
9. Persistence (region files)

**Phase 3 (Network):**
10. QUIC transport
11. NetworkId system
12. State synchronization
13. Client prediction

**Phase 4 (Content):**
14. Noise-based generation
15. Biomes
16. Structures (trees, caves)
17. Item system

**Phase 5 (Polish):**
18. Greedy meshing
19. Texture atlas
20. Performance optimization
21. Testing infrastructure

---

## 12. Appendices

### 12.1 Glossary (Enhanced)

- **ECS**: Entity-Component-System architecture
- **TPS**: Ticks Per Second (simulation rate)
- **FPS**: Frames Per Second (render rate)
- **BFS**: Breadth-First Search (lighting algorithm)
- **DDA**: Digital Differential Analyzer (raycasting)
- **QUIC**: Quick UDP Internet Connections (transport protocol)
- **WASM**: WebAssembly (modding runtime)
- **AO**: Ambient Occlusion (lighting effect)
- **LOD**: Level of Detail (optimization)
- **UUID**: Universally Unique Identifier

### 12.2 References (Enhanced)

- bevy_ecs: https://docs.rs/bevy_ecs
- wgpu: https://docs.rs/wgpu
- quinn (QUIC): https://docs.rs/quinn
- fastnoise_lite: https://github.com/Auburn/FastNoiseLite
- Greedy Meshing: https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/
- Minecraft Protocol: https://wiki.vg/Protocol
- Minecraft Lighting: https://minecraft.fandom.com/wiki/Light
- Rust Async Book: https://rust-lang.github.io/async-book/

### 12.3 Document Changelog

**v2.0 (2025.11.13):**
- Revised chunk storage to use Vec instead of Box<[_; N]>
- Fixed chunk coordinates to be 2D (X, Z) not 3D
- Added NetworkId system for stable entity IDs
- Enhanced lighting with cross-chunk propagation
- Added texture atlas design
- Added bandwidth estimation
- Added rate limiting
- Fixed EventSink trait mutability issue
- Added configuration management
- Added error handling strategy
- Added performance regression detection
- Added async chunk streaming
- Improved memory estimates (4MB → 400KB per chunk)
- Added 30+ design clarifications and fixes

**v1.0 (2025.11.12):**
- Initial design document

---

**Document Status**: Ready for Implementation
**Next Steps**:
1. Review v2.0 changes with team
2. Update implementation plan to reflect fixes
3. Begin Phase 1 implementation with corrected data structures
4. Set up CI with proper memory/perf monitoring

---

*End of High-Level Design Document (Revised)*
