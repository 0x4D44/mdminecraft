# Feature Gap Closure Plan — Toward Vanilla Minecraft Parity (Reviewed)

**Date:** 2025-12-16  
**mdminecraft snapshot:** `ca654b55589488081f95f5b08d67bd19f7c7d50b`  
**Companion analysis:** `wrk_docs/2025.12.16 - DOC - Feature Comparison vs Vanilla Minecraft.md`  

This roadmap targets **player-visible Minecraft-like survival breadth** while preserving mdminecraft’s defining constraints:

- **Determinism-first:** same seed + same inputs ⇒ same outputs (replayable; networking-friendly).
- **Performance budgets:** each milestone has a measurable budget enforced by CI metrics.
- **Server-authoritative by default:** implement gameplay in shared simulation so singleplayer = host+client.
- **Data-driven where possible:** blocks/items/recipes/loot/spawns defined as data, not hardcoded logic.

---

## 0) Review — issues found and how this revision fixes them

The previous plan was directionally correct but would cause rework/stalls. This version addresses the main failure modes explicitly.

### 0.1 Issues found

1. **Prereqs were “floating”**: registry/metadata/dimension abstraction and parity tests were listed as cross-cutting but not scheduled as owned stages.
2. **Dependencies were underspecified**: block state/modeling and world height refactors are high-blast-radius and need incremental rollout.
3. **World height change was too monolithic**: jumping straight to negative-Y + sectioned storage risks months of breakage (render, persistence, net, lighting, physics).
4. **UI/UX parity was missing as a stage**: inventory/crafting UX and options/accessibility are major “canonical Minecraft” gaps.
5. **AI/spawn depth wasn’t planned**: villagers, bosses, and “alive world” feel depend on pathfinding/goal systems and recognizable spawn rules.
6. **Save + network versioning was under-scoped**: parity work will repeatedly change chunk formats and state encoding; migrations need tooling and policy.
7. **Determinism risks weren’t operationalized**: float math, RNG surfaces, iteration order, and cross-platform verification need explicit exit gates.

### 0.2 Fixes applied

- Added **Stage 0 (harness + versioning)** and **Stage 1 (registry/metadata/dimension baseline)**.
- Split risky efforts into **incremental stages** (world height: sections first; then negative-Y expansion).
- Added **Stage 3 (UI/UX + survival rules)** to reach “feel parity” earlier.
- Added **Stage 7 (AI/spawn rules + villagers)** before Nether/End bosses.
- Made **migration tooling** and **protocol version bumps** explicit deliverables.
- Turned determinism/perf expectations into **required gates** per stage.

---

## 1) Define the parity target (choose deliberately)

“Minecraft parity” can mean different things:

1. **Feel parity (recommended):** “plays like vanilla” for the core survival loop; not protocol/world-format compatible; worldgen may differ while delivering similar experiences.
2. **Rule parity:** deeper behavioral matching (redstone update order, spawn rules, combat timing) without file/protocol compatibility.
3. **Compatibility parity:** read/write MC worlds, accept MC datapacks/resource packs, speak MC protocol (**very high cost** + maintenance + legal/IP risk).

This plan assumes **feel parity**, selectively pushing toward **rule parity** where it improves gameplay (redstone, combat, spawn rules).

---

## 2) Player-facing tier outcomes (goals, not stages)

### Tier A — “5 nights survival” (Overworld-only)
Spawn, gather, craft/smelt/enchant/brew, fight basic hostiles, sleep/respawn, and **save/load reliably**.

### Tier B — “Overworld depth”
Modern world height, richer biomes, major structures (villages/dungeons/mineshafts), more mobs, improved rule fidelity.

### Tier C — “Progression arc”
Nether + End, portals, bosses, endgame mobility and loot.

### Tier D — “Automation & meta”
Broader redstone ecosystem, commands, content packs/modding hooks, polish/accessibility.

---

## 3) Global guardrails (apply to every stage)

### 3.1 Determinism gates

1. **Stable ordering:** never rely on `HashMap` iteration for simulation decisions; use deterministic containers or explicit sorts.
2. **RNG discipline:** all randomness comes from seedable deterministic RNG streams; avoid OS entropy/time.
3. **Float policy:** if floats affect gameplay decisions, introduce tolerance-free deterministic representations (fixed-point/int) or restrict float usage to visuals.
4. **Cross-platform verification:** run determinism scenarios on multiple OS targets (Linux + Windows at minimum).

### 3.2 Performance gates

For each stage:

- Add **≥1 micro-test** (fast, targeted, runs in seconds).
- Add **≥1 worldtest** (integration, deterministic, emits metrics).
- Establish or update a **metrics baseline** with warning/fail thresholds.

### 3.3 Versioning gates

- **Persistence:** versioned schema + migration tool(s) for old saves.
- **Networking:** protocol version bumps with clear incompatibility errors; optionally support N-1 during dev.

---

## 4) Roadmap overview (stage sequencing)

Ordered to minimize rework:

1. Stage 0: parity harness + versioning scaffolding  
2. Stage 1: unified registry + metadata + dimension baseline  
3. Stage 2: persistence v2 (player/entities/block entities)  
4. Stage 3: UI/UX + survival loop fidelity (Tier A completion)  
5. Stage 4: block state/model/collision system (incremental)  
6. Stage 5: modern world height in two steps (sections → negative Y)  
7. Stage 6: structure pipeline + Overworld structures (Tier B)  
8. Stage 7: AI/spawn rules + villagers/trading (Tier B+)  
9. Stage 8: Nether dimension (Tier C)  
10. Stage 9: End dimension + boss loop (Tier C)  
11. Stage 10: redstone expansion toward practical automation (Tier D)  
12. Stage 11: commands + content packs + modding API (Tier D)  

---

## 5) Detailed multi-stage plan

Each stage lists: **Outcome**, **Scope**, **Dependencies**, **Engineering**, **Content**, **Tests/metrics**, **Exit criteria**, **Risks/mitigations**.

### Stage 0 — Parity harness + versioning scaffolding

**Outcome**
- A safe way to make progress: tests define expected behavior; formats can evolve without chaos.

**Scope**
- Deterministic “micro-worldtests”, golden snapshots, metrics baselines, version policy.

**Dependencies**
- None.

**Engineering**
- Add a micro-worldtest harness in `mdminecraft-testkit`:
  - tick-by-tick simulation runner
  - canonical snapshot writer (ordered, stable, minimal)
- Define snapshot schemas for:
  - block diffs over time
  - inventory diffs
  - entity state diffs
  - redstone power diffs
- Establish save/protocol version policy:
  - persistence schema version stored in headers
  - explicit protocol version bumps + mismatch errors
- Add multi-OS determinism CI job(s) (if available to the project).

**Tests/metrics**
- First golden micro-tests:
  - mining + drops timing
  - furnace tick progression
  - redstone wire propagation on a tiny circuit

**Exit criteria**
- Same scenario produces identical snapshot across reruns; metrics emit consistently.

**Risks/mitigations**
- Golden drift: snapshot only canonicalized data; avoid floats or quantize them deterministically.

---

### Stage 1 — Unified registry + metadata + dimension baseline

**Outcome**
- One authoritative definition of blocks/items/entities, deterministic metadata, and a dimension abstraction that avoids later rewrites.

**Scope**
- Identity + state model cleanup; no major content expansion required.

**Dependencies**
- Stage 0 harness.

**Engineering**
- Introduce a registry crate/module (in `mdminecraft-core` or new crate):
  - stable numeric IDs (`BlockId`, `ItemId`, `EntityTypeId`) for net/persist
  - stable string keys for authoring (e.g., `mdm:stone`)
  - tags (deterministic sets) for recipes/loot/spawn logic
- Define a deterministic metadata model:
  - “components” (typed fields) rather than raw NBT
  - ordered maps (`BTreeMap`) or sorted vectors for serialization
- Add a minimal dimension abstraction now:
  - `DimensionId` included in chunk keys, entity locations, persistence, networking
  - Overworld is the only enabled dimension initially
- Provide adapters so existing code paths keep working while migrating.

**Content**
- Convert `config/blocks.json` and recipes to use stable keys + tags (no behavior change needed).

**Tests/metrics**
- Golden tests for registry stability and metadata encode/decode.

**Exit criteria**
- A single registry truth is used across `world`, `render`, `net`, `client`, `server`.
- Persistence/networking are dimension-aware even in single-dimension mode.

**Risks/mitigations**
- Large refactor risk: migrate subsystem-by-subsystem with adapters/feature flags.

---

### Stage 2 — Persistence v2 (player + entities + block entities)

**Outcome**
- Worlds feel persistent: quitting and reloading preserves meaningful state.

**Scope**
- Save/load of player, entities, and block entities using the Stage 1 model.

**Dependencies**
- Stage 1 registry/metadata/dimension baseline.

**Engineering**
- Extend persistence to store:
  - player state (pos, inventory, health/hunger/xp, spawn point)
  - global state (time-of-day, weather)
  - entities (mobs, dropped items, projectiles; with despawn rules)
  - block entities (furnace/brewing/chest/etc inventories and timers)
- Add a migration tool:
  - `mdminecraft-cli` command (or tool) to upgrade old saves
- Deterministic ticking for block entities (stable ordering by position).

**Content**
- Define which entities persist vs despawn on reload (match vanilla expectations where practical).

**Tests/metrics**
- Worldtest: save/load roundtrip with machines running + mobs present.
- Property tests: `load(save(state)) == state` and serialization stability.

**Exit criteria**
- Scripted scenario survives 10 save/reload cycles without drift.

**Risks/mitigations**
- Save bloat: chunk-local block-entity tables; avoid per-tick disk writes; compress efficiently.

---

### Stage 3 — UI/UX + survival loop fidelity (Tier A completion)

**Outcome**
- The “first 5 nights” loop feels close to vanilla in core interactions.

**Scope**
- Player-facing UX + high-salience rules (inventory, crafting, sleep, damage sources, options).

**Dependencies**
- Stage 2 persistence (so UX flows matter).

**Engineering**
- Inventory UX parity improvements:
  - stack splitting, shift-click moves, drag behavior
  - tooltips + durability bars
- Crafting UX:
  - 2×2 personal crafting and 3×3 crafting table parity
  - optional “recipe book lite” (high impact, low content risk)
- Survival rules:
  - bed behavior (set spawn + skip night in singleplayer)
  - damage sources (fall, drowning, fire/lava, starvation) + invulnerability frames
  - basic difficulty knobs (mob damage, hunger drain)
- Options/accessibility:
  - keybind UI, mouse sensitivity/FOV, audio sliders, invert Y

**Content**
- Fill obvious early-game gaps needed for the loop (torches, basic food chain expansion if desired).

**Tests/metrics**
- Micro-tests: inventory operations + crafting correctness.
- Worldtest: scripted “first night” (spawn → gather → craft → shelter → sleep → reload).

**Exit criteria**
- A deterministic “5 nights” scripted scenario is replayable and survives save/load.

**Risks/mitigations**
- UI feel divergence: focus on functional parity first, visual parity later.

---

### Stage 4 — Block state/model/collision system (incremental)

**Outcome**
- Building feels Minecraft-like: orientation, connectivity, and non-cube collisions are correct enough for common builds.

**Scope**
- Block state schema + rendering models + collisions + placement rules.

**Dependencies**
- Stage 1 registry; Stage 3 UX.

**Engineering**
- Replace ad-hoc bit packing with a registry-driven state variant model:
  - blocks define finite valid state variants
  - runtime stores `BlockStateId` (index into variant table) for net/persist
  - canonical encoding stable across builds; versioned migrations when it changes
- Rendering:
  - stairs/slabs/fences/panes primitives
  - neighbor-aware connectivity resolution (meshing needs neighbor queries)
- Physics:
  - collision shapes derived from state (AABB sets)
- Placement/update rules:
  - support checks, facing rules, neighbor updates
- Waterlogging foundation (even if only some blocks support it initially).

**Content**
- Prioritize blocks that unlock parity building:
  - wood/stone families, slabs/stairs/walls
  - fences/panes, doors/trapdoors, torches

**Tests/metrics**
- Golden tests for state encode/decode and stability.
- Micro-worldtests for fence connectivity and stairs collision correctness.

**Exit criteria**
- Complex blocks roundtrip through save + network replication and behave correctly in key flows.

**Risks/mitigations**
- State-table churn: build explicit migration maps; avoid reordering IDs once shipped.

---

### Stage 5 — Modern world height (two-step refactor)

**Outcome**
- The world feels “modern” (deep caves + expanded vertical range) without destabilizing the engine.

**Scope**
- Chunk storage, worldgen, lighting, meshing, persistence, and networking changes required for modern height.

**Dependencies**
- Stage 4 strongly recommended (block state + neighbor queries will be needed anyway).

**Stage 5A: introduce vertical sections without changing height**
- Keep height at 256 initially, but store chunks as 16×16×16 sections.
- Update lighting/meshing/persistence/net paths to address sections.

**Stage 5B: expand vertical range (e.g., -64..319)**
- Allow negative Y coordinates.
- Update worldgen (heightmaps/density/ores) for new range.
- Update skylight propagation across sections.
- Persistence region format v2 (sectioned payloads) with migration tooling.
- Network chunk streaming payloads become section-addressed.

**Tests/metrics**
- Worldtests: determinism + seam continuity across vertical range.
- Encode/decode regression tests for section streaming and save migration.

**Exit criteria**
- No perf cliff vs baselines at comparable render distance.
- Determinism preserved under the new vertical model (replay + save/load).

**Risks/mitigations**
- Blast radius: ship Stage 5A first, Stage 5B behind a feature flag until stable.

---

### Stage 6 — Structure pipeline + Overworld structures (Tier B)

**Outcome**
- Exploration becomes compelling: structures provide landmarks, loot, and progression.

**Scope**
- Deterministic structure placement + generation across chunk boundaries; first major structure set.

**Dependencies**
- Stage 5 (structures should target final world scale).

**Engineering**
- Deterministic structure system:
  - region-based placement (seeded)
  - bounding boxes + terrain adaptation
  - palette placement + data-driven loot hooks
- Add structures in increasing complexity:
  - dungeons, mineshafts-lite, surface ruins
  - villages v0 (static structures first; full villager economy later)

**Content**
- Palettes + loot definitions (data-driven).

**Tests/metrics**
- Worldtest: structure determinism (same seed → same placements/blocks).
- Spot-check lighting/collision correctness around structures.

**Exit criteria**
- Structures generate deterministically, persist correctly, and don’t corrupt chunks.

**Risks/mitigations**
- Scope explosion: ship “static villages” first; trading/POIs deferred to Stage 7.

---

### Stage 7 — AI/spawn rules + villagers/trading (Tier B+)

**Outcome**
- The world feels alive: spawn rules and mob behavior feel recognizable; villagers become meaningful.

**Scope**
- Deterministic AI framework, pathfinding, spawn/despawn rules, initial villager trading.

**Dependencies**
- Stage 6 structures (villages exist) + Stage 3 survival loop.

**Engineering**
- AI framework:
  - deterministic goal selection and ticking
  - pathfinding with deterministic tie-breaking
- Spawn rules:
  - light-level gating, biome gating, local caps (simplified but recognizable)
  - despawn rules aligned with persistence decisions
- Villagers:
  - professions-lite + trades-lite (data-driven offers)
  - POI system v0 only if needed; keep minimal initially

**Content**
- Trade tables and villager professions (small set).

**Tests/metrics**
- Micro-tests: deterministic pathfinding outputs on fixed maps.
- Worldtest: spawn reproducibility + villager trade determinism.

**Exit criteria**
- Villagers have stable trades; hostile spawns feel predictable and consistent.

**Risks/mitigations**
- AI determinism is subtle: enforce strict ordering and snapshot AI decisions.

---

### Stage 8 — Nether dimension (Tier C begins)

**Outcome**
- Portals work; Nether provides distinct resources and hazards.

**Scope**
- Dimension gameplay + core Nether content subset.

**Dependencies**
- Stage 1 dimension abstraction (already in place).

**Engineering**
- Portal mechanics + dimension travel.
- Nether worldgen profile + environment rules.
- Dimension-aware persistence and networking exercised at scale.

**Content**
- Nether blocks subset + fortress-lite structure.
- First Nether mobs (minimal).

**Tests/metrics**
- Integration tests: portal determinism, dimension save/load, Nether chunk streaming.

**Exit criteria**
- Stable travel between dimensions with persisted state and reproducible worldgen.

---

### Stage 9 — End dimension + boss loop (Tier C)

**Outcome**
- A completion arc exists: reach the End and defeat a boss under deterministic replay.

**Scope**
- End worldgen + boss entity framework + portal entry path.

**Dependencies**
- Stage 8 (if following vanilla progression).

**Engineering**
- End worldgen + portal logic.
- Boss framework with deterministic phases and projectiles.
- Stronghold-like route (or alternative) to reach the End.

**Tests/metrics**
- Deterministic boss fight replay harness (scripted input log must replay identically).

**Exit criteria**
- End-to-end deterministic playthrough scenario exists and is regression-tested.

---

### Stage 10 — Redstone expansion toward practical automation (Tier D)

**Outcome**
- Practical automation: timers, doors, and basic item transport/logic.

**Scope**
- Expand component set and define stable update/tick rules.

**Dependencies**
- Stage 4 block state system.

**Engineering**
- Add core components: repeater, comparator, piston, observer, dispenser/dropper, hopper.
- Define update ordering and tick scheduling rules:
  - aim for “feel parity” first
  - document intentional deviations
- Deterministic replication + persistence of redstone state.

**Tests/metrics**
- Circuit snapshot tests (inputs over ticks → expected outputs).
- Performance tests for large networks (avoid pathological update storms).

**Exit criteria**
- Canonical contraptions work: clock, 2-way door, item sorter-lite.

---

### Stage 11 — Commands + content packs + modding API (Tier D)

**Outcome**
- High-leverage admin tools and a scalable, safe extension path.

**Scope**
- Commands first, then content packs, then deterministic scripting.

**Dependencies**
- Stage 0 harness; Stage 1 registry/metadata.

**Engineering**
- Commands:
  - deterministic execution order; permissions; audit logs
  - core set: `tp`, `give`, `time`, `weather`, `gamemode`, `setblock`, `summon`
- Content packs:
  - tags, recipes, loot tables, spawn tables, structure sets (mdminecraft-native formats)
- Modding:
  - scripting in a deterministic sandbox (WASM or a restricted embedded language)
  - explicit deterministic RNG and time surfaces

**Tests/metrics**
- Golden tests for command outputs.
- Deterministic script execution tests.

**Exit criteria**
- A content pack can add a block/item/recipe and is validated via tests without code changes.

---

## 6) Fastest “Minecraft-feel” wins

If time is limited, prioritize:

1. **Stage 2 (Persistence v2)** — makes the world real.
2. **Stage 3 (UI/UX + survival rules)** — makes the game feel like Minecraft.
3. **Stage 6 (Structures)** — makes exploration meaningful without Nether/End yet.

---

## 7) Tracking artifact (recommended)

Maintain a living parity backlog derived from the companion doc’s matrix:

- Each row: feature, stage, owner, test link, perf budget, status, known deviations.
- Tie “done” to stage exit criteria + passing tests + perf gate.
