# Journal — Near Minecraft Implementation (2025-11-19)

## 09:00 - Implementation kickoff
- Reviewed updated HLD/plan; confirmed phase sequence and staffing assumptions.
- Set objective for today: begin Phase 0 groundwork (tooling spikes) and ensure repo state/build remains clean.
- Next steps: catalog existing tooling gaps, set up placeholder tasks for asset pipeline spike, run baseline `cargo fmt/clippy/build` before editing.

## 09:20 - Phase 0 tooling focus
- Decided to start with the asset pipeline spike by adding a `tools/atlas_packer` crate to automate texture atlas generation; this supports Phase 1 rendering goals.
- Planned features: CLI w/ Clap, PNG ingestion via `image`, simple grid packing, metadata JSON output describing UV regions for runtime loader.
- TODO: add workspace dependencies (`clap`, `image`), scaffold new crate, update workspace manifest, and ensure build/clippy remain green.

## 10:15 - Atlas packer prototype
- Added `clap`, `image`, and `walkdir` to workspace deps and scaffolded the `tools/atlas_packer` binary crate. Implemented CLI supporting configurable tile size, padding, atlas columns, and optional resizing for mixed-size assets.
- Tool walks an input directory, packs square textures into a padded grid with deterministic ordering, writes PNG atlas + JSON metadata (UVs, pixel coordinates). Validates atlas bounds and reports duplicates.
- Verified workspace builds remain clean via `cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, and `cargo build`.

## 10:45 - Documentation + onboarding
- Extended README developer-tools section with `atlas_packer` usage examples, CLI flags, and metadata schema so artists/engineers know how to generate atlases for the new renderer pipeline.
- Next up: plan ECS benchmarking spike (Phase 0 task) and connect atlas metadata to runtime loader once assets land.

## 11:30 - ECS comparison harness
- Created `tools/ecs_compare`, a CLI that spawns configurable numbers of position/velocity entities and times 200+ ticks through both `bevy_ecs` (our current choice) and `hecs`. Randomized component initializers keep workloads realistic.
- Added shared `hecs` dependency to the workspace, wired the tool up with Clap, and exposed basic stats (total + per-tick durations). Updated README to document usage so we can run it in CI when evaluating ECS changes.
- Builds remain clean (`cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, `cargo build`). Next: analyze results + capture decision doc for ECS/persistence once we run benchmarks across hardware.

## 12:00 - Atlas metadata loader
- Extended `mdminecraft-assets` with `TextureAtlasMetadata` + `AtlasEntry` structs and validation logic matching the JSON emitted by `atlas_packer`. Loader supports parsing from string/file, sanity-checks atlas dimensions/padding, and exposes entry lookup for renderers.
- Added extensive validation (bounds, duplicate names, tile dimensions) + unit tests; re-exported types at the crate root so rendering/runtime modules can depend on a single source of truth.
- Repo still lint/format/build clean after the addition.

## 13:00 - Renderer integration
- Updated `mdminecraft-render` to load authored atlases (`assets/atlas/atlas.png/.json`, overridable via `MDM_ATLAS_*`). On success, textures upload via a new helper that handles row padding; metadata cached on `VoxelPipeline` for future material mapping.
- If atlas loading fails, we log a warning (new helper) and fall back to the procedural debug atlas so builds remain runable. README docs now mention where to place atlas outputs.
- Added `image`/`thiserror` deps, encapsulated runtime loading errors (`RuntimeAtlasError`), and ensured GPU writes honor wgpu row alignment. Re-verified with `cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, and `cargo build`.

## 14:00 - Atlas-aware meshing
- Extended block descriptors with optional `texture` names (defaulting to block `name`) and taught the greedy mesher to resolve UVs from the loaded atlas metadata when available. Fallback path retains the old 16×16 debug grid so early builds still render.
- Updated `mesh_chunk` to accept `Option<&TextureAtlasMetadata>`; plumbed this through renderer, game world, cache, CLI/test drivers, and chunk viewer so every mesh uses authored UVs once the atlas exists.
- Added `Renderer::atlas_metadata()` helper, ensured chunk rebuild paths (mining, placement, cache/driver) pass metadata, and refreshed docs/tests to include the new descriptor field. Toolchain remains clean via `cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, and `cargo build`.

## 15:00 - Per-face textures
- Introduced data-driven block texture sets: JSON definitions now support either a single `texture` or a nested `textures` map (`all`, `side`, `top`, `bottom`, `north`, etc.). `BlockDescriptor` stores a `BlockTextures` struct with lookup helpers + convenience constructor for tests.
- Added `BlockFace` enum, updated the greedy mesher to derive the face from the quad normal and fetch the correct atlas entry per face. Cache/driver/unit tests now build descriptors via helpers, and loader funnels definitions through `BlockDescriptor::from_definition`.
- Verified workspace via `cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, and `cargo build`. Ready to wire face-specific textures into future block packs.

## 15:30 - Configurable block packs
- Added `config/blocks.json` (with default air/stone/dirt/grass entries) and `config::load_block_registry()` so the game loads block packs at startup, warning and falling back to a built-in set if the file is missing/invalid.
- Hooked the new loader into `GameWorld::new`, documented the JSON format in the README, and ensured block meshes now use authored data end-to-end (from config → registry → atlas).
- Toolchain remains clean (`cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, `cargo build`).

## 15:45 - Scripted input samples
- Converted scripted input files to the `{ "steps": [...] }` format expected by `ScriptedInputPlayer` and added two new demos: `rotation_demo.json` (camera-only look sweeps) and `walk_square.json` (movement loops). README now lists the available scripts.
- These samples help QA/CI exercise auto-play mode without manual setup.

## 16:05 - Mouse sensitivity tweak
- Lowered the default `mouse_sensitivity` in `ControlsConfig` from 0.2 to 0.05 so fresh installs don’t feel over-responsive; users can still override via `config/controls.toml`.

## 16:20 - Mouse yaw inversion bug
- Bug: moving the mouse right rotated the camera left. `apply_mouse_look` fed positive X deltas directly into `camera.rotate`, but our view matrix expects positive yaw to turn left (Math coordinate issue). Fix: negate the X delta before calling `camera.rotate` so intuitive rightward motion turns the player to the right.

## 16:30 - Movement axis fix
- `W`/`S` movement was still tied to world axes because I inverted the forward input earlier to compensate for yaw. Removed the extra negation so `move_y` now projects correctly onto the camera’s forward vector—movement is fully relative to where the player is facing.

## 16:50 - Movement basis rewrite
- Replaced the ground-movement basis with an explicit yaw-derived forward/right pair (`forward = (cos yaw, 0, sin yaw)`), ensuring key input is always relative to the player’s facing direction regardless of pitch/roll quirks. This avoids subtle issues with `camera.forward()/right()` crossproducts.

## 17:05 - Missing block textures
- Added atlas entries + block config definitions for all worldgen block IDs (sand, gravel, water, ice, snow, clay, bedrock). Pulled CC0 art (sand/gravel/bedrock) from Joe Enderman’s pack and generated simple CC0 solid tiles for the remaining materials. Regenerated the atlas (14 entries) and updated README credits.

## 17:30 - Skylight integration
- Wired `mdminecraft_world::lighting::init_skylight` into chunk generation and block updates so skylight values reflect actual terrain height. Meshes now bake real skylight intensity (instead of hardcoded 0/50) and block edits re-run a simple skylight pass before remeshing.

## 17:50 - Atmospheric shading pass
- Extended `TimeUniform` to include fog color/parameters and updated voxel & skybox shaders accordingly. Added distance-based fog that varies with time-of-day plus a simple animated tint/alpha for water blocks. Gives the world a more atmospheric look and nudges Phase 1 rendering tasks forward.

## 18:10 - Sun/moon + clouds
- Upgraded the skybox shader to render sun/moon discs derived from the sun direction and added a procedural cloud layer driven by time-of-day. This advances the “sky/weather renderer” milestone: we now get day/night transitions with visible celestial bodies and moving clouds atop the gradient background.

## 16:40 - Backface culling
- Some blocks only rendered from one side because the GPU culled backfaces; our greedy mesher already avoids internal faces, so there’s no benefit. Disabled backface culling in the voxel pipeline so every face is visible regardless of winding inconsistencies.

## 18:55 - Particle/weather effects
- Took another pass at the renderer facade to expose the new particle pipeline (`ParticlePipeline`) alongside voxel/skybox passes so gameplay code can draw billboards with depth testing. Added a helper render pass that reuses the voxel depth buffer to avoid particles bleeding through terrain.
- Introduced CPU-side particle state in `GameWorld`: reusable emitter buffer, particle instances with lifetime/gravity, and a StdRng-backed weather scheduler. Added weather state tracking (`WeatherToggle`) and deterministic precipitation cadences that can still be toggled manually via the `O` key for QA.
- Hooked precipitation emitters plus block-break debris into gameplay: rain/snow spawns around the camera with wind + gravity, while mined blocks spray colored chips derived from the block registry. Each frame converts alive particles into GPU vertices and renders them in their own pass before the wireframe overlay.
- Ensured particle counts stay bounded (`MAX_PARTICLES`), added alpha fading, and kept everything deterministic so soak tests and scripted input runs remain reproducible. Next up: tie weather intensity/fog/audio together and expand emitters to footsteps/combat events.

## 20:15 - Atmospheric shading & HUD telemetry
- Plumbed the weather toggle through the renderer by extending `TimeUniform` with a precipitation channel (`fog_params.w`) and lerped fog start/end + tint based on intensity. Added a smooth `weather_blend` accumulator so transitions don't pop. Voxel and skybox shaders now dim sunlight, adjust water tint, and desaturate the sky under storms, while fog tightens during downpours.
- Extended `DebugHud` with atmosphere + telemetry readouts (weather label, precipitation intensity, per-frame chunk uploads, active particle count). Game loop now resets/upload counters each frame, and chunk-remesh sites bump the metric whenever we push new meshes to the GPU.
- Verified everything via `cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, and `cargo build --all-targets`; the repo stays clean with the new uniforms/shaders.
