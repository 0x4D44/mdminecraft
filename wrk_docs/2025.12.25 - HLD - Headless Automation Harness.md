# 2025.12.25 - HLD - Headless Automation Harness (Screenshots + Remote Input)

## Summary

This document proposes a first-class **automation harness** for `mdminecraft` that enables:

- **Headless execution** (no window / no OS input required).
- **Automated screenshots** at a regular interval and on-demand.
- **Remote control** (inject gameplay input and run commands) via a simple socket protocol.
- **Deterministic stepping mode** (simulation advances only when instructed) for robust automated testing.

The intent is to let LLM-driven agents (and conventional test runners) **drive and explore the world**, capture visual artifacts, and build reproducible automated tests.

## Design Review (Issues + Resolutions)

This section captures issues found while reviewing the initial design and the concrete resolutions incorporated below.

1. **Game loop uses wall-clock `Instant` for player movement and interactions**  
   - *Issue:* The current interactive loop mixes fixed-timestep simulation (`fixed_update`) with **frame-dt** player movement / block interaction. A headless harness that runs “as fast as possible” would change player motion and therefore world interactions.  
   - *Resolution:* Introduce a **deterministic tick-step API** for headless automation: in headless/step mode we run one “automation tick” as: `apply_input(dt=TICK_RATE) -> interaction/movement(dt) -> fixed_update()`. Wall-clock time is not used.

2. **`GameWorld` is tightly coupled to `winit::Window`**  
   - *Issue:* `GameWorld` stores `Arc<Window>` and uses it for cursor capture/UI paths. True headless (no display server) cannot create a `Window`.  
   - *Resolution:* Make window-dependent operations **optional** via a small “platform handle” abstraction (or `Option<Arc<Window>>`) and gate cursor/UI actions in headless mode.

3. **Renderer assumes a swapchain surface and always initializes UI**  
   - *Issue:* `mdminecraft-render::Renderer` currently initializes `RenderContext` from a `wgpu::Surface` + `winit::Window`, and always constructs `UiManager` which requires a `Window`.  
   - *Resolution:* Split renderer initialization into **windowed** and **headless** paths. Headless creates a `Device/Queue` without a surface and renders to an offscreen texture. UI is disabled in headless.

4. **Screenshot capture from a surface is not universally supported**  
   - *Issue:* Some platforms/backends do not allow `COPY_SRC` on the swapchain surface texture, so “copy surface to buffer” is not reliable. Also, windowed surface format may be BGRA which requires channel swizzle for PNG.  
   - *Resolution:* Headless always renders to an offscreen `COPY_SRC` texture. Windowed mode uses a **fallback capture path** (re-render to an offscreen capture texture on screenshot frames) when direct surface readback is unavailable.

5. **Protocol ambiguity and missing ergonomics**  
   - *Issue:* The initial protocol didn’t define axis order/units clearly, didn’t distinguish *hold vs click*, and had no request correlation or structured errors.  
   - *Resolution:* Define a minimal versioned NDJSON protocol with:
     - optional `id` echoed in responses,
     - structured `"event":"error"` responses,
     - explicit action fields (`move_x/move_y/...`),
     - explicit click/hold semantics (`attack_hold`, `attack_click`, …),
     - promoted `set_view` (absolute yaw/pitch) as a first-class command for closed-loop control.

6. **Save/seed semantics were underspecified**  
   - *Issue:* The engine persists world seed/state; a harness must avoid accidentally reusing/modifying a developer’s save.  
   - *Resolution:* Headless defaults to **ephemeral saves** unless `--save-dir` is explicitly set. `--world-seed` is validated against existing save meta unless `--reset-world` is provided.

## Background (what exists today)

`mdminecraft` already has automation-adjacent features:

- `--auto-play`: skip menu, enter world immediately.
- `--scripted-input <json>`: deterministic movement/look over time (see `config/scripts/*.json`).
- `--command-script <json>`: deterministic tick-scheduled command execution (`/time set`, `/tp`, etc.).

These are useful but insufficient for LLM-driven exploration/testing because they lack:

- A headless mode that runs in CI without a windowing system.
- A way to capture rendered images (screenshots).
- An interactive control interface for closed-loop agents (“observe -> act -> observe”).

## Goals

1. **Run headless** with no dependency on a display server.
2. **Capture screenshots**:
   - at a configured interval,
   - on demand via automation messages,
   - written to disk with stable naming (default: sim tick based).
3. **Inject input remotely**:
   - deterministic control via action-level inputs (preferred),
   - supports interactions sufficient to mine/place/use.
4. **Deterministic stepping mode**:
   - simulation advances only when requested,
   - inputs apply at tick boundaries (no timing jitter).
5. **Expose minimal state** for navigation/assertions:
   - tick, position, yaw/pitch, dimension, health/hunger.
6. **Avoid accidental save pollution**:
   - make it hard to write into `saves/default` unless explicitly requested.

## Non-goals

- Perfect cross-GPU **pixel-identical rendering determinism**. Screenshots are primarily artifacts/debugging aids; strict image regression will be backend-specific and gated.
- A general scripting language (WASM/Lua). This harness focuses on testing + control.
- Multiplayer automation in the first iteration.

## Requirements / Constraints

- **Determinism-first** for simulation when driven by the same actions at the same sim ticks.
- **CI-friendly**: should run without a windowing system.
- **No unsafe** unless clearly justified.
- **Low friction**: CLI flags + newline-delimited JSON protocol.

## Proposed User-Facing Interface (CLI)

### Execution / rendering

- `--headless`  
  Runs without `winit` windows or OS input. Implies `--auto-play`.

- `--resolution <WxH>` (default: `1280x720`)  
  Applies to headless offscreen rendering and screenshot output.

- `--no-render`  
  Runs simulation only (no GPU init, no screenshots). Useful for CI environments without any adapter.

- `--no-audio`  
  Skips audio device init (recommended in CI/headless).

### World persistence / determinism

- `--save-dir <path>`  
  Explicit save directory. **Windowed default:** `saves/default`. **Headless default:** ephemeral temp dir.

- `--no-save`  
  Forces an ephemeral save dir and deletes it on clean exit.

- `--reset-world`  
  Clears existing world state in the chosen `--save-dir` before starting (safe-guarded; should refuse if `--save-dir` is omitted and would otherwise be `saves/default`).

- `--world-seed <u64>`  
  Seed to use when creating a new world. If `--save-dir` already contains world meta with a different seed, the harness should:
  - error by default (fail fast),
  - allow override only with `--reset-world`.

### Screenshot capture

- `--screenshot-dir <path>`  
  Enables screenshots and selects output directory.

- `--screenshot-every-ticks <N>`  
  Captures a screenshot after every N **simulation ticks**. (`N=20` ≈ 1s at 20 TPS.)

- `--screenshot-format <png|qoi>` (optional)  
  Default: `png`. `qoi` can be added later for performance.

- `--screenshot-max <count>` (optional)  
  Captures at most N screenshots; after that, periodic capture stops (manual `screenshot` requests still work).

### Automation server

- `--automation-listen <addr>`  
  TCP listener for automation control. Default bind should be loopback (`127.0.0.1`) unless explicitly overridden.

- `--automation-uds <path>` (optional, unix-only)  
  Unix domain socket alternative (avoids port contention; local-only).

- `--automation-token <string>` (optional)  
  Shared secret required in `hello`.

- `--automation-step`  
  Enables deterministic stepping: simulation advances only on `step` requests.  
  **Scope:** headless only for the initial implementation (windowed `winit` loop is not a good fit for blocking step semantics).

- `--automation-log <path>` (optional)  
  Writes automation requests + key events to JSONL (redacting token).

- `--automation-exit-when-disconnected` (optional)  
  In headless mode, exit if the controlling client disconnects.

### Run bounds

- `--max-ticks <u64>`  
  Hard stop after N simulation ticks (safety timeout).

- `--exit-when-script-finished`  
  If `--command-script` is provided, exit once it completes.

### Compatibility / precedence rules

- If `--automation-listen/--automation-uds` is set, **automation input owns player input**.  
  `--scripted-input` should be treated as **mutually exclusive** (error) in this mode to avoid confusing precedence.

- `--command-script` remains compatible with automation (commands are applied on sim ticks).

### Example commands

Headless step mode with periodic screenshots:

```bash
mdminecraft --headless --no-audio --no-save --world-seed 123 \
  --automation-listen 127.0.0.1:4242 --automation-step \
  --screenshot-dir target/harness/run1 --screenshot-every-ticks 1
```

Headless free-run (no remote control), screenshot every second:

```bash
mdminecraft --headless --no-audio --no-save --world-seed 123 \
  --screenshot-dir target/harness/run1 --screenshot-every-ticks 20 --max-ticks 400
```

Windowed run with on-demand screenshots (best-effort):

```bash
mdminecraft --auto-play --screenshot-dir target/shots
```

## High-Level Architecture

### Components

1. **AutomationServer** (network thread)
   - Accepts a single controlling connection (first wins; others receive a “busy” error).
   - Parses newline-delimited JSON requests.
   - Sends validated requests to the game thread via a **bounded** `sync_channel` (prevents OOM).
   - For responses/events, receives messages from the game thread and writes NDJSON back to the client.

2. **AutomationController** (game thread)
   - Owns the current “virtual input” state (held axes/buttons + queued pulses).
   - Applies virtual input to the game’s `InputState` at tick/frame boundaries.
   - Executes commands (`/tp`, `/setblock`, etc.) via existing command plumbing.
   - Triggers screenshot capture and state queries.

3. **HeadlessRunner** (game thread)
   - A headless execution loop with no `winit` event loop.
   - In step mode: blocks waiting for `step` messages (with optional `max_ticks` escape hatch).
   - In free-run: advances at fixed ticks until `max_ticks` / script completion / disconnect.

4. **ScreenshotService** (render crate + integration)
   - Renders into a known `COPY_SRC` render target and performs GPU->CPU readback.
   - Encodes and writes files; returns metadata for automation responses/logs.

### Message flow

```
Automation Client
  -> TCP/UDS -> AutomationServer thread
    -> sync_channel::Sender<AutomationMsg> -> Game thread
      -> AutomationController applies input, steps sim, captures screenshots
      <- sync_channel::Receiver<AutomationEvent> <- Game thread
    <- AutomationServer writes NDJSON events back to client
```

## Automation Protocol (NDJSON v1)

### Transport

- TCP or Unix domain socket.
- Newline-delimited JSON objects (`\n` terminated).
- Messages are processed in order per connection.

### Conventions

- Requests MAY include `"id"` (integer or string). Responses echo `"id"` when present.
- The server sends:
  - synchronous responses to requests, and
  - asynchronous events (e.g., periodic `state`, screenshot completion).

### Handshake

Client:

```json
{"op":"hello","id":1,"version":1,"token":"optional"}
```

Server:

```json
{"event":"hello","id":1,"version":1,"capabilities":["step","screenshot","set_actions","pulse","set_view","command","get_state","shutdown"]}
```

### Errors

If a request fails validation or execution:

```json
{"event":"error","id":1,"code":"bad_request","message":"explanation"}
```

Recommended `code` values:
- `bad_request` (schema/validation)
- `unauthorized`
- `unsupported` (op not available in this mode)
- `busy` (already controlled)
- `internal` (unexpected)

### Input model

The protocol is **action-level**, not OS-level keys.
Axes map directly to the engine’s action semantics:

- `move_y`: forward/back (-1..1)
- `move_x`: right/left (-1..1)
- `move_z`: up/down (-1..1) (fly mode only)
- yaw/pitch: radians (absolute) or delta (relative)

Click/hold semantics are explicit:

- `*_hold`: treated as “button held” (mining uses hold).
- `*_click`: one-tick pulse (attacks/interactions use click).

### Core operations

**1) set_actions (held state)**

Sets the persistent held state. Omitted fields keep their previous values.

```json
{
  "op":"set_actions",
  "id":2,
  "actions":{
    "context":"Gameplay",
    "move_x":0.0,
    "move_y":1.0,
    "move_z":0.0,
    "sprint":true,
    "crouch":false,
    "jump_hold":false,
    "attack_hold":false,
    "use_hold":false,
    "hotbar_slot":2
  }
}
```

Response:

```json
{"event":"ok","id":2}
```

**2) pulse (one-tick events)**

Applies for the next tick only, then clears.

```json
{"op":"pulse","id":3,"actions":{"jump_click":true,"use_click":true}}
```

Response:

```json
{"event":"ok","id":3}
```

**3) set_view (absolute yaw/pitch)**

This is preferred for closed-loop control because it avoids sensitivity scaling.

```json
{"op":"set_view","id":4,"yaw":1.57,"pitch":-0.20}
```

Response:

```json
{"event":"ok","id":4}
```

**4) step (deterministic stepping)**

Only valid when `--automation-step` is enabled.

```json
{"op":"step","id":5,"ticks":10}
```

Response (after stepping completes):

```json
{"event":"stepped","id":5,"tick":1234}
```

Semantics:
- `step` advances the simulation by exactly `ticks` ticks.
- Periodic screenshots (`--screenshot-every-ticks`) are evaluated at each intermediate tick and may produce multiple screenshot events.

**5) screenshot (on-demand)**

Captures a screenshot of the current state (at the current simulation tick).

```json
{"op":"screenshot","id":6,"tag":"overlook"}
```

Response:

```json
{"event":"screenshot","id":6,"tick":1234,"path":"target/harness/run1/tick_00001234_tag-overlook.png","width":1280,"height":720}
```

**6) command**

Runs a slash-command through existing command execution.

```json
{"op":"command","id":7,"line":"/tp 0 80 0"}
```

Response:

```json
{"event":"command_result","id":7,"tick":1234,"ok":true,"lines":["Teleported to 0 80 0"]}
```

**7) get_state**

Returns current game state snapshot.

```json
{"op":"get_state","id":8}
```

Response:

```json
{
  "event":"state",
  "id":8,
  "tick":1234,
  "dimension":"Overworld",
  "player":{"pos":[1.2,64.0,-3.8],"yaw":1.57,"pitch":-0.22,"health":18.0,"hunger":19}
}
```

**8) shutdown**

```json
{"op":"shutdown","id":9}
```

Response:

```json
{"event":"ok","id":9}
```

## Input Injection Strategy (engine integration)

### Why not OS keystrokes?

OS-level input injection is fragile and not CI-friendly:

- Depends on window focus and OS APIs.
- Fails in headless containers.
- Timing jitter makes it nondeterministic.

### Mapping to the current engine

The engine uses:

- `InputState` (held keys/buttons, click sets, deltas),
- `InputProcessor` (translates `InputSnapshot` -> `ActionState`),
- plus some gameplay logic that reads `InputState` directly for mouse clicks/holds.

To avoid duplicating logic, automation maintains a **virtual input state** and writes it into `GameWorld.input` each tick/frame.

Key details (important for correctness):

- `InputState.reset_frame()` clears `mouse_clicks` and `keys_just_pressed` each rendered frame.
  - Therefore automation pulses must be re-applied each tick that needs them.
- Mining uses `is_mouse_pressed(Left)` (hold).
- Mob attack uses `is_mouse_clicked(Left)` (click).
  - Therefore automation needs explicit click/hold control.

### Implementation sketch

- Store `held` state and `pulses` inside `AutomationController`.
- At the start of each simulated tick:
  - populate `InputState.keys_pressed` / `mouse_buttons` from held state,
  - populate `InputState.keys_just_pressed` / `mouse_clicks` from pulses,
  - populate `InputState.mouse_delta` from look delta, OR bypass by applying `set_view` directly to camera.
- After applying pulses for the tick, clear them.

### Cursor capture and context

In headless mode there is no cursor. For gameplay interactions to work, headless should behave as if “cursor captured”:

- force `input.cursor_captured = true` (headless only),
- default `input.context = Gameplay`.

UI overlay actions (`toggle_cursor`, menu navigation) are ignored in headless.

## Rendering + Screenshot Capture Design

### Render modes

We support three modes:

1. **Windowed** (existing): renders to a swapchain surface; UI enabled.
2. **Headless/offscreen**: renders to an offscreen texture; UI disabled.
3. **No-render**: simulation only; screenshots are unsupported.

### Why surface readback is tricky

Reading pixels directly from a swapchain surface requires:

- the surface texture to support `COPY_SRC` usage, and
- handling BGRA formats (swizzle) and row padding alignment.

Some platforms do not expose `COPY_SRC` for the surface, so the design must not depend on it.

### Proposed renderer changes (mdminecraft-render)

Introduce a `RenderTarget` abstraction:

- `RenderTarget::Surface { surface, config, size, copy_src_supported }`
- `RenderTarget::Offscreen { texture, view, format, size }`

Adjust `RenderContext` to own:

- `device`, `queue`,
- a `RenderTarget`,
- common depth texture resources.

Split initialization:

- `RenderContext::new_windowed(window: Arc<Window>) -> Result<Self>`
- `RenderContext::new_headless(size: (u32,u32), format: TextureFormat) -> Result<Self>`

Split `Renderer` initialization accordingly:

- `Renderer::initialize_gpu_windowed(window: Arc<Window>)`
- `Renderer::initialize_gpu_headless()`

UI creation (`UiManager`) happens only in the windowed path.

### Screenshot capture paths

**Headless:** always capture from the offscreen render target texture (guaranteed `COPY_SRC`).

**Windowed:** best-effort:

1. If the surface supports `COPY_SRC`, capture directly from the surface texture.
2. Otherwise, on screenshot frames, **re-render** the scene into a dedicated offscreen capture texture and read back from there.

Rationale:
- Re-rendering is slower, but only happens on screenshot frames.
- It avoids complex postprocess/copy-to-surface hacks and works across backends.

### Pixel format and swizzle

- Prefer offscreen format `Rgba8UnormSrgb` for easy PNG encoding.
- If capturing from a BGRA surface, swizzle BGRA->RGBA before encoding.

### Readback mechanics (wgpu)

- Use `copy_texture_to_buffer` into a staging buffer.
- Respect `bytes_per_row` 256-byte alignment; strip padding per row into a packed RGBA buffer.
- Block on `map_async` using `device.poll(Maintain::Wait)` for simplicity (acceptable for testing).

## Headless Game Loop Design

### Problem statement

The current windowed loop uses wall-clock dt and runs `fixed_update()` based on an accumulator, while player movement/interactions are processed per frame. Headless automation must not depend on wall-clock dt.

### Proposed internal API

Introduce a “single deterministic tick” method used by headless:

`GameWorld::automation_tick(dt: f32)`:

1. Apply automation input into `InputState`.
2. Process actions (`process_actions(dt)`).
3. Update camera/movement with `dt` (in headless we use `dt = TICK_RATE`).
4. Run raycast + interaction handling as needed for mining/placing (also with `dt`).
5. Run `fixed_update()` exactly once.

Notes:
- This is intentionally “tick-oriented” for determinism.
- The existing windowed path can continue to use `update_and_render()` without behavior changes.

### Headless runner modes

**Free-run:**
- Loop `automation_tick(TICK_RATE)` until:
  - `max_ticks` reached, or
  - command script finished and `--exit-when-script-finished`, or
  - controller disconnect and `--automation-exit-when-disconnected`.

**Step mode:**
- Block waiting for `step` requests.
- For each `step(ticks)`:
  - run `automation_tick(TICK_RATE)` `ticks` times.
  - evaluate periodic screenshot schedule at each intermediate tick.

### Rendering frequency

Rendering is only required for screenshots:

- In headless step mode, render *only when* a screenshot is due (periodic or on-demand).
- In headless free-run with periodic screenshots, render only at screenshot ticks.

This keeps headless throughput high while still producing images.

## Screenshot Scheduling & Naming

### When is a screenshot taken?

- A screenshot corresponds to the world **after** completing tick `T` (i.e., the state at current `sim_tick`).
- In step mode, if stepping through multiple ticks, periodic screenshots are emitted at each tick that satisfies the interval.

### Naming

Default filename uses sim tick:

- `tick_00001234.png`

If `tag` is provided:

- `tick_00001234_tag-overlook.png`

Tag is sanitized to `[a-zA-Z0-9._-]` to avoid directory traversal and weird filenames.

### Output structure

If `--screenshot-dir target/harness/run1`:

```
target/harness/run1/
  run.json
  events.jsonl            (if --automation-log)
  tick_00000000.png
  tick_00000020.png
  ...
```

`run.json` should include:
- world seed
- save-dir mode (ephemeral vs explicit)
- resolution
- render mode (windowed/headless/no-render)
- wgpu adapter/backend info (if rendering enabled)
- CLI flags used (redacted where needed)

## Telemetry / Logging

If `--automation-log <path>` is set, write NDJSON records including:

- connect/disconnect
- received requests (minus token)
- responses/errors
- screenshot events (tick, path, optional hash)

This is intended for triage; it is not the determinism oracle (worldtests remain that).

## Testing Strategy

### Unit tests (always-on)

- Protocol parsing/validation:
  - invalid JSON
  - missing required fields
  - token behavior
  - `set_actions` merge semantics
- Input mapping:
  - held vs pulse populates the correct `InputState` fields for a tick
  - `set_view` updates camera orientation deterministically
- Filename sanitization for screenshot tags.

### Integration tests (gated)

GPU/headless tests should be gated behind an env var:

- `MDM_RUN_HEADLESS_GPU_TESTS=1`

Smoke test scenario:
- Start `mdminecraft --headless --no-audio --no-save --world-seed 1 --automation-step --automation-listen ... --screenshot-dir ...`
- Connect client, `hello`, `get_state`, `step 1`, `screenshot`.
- Assert screenshot file exists and has correct dimensions.

### “No-render” tests (CI-friendly)

When no GPU adapter is present, automation can still be tested with `--no-render`:

- step mode works,
- `get_state` works,
- `command` works,
- `screenshot` returns a structured `unsupported` error.

## Security & Robustness

- Default listen address is loopback only.
- Optional token auth; no TLS (intended for local/CI).
- Limit max line length (e.g., 1MB) and reject oversized messages.
- Use bounded channels to prevent unbounded buffering.
- Single controlling connection by default.
- Clean shutdown via `shutdown` or exit conditions.

## Implementation Plan (phased)

### Phase 1: Protocol + automation controller (windowed)

- Implement `AutomationServer` + `AutomationController`.
- Implement `set_actions`, `pulse`, `set_view`, `command`, `get_state`.
- Wire controller into the existing windowed loop (process messages each frame).
- Add `--automation-listen`, `--automation-token`, `--automation-log`.

### Phase 2: Screenshot capture (windowed best-effort)

- Add screenshot flags and naming/sanitization.
- Implement surface readback when supported; otherwise re-render-to-offscreen capture texture for screenshot frames.

### Phase 3: True headless rendering + headless runner

- Implement `RenderContext::new_headless` and `Renderer::initialize_gpu_headless`.
- Add `--headless`, `--resolution`, `--no-render`, `--no-audio`.
- Implement `HeadlessRunner` with deterministic tick stepping (`automation_tick`).
- Implement `--automation-step` (headless-only).

### Phase 4: Harden + test

- Add gated integration test(s) for headless screenshot.
- Add no-render CI tests for protocol + stepping.
- Optional: add `--automation-uds` on unix.

## Open Questions / Follow-ups

1. **Image regression expectations**
   - If we want CI screenshot comparisons, we should define a dedicated GPU/backend and a tolerant comparison strategy.

2. **World interaction parity**
   - Headless tick-stepping may not match windowed behavior 1:1 (because windowed processes interactions per frame). This is acceptable for the harness, but we should document it and keep harness behavior stable.

3. **API growth**
   - Likely future additions: `raycast` query, block inspection, inventory queries, and structured event streams for “agent observations”.

