# High-Level Design — UI3D Billboard Pipeline (revised 2025-11-20)

## Goals (unchanged)
- Render camera-facing quads for world-space UI (labels, icons, markers) cheaply and deterministically.
- Integrate with existing `mdminecraft-ui3d` / `mdminecraft-render` camera+atlas resources.
- Keep the feature opt-in via `ui3d_billboards` until production-ready.

## Gaps / Issues Found in Initial Draft
1) **Buffer choice/alignments** – Draft mentioned std430 storage buffers; better to use a per-instance vertex buffer to avoid extra bind groups and alignment pitfalls. wgpu prefers vertex attributes for instancing; storage buffer would need stricter alignment and bind group plumbing. 
2) **Ordering & layers** – Only "deterministic order" noted; need explicit sort key (layer + stable id) to control overlay vs world icons and reduce blending artifacts.
3) **Depth handling** – Two pipelines were suggested but not fully specified (depth write/compare/bias). Need a clear policy for depth-tested vs overlay, plus optional depth bias to avoid z-fighting.
4) **Lighting** – Optional light flag exists, but how to derive per-instance light value wasn’t defined. Should reuse voxel/block light (0–15) or supply explicit scalar.
5) **Atlas binding** – Must reuse the existing atlas view/sampler from render pipeline to avoid duplicate textures and to honor sRGB expectations.
6) **Bounds/perf** – No frustum culling or capacity limits noted; need instance cap and deterministic growth policy.
7) **Testing** – Hash-based determinism/regression plan should be explicit; include headless smoke.

## Revised Design
### Data Model (Rust)
```rust
#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
pub struct BillboardInstance {
    pub position: [f32; 3];          // world space
    pub size: [f32; 2];              // meters, x/y before facing transform
    pub rot: f32;                    // radians about camera-forward
    pub uv_min: [f32; 2];            // atlas UVs
    pub uv_max: [f32; 2];
    pub color: [f32; 4];             // premultiplied RGBA
    pub light: f32;                  // 0..1, optional (0 uses unlit if emissive flag not set)
    pub layer: i16;                  // sort key higher = drawn later
    pub flags: u16;                  // bit0: emissive (ignore light), bit1: overlay_no_depth
}
```
- Packed to 64 bytes; `bytemuck::Pod` verified in unit test against WGSL layout.
- Instance buffer is a vertex buffer with `VertexStepMode::Instance` (no bind group needed).

### WGSL Layout (instanced quad)
```wgsl
struct CameraUniform { view_proj: mat4x4<f32>; camera_pos: vec4<f32>; } // existing
@group(0) @binding(0) var<uniform> camera: CameraUniform;

struct Instance {
  position: vec3<f32>;
  size: vec2<f32>;
  rot: f32;
  uv_min: vec2<f32>;
  uv_max: vec2<f32>;
  color: vec4<f32>;
  light: f32;
  layer: i32;        // packed as i16 in Rust; converted in shader
  flags: u32;        // lower bits
};

struct VSOut {
  @builtin(position) clip: vec4<f32>;
  @location(0) uv: vec2<f32>;
  @location(1) color: vec4<f32>;
  @location(2) light: f32;
  @location(3) flags: u32;
};

@vertex
fn vs_main(@location(0) quad_pos: vec2<f32>, @location(1) inst: Instance) -> VSOut {
  // Build facing basis from camera forward/right/up
  let forward = normalize(camera.camera_pos.xyz - inst.position);
  let right = normalize(cross(vec3<f32>(0.0,1.0,0.0), forward));
  let up = normalize(cross(forward, right));
  let rot_sin = sin(inst.rot); let rot_cos = cos(inst.rot);
  let local = vec2<f32>(
    quad_pos.x * rot_cos - quad_pos.y * rot_sin,
    quad_pos.x * rot_sin + quad_pos.y * rot_cos);
  let world = inst.position + right * local.x * inst.size.x + up * local.y * inst.size.y;
  var out: VSOut;
  out.clip = camera.view_proj * vec4<f32>(world, 1.0);
  // Map quad_pos (-0.5..0.5) to UV
  let uv = mix(inst.uv_min, inst.uv_max, quad_pos * 0.5 + vec2<f32>(0.5));
  out.uv = uv;
  out.color = inst.color;
  out.light = inst.light;
  out.flags = inst.flags;
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  var c = textureSample(atlas_texture, atlas_sampler, in.uv) * in.color;
  if ((in.flags & 0x1u) == 0u) { // not emissive
     let l = clamp(in.light, 0.0, 1.0);
     c.rgb *= mix(0.35, 1.0, l);
  }
  return c; // premultiplied assumed
}
```
- Vertex input for quad: a static 4-vertex buffer with positions (-0.5,-0.5), (0.5,-0.5), ( -0.5,0.5), (0.5,0.5) and an index buffer for two triangles.
- Atlas bindings reuse existing atlas view/sampler (sRGB). Only one bind group (atlas) plus shared camera.

### Pipelines
- `billboard_pipeline`: depth test `LessEqual`, depth write enabled, no bias by default, premultiplied alpha blending.
- `billboard_overlay_pipeline`: depth test `Always`, depth write disabled (for UI overlays); optional small depth bias instead of `Always` if we still want ordering with depth.
- Separate render passes may be used if switching pipelines mid-frame is costly; but two pipelines share bind group layouts.

### Ordering & Determinism
- Caller sorts instances by `(layer, stable_id)` before upload. Provide helper to stable-sort given `(layer, id)` pair.
- Renderer does no sorting; assumes deterministic input order.

### Integration
- Feature gate: `ui3d_billboards` (already present). All code `cfg`-guarded.
- `RenderResources` (ui3d) gains optional `billboard_renderer` and pipelines when feature is on, borrowing the existing atlas bind group and camera layout.
- `BillboardEmitter` exposed for gameplay/UI code; cleared each frame after upload.
- Debug HUD: `billboard_instances`, `billboard_draws` counters.

### Performance & Limits
- Instance buffer resized by doubling up to a cap (default 32k). Log on grow; avoid per-frame allocs.
- Optional CPU frustum culling: reject instances outside camera frustum before upload (simple sphere-radius from size).
- Uses instanced quads (no point_size builtin) to stay compatible across Vulkan/Metal/GL.

### Testing
- Layout test: assert Rust instance size/align matches WGSL using bytemuck + naga reflection.
- Render smoke test (headless wgpu surface) to ensure pipeline compiles and draws non-zero pixels.
- Determinism test: sort known instances, render twice, hash color buffer to confirm identical output.
- CI: add optional job `cargo test -p mdminecraft-ui3d --features ui3d_billboards --lib` plus smoke example run behind feature flag.

### Failure Handling
- If atlas bind group unavailable or feature disabled, renderer skips with a logged warning (no panic).
- If instance upload exceeds cap and resizing fails, drop the frame’s billboards with warning and keep running.

### Remaining Decisions (during implementation)
- Exact lighting scalar: either pass precomputed light (0–1) from caller or sample voxel light at emitter time; design assumes caller supplies it.
- Depth bias values: choose small bias (e.g., -2) for depth-tested pipeline to mitigate z-fighting near geometry; tweak after smoke tests.
- Overlay approach: either separate pass with `overlay_pipeline` or encode overlay instances in a second draw call; start with second draw call (simpler state changes only).

### Next Steps
1) Implement WGSL shader and Rust structs/buffers per revised layout.
2) Implement `BillboardEmitter` + `BillboardRenderer`, wired into `RenderResources` under feature flag.
3) Add stable-sort helper based on `(layer, id)` and document contract for callers.
4) Add smoke/example (`examples/billboard_demo.rs`) and CI optional job when feature on.
5) Tune depth bias and lighting scalar in a manual test on CPU (llvmpipe) and one hardware backend.

### Implementation Notes (2025-11-21)
- Depth-tested pipeline uses `LessEqual` with depth write on and bias (-2 constant, -1.5 slope).
- Overlay pipeline uses `Always` compare, depth write off, drawn after depth instances in the same pass.
- Premultiplied alpha blending with atlas sampling reused from caller-supplied view/sampler.
- Instance buffer starts at 1k slots, doubles up to 32k; excess instances are dropped with a warning.
