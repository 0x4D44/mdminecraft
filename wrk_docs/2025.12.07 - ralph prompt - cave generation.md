# Ralph Prompt: Advanced Cave Generation System

## TASK: Implement Cave Generation and Underground Features

You are implementing a comprehensive cave generation system for **mdminecraft**. This adds underground exploration with carving algorithms, cave biomes, and new underground blocks.

### JOURNAL REQUIREMENT

Maintain a journal in `wrk_journals` folder. Name: `YYYY.MM.DD - JRN - Cave Generation.md`

### COMPLETION CRITERIA

1. `cargo build` compiles with zero errors and zero warnings
2. `cargo clippy --all-targets --all-features` passes with zero warnings
3. `cargo fmt --all -- --check` passes
4. `cargo test --all` passes ALL tests
5. Caves generate naturally underground with varied shapes
6. At least 3 distinct underground biome variants
7. Cave-specific blocks render correctly

---

## PHASE 1: Cave Carving Algorithm

### 1.1 Add Cave Carver to Terrain Generation

Create `crates/world/src/cave.rs`:

```rust
//! Cave generation using 3D noise carving

use crate::chunk::{BlockId, Chunk, CHUNK_SIZE_X, CHUNK_SIZE_Y, CHUNK_SIZE_Z};
use crate::noise::NoiseGenerator;

/// Cave generation parameters
pub struct CaveParams {
    /// Base frequency for cave noise
    pub frequency: f64,
    /// Threshold below which air is carved (0.0-1.0)
    pub threshold: f64,
    /// Minimum Y level for caves
    pub min_y: i32,
    /// Maximum Y level for caves
    pub max_y: i32,
    /// Vertical squash factor (makes caves more horizontal)
    pub vertical_squash: f64,
}

impl Default for CaveParams {
    fn default() -> Self {
        Self {
            frequency: 0.05,
            threshold: 0.45,
            min_y: 5,
            max_y: 56,
            vertical_squash: 2.0,
        }
    }
}

/// Cave carver using 3D simplex noise
pub struct CaveCarver {
    noise: NoiseGenerator,
    params: CaveParams,
}

impl CaveCarver {
    pub fn new(seed: u64) -> Self {
        Self {
            noise: NoiseGenerator::new(seed ^ 0xCAVE_SEED),
            params: CaveParams::default(),
        }
    }

    pub fn with_params(seed: u64, params: CaveParams) -> Self {
        Self {
            noise: NoiseGenerator::new(seed ^ 0xCAVE_SEED),
            params,
        }
    }

    /// Carve caves into an existing chunk
    pub fn carve_chunk(&self, chunk: &mut Chunk, chunk_x: i32, chunk_z: i32) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in self.params.min_y..=self.params.max_y.min(CHUNK_SIZE_Y as i32 - 1) {
                    if self.should_carve(world_x, y, world_z) {
                        let voxel = chunk.voxel_mut(local_x, y as usize, local_z);
                        // Don't carve bedrock or water
                        if voxel.id != 0 && voxel.id != 1 && voxel.id != 14 {
                            voxel.id = 0; // Air
                        }
                    }
                }
            }
        }
    }

    /// Check if a position should be carved out
    fn should_carve(&self, x: i32, y: i32, z: i32) -> bool {
        // Apply vertical squash to make caves more horizontal
        let squashed_y = y as f64 / self.params.vertical_squash;

        let noise_val = self.noise.get_3d(
            x as f64 * self.params.frequency,
            squashed_y * self.params.frequency,
            z as f64 * self.params.frequency,
        );

        // Normalize from [-1, 1] to [0, 1]
        let normalized = (noise_val + 1.0) / 2.0;

        // Add depth-based variation - caves more common at certain depths
        let depth_factor = self.depth_modifier(y);

        normalized * depth_factor < self.params.threshold
    }

    /// Modify cave density based on depth
    fn depth_modifier(&self, y: i32) -> f32 {
        // Peak cave density around y=30, less near surface and bedrock
        let optimal_depth = 30.0;
        let distance_from_optimal = (y as f32 - optimal_depth).abs();
        let falloff = 1.0 - (distance_from_optimal / 40.0).min(0.5);
        falloff
    }
}
```

### 1.2 Integrate Cave Carver into TerrainGenerator

Modify `crates/world/src/terrain.rs`:

```rust
use crate::cave::CaveCarver;

pub struct TerrainGenerator {
    // ... existing fields ...
    cave_carver: CaveCarver,
}

impl TerrainGenerator {
    pub fn new(seed: u64) -> Self {
        Self {
            // ... existing initialization ...
            cave_carver: CaveCarver::new(seed),
        }
    }

    pub fn generate_chunk(&self, pos: ChunkPos) -> Chunk {
        let mut chunk = Chunk::new();

        // Existing terrain generation...
        self.generate_terrain(&mut chunk, pos);
        self.place_ores(&mut chunk, pos);

        // Carve caves AFTER terrain and ores
        self.cave_carver.carve_chunk(&mut chunk, pos.x, pos.z);

        // Trees and surface features AFTER caves
        self.place_trees(&mut chunk, pos);

        chunk
    }
}
```

---

## PHASE 2: Underground Biomes

### 2.1 Define Underground Biome Types

Add to `crates/world/src/biome.rs` or create `crates/world/src/cave_biome.rs`:

```rust
/// Underground biome types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CaveBiome {
    /// Standard stone caves
    Stone,
    /// Lush caves with moss and glow berries
    Lush,
    /// Dripstone caves with stalactites/stalagmites
    Dripstone,
    /// Deep dark - below y=0 (if supported), or deep caves
    DeepDark,
    /// Flooded caves with water pools
    Flooded,
}

impl CaveBiome {
    /// Determine cave biome based on position and noise
    pub fn from_position(x: i32, y: i32, z: i32, noise: &NoiseGenerator) -> Self {
        // Use different noise frequency for biome selection
        let biome_noise = noise.get_2d(x as f64 * 0.01, z as f64 * 0.01);
        let depth_noise = noise.get_2d(x as f64 * 0.02, z as f64 * 0.02);

        // Depth-based biome selection
        if y < 10 {
            return CaveBiome::DeepDark;
        }

        // Biome noise determines type
        if biome_noise > 0.6 {
            CaveBiome::Lush
        } else if biome_noise > 0.3 {
            CaveBiome::Dripstone
        } else if biome_noise < -0.4 && depth_noise < 0.0 {
            CaveBiome::Flooded
        } else {
            CaveBiome::Stone
        }
    }

    /// Get floor block for this biome
    pub fn floor_block(&self) -> BlockId {
        match self {
            CaveBiome::Stone => 13,      // stone
            CaveBiome::Lush => 80,       // moss_block (new)
            CaveBiome::Dripstone => 13,  // stone
            CaveBiome::DeepDark => 81,   // deepslate (new)
            CaveBiome::Flooded => 10,    // gravel
        }
    }

    /// Get ceiling decoration block
    pub fn ceiling_decoration(&self) -> Option<BlockId> {
        match self {
            CaveBiome::Lush => Some(82),       // glow_lichen (new)
            CaveBiome::Dripstone => Some(83),  // pointed_dripstone (new)
            CaveBiome::DeepDark => Some(84),   // sculk (new)
            _ => None,
        }
    }
}
```

### 2.2 Add New Cave Blocks to Registry

Update `config/blocks.json` with new cave blocks:

```json
{
  "name": "moss_block",
  "id": 80,
  "opaque": true,
  "textures": {
    "all": "blocks/moss_block"
  }
},
{
  "name": "deepslate",
  "id": 81,
  "opaque": true,
  "textures": {
    "all": "blocks/deepslate"
  }
},
{
  "name": "glow_lichen",
  "id": 82,
  "opaque": false,
  "transparent": true,
  "light_level": 7,
  "textures": {
    "all": "blocks/glow_lichen"
  }
},
{
  "name": "pointed_dripstone",
  "id": 83,
  "opaque": false,
  "textures": {
    "all": "blocks/pointed_dripstone"
  }
},
{
  "name": "sculk",
  "id": 84,
  "opaque": true,
  "textures": {
    "all": "blocks/sculk"
  }
}
```

---

## PHASE 3: Cave Decorations

### 3.1 Stalactite/Stalagmite Generation

Add to cave.rs:

```rust
/// Generate dripstone formations in caves
pub struct DripstoneGenerator {
    noise: NoiseGenerator,
}

impl DripstoneGenerator {
    pub fn new(seed: u64) -> Self {
        Self {
            noise: NoiseGenerator::new(seed ^ 0xDRIP_SEED),
        }
    }

    /// Place dripstone in carved cave areas
    pub fn decorate_chunk(
        &self,
        chunk: &mut Chunk,
        chunk_x: i32,
        chunk_z: i32,
        biome_fn: impl Fn(i32, i32, i32) -> CaveBiome,
    ) {
        let world_x_base = chunk_x * CHUNK_SIZE_X as i32;
        let world_z_base = chunk_z * CHUNK_SIZE_Z as i32;

        for local_x in 0..CHUNK_SIZE_X {
            for local_z in 0..CHUNK_SIZE_Z {
                let world_x = world_x_base + local_x as i32;
                let world_z = world_z_base + local_z as i32;

                for y in 5..120 {
                    let biome = biome_fn(world_x, y as i32, world_z);

                    if biome != CaveBiome::Dripstone {
                        continue;
                    }

                    let voxel = chunk.voxel(local_x, y, local_z);
                    if voxel.id != 0 {
                        continue; // Not air
                    }

                    // Check for ceiling (stalactite)
                    if y + 1 < CHUNK_SIZE_Y {
                        let above = chunk.voxel(local_x, y + 1, local_z);
                        if above.id == 13 { // Stone ceiling
                            let spawn_chance = self.noise.get_3d(
                                world_x as f64 * 0.3,
                                y as f64 * 0.3,
                                world_z as f64 * 0.3,
                            );
                            if spawn_chance > 0.7 {
                                chunk.voxel_mut(local_x, y, local_z).id = 83; // pointed_dripstone
                            }
                        }
                    }

                    // Check for floor (stalagmite)
                    if y > 0 {
                        let below = chunk.voxel(local_x, y - 1, local_z);
                        if below.id == 13 { // Stone floor
                            let spawn_chance = self.noise.get_3d(
                                world_x as f64 * 0.3 + 100.0,
                                y as f64 * 0.3,
                                world_z as f64 * 0.3 + 100.0,
                            );
                            if spawn_chance > 0.75 {
                                chunk.voxel_mut(local_x, y, local_z).id = 83; // pointed_dripstone
                            }
                        }
                    }
                }
            }
        }
    }
}
```

### 3.2 Underground Water Pools

```rust
/// Generate underground water pools in caves
pub fn flood_low_areas(chunk: &mut Chunk, water_level: i32, water_id: BlockId) {
    for x in 0..CHUNK_SIZE_X {
        for z in 0..CHUNK_SIZE_Z {
            for y in 1..water_level as usize {
                let voxel = chunk.voxel_mut(x, y, z);
                if voxel.id == 0 { // Air
                    voxel.id = water_id;
                }
            }
        }
    }
}
```

---

## PHASE 4: Create Placeholder Textures

Create simple placeholder textures for new blocks. Use the atlas_packer tool format.

For each new block, create a 16x16 PNG:
- `assets/textures/src/blocks/moss_block.png` - green mossy texture
- `assets/textures/src/blocks/deepslate.png` - dark grey layered stone
- `assets/textures/src/blocks/glow_lichen.png` - cyan/green glowing dots
- `assets/textures/src/blocks/pointed_dripstone.png` - brown/tan pointed
- `assets/textures/src/blocks/sculk.png` - dark blue/black organic

After creating textures, regenerate atlas:
```bash
cargo run -p atlas_packer
```

---

## PHASE 5: Testing

### 5.1 Add Unit Tests

Create `crates/world/src/cave_test.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cave_carver_creates_air() {
        let carver = CaveCarver::new(12345);
        let mut chunk = Chunk::new();

        // Fill with stone
        for x in 0..16 {
            for y in 0..64 {
                for z in 0..16 {
                    chunk.voxel_mut(x, y, z).id = 13;
                }
            }
        }

        carver.carve_chunk(&mut chunk, 0, 0);

        // Should have created some air
        let mut air_count = 0;
        for x in 0..16 {
            for y in 5..56 {
                for z in 0..16 {
                    if chunk.voxel(x, y, z).id == 0 {
                        air_count += 1;
                    }
                }
            }
        }

        assert!(air_count > 0, "Cave carver should create air pockets");
        assert!(air_count < 16 * 51 * 16, "Cave carver shouldn't carve everything");
    }

    #[test]
    fn test_cave_biome_depth_selection() {
        let noise = NoiseGenerator::new(42);

        // Deep areas should be DeepDark
        let deep = CaveBiome::from_position(0, 5, 0, &noise);
        assert_eq!(deep, CaveBiome::DeepDark);

        // Higher areas should vary
        let mid = CaveBiome::from_position(0, 40, 0, &noise);
        assert_ne!(mid, CaveBiome::DeepDark);
    }
}
```

---

## FILES TO CREATE/MODIFY

### New Files:
- `crates/world/src/cave.rs` - Cave carver and parameters
- `crates/world/src/cave_biome.rs` - Underground biome logic (or add to biome.rs)
- `assets/textures/src/blocks/moss_block.png`
- `assets/textures/src/blocks/deepslate.png`
- `assets/textures/src/blocks/glow_lichen.png`
- `assets/textures/src/blocks/pointed_dripstone.png`
- `assets/textures/src/blocks/sculk.png`

### Files to Modify:
- `crates/world/src/lib.rs` - Export cave module
- `crates/world/src/terrain.rs` - Integrate CaveCarver
- `config/blocks.json` - Add new block definitions

---

## IMPLEMENTATION ORDER

1. Create cave.rs with CaveCarver struct
2. Add mod cave to lib.rs
3. Integrate carver into TerrainGenerator
4. Test basic cave generation works
5. Add CaveBiome enum and logic
6. Add new blocks to blocks.json
7. Create placeholder textures
8. Regenerate atlas
9. Add decoration generators (dripstone, etc)
10. Add tests
11. Run full test suite and fix any issues

---

## VERIFICATION

After implementation, verify:
1. Run game and dig down - caves should be visible
2. Different cave biomes appear at different locations
3. New blocks render correctly
4. No performance regression (caves shouldn't break chunk loading)
5. All tests pass
