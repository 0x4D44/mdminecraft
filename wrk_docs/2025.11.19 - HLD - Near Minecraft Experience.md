# High-Level Design — Near-Minecraft Experience (2025-11-19)

## Change Log
- **2025-11-19 (initial)**: Captured MVP goals, functional requirements, architecture, and milestone outline.
- **2025-11-19 (review update)**: Added scope guardrails, success metrics, staffing assumptions, asset pipeline requirements, tech choices (ECS/audio), and risk mitigations for content/auth asset needs.

## 1. Vision
Deliver a standalone Rust executable evoking Minecraft Java Edition 1.20: blocky visuals, responsive first-person controls, procedurally generated worlds, survival crafting loop, mobs, ambient audio, and day/night cycles. Target 60 FPS on mid-range 2019 gaming laptops and reach single-player survival parity by Q1 2026.

### Success Metrics
- **Performance**: ≥60 FPS at 1920×1080 on GTX 1660 / Ryzen 5 3600, with frame pacing <4 ms jitter.
- **Gameplay coverage**: Player can start a new world, survive first 5 nights, craft iron gear, defeat hostile mobs, and save/load progress without crashes.
- **Content breadth**: ≥8 distinct biomes, ≥6 ores/resources, ≥6 tools/weapons, ≥6 mob types.

## 2. Experience Goals
1. **Visual fidelity** — per-face textures, biome tinting, animated fluids, sky gradients, weather, particles.
2. **Core survival loop** — harvest → craft → build → combat with hunger/health management.
3. **World dynamism** — varied biomes, caves, ore veins, structures, passive/hostile mobs, weather + day/night effects.
4. **Audio immersion** — adaptive soundtrack, positional SFX, ambience tied to biomes/weather/time.
5. **Polish & usability** — intuitive controls, options UI, cursor capture, save/load, pause menu, accessibility toggles, debug tooling for dev workflows.

## 3. Out-of-Scope (Initial Release)
- Multiplayer networking, realms/servers.
- Modding API or compatibility with Mojang resources.
- Redstone automation, enchanting, potion brewing, Nether/End dimensions (track as Phase 2).
- VR support, console ports, ray tracing.

## 4. Functional Requirements
### 4.1 Rendering & Assets
- **Texture pipeline**: pack authored PNGs (16×16/32×32) into runtime atlas with mipmaps, per-face UV assignments, biome tint masks. Support emissive textures (glow) and animation frames (water/lava/fire).
- **Lighting**: dual-channel skylight/block light (0-15), sunlight propagation, colored light from blocks, smooth lighting at vertices (AO). Apply gamma-correct shading and fog tuned per biome/weather.
- **Sky & weather**: gradient sky, sun/moon billboard, starfield, volumetric-ish clouds. Weather overlays (rain streaks, snowflakes) influencing fog, light, audio.
- **Fluids & particles**: Flowing water/lava with normal-mapped shading, foam at edges. Particle emitters for block break, footsteps, damage, ambient effects.
- **Assets**: original art/audio license. Provide tooling for importing textures, models (item icons), and audio banks.

### 4.2 Input & Camera
- Keyboard/mouse: existing pipeline plus FOV slider, discrete sensitivities per axis, sprint toggle, crouch hold/toggle, swimming transitions, fly (creative) mode. Capture cursor with platform fallbacks; expose keybinding UI.
- Gamepad (stretch): abstract input layer for dual-stick, triggers, rumble.

### 4.3 Worldgen & Persistence
- Noise-based heightmap with biome blending (temperature/humidity). Include plains, forests, deserts, taiga, mountains, swamp, jungle, snowy tundra.
- Feature placement: trees (variants), lakes, simple villages (cottages, farms), mineshafts-lite, surface boulders.
- Ore distribution by Y-level (coal, iron, copper, redstone, gold, lapis, diamond), clay/sand pockets, fossils (stretch).
- Region save format (e.g., compressed chunk blobs). Metadata for time, weather, player stats, structures.
- Background streaming: configurable simulation radius (10 chunks), asynchronous generation, lighting, meshing, saving.

### 4.4 Blocks & Items
- Data-driven definitions with fields: hardness, blast resistance, tool tier, light emission, collision shape, drop table, sound set, texture set (per face), behavior hooks.
- Items: stack size, durability, attack damage/speed, consumption effects, fuel value.
- Crafting: 2×2 (player) + 3×3 (crafting table) grid; recipe book UI; furnace/blast furnace/smoker with fuel burn times and XP output.
- Redstone placeholder: not in MVP but architecture should leave channel for future block states and neighbor updates.

### 4.5 Player Systems
- Attributes: health, hunger, saturation, exhaustion, armor, XP level/progress.
- Status effects placeholder (poison, regeneration) for future features.
- Movement states: walking, sprinting, crouching, swimming, climbing ladders, riding minecarts (stretch), flying (creative).
- Beds for spawn reset + night skip (skip triggered if all players sleep; in SP simply fast-forward).

### 4.6 Entities & AI
- ECS decision: evaluate `bevy_ecs` or `hecs` vs custom; requirement: >500 active entities with minimal frame impact.
- Passive mobs: cow, pig, sheep, chicken (breeding, drops, simple wander/avoid).
- Hostiles: zombie (melee), skeleton (ranged), creeper (explosion). Basic pathfinding over voxel navmesh; handle water avoidance, daylight burn for undead.
- Utility entities: dropped items (lifespan, pickup), projectiles (arrows), TNT/explosions altering terrain with damage falloff.

### 4.7 Audio & Music
- Audio backend (Kira or custom rodio wrapper) with streaming music, positional SFX, mixer buses (master, music, SFX, ambient, UI).
- Event hooks: footstep surface-dependent, block break/place, tool swings, UI clicks, mob actions, weather, ambient loops (caves, ocean).
- Music scheduler: random tracks by context (day/night/cave), crossfade to weather cues.

### 4.8 UI/UX
- Title menu with animated background, buttons: Play, Options, Credits, Quit.
- World select/create UI: choose seed, game mode (Survival/Creative), difficulty, world settings.
- Options: video (resolution, fullscreen, render distance, VSync, graphics quality), audio (volumes), controls (bindings, sensitivity), accessibility (text size, colorblind filters).
- HUD: hearts, hunger, armor, XP bar, hotbar, crosshair, status effects, chat overlay (stretch), debug F3 view (toggle).
- Pause menu: Resume, Options, Feedback, Quit to Title.

## 5. Architecture
### 5.1 Module Boundaries & Ownership
- `crates/render`: renderer, shaders, materials, particle system, UI integration.
- `crates/world`: chunk storage, worldgen, lighting, region IO, biome data.
- `crates/gameplay`: block/item registries, crafting, inventory, status/hunger, damage.
- `crates/entities`: ECS runtime, physics integration, AI behaviors, animation states.
- `crates/audio`: asset loading, playback, mixer, emitter components.
- `crates/client`: game state machine, input, UI screens, orchestration.
- Additional: `crates/tools` (texture packer, asset converters) for build pipeline.

### 5.2 Data Flow
- **Simulation tick (20 TPS)**: collect input snapshot → update player systems (movement, hunger) → gameplay logic (crafting, inventory, block interactions) → ECS systems (AI, physics, combat) → world state (block updates, lighting jobs) → schedule chunk rebuilds.
- **Render frame (vsync)**: gather visible chunks/entities/particles → update GPU buffers → issue passes (sky, terrain, transparent, particles, UI).
- **Async workers**: thread pool for worldgen, lighting propagation, meshing, audio streaming, save/load.

### 5.3 Key Systems Details
- **Chunk Streamer**: maintain prioritized job queues (generation, lighting, meshing). Support background LRU eviction, disk IO scheduling, and progress telemetry.
- **Lighting Engine**: nibble arrays + propagation frontier queue; handle skylight column resets on block changes; incremental updates for block light emitters.
- **Inventory/Crafting**: event-driven UI; recipes defined via JSON; serverless logic verifying crafting grids; furnace uses tick timers.
- **AI Framework**: Behavior trees built from reusable actions (wander, chase, attack, flee). Pathfinding uses voxel-based navgraph with heuristics; fallback steering in tight spaces.
- **Audio Mixer**: multiple buses with per-context ducking (reduce music when dialogue plays). Streaming loader for large WAV/OGG.

### 5.4 Tech Choices & Dependencies
- Renderer: wgpu 0.19+, egui for dev UI, consider moving UI to custom immediate-mode for in-game look.
- ECS: adopt `bevy_ecs` for mature scheduling, or `hecs` for lightweight integration; evaluate based on borrow checking ergonomics.
- Physics: simple AABB collision for player/mobs; integrate `rapier3d` (stretch) for rigid bodies (minecarts, falling blocks).
- Serialization: `serde` + custom chunk compression (Zstd) for saves.

## 6. Roadmap & Estimates (single-team baseline)
| Milestone | Scope | Duration | Dependencies |
|-----------|-------|----------|--------------|
| M1 Rendering Upgrade | Texture atlas, lighting rewrite, sky/weather, fluids, particles | 6 weeks | Current renderer foundation |
| M2 Gameplay Loop | Block/item registry overhaul, inventory UI, crafting/smelting, hunger/tools/drops | 8 weeks | M1 assets + UI plumbing |
| M3 Persistence & Streaming | Region saves, chunk eviction/prefetch, world selection UI | 4 weeks | M1 lighting, M2 block data |
| M4 Entities & Combat | ECS adoption, passive/hostile mobs, combat/drops, AI behaviors | 8 weeks | M2 gameplay infrastructure |
| M5 Audio & UX | Audio backend, HUD parity, menus/options, accessibility | 4 weeks | M1 assets, M2 inventory |
| M6 Content Expansion (stretch) | Structures, additional biomes, weather impact, advanced mobs, polish | 6+ weeks | Prior milestones |

Assume 4 engineers (render, gameplay, worldgen, systems) + 1 artist + 1 audio contractor. Parallelize by branching feature teams once foundations stable.

## 7. Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Asset production bottleneck | Visual/audio polish blocked | Engage contractors early, build placeholder pipeline, prioritize tooling |
| Performance regressions (lighting, ECS, AI) | FPS drops, unplayable | Set performance budgets per milestone, integrate profiling early, add automated perf tests |
| Scope creep | Delayed release | Maintain feature freeze per milestone, backlog stretch goals, hold exit reviews |
| Save format churn | Corrupted worlds | Versioned schema, migration tools, integration tests for persistence |
| AI/pathfinding complexity | Poor mob behavior | Start with simple FSMs, upgrade to BTs later, limit spawn counts |
| Legal/IP concerns | Release risk | Hire counsel, ensure assets/audio wholly original |

## 8. Open Questions
1. Minimum hardware spec (GPU/CPU/RAM)? Drives render distance defaults.
2. Are creative/spectator modes required for MVP? (affects controls/UI.)
3. Should saves be compatible across OS/platforms? (endianness, file paths.)
4. Localization languages & font requirements.
5. Is modding support a near-term requirement? (impacts data-driven design.)

## 9. Next Steps
- Review HLD with stakeholders; confirm MVP scope, staffing, and timeline.
- Draft Milestone 1 implementation plan (texture atlas + lighting) with task breakdown.
- Begin asset pipeline prototype (texture packer, audio ingestion).
- Evaluate ECS library vs custom prototype; spike pathfinding approach.
- Outline QA strategy (automated world gen tests, perf regression suite) and documentation plan.
