# High-Level Design: Rust Voxel Game Engine (mdminecraft)

**Document Version:** 1.0
**Date:** 2025.11.12
**Project:** mdminecraft - Performant, Moddable Voxel Sandbox
**Target Language:** Rust
**Architecture:** ECS-based, Client-Server with Headless Testing

---

## 1. Executive Summary

### 1.1 Purpose
This document provides the high-level design for a production-grade voxel sandbox game engine written in Rust. The system emphasizes:
- **Deterministic simulation** for reproducible testing
- **First-class automated testing** via event streams, headless rendering, and replay logs
- **Moddability** through data-driven configuration and optional WASM API
- **Performance** targeting 60 FPS rendering and 20 TPS simulation
- **Cross-platform support** (Windows/Linux/macOS) via wgpu

### 1.2 Design Scope
This HLD covers the transition from the existing JavaScript/Three.js prototype (V1/index.html) to a Rust-based production engine with:
- Multi-crate workspace architecture
- ECS-based entity management (bevy_ecs)
- Authoritative server architecture with client prediction
- Comprehensive testing infrastructure (event streams, world DSL, snapshot tests)
- Infinite terrain generation with chunked storage

### 1.3 Key Design Principles
1. **Separation of Concerns**: Core simulation decoupled from rendering and networking
2. **Determinism First**: Seeded RNG, fixed timestep, no wall-clock dependencies in simulation
3. **Testability**: Event-driven architecture with observable, replayable state changes
4. **Performance**: Cache-friendly data layouts via ECS, instanced rendering, parallel chunk generation
5. **Extensibility**: Plugin system for blocks/items/recipes, WASM modding hooks

---

## 2. System Architecture

### 2.1 Workspace Structure

```
workspace/
├── Cargo.toml           # Workspace manifest
├── crates/
│   ├── core/            # Foundation: math, IDs, coordinates, time, RNG, errors
│   ├── ecs/             # ECS facade over bevy_ecs
│   ├── world/           # Blocks, chunks, biomes, generation, lighting, persistence
│   ├── physics/         # AABB collision, movement, raycasting
│   ├── render/          # wgpu renderer, meshing, materials, post-processing
│   ├── net/             # Protocol, serialization (bincode/postcard), QUIC transport
│   ├── server/          # Authoritative simulation loop, headless mode
│   ├── client/          # Input handling, prediction, interpolation, UI shell
│   ├── assets/          # Asset registry, pack loading, validation
│   ├── scripting/       # WASM modding API (post-MVP)
│   ├── testkit/         # Event streams, replay engine, world DSL, golden tests
│   └── cli/             # Binary targets: game-client, game-server, worldtool, worldtest
├── assets/
│   ├── blocks.toml      # Block registry
│   ├── recipes.json     # Crafting recipes
│   ├── textures/        # Block textures atlas
│   └── shaders/         # WGSL shaders
├── scenarios/           # .worldtest.toml test scenarios
├── goldens/             # Platform-specific render snapshot hashes
└── docs/                # Design docs, API references
```

### 2.2 Crate Responsibilities

| Crate | Purpose | Key Dependencies |
|-------|---------|------------------|
| **core** | Shared primitives (IVec3, BlockId, tick system, seeded RNG) | None (no_std compatible) |
| **ecs** | Entity-Component-System abstraction | bevy_ecs |
| **world** | Chunk storage, block registry, terrain generation, lighting | core, ecs, noise (fastnoise_lite) |
| **physics** | Collision detection/resolution, raycasting | core, ecs |
| **render** | Meshing (greedy), wgpu pipelines, camera, headless backend | core, world, wgpu, bytemuck |
| **net** | Network protocol, state synchronization | core, ecs, world, quinn (QUIC) |
| **server** | Authoritative tick loop, world management | core, ecs, world, physics, net |
| **client** | Input, prediction/reconciliation, UI (egui) | core, ecs, render, net, egui |
| **assets** | Resource loading, pack validation | serde, image |
| **scripting** | WASM host API (post-MVP) | wasmtime, wasmer |
| **testkit** | Event recording, replay, world DSL parser, snapshot diffing | serde_json, image, sha2 |
| **cli** | Binary entry points | all above |

### 2.3 High-Level Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                        Client Binary                        │
│  ┌────────────┐  ┌────────────┐  ┌──────────────────────┐  │
│  │   Input    │─▶│Prediction  │─▶│  Render (wgpu)      │  │
│  │  Handler   │  │Engine      │  │  - Meshing          │  │
│  └────────────┘  └────────────┘  │  - Camera           │  │
│         │                │         │  - Materials        │  │
│         └────────────────┴────────▶│  - Instanced Draw   │  │
│                          │         └──────────────────────┘  │
│                          ▼                                   │
│                   ┌─────────────┐                            │
│                   │  Net Client │◀───────────────────────────┤
│                   └─────────────┘                            │
└──────────────────────┬──────────────────────────────────────┘
                       │ QUIC (quinn)
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                        Server Binary                        │
│  ┌────────────┐  ┌────────────┐  ┌──────────────────────┐  │
│  │ Net Server │─▶│  Tick Loop │─▶│  World Manager      │  │
│  │  (quinn)   │  │  (20 TPS)  │  │  - Chunks           │  │
│  └────────────┘  └────────────┘  │  - Entities (ECS)   │  │
│         ▲                │         │  - Lighting         │  │
│         │                ▼         │  - Physics          │  │
│         │         ┌─────────────┐  └──────────────────────┘  │
│         └─────────│ Event Bus   │◀───────────────────────────┤
│                   │ (testkit)   │                            │
│                   └─────────────┘                            │
│                          │                                   │
│                          ▼                                   │
│                   ┌─────────────┐                            │
│                   │ Persistence │                            │
│                   │ (.rg files) │                            │
│                   └─────────────┘                            │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. Core Subsystems Design

### 3.1 Coordinate System & Data Model

#### 3.1.1 World Coordinates
- **System**: Right-handed, Y-up (X=east, Y=up, Z=south)
- **Chunk Size**: 16×256×16 voxels (X, Y, Z)
- **World Bounds**: Infinite horizontal (lazy chunk loading), Y ∈ [0, 512) with compile flag
- **Region Files**: 32×32 chunk groups saved as `.rg` files

#### 3.1.2 Block Representation
```rust
// core/src/block.rs
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct BlockId(pub u16);  // Index into registry, 0 = air

#[derive(Clone, Copy)]
pub struct BlockState(pub u16); // Orientation, moisture, etc.

#[derive(Clone, Copy)]
pub struct Voxel {
    pub id: BlockId,
    pub state: BlockState,
    pub light_sky: u8,    // Skylight 0-15
    pub light_block: u8,  // Block light 0-15
}
```

#### 3.1.3 Chunk Storage
```rust
// world/src/chunk.rs
pub struct Chunk {
    pub position: IVec3,              // Chunk coordinates (world_pos / 16)
    pub voxels: Box<[Voxel; 16*256*16]>, // Flat array for cache locality
    pub light_queue: VecDeque<IVec3>, // Pending light updates
    pub dirty_mesh: bool,             // Needs remeshing?
    pub generated: bool,              // Terrain generated?
}

pub struct ChunkManager {
    chunks: HashMap<IVec3, Chunk>,
    generation_queue: VecDeque<IVec3>,
    load_radius: u32,
}
```

### 3.2 Entity Component System (ECS)

#### 3.2.1 Component Design
```rust
// ecs/src/components.rs
#[derive(Component)]
pub struct Transform {
    pub position: Vec3,
    pub rotation: Quat,
}

#[derive(Component)]
pub struct Velocity(pub Vec3);

#[derive(Component)]
pub struct Collider {
    pub shape: ColliderShape, // AABB or Capsule
    pub radius: f32,
    pub height: f32,
}

#[derive(Component)]
pub struct Inventory {
    pub slots: [Option<ItemStack>; 36],
}

#[derive(Component)]
pub struct Health {
    pub current: f32,
    pub max: f32,
}

#[derive(Component)]
pub struct PlayerTag; // Marker component

#[derive(Component)]
pub struct MobAI {
    pub state: AIState,
    pub target: Option<Entity>,
}
```

#### 3.2.2 System Scheduling (20 TPS)
```rust
// server/src/tick.rs
pub struct TickSchedule {
    pub systems: Vec<Box<dyn System>>,
}

// Execution order per tick:
// 1. Input ingestion      (net::process_input_packets)
// 2. World updates        (world::tick_blocks, world::update_lighting)
// 3. Entity physics       (physics::integrate_velocity, physics::resolve_collisions)
// 4. Entity AI            (ai::update_mobs)
// 5. Inventory/crafting   (inventory::process_crafting)
// 6. Event emission       (testkit::emit_events)
// 7. State serialization  (net::send_state_deltas)
```

### 3.3 World Generation Pipeline

#### 3.3.1 Generation Stages
```rust
// world/src/generation/mod.rs
pub struct GenerationPipeline {
    seed: u64,
    stages: Vec<Box<dyn GenerationStage>>,
}

pub trait GenerationStage: Send + Sync {
    fn generate(&self, chunk: &mut Chunk, neighbors: &NeighborCache);
}

// Pipeline stages (order matters):
// 1. BaseHeightmapStage   - Multi-octave noise for terrain height
// 2. BiomeMapStage        - Temperature/moisture for biomes
// 3. SurfaceCompoStage    - Place grass/dirt/stone layers
// 4. CaveCarverStage      - 3D noise-based cave systems
// 5. StructurePlaceStage  - Trees, ores, lakes
// 6. PopulationStage      - Surface decorations
// 7. LightingPrecompute   - Initial skylight flood fill
```

#### 3.3.2 Determinism Guarantees
- All noise functions seeded by `hash(world_seed, chunk_pos)`
- No cross-chunk reads during generation (use cached neighbor data)
- Floating-point operations do NOT affect block placement decisions (quantize first)

```rust
// world/src/generation/noise.rs
pub struct DeterministicNoise {
    seed: u64,
    noise: FastNoiseLite, // Seeded noise library
}

impl DeterministicNoise {
    pub fn sample_2d(&self, x: f32, z: f32) -> f32 {
        // Always returns same value for same (x, z) across runs
        self.noise.get_noise_2d(x, z)
    }
}
```

### 3.4 Lighting System

#### 3.4.1 Propagation Model
- **Dual Channels**: Skylight (0-15) and block light (0-15)
- **Propagation**: BFS with Manhattan distance attenuation (-1 per step)
- **Skylight Source**: Top of world (Y=255), floods downward
- **Block Light Sources**: Emissive blocks (e.g., torches emit 14)

#### 3.4.2 Update Algorithm
```rust
// world/src/lighting.rs
pub struct LightingEngine {
    add_queue: VecDeque<(IVec3, u8)>,  // (pos, light_level)
    remove_queue: VecDeque<(IVec3, u8)>,
}

impl LightingEngine {
    pub fn add_light_source(&mut self, world: &mut ChunkManager, pos: IVec3, level: u8) {
        // BFS propagation: enqueue neighbors with (level - 1)
        // Stop when neighbor light >= propagated light
    }

    pub fn remove_light_source(&mut self, world: &mut ChunkManager, pos: IVec3) {
        // Flood-fill removal: clear all dependent light values
        // Re-propagate from remaining sources found during flood
    }
}
```

#### 3.4.3 Cross-Chunk Handling
- Maintain border light queues for neighboring chunks
- When chunk unloads, persist border light states
- On chunk load, recompute light from borders inward

### 3.5 Meshing & Rendering

#### 3.5.1 Greedy Meshing Algorithm
```rust
// render/src/meshing.rs
pub struct ChunkMesh {
    pub opaque_vertices: Vec<Vertex>,
    pub opaque_indices: Vec<u32>,
    pub transparent_vertices: Vec<Vertex>,
    pub transparent_indices: Vec<u32>,
    pub hash: u64, // SHA-256 for deterministic testing
}

pub fn greedy_mesh(chunk: &Chunk) -> ChunkMesh {
    // For each axis (X, Y, Z):
    //   1. Create 2D slice perpendicular to axis
    //   2. Run greedy rect merge on visible faces
    //   3. Emit quads with per-vertex light (AO optional)
    // Separate passes: opaque, alpha-cutout, translucent
}
```

**Optimizations**:
- Only mesh exposed faces (check neighbor voxels)
- Merge coplanar quads into larger rectangles
- Pack vertex data: position (3×f32), UV (2×f16), light (2×u8), AO (4×u8)

#### 3.5.2 Renderer Architecture (wgpu)
```rust
// render/src/renderer.rs
pub struct VoxelRenderer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    pipelines: HashMap<MaterialId, wgpu::RenderPipeline>,
    texture_atlas: wgpu::Texture,
    camera_buffer: wgpu::Buffer,
    chunk_buffers: HashMap<IVec3, ChunkGpuBuffers>,
}

impl VoxelRenderer {
    pub fn render_frame(&mut self, world: &ChunkManager, camera: &Camera) {
        // 1. Frustum culling (skip out-of-view chunks)
        // 2. Sort transparent chunks back-to-front
        // 3. Bind atlas texture + camera UBO
        // 4. Draw opaque chunks (Z-test, no blend)
        // 5. Draw transparent chunks (Z-test, alpha blend)
        // 6. Post-processing (fog, tone mapping)
    }
}
```

#### 3.5.3 Headless Rendering (Testing)
```rust
// render/src/headless.rs
pub struct HeadlessRenderer {
    renderer: VoxelRenderer,
    offscreen_texture: wgpu::Texture,
}

impl HeadlessRenderer {
    pub fn render_snapshot(&mut self, camera: &Camera, world: &ChunkManager) -> SnapshotResult {
        // 1. Render to offscreen texture (no window)
        // 2. Read back pixel data
        // 3. Compute SHA-256 hash
        // 4. Optionally save PNG for debugging
        // 5. Return hash + timing metrics
    }
}
```

### 3.6 Physics & Collision

#### 3.6.1 Entity Physics Integration
```rust
// physics/src/integration.rs
pub fn integrate_velocity(
    query: Query<(&mut Transform, &mut Velocity, &Collider)>,
    world: &ChunkManager,
    dt: f32,
) {
    for (mut transform, mut velocity, collider) in query.iter_mut() {
        // Semi-implicit Euler
        let prev_pos = transform.position;
        let next_pos = prev_pos + velocity.0 * dt;

        // Resolve collisions (AABB vs voxel grid)
        let resolved_pos = resolve_collisions(prev_pos, next_pos, collider, world);
        transform.position = resolved_pos;

        // Apply friction/gravity
        if on_ground { velocity.0.x *= 0.8; velocity.0.z *= 0.8; }
        velocity.0.y -= GRAVITY * dt;
    }
}
```

#### 3.6.2 Collision Detection
```rust
// physics/src/collision.rs
pub fn resolve_collisions(
    prev: Vec3,
    next: Vec3,
    collider: &Collider,
    world: &ChunkManager,
) -> Vec3 {
    // 1. Compute AABB bounds [min, max] for capsule/box
    // 2. Query all solid voxels overlapping bounds
    // 3. Resolve Y-axis first (landing/head-bump)
    // 4. Resolve X-axis (wall collision)
    // 5. Resolve Z-axis (wall collision)
    // 6. Return adjusted position
}
```

#### 3.6.3 Raycasting (Block Targeting)
```rust
// physics/src/raycast.rs
pub fn raycast_voxel(
    origin: Vec3,
    direction: Vec3,
    max_distance: f32,
    world: &ChunkManager,
) -> Option<RaycastHit> {
    // DDA (Digital Differential Analyzer) voxel traversal
    // Returns: hit position, block ID, face normal
}
```

### 3.7 Networking

#### 3.7.1 Network Topology
- **Model**: Authoritative server, thin clients
- **Transport**: QUIC (via `quinn`) for reliability + encryption
- **Tick Rate**: Server runs at 20 TPS, sends state updates every tick
- **Client Prediction**: Clients predict movement, reconcile on server corrections

#### 3.7.2 Protocol Messages
```rust
// net/src/protocol.rs
#[derive(Serialize, Deserialize)]
pub enum ClientPacket {
    Join { username: String, protocol_version: u32 },
    Input { tick: u64, movement: Vec3, jump: bool, look: Vec2 },
    BlockPlace { pos: IVec3, block: BlockId },
    BlockBreak { pos: IVec3 },
    ChatMessage { text: String },
}

#[derive(Serialize, Deserialize)]
pub enum ServerPacket {
    JoinAccept { entity_id: Entity, spawn_pos: Vec3 },
    StateUpdate { tick: u64, entities: Vec<EntitySnapshot>, blocks: Vec<BlockUpdate> },
    ChunkData { pos: IVec3, compressed_data: Vec<u8> },
    Disconnect { reason: String },
}
```

#### 3.7.3 State Synchronization
```rust
// net/src/sync.rs
pub struct StateSynchronizer {
    pub tick: u64,
    pub entity_snapshots: HashMap<Entity, EntitySnapshot>,
    pub dirty_chunks: HashSet<IVec3>,
}

impl StateSynchronizer {
    pub fn send_updates(&mut self, clients: &mut ClientRegistry) {
        // 1. For each connected client:
        //    - Compute visible chunks (load radius)
        //    - Send full chunk data for newly visible chunks
        //    - Send delta updates for dirty chunks in view
        // 2. For entities in client's view distance:
        //    - Send transform + component deltas (compressed)
        // 3. Compress with zstd, send via QUIC
    }
}
```

#### 3.7.4 Client Prediction & Reconciliation
```rust
// client/src/prediction.rs
pub struct PredictionEngine {
    pub pending_inputs: VecDeque<InputFrame>,
    pub last_acked_tick: u64,
}

impl PredictionEngine {
    pub fn predict_movement(&mut self, local_player: &mut Transform, dt: f32) {
        // Apply local input immediately (no latency)
        // Store input in buffer for reconciliation
    }

    pub fn reconcile(&mut self, server_state: EntitySnapshot) {
        // 1. Find matching server tick in pending inputs
        // 2. If position diverges > threshold:
        //    - Snap to server position
        //    - Replay all inputs since server tick
        // 3. Discard acked inputs
    }
}
```

### 3.8 Persistence

#### 3.8.1 Region File Format
```rust
// world/src/persistence.rs
pub struct RegionFile {
    path: PathBuf,
    chunks: HashMap<(u8, u8), ChunkRecord>, // Local chunk coords within region
}

pub struct ChunkRecord {
    offset: u64,       // Byte offset in file
    length: u32,       // Compressed size
    crc32: u32,        // Integrity check
    version: u8,       // Schema version
    data: Vec<u8>,     // zstd-compressed chunk data
}
```

**File Layout**:
```
[Header: 4096 bytes]
  - Magic bytes: "RGVX"
  - Version: u8
  - Chunk index: [(x, y) -> (offset, length, crc32)] for 32×32 chunks
[Chunk Data]
  - Variable-length zstd-compressed chunk records
```

#### 3.8.2 Player Data
```rust
// world/src/persistence.rs
#[derive(Serialize, Deserialize)]
pub struct PlayerData {
    pub uuid: Uuid,
    pub username: String,
    pub position: Vec3,
    pub rotation: Vec2,
    pub health: f32,
    pub inventory: Inventory,
    pub game_mode: GameMode,
}
```
Saved as `players/{uuid}.json` (or msgpack for binary).

---

## 4. Testing Infrastructure

### 4.1 Event Stream Architecture

#### 4.1.1 Event Bus Design
```rust
// testkit/src/events.rs
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "kind")]
pub enum GameEvent {
    TickStart { tick: u64 },
    TickEnd { tick: u64, duration_us: u64 },
    BlockPlaced { tick: u64, pos: [i32; 3], by: Entity, block: String, state: u16 },
    BlockBroken { tick: u64, pos: [i32; 3], by: Entity },
    ChunkGenerated { tick: u64, chunk: [i32; 3], generation_time_ms: f32 },
    ChunkMeshed { tick: u64, chunk: [i32; 3], triangles: u32, mesh_sha: String },
    LightingUpdated { tick: u64, region: [i32; 2], updates: u32 },
    EntitySpawned { tick: u64, entity: Entity, archetype: String, pos: [f32; 3] },
    EntityMoved { tick: u64, entity: Entity, from: [f32; 3], to: [f32; 3] },
    SnapshotSaved { tick: u64, camera: String, image_sha: String, width: u32, height: u32 },
    Warning { tick: u64, message: String },
    Error { tick: u64, message: String },
}

pub trait EventSink: Send + Sync {
    fn on_event(&self, event: &GameEvent);
}
```

#### 4.1.2 Event Recording
```rust
// testkit/src/recorder.rs
pub struct JsonlRecorder {
    file: BufWriter<File>,
}

impl EventSink for JsonlRecorder {
    fn on_event(&self, event: &GameEvent) {
        // Write each event as newline-delimited JSON
        serde_json::to_writer(&mut self.file, event).unwrap();
        self.file.write_all(b"\n").unwrap();
    }
}
```

### 4.2 World Test DSL

#### 4.2.1 Scenario Format
```toml
# scenarios/torch_lighting.worldtest.toml
[world]
seed = 12345
spawn = [0, 65, 0]
time_of_day = "noon"
flat = true

[[blocks.fill]]
from = [-5, 64, -5]
to = [5, 64, 5]
block = "stone"

[[script]]
tick = 1
action = { place = { at = [0, 65, 1], block = "torch" } }

[[expect]]
by_tick = 3
light = { at = [0, 65, 1], sky = 0, block = { gte = 14 } }

[[expect]]
by_tick = 2
event = "BlockPlaced"
count = 1

[[camera]]
name = "overview"
pos = [3.5, 69.0, -4.0]
look = [0.0, -0.4, 0.8]
fov = 70

[[expect]]
by_tick = 5
snapshot = { camera = "overview", sha = "6a49c7..." }
```

#### 4.2.2 DSL Parser & Runner
```rust
// testkit/src/worldtest.rs
#[derive(Deserialize)]
pub struct WorldTest {
    pub world: WorldConfig,
    pub blocks: Option<BlockSetup>,
    pub script: Vec<ScriptAction>,
    pub expect: Vec<Expectation>,
    pub camera: Vec<CameraSpec>,
}

pub fn run_worldtest(test_path: &Path) -> TestResult {
    let test: WorldTest = toml::from_str(&fs::read_to_string(test_path)?)?;

    // 1. Initialize world with config
    let mut server = Server::new_headless(test.world);

    // 2. Apply block setup (fills, placements)
    apply_block_setup(&mut server, test.blocks);

    // 3. Run simulation with scripted actions
    let events = server.run_scripted(test.script, MAX_TICKS);

    // 4. Validate expectations
    validate_expectations(&events, test.expect)?;

    // 5. Capture render snapshots if cameras defined
    if !test.camera.is_empty() {
        let snapshots = render_snapshots(&server, test.camera);
        validate_snapshots(&snapshots, test.expect)?;
    }

    Ok(TestResult::Pass)
}
```

### 4.3 Headless Snapshot Testing

#### 4.3.1 Deterministic Rendering Setup
```rust
// testkit/src/snapshot.rs
pub struct SnapshotTester {
    renderer: HeadlessRenderer,
    golden_dir: PathBuf,
}

impl SnapshotTester {
    pub fn capture_and_compare(&mut self, spec: &CameraSpec, world: &ChunkManager) -> Result<()> {
        // 1. Render scene with fixed camera
        let snapshot = self.renderer.render_snapshot(&spec.camera, world);

        // 2. Compute SHA-256 of pixel data
        let hash = compute_sha256(&snapshot.pixels);

        // 3. Load golden hash from file
        let golden_path = self.golden_dir.join(format!("{}.sha256", spec.name));
        let golden_hash = fs::read_to_string(golden_path)?;

        // 4. Compare hashes
        if hash != golden_hash {
            // Save diff image for debugging
            save_snapshot_png(&snapshot, format!("{}_actual.png", spec.name));
            return Err(SnapshotMismatch { expected: golden_hash, actual: hash });
        }

        Ok(())
    }
}
```

#### 4.3.2 Golden Management
```
goldens/
├── linux_vulkan/
│   ├── torch_lighting_overview.sha256
│   └── biome_boundary.sha256
├── windows_dx12/
│   ├── torch_lighting_overview.sha256
│   └── biome_boundary.sha256
└── macos_metal/
    ├── torch_lighting_overview.sha256
    └── biome_boundary.sha256
```

**Golden Update Process**:
```bash
# When rendering changes are intentional:
cargo run -p cli -- worldtest --update-goldens scenarios/*.worldtest.toml
```

### 4.4 Property-Based Testing

```rust
// world/src/lighting/tests.rs
use proptest::prelude::*;

proptest! {
    #[test]
    fn light_propagation_is_monotonic(
        source_pos in (0i32..16, 0i32..256, 0i32..16),
        probe_pos in (0i32..16, 0i32..256, 0i32..16),
    ) {
        let mut chunk = Chunk::new(IVec3::ZERO);
        add_light_source(&mut chunk, source_pos, 15);

        let source_light = chunk.get_light(source_pos);
        let probe_light = chunk.get_light(probe_pos);

        let manhattan = (source_pos - probe_pos).abs().sum();
        prop_assert!(probe_light <= source_light.saturating_sub(manhattan as u8));
    }
}
```

### 4.5 Replay System

```rust
// testkit/src/replay.rs
pub struct ReplayEngine {
    input_log: Vec<InputFrame>,
    expected_events: Vec<GameEvent>,
}

impl ReplayEngine {
    pub fn replay_and_verify(&self) -> Result<()> {
        let mut server = Server::new_deterministic(self.world_seed);
        let mut recorder = InMemoryRecorder::new();
        server.attach_sink(Box::new(recorder.clone()));

        // Feed recorded inputs
        for input in &self.input_log {
            server.apply_input(input);
        }

        // Compare event streams
        let actual_events = recorder.events();
        diff_event_streams(&self.expected_events, &actual_events)?;

        Ok(())
    }
}
```

---

## 5. Data-Driven Configuration

### 5.1 Block Registry (TOML)

```toml
# assets/blocks.toml
[[block]]
name = "stone"
id = 1
opaque = true
collidable = true
solid = true
render_model = "cube"
hardness = 1.5
tool = "pickaxe"
light_attenuation = 15

[[block]]
name = "torch"
id = 50
opaque = false
collidable = false
solid = false
render_model = "sprite"
light_emission = 14
flammable = true

[[block]]
name = "water"
id = 8
opaque = false
collidable = false
solid = false
transparent = true
fluid_like = true
light_attenuation = 2
render_model = "fluid"
```

### 5.2 Crafting Recipes (JSON)

```json
{
  "recipes": [
    {
      "type": "shaped",
      "pattern": ["SS", "SS"],
      "key": { "S": "stone" },
      "result": { "item": "stone_bricks", "count": 4 }
    },
    {
      "type": "shapeless",
      "ingredients": ["wood"],
      "result": { "item": "planks", "count": 4 }
    }
  ]
}
```

### 5.3 Asset Validation

```rust
// assets/src/validation.rs
pub fn validate_block_registry(path: &Path) -> Result<BlockRegistry> {
    let config: BlockConfig = toml::from_str(&fs::read_to_string(path)?)?;

    // Checks:
    // - No duplicate IDs
    // - All render models exist
    // - Opaque blocks have light_attenuation = 15
    // - Emissive blocks have light_emission > 0
    // - Tool references are valid

    Ok(BlockRegistry::from_config(config))
}
```

---

## 6. Performance Targets & Optimization

### 6.1 Performance Budget

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Sim Tick Time** | ≤ 2.5 ms | Per-tick profiling (20 TPS = 50 ms budget) |
| **Frame Time (P95)** | ≤ 16.6 ms | Frame timing (60 FPS target) |
| **Chunk Gen Time** | ≤ 8 ms | Generation pipeline timer |
| **Mesh Build Time** | ≤ 5 ms | Greedy meshing profiler |
| **Memory (9×9 chunks)** | < 1.5 GB | RSS measurement |
| **World Save Rate** | ≤ 100 MB/hr | Disk I/O monitoring |

### 6.2 Optimization Strategies

#### 6.2.1 ECS Parallelism
```rust
// Leverage bevy_ecs parallel queries
pub fn parallel_chunk_generation(
    mut chunks: Query<&mut Chunk, With<NeedsGeneration>>,
) {
    chunks.par_iter_mut().for_each(|mut chunk| {
        generate_terrain(&mut chunk);
    });
}
```

#### 6.2.2 Chunk Loading Strategy
- **Spiral Pattern**: Load chunks in expanding spiral from player
- **Priority Queue**: Sort by (distance, last_accessed_time)
- **Unload Threshold**: Unload chunks > (load_radius + 2)

#### 6.2.3 Meshing Optimization
- **Dirty Flagging**: Only remesh chunks with block changes or lighting updates
- **Mesh Caching**: Store mesh buffers in GPU memory, rebuild only when dirty
- **Occlusion Culling**: Use depth pre-pass to skip hidden chunks

#### 6.2.4 Network Optimization
- **Delta Compression**: Send only changed entity components
- **Chunk Compression**: zstd level 3 (balance speed/size)
- **Bandwidth Throttling**: Limit chunk data to 1 MB/sec per client

---

## 7. Security & Stability

### 7.1 Input Validation
```rust
// net/src/validation.rs
pub fn validate_client_input(input: &ClientPacket) -> Result<()> {
    match input {
        ClientPacket::BlockPlace { pos, block } => {
            // Check block ID is valid
            if !BLOCK_REGISTRY.contains(*block) {
                return Err(ValidationError::InvalidBlockId);
            }
            // Check position is within reasonable range (not too far from player)
            if pos.length() > MAX_INTERACTION_DISTANCE {
                return Err(ValidationError::PositionOutOfRange);
            }
        },
        ClientPacket::Input { movement, .. } => {
            // Clamp movement vector magnitude
            if movement.length() > MAX_MOVEMENT_SPEED * 1.1 {
                return Err(ValidationError::SpeedHack);
            }
        },
        _ => {}
    }
    Ok(())
}
```

### 7.2 Resource Limits
- **Max Chunks Per Client**: 25×25 (625 chunks)
- **Max Packet Size**: 64 KB
- **Connection Timeout**: 30 seconds idle
- **Max Entities Per Chunk**: 256

### 7.3 Save Format Integrity
```rust
// world/src/persistence.rs
pub fn save_chunk(chunk: &Chunk, path: &Path) -> Result<()> {
    let data = bincode::serialize(chunk)?;
    let compressed = zstd::encode_all(&data[..], 3)?;
    let crc = crc32fast::hash(&compressed);

    let record = ChunkRecord {
        version: CURRENT_VERSION,
        crc32: crc,
        data: compressed,
    };

    fs::write(path, bincode::serialize(&record)?)?;
    Ok(())
}

pub fn load_chunk(path: &Path) -> Result<Chunk> {
    let record: ChunkRecord = bincode::deserialize(&fs::read(path)?)?;

    // Verify CRC
    if crc32fast::hash(&record.data) != record.crc32 {
        return Err(LoadError::CorruptedData);
    }

    // Check version compatibility
    if record.version > CURRENT_VERSION {
        return Err(LoadError::IncompatibleVersion);
    }

    let data = zstd::decode_all(&record.data[..])?;
    Ok(bincode::deserialize(&data)?)
}
```

---

## 8. Modding Architecture (Post-MVP)

### 8.1 WASM Module Interface

```rust
// scripting/src/api.rs
#[wasm_bindgen]
pub struct ModContext {
    world: *mut ChunkManager,
    registry: *mut BlockRegistry,
}

#[wasm_bindgen]
impl ModContext {
    pub fn register_block(&mut self, name: String, props: BlockProperties) -> Result<BlockId> {
        // Add custom block to registry
        // Validate properties, assign ID, notify clients
    }

    pub fn on_block_tick(&self, pos: IVec3) {
        // Called every tick for custom block logic (e.g., crop growth)
    }

    pub fn spawn_structure(&self, origin: IVec3, schematic: StructureData) {
        // Place multi-block structure in world
    }
}
```

### 8.2 Safety & Sandboxing
```rust
// scripting/src/runtime.rs
pub struct WasmRuntime {
    engine: wasmtime::Engine,
    store: wasmtime::Store<ModContext>,
}

impl WasmRuntime {
    pub fn execute_tick_hook(&mut self, module: &Module) -> Result<()> {
        // Fuel system: 10ms CPU budget
        self.store.add_fuel(10_000_000)?;

        let tick_fn = module.get_func(&mut self.store, "on_tick")?;
        tick_fn.call(&mut self.store, &[])?;

        // Check fuel remaining
        let remaining = self.store.consume_fuel(0)?;
        if remaining == 0 {
            warn!("Mod exceeded CPU budget");
        }

        Ok(())
    }
}
```

---

## 9. Migration from V1 Prototype

### 9.1 Feature Parity Checklist

| V1 Feature (JS/Three.js) | V2 Implementation (Rust) | Status |
|--------------------------|--------------------------|--------|
| Simplex noise terrain | `world::generation` + fastnoise_lite | ✅ Planned |
| Canvas-generated textures | Pre-baked texture atlas (PNG) | ✅ Planned |
| Instanced rendering | wgpu instanced draw calls | ✅ Planned |
| Greedy meshing | `render::meshing::greedy_mesh()` | ✅ Planned |
| WASD + mouse controls | `client::input` + PointerLock | ✅ Planned |
| Collision (capsule) | `physics::collision::resolve_collisions()` | ✅ Planned |
| Block place/break | Server-authoritative via `net::protocol` | ✅ Planned |
| Undo/redo | Event sourcing via testkit | ⚠️ Post-MVP |
| Day/night cycle | `render::sky::update_daylight()` | ✅ Planned |
| Fly mode toggle | Client-side movement override | ✅ Planned |

### 9.2 Data Migration
No migration needed (V1 is prototype; V2 starts fresh with proper save format).

---

## 10. Development Milestones

### 10.1 Milestone A: Engine Core (4-6 weeks)
**Goal**: Render static world with player movement

**Deliverables**:
- ✅ Workspace setup + crate structure
- ✅ Block registry + chunk storage
- ✅ Basic terrain generation (superflat + noise)
- ✅ Greedy meshing + wgpu renderer
- ✅ Camera + WASD controls
- ✅ AABB collision detection
- ✅ Event bus + JSONL recorder

**Acceptance Test**: `superflat_basics.worldtest.toml` passes
- Player can walk on flat terrain
- 60 FPS in 9×9 chunk area
- No events with `kind: "Error"`

### 10.2 Milestone B: Lighting & Persistence (3-4 weeks)
**Goal**: Dynamic lighting + save/load

**Deliverables**:
- ✅ Skylight + block light propagation
- ✅ Emissive blocks (torches)
- ✅ Light update on block place/break
- ✅ Region file save/load (zstd)
- ✅ Player data persistence
- ✅ Inventory + crafting basics

**Acceptance Test**: `torch_lighting.worldtest.toml` passes
- Placing torch updates light within 2 ticks
- Removing torch removes light within 2 ticks
- Save/reload preserves world exactly (binary diff)

### 10.3 Milestone C: Networking (4-5 weeks)
**Goal**: Multiplayer over LAN

**Deliverables**:
- ✅ QUIC server (quinn)
- ✅ Client-server handshake + authentication
- ✅ State synchronization (entity transforms, block updates)
- ✅ Client prediction + reconciliation
- ✅ Chunk streaming (spatial interest management)

**Acceptance Test**: `multiplayer_tower.worldtest.toml` passes
- Two clients join server
- Both clients build a tower collaboratively
- Event streams match server's authoritative log
- No desync under 100 ms RTT

### 10.4 Milestone D: Biomes & Structures (3-4 weeks)
**Goal**: Rich terrain with trees, caves, ores

**Deliverables**:
- ✅ Multi-biome noise-based generation
- ✅ Cave carving (3D noise)
- ✅ Tree placement (procedural)
- ✅ Ore veins
- ✅ Weather toggle (rain particles)
- ✅ Render snapshot goldens locked

**Acceptance Test**: `biome_boundary.worldtest.toml` passes
- No seams at biome borders
- Mesh hashes stable across runs
- Snapshot SHA matches golden

---

## 11. Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| **Cross-platform render variance** | Snapshot tests fail on different GPUs | High | Per-backend goldens; disable temporal effects; use integer vertex coords |
| **Determinism drift** | Replays diverge over time | Medium | Unit tests for replay round-trips; seed auditing; ban `std::time::Instant` in sim |
| **ECS performance bottleneck** | Frame drops in dense entity areas | Medium | Profile with `tracy`; optimize system ordering; use sparse sets for rare components |
| **WASM modding complexity** | High development cost for limited gain | Low | Mark as post-MVP; focus on data-driven blocks first |
| **Save format compatibility** | Old saves break on updates | High | Semantic versioning + migration hooks; CRC checks |
| **CI GPU availability** | Snapshot tests can't run | Medium | Use wgpu software adapter (SwiftShader); cache goldens; allow manual golden updates |

---

## 12. Open Questions & Future Work

### 12.1 Open Design Questions
1. **Lighting Storage**: Pack both light channels into single `u8` (4 bits each) or separate?
   - **Recommendation**: Separate `u8` for simplicity; optimize later if memory-bound

2. **Chunk Height**: Fixed 256 or configurable?
   - **Recommendation**: Compile-time constant with feature flags (`height_512`, `height_256`)

3. **Entity Interpolation**: Lerp between ticks or use Hermite curves?
   - **Recommendation**: Linear interpolation for MVP; cubic for smoother post-MVP

4. **UI Framework**: egui (immediate mode) or custom?
   - **Recommendation**: egui for MVP (fast prototyping); custom later if needed

### 12.2 Post-MVP Features
- **Redstone-like Circuits**: Event-driven wire propagation
- **Advanced Mobs**: Pathfinding (A*), behavior trees
- **Spline Camera Tool**: For cinematic snapshots
- **Replay Viewer UI**: Seek by tick, overlay events
- **Shader Mods**: Expose wgpu pipeline customization
- **Dedicated Test Console**: Run `.worldtest` files in-game

---

## 13. Appendices

### 13.1 Glossary
- **ECS**: Entity-Component-System architecture
- **TPS**: Ticks Per Second (simulation rate)
- **BFS**: Breadth-First Search (lighting algorithm)
- **DDA**: Digital Differential Analyzer (raycasting)
- **QUIC**: Quick UDP Internet Connections (transport protocol)
- **WASM**: WebAssembly (modding runtime)

### 13.2 References
- bevy_ecs: https://docs.rs/bevy_ecs
- wgpu: https://docs.rs/wgpu
- quinn: https://docs.rs/quinn
- fastnoise_lite: https://github.com/Auburn/FastNoiseLite
- Greedy Meshing: https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/

### 13.3 Success Criteria Summary
✅ **Functionality**: All milestone acceptance tests pass
✅ **Performance**: Meets all performance budgets (see §6.1)
✅ **Testability**: 100% event coverage, golden snapshots stable
✅ **Maintainability**: <1000 lines per crate (except `world`), full rustdoc
✅ **Moddability**: Data packs load/validate without code changes

---

**Document Status**: Draft for Implementation
**Next Steps**:
1. Review with stakeholders
2. Create GitHub project with milestone tracking
3. Begin Milestone A implementation
4. Set up CI pipeline with headless runners

---

*End of High-Level Design Document*
