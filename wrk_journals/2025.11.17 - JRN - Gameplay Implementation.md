# Development Journal: Complete Gameplay Implementation

**Date:** 2025-11-17
**Session:** Gameplay Features - Tools, Caves, Survival, UI
**Goal:** Implement comprehensive gameplay systems to make mdminecraft playable

---

## Multi-Stage Implementation Plan

### Overview
Implementing four major feature sets:
- **Stage 1:** Tools & Mining System (D)
- **Stage 2:** Cave Generation (C)
- **Stage 3:** Survival Mechanics (B)
- **Stage 4:** 3D UI Integration (A)

**Estimated Total Time:** 12-16 hours of implementation
**Target:** Get as far as possible in this session

---

## Stage 1: Tools & Mining System üî®

### Goals
- Tool types: Pickaxe, Axe, Shovel, Sword
- Material tiers: Wood ‚Üí Stone ‚Üí Iron ‚Üí Diamond
- Block hardness and mining speed
- Durability system
- Tool crafting recipes

### Implementation Steps

#### 1.1 Tool Data Structures
```rust
// crates/core/src/item.rs
pub enum ItemType {
    Tool(ToolType, ToolMaterial),
    Block(BlockId),
    // ... other types
}

pub enum ToolType {
    Pickaxe,
    Axe,
    Shovel,
    Sword,
}

pub enum ToolMaterial {
    Wood,
    Stone,
    Iron,
    Diamond,
}

pub struct Tool {
    tool_type: ToolType,
    material: ToolMaterial,
    durability: u32,
    max_durability: u32,
}
```

#### 1.2 Block Properties
```rust
// crates/world/src/block_properties.rs
pub struct BlockProperties {
    pub hardness: f32,
    pub best_tool: Option<ToolType>,
    pub required_tier: ToolMaterial,
    pub drops: Vec<(ItemType, u32)>,
}
```

#### 1.3 Mining Speed Calculation
- Base breaking time based on hardness
- Tool effectiveness multiplier
- Tier bonuses
- No tool penalty

#### 1.4 Tool Crafting
- Add crafting recipes for all tool tiers
- Stick recipes
- Tool bench (optional)

**Time Estimate:** 2-3 hours

---

## Stage 2: Cave Generation üï≥Ô∏è

### Goals
- 3D Perlin noise cave systems
- Natural cave formations
- Cave biomes (lush, dripstone, deep dark)
- Integration with terrain generation
- Exposed ore veins in caves

### Implementation Steps

#### 2.1 Cave Noise Generator
```rust
// crates/world/src/caves.rs
pub struct CaveGenerator {
    noise: PerlinNoise,
    threshold: f32,
}

impl CaveGenerator {
    pub fn is_cave(&self, x: i32, y: i32, z: i32) -> bool {
        let noise_value = self.sample_3d(x, y, z);
        noise_value > self.threshold
    }
}
```

#### 2.2 Integration with Terrain
- Modify chunk generation to carve caves
- Preserve surface terrain
- Cave entrances at mountains/hills
- Cave floor generation (stone, gravel)

#### 2.3 Cave Features
- Underground lakes (water at y < 50)
- Ore veins exposed in cave walls
- Stalactites/stalagmites (optional)
- Cave lighting (darkness by default)

#### 2.4 Performance
- Optimize 3D noise sampling
- Cache cave data per chunk
- LOD for distant caves

**Time Estimate:** 3-4 hours

---

## Stage 3: Survival Mechanics ‚ù§Ô∏è

### Goals
- Health system (20 hearts = 20.0 HP)
- Damage sources (fall, mobs, lava)
- Death and respawn
- Basic hostile mob (Zombie)
- Mob AI (pathfinding, attack)
- Food system (basic)

### Implementation Steps

#### 3.1 Health System
```rust
// crates/core/src/player.rs
pub struct PlayerHealth {
    pub current: f32,
    pub max: f32,
    pub regeneration_rate: f32,
}

pub enum DamageSource {
    Fall(f32),
    Mob(MobType),
    Lava,
    Fire,
    Drowning,
}
```

#### 3.2 Fall Damage
- Track player vertical velocity
- Calculate damage on landing: `max(0, (fall_distance - 3.0) * 2.0)`
- Apply to health

#### 3.3 Hostile Mobs
```rust
// crates/world/src/mob.rs
pub enum MobType {
    // Passive (existing)
    Pig, Cow, Sheep, Chicken,
    // Hostile (new)
    Zombie, Skeleton, Spider, Creeper,
}

pub struct HostileMob {
    pub mob_type: MobType,
    pub target: Option<EntityId>,
    pub attack_damage: f32,
    pub attack_cooldown: f32,
}
```

#### 3.4 Mob AI
- Simple pathfinding (move towards player)
- Attack when in range (1.5 blocks)
- Damage cooldown (0.5 seconds)
- Spawning rules (darkness, surface)

#### 3.5 Death & Respawn
- Death screen overlay
- Respawn button
- Reset health
- Teleport to spawn point
- Drop inventory (optional)

#### 3.6 Food System (Basic)
```rust
pub struct Food {
    pub hunger_restored: f32,
    pub saturation: f32,
}
```
- Hunger bar (20 points)
- Food items (bread, meat, apple)
- Eating mechanics
- Hunger damage (when at 0)

**Time Estimate:** 4-5 hours

---

## Stage 4: 3D UI Integration üé®

### Goals
- Floating spawn point label
- Coordinate display in 3D
- Health bar in 3D space
- Block information labels
- Mob nameplates

### Implementation Steps

#### 4.1 UI Manager
```rust
// src/game.rs
pub struct UIManager {
    text_renderer: TextRenderer,
    labels: Vec<Label3D>,
    font_atlas: FontAtlas,
}
```

#### 4.2 Spawn Point Indicator
- Floating "Spawn Point" label at world origin
- Green color, large text
- Visible from distance
- Distance fade (50-100 blocks)

#### 4.3 Coordinate Display
- Show X, Y, Z coordinates
- Update in real-time
- Position: top-left of screen in 3D
- Small, unobtrusive font

#### 4.4 Health Bar
- 3D heart icons
- Positioned relative to player view
- Updates with damage/healing
- Red color when low health

#### 4.5 Block Info
- When looking at block, show name
- Distance display
- Hardness indicator

**Time Estimate:** 2-3 hours

---

## Implementation Order & Priorities

### Session 1 (Current)
1. ‚úÖ Create implementation plan
2. ‚è≥ Stage 1: Tools & Mining (most foundational)
3. ‚è≥ Stage 2: Cave Generation (makes world interesting)
4. ‚è≥ Stage 3: Survival Mechanics (adds challenge)
5. ‚è≥ Stage 4: 3D UI Integration (polish)

### Success Metrics
- **Minimum Viable:** Tools working, can mine blocks
- **Good:** Caves generating, ores distributed
- **Great:** Health system, hostile mobs, combat
- **Excellent:** Full 3D UI integration

---

## Technical Approach

### New Crates/Modules
- `crates/core/src/item.rs` - Item system
- `crates/core/src/tool.rs` - Tool mechanics
- `crates/world/src/caves.rs` - Cave generation
- `crates/world/src/block_properties.rs` - Block data
- `crates/gameplay/` - New crate for game logic (health, combat, etc.)

### Integration Points
- Modify `GameWorld` to include health, inventory
- Extend chunk generation with caves
- Add mob spawning logic
- Integrate 3D UI rendering

---

## Work Log

### [16:00] Session Start
- Created comprehensive multi-stage plan
- Identified dependencies between systems
- Estimated ~12-16 hours total work
- Starting with Stage 1: Tools & Mining

### [16:15] Beginning Stage 1 Implementation
- Creating item and tool systems...

### [16:30] Stage 1.1 - Item System Complete ‚úÖ
**Created:** `crates/core/src/item.rs` (220 lines)

Implemented comprehensive item system:
- `ItemType` enum: Tool, Block, Food, Item
- `ToolType` enum: Pickaxe, Axe, Shovel, Sword, Hoe
- `ToolMaterial` enum: Wood (0), Stone (1), Iron (2), Diamond (3), Gold (4)
  - Gold has tier 0 mining power (like Wood) but 12x speed multiplier
  - Special `can_mine_tier()` logic to handle Gold's unique properties
- `ItemStack` struct with durability tracking
  - `damage_durability()` - reduce tool durability
  - `is_broken()` - check if tool is broken
  - `max_durability()` - get max durability
- Material-specific durability values (Wood: 59, Diamond: 1561)
- Speed multipliers per material (Wood: 2x, Diamond: 8x, Gold: 12x)

**Tests:** Full test coverage for tool tiers, durability, and item stacks

### [16:45] Stage 1.2 - Block Properties Complete ‚úÖ
**Created:** `crates/world/src/block_properties.rs` (286 lines)

Implemented block mining mechanics:
- `BlockProperties` struct with:
  - `hardness` - mining time modifier
  - `best_tool` - optimal tool type
  - `required_tier` - minimum material tier to harvest
  - `instant_break` - for air/flowers
  - `is_solid` - collision flag
- Factory methods for common blocks:
  - `air()` - instant break, not solid
  - `dirt()` - 0.5 hardness, shovel
  - `stone()` - 1.5 hardness, pickaxe, requires Wood tier
  - `wood()` - 2.0 hardness, axe
  - `iron_ore()` - 3.0 hardness, requires Stone tier
  - `diamond_ore()` - 3.0 hardness, requires Iron tier
- `calculate_mining_time()` - Complex calculation:
  - Base time from hardness (√ó1.5)
  - Tool effectiveness multiplier
  - Harvest penalty (5x slower if wrong tier)
  - Water penalty (5x slower when underwater)
- `can_harvest()` - Check if tool tier is sufficient
- `BlockPropertiesRegistry` with defaults for IDs 0-12

**Tests:** Mining time calculations, harvest requirements, registry

### [17:00] Stage 1.3 - Game Integration Complete ‚úÖ
**Modified:** `src/game.rs` (~200 lines changed)

Integrated mining system into main game:
1. **Hotbar System Redesign:**
   - Changed from `[BlockId; 9]` to `[Option<ItemStack>; 9]`
   - Default inventory: Wood/Stone/Iron pickaxes, shovels, blocks
   - `selected_tool()` - Get current tool for mining
   - `selected_block()` - Get block for placement
   - `item_name()` - Display item names (e.g., "Iron Pickaxe")

2. **Mining Progress Tracking:**
   - New `MiningProgress` struct tracks:
     - `block_pos` - which block is being mined
     - `time_mining` - time spent mining
     - `time_required` - total time needed
   - Reset when looking away or releasing mouse
   - Visual progress bar in debug HUD

3. **Mining Mechanics:**
   - `handle_mining()` - Progressive mining system:
     - Calculate required time based on block + tool
     - Track progress over time
     - Break block when 100% complete
     - Check harvest requirements
     - Damage tool durability
     - Remove broken tools
   - Tool durability damage on each block mined
   - Proper tool tier checking

4. **Block Placement:**
   - `handle_block_placement()` - Separate method
   - Decrease block count from stack
   - Remove empty stacks

5. **UI Updates:**
   - Hotbar shows tool durability (% with color coding)
   - Hotbar shows block counts (x64)
   - Mining progress in debug HUD (F3)
   - Tool names displayed on selection

**Added:** `BlockPropertiesRegistry` to `GameWorld`

### [17:15] Debug HUD Enhancement ‚úÖ
**Modified:** `crates/render/src/ui.rs`

Added mining progress visualization:
- `mining_progress: Option<f32>` field
- Progress bar widget (0-100%)
- Percentage display
- Only shown when actively mining

### [17:20] Build Success ‚úÖ

Fixed compilation errors:
1. Duplicate discriminant for Gold (was 0, now 4)
2. Added missing `damage_durability()`, `is_broken()`, `max_durability()` methods
3. Exported `BlockPropertiesRegistry` from world crate

**Build Result:** Success with only unused variable warnings

### Stage 1 Status: COMPLETE ‚úÖ

**Implemented:**
- ‚úÖ Item and tool type system
- ‚úÖ Tool material tiers with proper ordering
- ‚úÖ Block properties with hardness
- ‚úÖ Mining speed calculation
- ‚úÖ Tool durability system
- ‚úÖ Progressive mining with visual feedback
- ‚úÖ Harvest tier requirements
- ‚úÖ Tool effectiveness multipliers

**Not Yet Implemented:**
- ‚è≥ Tool crafting recipes (deferred - not critical)
- ‚è≥ Item drops from mined blocks (deferred)

**Time Spent:** ~1 hour
**Estimated:** 2-3 hours (came in under budget!)

---

---

## Stage 2: Cave Generation üï≥Ô∏è

### [17:25] Beginning Stage 2 Implementation

Starting 3D cave system implementation...

### [17:40] Stage 2.1 - Cave Generator Complete ‚úÖ
**Created:** `crates/world/src/caves.rs` (155 lines)

Implemented 3D cave generation system:
- `CaveGenerator` using 3D Perlin noise
- Dual noise layers:
  - **Cave noise**: Large caverns (frequency 0.02, 3 octaves)
  - **Tunnel noise**: Smaller passages (frequency 0.05, 4 octaves)
- Thresholds for cave formation (0.6 for caverns, 0.7 for tunnels)
- Altitude-based density reduction (fewer caves near surface)
- `is_cave()` - Determines if position should be carved
- `cave_density()` - Returns 0-1 density for smooth transitions
- `should_have_water()` - Underground lakes below y=40
- Y-range limiting: No caves above y=120 or below y=10

**Configuration:**
- Cavern scale: 0.02 (50-block features)
- Tunnel scale: 0.05 (20-block features)
- Multi-octave sampling for organic shapes
- Deterministic (seeded from world_seed)

**Tests:** Cave generation, density calculation, water levels

### [17:50] Stage 2.2 - Terrain Integration Complete ‚úÖ
**Modified:** `crates/world/src/terrain.rs` (~50 lines changed)

Integrated cave carving into terrain generation:
1. **TerrainGenerator Updates:**
   - Added `cave_generator: CaveGenerator` field
   - Initialize with world seed
   - New `carve_caves()` method

2. **Cave Carving Algorithm:**
   - Runs after terrain generation, before trees
   - Iterates through all chunk blocks (16√ó256√ó16 = 65,536 positions)
   - Calculates world coordinates for each position
   - Checks `is_cave()` for each block
   - Carves air through solid blocks
   - Fills caves below y=40 with water (underground lakes)
   - Preserves existing air and water

3. **Generation Order:**
   1. Heightmap-based terrain
   2. Bedrock layer
   3. Stone layer
   4. Surface blocks (grass/dirt/sand)
   5. **Cave carving** ‚Üê NEW
   6. Tree population

**Performance:** ~65k cave checks per chunk, O(n¬≥) but parallelizable

### [18:00] Dependencies & Build ‚úÖ
**Modified:** `crates/world/Cargo.toml`

- Added `rand = { workspace = true }` for RNG seeding
- Build successful with 0 errors

### Stage 2 Status: COMPLETE ‚úÖ

**Implemented:**
- ‚úÖ 3D Perlin noise cave generator
- ‚úÖ Dual-layer cave system (caverns + tunnels)
- ‚úÖ Altitude-based cave density
- ‚úÖ Underground water lakes
- ‚úÖ Integration with terrain generation
- ‚úÖ Cave carving algorithm
- ‚úÖ Deterministic cave generation

**Features:**
- Organic, naturalistic cave shapes
- Multiple cave scales (large caverns + small tunnels)
- Water-filled caves below y=40
- No caves near surface (y > 120)
- Proper integration with existing terrain

**Not Implemented:**
- ‚è≥ Ore veins exposed in cave walls (deferred)
- ‚è≥ Stalactites/stalagmites (deferred - decoration)
- ‚è≥ Cave-specific biomes (deferred)

**Time Spent:** ~35 minutes
**Estimated:** 3-4 hours (way under budget - reused noise system!)

---

---

## Stage 3: Survival Mechanics ‚ù§Ô∏è

### [18:05] Beginning Stage 3 Implementation

Starting health system, fall damage, and death mechanics...

### [18:20] Stage 3.1 - Health System Complete ‚úÖ
**Modified:** `src/game.rs` (~200 lines added)

Implemented comprehensive player health system:
1. **PlayerHealth Struct:**
   - `current: f32` - Current health (0-20)
   - `max: f32` - Maximum health (20.0 = 10 hearts)
   - `regeneration_rate: f32` - Future health regen support
   - `time_since_damage: f32` - Time tracking for regen
   - `invulnerability_time: f32` - Damage immunity timer

2. **Health Methods:**
   - `new()` - Create with 20.0 max health
   - `damage(amount: f32)` - Take damage with invulnerability frames
     - 0.5 second invulnerability after damage
     - Prevents rapid repeated damage
     - Clamps health to 0.0 minimum
   - `heal(amount: f32)` - Restore health (max 20.0)
   - `is_dead()` - Check if health <= 0.0
   - `update(dt: f32)` - Update invulnerability timer
   - `reset()` - Full heal to 20.0

3. **GameWorld Integration:**
   - Added `player_health: PlayerHealth` field
   - Added `spawn_point: Vec3` field for respawning
   - Health update in game loop
   - Death check every frame

**Design Notes:**
- Minecraft-style health: 20 points = 10 hearts
- Invulnerability frames prevent damage spam
- Regeneration rate set to 0.0 (disabled for now)
- Health regeneration can be enabled later

### [18:35] Stage 3.2 - Fall Damage Complete ‚úÖ
**Modified:** `src/game.rs`, `PlayerPhysics` struct

Implemented Minecraft-style fall damage:
1. **Physics Tracking:**
   - Added `last_ground_y: f32` to PlayerPhysics
   - Tracks last known ground position
   - Updates when player leaves ground

2. **Fall Detection:**
   - Track when player was on ground vs. in air
   - Capture falling state (`velocity.y < 0.0`)
   - Detect landing moment (was_falling && hit_ground)

3. **Damage Calculation:**
   - `calculate_fall_damage(fall_distance: f32)` method
   - Formula: `damage = (fall_distance - 3.0) * 1.0`
   - No damage for falls < 3 blocks
   - 1 damage per block after 3-block threshold
   - Applies damage through health system

4. **Integration:**
   - Fall damage calculated on landing
   - Logged to console for debugging
   - Proper borrow handling (release camera before damage)

**Examples:**
- Fall 3 blocks ‚Üí 0 damage
- Fall 5 blocks ‚Üí 2 damage (5 - 3 = 2)
- Fall 10 blocks ‚Üí 7 damage (10 - 3 = 7)
- Fall 23+ blocks ‚Üí death (20+ damage)

### [18:50] Stage 3.3 - Death & Respawn Complete ‚úÖ
**Modified:** `src/game.rs`

Implemented death and respawn system:
1. **Death Detection:**
   - Check `player_health.is_dead()` in game loop
   - Triggers `handle_death()` when health <= 0.0

2. **Respawn Mechanics:**
   - Teleport player to spawn point
   - Reset health to 20.0
   - Clear physics velocity
   - Reset ground tracking
   - Log respawn event

3. **Spawn Point:**
   - Stored in `GameWorld.spawn_point`
   - Default: world origin (0, 64, 0)
   - Used for respawning on death

**TODOs (deferred):**
- Death screen overlay
- Respawn button UI
- Inventory dropping on death
- Death statistics

### [19:05] Stage 3.4 - Health Bar UI Complete ‚úÖ
**Modified:** `src/game.rs`, added `render_health_bar()` function

Implemented visual health display:
1. **Heart Display:**
   - 10 hearts representing 20 health points
   - Full heart: ‚ô• (red) when >= 1.0 health
   - Half heart: ‚ô• (dark red) when >= 0.5 health
   - Empty heart: ‚ô° (gray) when < 0.5 health

2. **Numerical Display:**
   - Shows "current/max" (e.g., "15.0/20.0")
   - Color-coded by health level:
     - Red: health < 6.0 (critical)
     - Yellow: health < 10.0 (warning)
     - White: health >= 10.0 (healthy)

3. **Positioning:**
   - Bottom-left corner
   - Offset [10, -70] from anchor
   - Above hotbar
   - Always visible

4. **UI Integration:**
   - Called from main UI render
   - Uses egui Area widget
   - Font size: 20pt for hearts, 14pt for numbers

### [19:15] Build & Testing ‚úÖ

**Compilation Status:**
- ‚úÖ Build successful: 0 errors
- ‚ö†Ô∏è 6 warnings (unused variables/fields)

**Build Output:**
```
Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.95s
```

**Borrow Checker Fix:**
- Error: Cannot borrow `*self` as mutable more than once
- Issue: `camera` mutable borrow still in scope when calling `calculate_fall_damage()`
- Fix: Use `let _ = camera;` to explicitly release borrow before method call
- Learning: Must release borrows before calling methods that borrow `self`

### Stage 3 Status: PARTIALLY COMPLETE ‚è≥

**Implemented:**
- ‚úÖ Health system (20.0 max health)
- ‚úÖ Damage system with invulnerability frames
- ‚úÖ Fall damage (Minecraft formula)
- ‚úÖ Death detection
- ‚úÖ Respawn mechanics
- ‚úÖ Health bar UI (hearts + numerical)
- ‚úÖ Color-coded health display

**Not Yet Implemented:**
- ‚è≥ Hostile mobs (Zombie, Skeleton, etc.) - DEFERRED
- ‚è≥ Mob AI (pathfinding, attack) - DEFERRED
- ‚è≥ Mob spawning system - DEFERRED
- ‚è≥ Combat system - DEFERRED
- ‚è≥ Food system - DEFERRED
- ‚è≥ Hunger bar - DEFERRED

**Decision:**
Implementing hostile mobs and mob AI is a significant undertaking (~3-4 hours). Core survival mechanics (health, damage, death) are complete and functional. Moving to Stage 4 (3D UI Integration) to complete the session goals, then can return to hostile mobs in a future session if desired.

**Time Spent:** ~1 hour 10 minutes
**Estimated:** 4-5 hours (health portion came in under budget)

---

## Stage 4: 3D UI Integration üé®

### [19:20] Preparing Stage 4 Implementation

Ready to integrate 3D UI rendering into the game world...

---

*Journal will be updated as implementation progresses...*
