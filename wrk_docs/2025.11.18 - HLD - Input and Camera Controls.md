# High-Level Design — Input and Camera Controls Overhaul (2025-11-18)

## 1. Summary
Players cannot currently control the avatar comfortably: mouse look is inert, WASD feels decoupled from view direction, there is no way to ascend/descend, and the cursor is never grabbed. This design defines a comprehensive control scheme spanning input capture, state management, and gameplay responses so that first-person navigation matches modern expectations (Minecraft, FPS titles, etc.).

## 2. Goals
1. **Reliable relative camera control** — tie mouse delta to yaw/pitch while the cursor is locked; restore cursor when the player opens menus.
2. **Predictable movement** — WASD moves along the camera’s local axes, with configurable speeds, sprint modifier, crouch/slow modifier, and physics integration for grounded mode.
3. **Vertical control** — provide jump + crouch in physics mode and ascend/descend in free-fly mode.
4. **Clear input states** — consistent handling of key-repeat, mouse clicks, per-frame deltas, and debouncing with a notion of “input contexts” (Menu vs Game vs UI overlay).
5. **Automation-friendly** — keep the `--auto-play` entry path working by auto-capturing the cursor and entering gameplay state immediately.

## 3. Non-Goals
- Key rebinding UI (define data model and config hooks but no graphical editor yet).
- Controller/gamepad support.
- Networking of player inputs (single-player only for now).
- Advanced smoothing/inertia for camera (basic configurable sensitivity suffices).

## 4. Current State Assessment
- `InputState` gathers events but cursor grabbing only toggles manually; we never lock upon entering the game, so `mouse_delta` stays zero.
- `update_camera` uses `camera.forward/right` but zeroes vertical input and clamps Y by simply resetting position to 50 units—no collision vs world, no crouch/sprint, and no ascend while flying.
- There is no concept of input context; the same handler runs while menus are up, causing stuck keys when UI steals focus.
- Jump handling is present but physics (AABB) only enforces floor at y=50, so falling/jumping feel unnatural. Movement speed is constant and unaffected by modifiers.
- ESC only returns to menu; no pause overlay or cursor release.

## 5. Proposed Architecture
### 5.1 Input Contexts & Snapshotting
- Extend `InputState` with a `context: InputContext` enum (`Menu`, `Gameplay`, `UiOverlay`).
- Add `InputState::snapshot()` returning an immutable `InputSnapshot` consumed per frame. Snapshot freezes pressed keys, mouse delta, scroll, and click edges so that systems read consistent data even if winit events arrive mid-frame.
- Event handling (`GameWorld::handle_event`) chooses context transitions:
  - When entering gameplay (auto-play or after menu), call `input.enter_gameplay(window)` which locks cursor and zeroes deltas.
  - When ESC is pressed in gameplay, unlock cursor, switch to `Menu` context, and bubble `GameAction::ReturnToMenu`.

### 5.2 Cursor & Mouse Look
- Implement `InputState::set_cursor_capture(window, bool)` used by gameplay entry/exit. Capture attempts must handle Wayland’s refusal to warp the cursor; fall back to `CursorGrabMode::Confined` when `Locked` is unavailable.
- Track mouse deltas via two sources: `DeviceEvent::MouseMotion` (preferred for relative motion) and `WindowEvent::CursorMoved` (as fallback when relative events are unsupported). Accumulate both into `raw_mouse_delta`, and expose a post-sensitivity `look_delta` in the snapshot. On platforms where recentering is prohibited, rely entirely on device motion so view control still works.
- In `update_camera`, apply `look_delta * sensitivity` to yaw/pitch, store yaw/pitch in a dedicated `PlayerLook` component, and clamp pitch to avoid gimbal lock. Sensitivity, inverted-Y flag, and smoothing toggle live in `ControlsConfig` (TOML under `config/controls.toml` read at startup).

### 5.3 Movement Modes
Define two player locomotion modes:
1. **Physics Walk Mode** (default when `player_physics.physics_enabled = true`):
   - Horizontal vector derived from WASD relative to yaw (ignoring pitch) and normalized.
   - Speed tiers: `walk_speed`, `sprint_speed` (when Shift held), `crouch_speed` (Control). `jump_strength` used for vertical impulse.
   - Integrate gravity & jump using the existing `PlayerPhysics` struct but extend it with acceleration smoothing and actual world-collision queries (future work). For now, maintain floor/ceiling clamps based on chunk data.
2. **Free-Fly Mode** (when toggled via F4 or when physics disabled):
   - Use camera forward/right/up to move in 3 axes. `Space` ascends, `Ctrl` descends.
   - Support boost modifier to change speed on the fly.

### 5.4 Vertical Movement
- Physics mode: `Space` triggers jump if `on_ground`; `Ctrl` (or `Shift`) toggles crouch lowering camera height.
- Fly mode: `Space`/`Ctrl` adjust vertical velocity directly; optionally map `E`/`Q` for ascend/descend to match creative Minecraft controls.

### 5.5 Action Mapping Layer
- Introduce `enum PlayerAction { MoveForward(f32), MoveRight(f32), MoveUp(f32), Jump, ToggleFly, ToggleCursor, Sprint(bool), Crouch(bool), UseItem, BreakBlock, Hotbar(u8), ... }`.
- Map hardware inputs to actions through a `Bindings` struct. Version-0 ships with static defaults but the struct must deserialize from `controls.toml` so rebinding is data-driven even before a UI exists. Bindings can be layered: `Base`, `Gameplay`, `Menu`, etc., merged each frame based on `InputContext`.
- Each frame, build an `ActionState` containing analog values (e.g., `move_x`, `move_y`, `move_z`, `look_delta`) plus boolean edges. Gameplay systems consume this rather than raw key states; tests can construct synthetic `ActionState` instances for automation.

### 5.6 Menu & UI integration
- Menus should own the cursor: entering menu releases the pointer, sets context to `Menu`, flushes `mouse_delta`. Returning to game reacquires pointer and zeroes delta to avoid jumpy view.
- Hotbar scrolling: integrate mouse wheel events into `InputState` (add `scroll_delta`), use them to change selected slot.

## 6. Implementation Plan
1. **Input groundwork**
   - Add `InputContext`, `InputSnapshot`, `scroll_delta`, `raw_mouse_delta`, and capture helpers to `InputState`.
   - Update event handling (both `WindowEvent` and `DeviceEvent`) to populate scroll/input context and provide `snapshot()` each frame before `update_camera`.
2. **Action mapping**
   - Create `Bindings` with default key-to-action map; update `GameWorld::handle_event` to update `InputState`, then derive `ActionState` each tick.
3. **Camera & cursor changes**
   - Apply `ActionState.look` to `camera.yaw/pitch`; clamp pitch; add config-driven sensitivity.
   - Acquire/release cursor on gameplay/menu transitions and on explicit toggle key (e.g., `F1`).
4. **Movement rewrite**
   - Replace current WASD logic with action-driven vector; support sprint, crouch, vertical ascend/descend. For physics mode, keep placeholder collision but ensure Y clamps derive from `PlayerPhysics` height.
   - For fly mode, add ascend/descend inputs and ensure time-of-day updates still run.
5. **Polish + testing**
   - Update docs/help text (Debug HUD could show current mode and speeds).
   - Extend `--auto-play` smoke test by adding an optional `--scripted-input` flag that feeds canned `ActionState` sequences to prove movement/looking works headlessly.
   - Manual verification: menu entry/exit, cursor, WASD relative movement, jumping/flying, mouse look responsiveness.

## 7. Risks & Mitigations
- **Platform differences (Wayland/X11)**: relative mouse locking varies; implement fallback to recenter cursor using window APIs and gate errors.
- **Key repeat noise**: rely on `WindowEvent::KeyboardInput` and ignore `Repeat` events to avoid double inserts.
- **Motion sickness**: allow users to configure sensitivity and invert Y via config file; document defaults.

## 8. Future Extensions
- Keybinding config file loader + UI.
- Controller and touchscreen support.
- Multiplayer input prediction once networking is revived.
- Cinematic camera smoothing / acceleration curves.

## 9. Review Notes & Updates
1. **Relative mouse capture on Wayland** — Original draft assumed we could re-center the cursor each frame; that is forbidden on Wayland. Solution: favor `DeviceEvent::MouseMotion` and only use `CursorMoved` deltas as a fallback, without warping the pointer.
2. **Config persistence** — Earlier sections mentioned sensitivity but not storage. Added `controls.toml` location and requirement to deserialize bindings/sensitivity at startup.
3. **Action coverage** — Initial action list missed sprint/crouch toggles; expanded the enum and clarified layering for different contexts.
4. **Automated testing** — The plan simply suggested “extend auto-play.” Updated to require a scripted-input option so CI can simulate look/move behavior deterministically.
5. **Event ordering** — Made it explicit that both `WindowEvent` and `DeviceEvent` must feed `InputState`, ensuring mouse look works even when the OS suppresses cursor motion events.
