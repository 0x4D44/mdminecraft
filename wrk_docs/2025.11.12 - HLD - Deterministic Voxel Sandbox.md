# High-Level Design - Deterministic Voxel Sandbox MVP
Date: 2025-11-12

## 1. Objectives & Scope
- Deliver a moddable voxel sandbox (survival + creative) with deterministic simulation, LAN/online multiplayer, and an automated testing surface that treats the game as a reproducible system under test.
- Cover MVP pillars defined in the requirements: infinite chunked terrain, core block loop, lighting, simple fluids, seed-based saves, player/drop/passive entities, and headless CI-friendly rendering.
- Exclude explicitly deferred features (advanced mobs, redstone-like circuits, shader mods, anti-cheat) to protect schedule and keep the deterministic contract tight.

## 2. Success Criteria & Non-Goals
- Simulation tick rate locked at 20 TPS with <=2.5 ms/tick CPU on a 4-chunk radius scene; renderer sustains 60 FPS and <=6 ms/frame on target GPUs.
- Lighting updates propagate within two ticks; skylight/block light stay monotonic.
- Networking round-trips yield <=30 ms reconciliation error at 100 ms RTT; joining a remote server reproduces terrain within 10 chunks of spawn.
- World saves (region + player data) are bit-stable across save/load; deterministic replays regenerate identical event streams, meshes, and headless snapshots.
- Non-goals: combat depth, complex AI, shader-based post-processing, platform-specific rendering features that threaten determinism.

## 3. Architectural Overview
```
cli worldtest -+
               |        +------------+           +------------+
client crate --+--net-->| server ECS |--events-->+ testkit    |
               |        +------------+           +------------+
 renderer <--render-- world crate --persist--> assets/regions
 physics  ---collide---+          |
 scripting (opt) ---------------+
```
- Crate layering follows the spec: core (math/time), ecs (bevy_ecs facade and schedule), world (chunks, lighting, generation, persistence), physics, render, net, server, client, assets, scripting (feature), testkit, cli.
- Server hosts the authoritative ECS schedule; client mirrors presentation systems (input/prediction, interpolation, HUD) and may embed the server for single-player.
- testkit attaches sinks (JSONL, snapshots, metrics) to the event bus, enabling deterministic CI workflows.

## 4. Simulation & ECS Design
- Adopt bevy_ecs::Schedule with fixed-stage ordering per tick: InputIngest -> WorldUpdates -> EntityLogic -> Physics -> PostTick (events/net). Each stage has tight data access rules to keep Rust borrow checking predictable.
- Determinism: a tick-scoped RNG seeded by (world_seed, chunk_pos, tick, stream_id) is injected into systems; no wall-clock usage inside the ECS schedule. Floating-point computations never gate branching logic; thresholds are quantized.
- Timekeeping uses SimTick(u64) and SimDuration(u32 millis) newtypes to prevent accidental mixing with real time.
- Client prediction runs a trimmed schedule (InputIngest -> Physics -> MinimalWorldView) using the same components, making reconciliation diffs comparable.

## 5. World Representation & Generation
- Coordinate system: right-handed XYZ (X east, Y up, Z south). Chunks are 16x256x16 with a compile-time feature for taller worlds (up to 512).
- Chunk storage: structure-of-arrays per voxel attribute (id, state, sky light, block light) inside world::chunks::Chunk. Each chunk owns a MeshHandle and dirty flags for lighting and meshing.
- Region persistence groups 32x32 chunks into .rg files with zstd-compressed records; header stores CRC32, version, and payload length.
- Generation pipeline (per chunk job): noise-derived heightmap -> biome map -> surface composition -> caves/structures -> population (ores, lakes) -> skylight precompute. Jobs run on a work-stealing pool; neighbor data supplied through immutable caches for seam-free transitions.

## 6. Environmental Simulation (Day/Night & Weather)
- SimTime resource advances deterministically (default 20 in-game minutes per real minute) and can be overridden in worldtest scenarios for reproducible setups. Time state persists in saves and is part of the replay log.
- Day/night cycle computes sun elevation from SimTime and feeds the lighting system with a global skylight scalar; sunsets/sunrises interpolate between target color ramps while keeping integer light values stable.
- WeatherToggle component lives on the world singleton and supports at least Clear and Precipitation states. State changes propagate deterministic `WeatherChanged` events so clients and the replay system stay synchronized.
- Weather affects ambience (fog density, particle spawns) and optional gameplay hooks (e.g., disable skylight decay when raining) but never introduces randomness outside the seeded RNG. Server exposes admin/testkit commands to force weather for CI.
- Client visuals interpolate toward the server-authoritative weather/time-of-day to hide network jitter but still reference the replicated SimTime so snapshots taken in headless mode match gameplay captures exactly.

## 7. Lighting System
- Dual light channels (sky/block) range 0-15 using BFS queues for propagation. Skylight floods downward starting at world max Y, blocking on opaque voxels, and scales with the current SimTime sun value.
- Light updates enqueue LightUpdate jobs scoped to chunk-local structures but spill over chunk borders through shared edge queues. Removal events execute reverse BFS to avoid light popping.
- Mesher samples per-vertex light, optionally computing face-based ambient occlusion (AO disabled in CI runs for hash stability, toggleable elsewhere).

## 8. Meshing & Rendering
- Greedy mesher collapses opaque surfaces per axis, emitting sub-meshes for opaque, alpha-cutout, translucent, and sprite categories. Vertex data encodes block id/material index plus baked light.
- Renderer uses wgpu in forward mode with backend selection (DX12/Vulkan/Metal). Rendering thread consumes chunk meshes from a render::SceneGraph fed by the world crate; frustum culling happens per chunk.
- Headless mode renders off-screen textures with deterministic camera rigs and texture atlases. Snapshot outputs include PNG, SHA-256, render timing, and warnings for goldens.
- Mesh hashing: after meshing, vertex/index buffers are hashed (blake3) and compared with previous hash to short-circuit uploads, improving determinism and performance.

## 9. Physics, Fluids, and Interaction
- Physics components: Transform, Velocity, Collider (AABB or capsule), PhysicsMaterial. Semi-implicit Euler integrates motion at 50 ms steps with sweep-and-prune broad phase and discrete voxel collision through DDA.
- Fluids (configurable) run as a discrete cellular automaton with per-voxel state stored in block metadata; scheduler throttles updates to avoid starvation.
- Raycasts use integer DDA for block targeting; inventory interactions raise BlockInteract events consumed by crafting and inventory systems.

## 10. Entity Systems & AI
- ECS archetypes cover Player, DropItem, and PassiveMob placeholder entities alongside utility entities (e.g., projectiles later). Shared components include Transform, Velocity, Collider, Health, InventoryHandle, and SpawnSeed for deterministic behaviors.
- Player entity layers prediction buffers, input timestamps, and survival-specific components (NeedsHunger). Creative mode simply removes survival components without branching the schedule.
- DropItem entities contain an ItemStack, PickupRadius, Lifetime, and FloatBob components. Lifetime expiration and pickup both emit GameEvents so replays and testers can assert correct drops.
- PassiveMob uses a lightweight deterministic finite-state machine (Idle, Wander, Flee). The FSM consumes a per-entity RNG stream derived from world_seed + chunk + entity_id so identical seeds yield the same idle routes. Steering uses voxel-aware navigation sampled every few ticks to stay within perf budget.
- Biome-aware spawn tables run during chunk population and emit EntitySpawned events. Despawn heuristics rely on distance plus cap tables to keep entity counts predictable in CI scenarios.

## 11. Gameplay Systems & UI
- Inventory supports 36 slots with per-item stack caps; data-driven recipes (JSON) validated at startup, producing ECS resources for crafting tables.
- UI shell exposes HUD (crosshair, hotbar, health), tooltips, and debug overlays. Input mapping loaded from TOML into a deterministic action stream so replays can inject the same InputApplied events.
- Creative/survival toggles change component archetypes (for example NeedsHunger only in survival) without branching the main loop.

## 12. Networking & Multiplayer
- Transport via QUIC (quinn) running over UDP with TLS encryption. Server owns the simulation timeline; clients send input bundles tagged with the last acknowledged tick.
- Protocol uses postcard/bincode messages with version byte plus schema hash. Channels: Input, ChunkStream, EntityDelta, Chat, Diagnostics.
- Server applies delta compression for chunk data (palette + RLE) and entity transforms. Client prediction plus interpolation smooths renders while reconciliation rewinds/resimulates divergent ticks.
- Basic sanity validation rejects impossible inputs (teleports, high velocity). Anti-cheat beyond sanity checks is a later milestone.

## 13. Persistence & Asset Pipeline
- World saves: .rg region files per 32x32 chunk area; server flushes dirty chunks asynchronously to avoid tick stalls. Player data serialized as JSON or MsgPack with fields for transform, health, inventory, and selected hotbar slot.
- Asset registry (TOML/JSON) defines blocks, items, recipes, and materials. Loader performs schema validation and produces hashes (reg_hash) baked into save metadata so mismatched packs trigger migrations or invalidation.

## 14. Observability & Tooling
- Structured logging with tracing spans for ticks, generation, meshing, networking, and persistence. Log levels escalate to Event::Warning/Error, allowing CI to fail immediately if emitted during curated scenarios.
- Metrics pipeline (metrics crate) exports frame times, chunk counts, memory pressure, mesh bytes, bandwidth. CLI flag --metrics-out dumps JSON for performance regression comparison.
- Debug overlays (hotkeys) visualize chunk borders, light levels, and mesh stats. testkit can capture metrics snapshots alongside event streams and PNGs.

## 15. Automated Testing Surfaces
1. Event Stream Recorder: JSONL sink subscribes to GameEvent; deterministic ordering ensures replays diff cleanly. Assertions include no warnings, bounded triangle counts, lighting updates present.
2. World Test DSL: worldtest CLI ingests .worldtest.toml scenarios (initial fills, scripted actions, expectations). Runner emits pass/fail, event stream, metrics, and optional snapshots.
3. Headless Snapshot Tests: deterministic camera rigs capture PNG + SHA-256 per backend. CI compares SHA; mismatches attach diff artifacts.
4. Property and Fuzz Tests: proptest suites for lighting monotonicity, greedy meshing correctness, collision safety, chunk seams. cargo-fuzz targets input decoder, chunk deserializer, recipe parser.
5. Performance Baselines: scripted MegaForest and CaveCity scenarios record frame_time_p95, chunk_gen_time_avg, and initial_load_to_playable, enforcing spec thresholds.
6. Input & Replay Harness: deterministic input logs (player commands only) are captured alongside event streams. testkit::replay feeds the same inputs back into a headless build, regenerating the authoritative event stream for diffing; schema versions are embedded so CI can invalidate stale goldens safely.

## 16. Performance & Scalability Strategies
- Multithreaded executors: generation, lighting, and meshing run on worker pools fed by chunk job queues; renderer has its own thread that consumes prepared meshes.
- Memory budgets enforced via chunk cache sizes per dimension; LRU eviction tied to player distance. Target residency <1.5 GB at a 9x9 chunk area.
- Generation budgets: per-chunk instrumentation keeps single-thread gen time <=8 ms (desktop target) and records both average and p95 in metrics.json. Initial load-to-playable path aims for <=2.0 s with the required chunk fan-out.
- IO throttling ensures world saves stay <=100 MB/hour: dirty chunk flush batching and zstd level tuned for throughput.
- Network scalability: chunk streaming throttled per client; bandwidth metrics feed back-pressure to avoid saturating low RTT clients.

## 17. Deployment & CI/CD
- Toolchain: Rust stable with clippy and rustfmt gates. Build matrix spans Windows (DX12), Linux (Vulkan), macOS (Metal) to validate rendering backends.
- CI stages: lint/unit tests -> property/fuzz smoke (time-boxed) -> headless world tests that emit events.jsonl, metrics.json, snapshots/*.png plus sha256.txt. Artifacts retained 30 days for bisect/replay.
- Versioning couples semantic version with content reg_hash; cache invalidation occurs when assets change.

## 18. Delivery Plan
- Milestone A - Engine Core (4-6 weeks): chunk store, block registry, greedy mesher, renderer, camera/collision. Acceptance: Superflat world loads, place/break loop works, 60 FPS in 9x9 chunk area, Superflat worldtest passes.
- Milestone B - Lighting & Save: skylight + emissive propagation, zstd region save/load, inventory/crafting basics. Acceptance: Torch worldtest passes; torch removal updates neighbors within two ticks; save/load is bit-identical.
- Milestone C - Networking (LAN): server authoritative movement, chunk streaming, prediction/reconciliation. Acceptance: two clients build the same tower; event streams match server log; no desync at 100 ms RTT scenario.
- Milestone D - Biomes & Structures: biome noise, trees/ores, weather toggle, locked render goldens. Acceptance: no biome seams; meshing hashes stay stable.

## 19. Risks & Mitigations
- Render determinism drift: lock texture atlases, disable temporal effects, hash meshes and snapshots per backend; CI diff reports highlight regressions.
- Mesh hash instability from floats: keep meshing integer-only; restrict floating point to final vertex transforms.
- Determinism regressions: enforce replay tests in CI; require new systems to declare RNG seeds; run seed audits.
- CI GPU scarcity: prefer wgpu headless with SwiftShader fallback; cache goldens per adapter.
- Network cheating (future): MVP only does sanity validation; track for post-MVP anti-cheat.

## 20. Open Questions & Next Steps
1. Confirm final transport choice (QUIC vs reliable UDP) based on latency budget and platform support; default plan assumes QUIC/quinn.
2. Decide whether AO is enabled outside CI by default or exposed as a per-world toggle.
3. Finalize asset pack schema versioning strategy (TOML vs JSON) and migration tooling.
4. Define reference hardware profile used for performance baselines to prevent moving targets.
5. Flesh out scripting/WASM surface once MVP stabilizes; feature remains toggled off until sandbox policies are approved.

This design aligns with the 2025.11.12 requirements by mapping each spec pillar to an owned subsystem, defining deterministic contracts, detailing data and execution flows, and embedding the automated testing story as a first-class outcome.
