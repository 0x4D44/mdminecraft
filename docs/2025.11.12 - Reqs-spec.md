0) Goals & Scope

Goal: Build a performant, moddable, single‑ and multi‑player voxel sandbox with survival/creative basics, written in Rust, with a first‑class automated testing story (headless mode, deterministic simulation, render snapshot tests, and an event stream that doubles as a replay log).

MVP Gameplay Scope:

Infinite terrain (chunked), day/night cycle, basic weather toggle.

Core block loop: mine, place, craft simple recipes, inventory, hotbar.

Entities: player, drop item, passive mob placeholder.

Lighting: skylight + emissive blocks.

Basic fluids (static or simple spread—configurable).

Save/load world; seed-based generation.

Singleplayer local server; LAN/online server.

Creative & survival modes; simple UI (hotbar, crosshair).

Non‑Goals for MVP: redstone‑like circuits, complex combat, advanced mobs, shader mods; these arrive in later milestones.

1) Architecture Overview
workspace/
  Cargo.toml
  crates/
    core/            // math, ids, coords, time, rng, error types
    ecs/             // entity-component-system facade (bevy_ecs or custom)
    world/           // blocks, chunks, biomes, gen, lighting, persistence
    physics/         // AABB, movement, collision, raycasts
    render/          // wgpu renderer, meshing, materials, post
    net/             // protocol, serialization, transport
    server/          // authoritative sim loop + headless
    client/          // input, prediction, interpolation, UI shell
    assets/          // asset registry, pack loader, pack validation
    scripting/       // optional WASM modding API
    testkit/         // event stream, replay, fixtures, world DSL, golden tests
    cli/             // binaries: game, server, tools


Key design choices

ECS: Use bevy_ecs (pure ECS crate, no engine lock‑in) for predictable data layout and parallelism.

Rendering: wgpu for cross‑platform, with headless backend enabled for CI snapshot tests.

Transport: QUIC (via quinn) or reliable UDP; server authoritative; lockstep tick.

Determinism: Fixed timestep; seeded RNG; no wall‑clock reliance in sim. “Deterministic Mode” uses integer/fixed-point paths for tests.

Testing surfaces: (1) event stream (JSONL), (2) headless renderer image diffs, (3) world DSL scenarios, (4) property‑based tests, (5) replayable input logs.

2) Core Simulation & Timing

Tick rate: 20 TPS for game simulation (SimTick = 50 ms).

Render rate target: 60 FPS; decoupled render thread interpolates between ticks.

Order of operations per tick (server):

Ingest input events from clients (time‑stamped with prior tick).

Apply world updates (block ticks, fluids, lighting updates).

Update entities (AI, physics, inventory, crafting).

Emit GameEvents (for recording, testing, and UI).

Package and send state deltas to clients (reliable, delta‑compressed).

Determinism rules: All randomness derives from a tick‑scoped RNG stream seeded by (world_seed, chunk_pos, tick). No std::time::Instant in sim code. All floating‑point decisions must not affect branching outcomes; use quantized thresholds or fixed‑point for branch conditions.

3) Coordinate System & Data Model

World coordinates: Right‑handed; X east, Y up, Z south.

Chunk size: 16 x 256 x 16 (X,Y,Z). Height is configurable; engine supports Y in [0, 512) via compile‑time feature.

Regions: Disk layout groups chunks into 32x32 areas (.rg files).

Block definition

struct BlockId(u16); // index into registry; 0 = air
struct BlockState(u16); // variant bits (orientation, moisture, etc.)

#[derive(Clone, Copy)]
struct Voxel {
    id: BlockId,
    state: BlockState,
    light_sky: u8,   // 0-15
    light_block: u8, // 0-15 emitted
}


Block registry: Declarative (TOML/JSON) with properties:

opaque, transparent, collidable, solid, light_emission, light_attenuation,

hardness, tool, flammable, fluid_like, render_model (cube, cross, custom mesh).

Entities: ECS components for Transform, Velocity, Collider(AABB), Inventory, Health, PlayerTag, etc.

4) World Generation

Inputs: world_seed, world_params.toml.

Pipeline: (1) base heightmap (noise stack), (2) biome map, (3) surface composition, (4) caves/tunnels, (5) structures (trees, huts), (6) population passes (ores, lakes), (7) lighting precompute for skylight.

Parallelism: Generate per‑chunk with a job queue; neighbor access by read‑only caches.

Determinism: All noise seeded deterministically per chunk + global seed.

Acceptance (Gen)

Never produce uninitialized voxels.

Chunk borders align (no seams in terrain or lighting).

Performance: gen ≤ 8 ms/chunk (desktop target) on a single thread; scalable with threads.

5) Lighting

Model: 0–15 levels for skylight and block light, Manhattan propagation with attenuation (1 per step). Skylight starts at max at top of world and floods downward, blocked by opaque blocks.

Updates: BFS queues for add/remove; chunk‑local with cross‑chunk border queues.

Ambient occlusion: Optional per‑vertex “face AO” in mesher (configurable for test stability).

Acceptance (Lighting)

Light must be monotonic (no increase along path away from source).

Chunk mesh reflect correct light values on vertices (unit test using probe blocks).

Removing an emissive block updates neighbors within ≤2 ticks.

6) Meshing & Rendering

Meshing: Greedy meshing on opaque surfaces to reduce quads; separate passes for:

Opaque cubes

Semi‑transparent (alpha cutout, e.g., leaves)

Translucent (sorted) – MVP can render per‑face without full sorting guarantees

Sprites (cross‑quads)

Geometry cache: Per‑chunk mesh + shared material atlas.

Renderer: wgpu forward+ (MVP forward), per‑material pipelines, frustum culling, optional occlusion queries. Shadowing is out‑of‑scope for MVP to keep headless snapshot deterministic.

Camera: Free‑look with collision capsule. FOV and near/far configurable.

Headless Mode: Off‑screen render to texture; deterministic camera path & exposure; no temporal effects; atlas hashing to lock textures.

Acceptance (Rendering)

Rebuilding a chunk that did not change yields identical vertex/index buffers (hash stable).

Headless snapshot test copies SHA‑256 of the render target that matches a golden file per platform.

7) Physics & Collisions

Entity collider: Capsule or AABB; axis‑aligned collisions against solid voxels.

Integration: Fixed‑step semi‑implicit Euler; gravity; friction; step‑height support.

Raycast: Discrete DDA voxel traversal for block targeting.

Fluids (MVP option): Discrete cellular automaton (simple spread) toggled by world params.

Acceptance (Physics)

No tunneling at ≤6 m/s with Δt = 50 ms.

Standing on a single block is stable (no micro‑slips).

Raycast picks the expected voxel face in unit tests with known scenes.

8) Inventory, Crafting, and UI

Inventory: 36 slots, stack sizes per block/item type.

Crafting: JSON recipes (shaped and shapeless). Loading validated at startup.

UI: Immediate‑mode wrapper; provide HUD: crosshair, hotbar, hearts, toolbar tooltips.

Input mapping: Rebindable (TOML). All input generates typed input events for deterministic replays.

9) Persistence

Format: Region files (.rg) containing chunk records; chunk record compressed with zstd, record header = CRC32 + version + length.

Player data: Per‑player JSON (or msgpack) with position, health, inventory.

Versioning: Semantic world version; migration hooks in world::migrate.

10) Networking

Topology: Dedicated server (server crate), thin client (client crate).

Transport: QUIC (reliable), encrypted by default.

Sync model: Server authoritative, 20 TPS lockstep. Client prediction for movement with reconciliation.

State transfer: Chunk streaming near player; delta compression of block updates and entity transforms.

Protocol: bincode/postcard messages with version byte and schema hash.

Anti‑cheat: Out‑of‑scope MVP; basic sanity checks on inputs.

Acceptance (Net)

Joining a server with identical seed yields identical terrain within 10 chunks of spawn.

Reconciliation produces ≤30 ms average rubber‑band under 100 ms RTT in test harness.

11) Modding (Post‑MVP toggleable)

WASM host API: Blocks, items, recipes, structure generation hooks, tick callbacks.

Safety: Fuelled by wasmtime; 10 ms per tick budget per module; memory sandbox.

Data‑driven: Blocks/items/recipes can be registered via data packs without WASM.

12) Observability

Logging: Structured (tracing) with spans for ticks, gen, mesh, net.

Metrics: metrics crate exporters (frame time, chunk counts, mesh bytes, bandwidth).

Debug overlays: Chunk borders, mesh stats, light levels (toggle).

13) The Automated Testing Story (Core Requirement)

This project treats the game like a deterministic system under test with three orthogonal verification surfaces:

13.1 Event Stream (Primary Interface)

Purpose: Drive black‑box tests, reproduce bugs, and assert high‑level behavior.

Shape: Newline‑delimited JSON (.jsonl) with stable schemas. Each record is one GameEvent.

// example line
{"tick": 42, "kind": "BlockPlaced", "pos":[12,64,-3], "by":"Player(7)", "block":"oak_planks", "state":0}
{"tick": 42, "kind": "ChunkMeshed", "chunk":[0,4,-1], "triangles": 18240, "mesh_sha":"3bc2..."}
{"tick": 43, "kind": "LightingUpdated", "region":[0,0], "updates": 512}
{"tick": 45, "kind": "SnapshotSaved", "camera":"test_cam_01", "image_sha":"6a49...", "width":1280, "height":720}


Determinism: Emission order is deterministic (sorted by subsystem), and events are idempotent for replay.

Replay: testkit::replay can ingest an input log (player inputs only) and deterministically regenerate the same output event stream; diffs are compared to goldens.

Minimum Event Types

World: BlockPlaced, BlockBroken, BlockUpdated, ChunkGenerated, ChunkMeshed, LightingUpdated.

Entities: EntitySpawned, EntityDespawned, Moved, Damaged.

Player: InputApplied, CommandExecuted.

Net: ClientJoined, ClientLeft, PacketStats.

Render: SnapshotSaved, MeshBuilt, AtlasReloaded.

System: TickStart, TickEnd, Warning, Error.

Assertions in CI

No Warning/Error events during curated scenarios.

Event counts within budget ranges (e.g., triangles per chunk < N).

13.2 World Test DSL (Declarative Scenarios)

Format: *.worldtest.toml for initial conditions + scripted steps + expectations.

[world]
seed = 12345
spawn = [0, 65, 0]
time_of_day = "noon"
flat = true

[[blocks.fill]]     # Fill a volume with blocks
from = [-5,64,-5]
to   = [ 5,64, 5]
block = "stone"

[[script]]
tick = 1
action = { place = { at=[0,65,1], block="torch" } }

[[expect]]
by_tick = 3
light = { at=[0,65,1], sky=0, block>=14 }

[[expect]]
by_tick = 2
event = "BlockPlaced"
count = 1


Runner: cargo run -p cli -- worldtest ./scenarios/*.worldtest.toml

Output: Pass/Fail summary + event stream artifact + optional headless snapshot.

13.3 Headless Render Snapshot Tests

Mechanism: Deterministic camera rigs defined in the DSL (path or static). Renderer dumps PNG and SHA‑256. Tests compare SHA, not PNG bytes, to minimize IO.

Stability: Disable temporal AA, bloom, and per‑frame noise. Use fixed exposure and no platform‑dependent gamma (or bake gamma into shader).

Golden Storage: Platform‑specific goldens per backend (e.g., goldens/win_dx12/…). CI selects proper set.

[[camera]]
name = "test_cam_01"
pos  = [2.5, 67.0, -1.5]
look = [0.0, 0.0, 1.0]
fov  = 70

[[expect]]
by_tick = 1
snapshot = { camera="test_cam_01", sha="6a49c7..." }

13.4 Property‑Based & Fuzz Tests

Property‑Based: proptest suites:

Lighting propagation is monotonic and bounded.

Greedy meshing never produces overlapping quads; surface area ≤ naïve meshing.

Collision solver never penetrates solids; position remains finite.

Chunk border faces match when blocks match.

Fuzz: Input decoder, chunk deserializer, and recipe parser fuzzed via cargo-fuzz.

13.5 Performance/Regression Tests

Scripted scenario “Mega‑Forest” and “Cave‑City”: assert

frame_time_p95 ≤ 16.6 ms (render‑only) on reference machine flags.

chunk_gen_time_avg ≤ 8 ms.

initial_load_to_playable ≤ 2.0 s (<= N chunks and UI ready).

Collected via testkit::metrics and dumped as JSON; CI compares to last accepted baseline with thresholds.

14) Public APIs (Selected)
14.1 Event Bus
pub enum GameEvent<'a> {
    TickStart{ tick: u64 },
    TickEnd{ tick: u64 },
    BlockPlaced{ tick: u64, pos: IVec3, by: Entity, block: BlockId, state: BlockState },
    // ...
}

pub trait EventSink: Send + Sync {
    fn on_event(&self, ev: &GameEvent);
}


Default sinks: JsonlRecorder, InMemoryCollector, MetricsSink, NoopSink.

Testkit can attach multiple sinks.

14.2 World Editing API
pub trait VoxelWorld {
    fn get(&self, p: IVec3) -> Voxel;
    fn set(&mut self, p: IVec3, v: Voxel) -> Result<()>;
    fn schedule_block_tick(&mut self, p: IVec3, delay: u16);
    fn chunk_mut(&mut self, cpos: IVec3) -> ChunkMut<'_>;
}

14.3 Headless Snapshot
pub struct SnapshotRequest {
    pub camera: CameraSpec,
    pub resolution: UVec2,
    pub output_path: PathBuf,
}

pub fn render_snapshot(world: &World, req: &SnapshotRequest) -> SnapshotResult;
// returns sha256, timing, warnings

14.4 CLI
game-client [--server ip:port] [--world W] [--profile dev|release]
game-server [--world W] [--headless] [--max-players N]
worldtool   gen --seed 42 --out W
worldtest   run ./scenarios/...

15) Data Formats
15.1 Block Registry (TOML)
[[block]]
name = "stone"
id = 1
opaque = true
collidable = true
render_model = "cube"
hardness = 1.5

[[block]]
name = "torch"
id = 50
opaque = false
collidable = false
render_model = "sprite"
light_emission = 14

15.2 Recipes (JSON)
{
  "type": "shaped",
  "pattern": ["SS","SS"],
  "key": { "S": "stone" },
  "result": { "item": "stone_bricks", "count": 4 }
}

16) Performance Targets

CPU: ≤ 2.5 ms/tick sim (single player, 4 loaded chunks radius).

GPU: ≤ 6 ms/frame typical scene on entry‑level dGPU or Apple M‑series.

Memory: < 1.5 GB resident with 9×9 chunk area loaded at 256 height.

IO: World save ≤ 100 MB/hour of play (zstd compressed).

17) Security & Stability

No unbounded allocations on network paths.

Validate all asset pack indices and texture sizes.

Save format CRC and version guard.

WASM mods sandboxed and time‑boxed (if enabled).

18) CI/CD Pipeline

Rust toolchain: stable; clippy and rustfmt enforced.

Build matrix: Windows (DX12), Linux (Vulkan), macOS (Metal).

Stages:

Lint + unit tests (cargo test --all-features).

Property & fuzz smoke (time‑boxed).

Headless world tests (worldtest run), produce artifacts:

events.jsonl

metrics.json

snapshots/*.png + sha256.txt

Golden compare; if mismatch, attach diff report.

Artifacts retained for 30 days to allow bisect/replay.

Versioning: Semver + content reg_hash to invalidate caches.

19) Milestones & Acceptance
Milestone A — Engine Core (4–6 weeks)

Chunk store, block registry, basic gen, greedy mesher, wgpu renderer, player camera & collisions.

Acceptance: Load superflat, place/break blocks, 60 FPS in 9×9 chunk area, pass “Superflat Basics” worldtest (events & snapshot stable).

Milestone B — Lighting & Save

Skylight + emissive; zstd region save; reload world; crafting/inventory basics.

Acceptance: “Torch Light” worldtest passes; removing torch updates light within 2 ticks; save/reload preserves world bit‑exactly.

Milestone C — Networking (LAN)

Server authoritative movement, chunk streaming, prediction/reconciliation.

Acceptance: Two clients build the same tower; event streams match server’s authoritative record; no desync on 100 ms RTT scenario.

Milestone D — Biomes & Structures

Noise biomes, trees/ores, weather toggle; render snapshot goldens updated and locked.

Acceptance: Biome border seams absent; meshing hashes stable across runs.

20) Appendix: Example Test Assets
20.1 Minimal Scenario (superflat.worldtest.toml)
[world]
seed = 1
flat = true
spawn = [0,5,0]

[[blocks.fill]]
from = [-16,0,-16]
to   = [ 16,4, 16]
block = "stone"

[[script]]
tick = 1
action = { player_move = { id=1, dir=[0,0,1], seconds=1.0 } }

[[script]]
tick = 5
action = { place = { at=[0,6,2], block="torch" } }

[[expect]]
by_tick = 6
event = "LightingUpdated"
count >= 1

[[camera]]
name = "overview"
pos  = [3.5, 9.0, -4.0]
look = [0.0, -0.4, 0.8]
fov  = 70

[[expect]]
by_tick = 6
snapshot = { camera="overview", sha="TO_BE_SET_ON_FIRST_GOLDEN" }

20.2 Event Stream Schema (Rust serde)
#[derive(Serialize, Deserialize)]
#[serde(tag="kind")]
pub enum EventRecord {
  TickStart { tick: u64 },
  TickEnd   { tick: u64 },
  BlockPlaced { tick: u64, pos: [i32;3], by: String, block: String, state: u16 },
  // ...
  SnapshotSaved { tick: u64, camera: String, image_sha: String, width: u32, height: u32 },
}

21) Risks & Mitigations

Cross‑platform render variance: lock texture atlas hashes, disable temporal effects, keep a per‑backend golden set.

Determinism drift: unit tests that round‑trip replay logs; log schema versioning; seed audit.

Mesh hash instability (float math): mesh generation entirely integer/bit‑exact; only vertex transforms use floats at render time.

CI GPU availability: use wgpu headless + software adapters (SwiftShader) fallback; cache goldens per adapter.

22) Nice‑to‑Have Extensions (Post‑MVP)

Redstone‑like circuits with discrete simulation events (naturally testable).

Spline camera tool for cinematic snapshot sweeps.

Replay viewer UI (seek by tick, show event overlays).

In‑game test console to run .worldtest scenarios live.

Final Notes on Testing Visual Elements

You have three complementary strategies for visual verification:

Headless snapshots with deterministic camera rigs and a per‑backend golden SHA; this directly tests “what the player sees”.

Mesh artifact hashing (vertex/index buffer hashes) per chunk—more stable and cheaper than full images; failures localize straight to the mesher.

Event‑level assertions (e.g., “torches emit ≥14 block light at placement”). These assert intent at the game‑logic layer even if rendering is swapped out.

With these in place, the engine can be validated in CI without a human opening the game—and bugs can be reproduced exactly via the event stream replay.